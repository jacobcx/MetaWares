/******************************************************************************
* This file is automatically generated by VSC.
* Do not edit manually.
* VSC Version    : 2.5.4
* Plugin Version : com.mentor.bsw.os.PowerPC.MPC5746R 4.8.0
*==============================================================================
* Module:       Os
*
* File Name:    Ioc.c
*
* Description:  This file shall contain the IOC public generated APIs
*
******************************************************************************/

#define IOC_C_SW_MAJOR_VERSION    (4U)
#define IOC_C_SW_MINOR_VERSION    (8U)
#define IOC_C_SW_PATCH_VERSION    (0U)

/*=============================== INCLUSIONS ================================*/

#define OS_SOURCE_FILE

#include "Os_Os.h"
#include "Ioc.h"
#include "Os_LCfg.h"
#include "Os_Isr.h"
#include "Vstar_Bits.h"

/*============================ MACRO DEFINITIONS ============================*/

#ifdef offsetof
#define OS_IOC_OFFSETOF(_type, _member)     (Os_IOC_DataOffsetType)offsetof(_type, _member) /* KW MISRA.DEFINE.FUNC MISRA.DEFINE.NOPARS */
#else
#define OS_IOC_OFFSETOF(_type, _member)     (Os_IOC_DataOffsetType)( (uint8*) &((_type*) 0)->_member - (uint8*) 0 ) /* KW MISRA.DEFINE.FUNC MISRA.DEFINE.NOPARS */
#endif

#define OS_CALL_VSTAR_COPY(_dst, _src, _len)    vstar_copy( (uint8*)(_dst), (uint8*)(_src), (uint32)(_len) ) /* KW MISRA.DEFINE.FUNC MISRA.DEFINE.BADEXP */

/*============================ TYPE DEFINITIONS =============================*/

/* Channel types */

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    VAR (sint32, TYPEDEF)  IOC_MasterToMaster_0;
} IOC_MasterToMasterChannelType;

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    VAR (uint32, TYPEDEF)  IocNto1_0;
    VAR (uint8, TYPEDEF)  IocNto1_1;
} IocNto1ChannelType;

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    VAR (uint32, TYPEDEF)  OsIocCommunication_0;
} OsIocCommunicationChannelType;



/* Syscall parameter types */

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    P2VAR (sint32, TYPEDEF, OS_APPL_DATA)  IOC_MasterToMaster_0;
} IOC_MasterToMasterParamType;

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    P2VAR (uint32, TYPEDEF, OS_APPL_DATA)  IocNto1_0;
    P2VAR (uint8, TYPEDEF, OS_APPL_DATA)  IocNto1_1;
} IocNto1ParamType;

typedef struct /* KW PORTING.STORAGE.STRUCT */
{
    P2VAR (uint32, TYPEDEF, OS_APPL_DATA)  OsIocCommunication_0;
} OsIocCommunicationParamType;

/*==================== INTERNAL FUNCTION DECLARATIONS =======================*/

/*======================= EXTERNAL VARIABLE DECLARATIONS ====================*/

#define OS_START_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

EXTERN_VAR (Os_LockResourceType, OS_VAR) Os_LockResources [4U];

#define OS_STOP_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

/*======================= INTERNAL VARIABLE DECLARATIONS ====================*/

/* IOC communication buffers */

#define  OS_START_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

static VAR (IOC_MasterToMasterChannelType, OS_VAR) IOC_MasterToMasterChannel [1U];
static VAR (IocNto1ChannelType, OS_VAR) IocNto1Channel [2U];
static VAR (OsIocCommunicationChannelType, OS_VAR) OsIocCommunicationChannel [1U];

#define  OS_STOP_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */



/* IOC communication dyn segment */

#define  OS_START_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

static VAR (Os_IOC_ChannelDynType, OS_VAR) IOC_MasterToMaster_Dyn;
static VAR (Os_IOC_ChannelDynType, OS_VAR) IocNto1_Dyn;
static VAR (Os_IOC_ChannelDynType, OS_VAR) OsIocCommunication_Dyn;

#define  OS_STOP_SEC_VAR_NO_INIT
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */



/* Pullcallbacks */


/* Data descriptor */

#define  OS_START_SEC_CONST
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

#define  OS_STOP_SEC_CONST
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


/* IOC Stat segment */

#define  OS_START_SEC_CONST
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

static CONST (Os_IOC_ChannelStatType, OS_CONST) IOC_MasterToMaster_Stat =
{
    /* Os_IOC_ChannelDyn          */    &IOC_MasterToMaster_Dyn,
    /* Os_IOC_ChannelLenght       */    1U,
    /* Os_IOC_ChannelBuffer       */    IOC_MasterToMasterChannel,
    /* Os_IOC_ChannelElementSize  */    (uint16) OS_SIZEOF(IOC_MasterToMasterChannelType),
    /* Os_IOC_DataCount           */    1U,
    /* Os_IOC_DataDescriptor      */    NULL_PTR,
    /* Os_IOC_LockResourceAddress */    NULL_PTR
};

static CONST (Os_IOC_ChannelStatType, OS_CONST) IocNto1_Stat =
{
    /* Os_IOC_ChannelDyn          */    &IocNto1_Dyn,
    /* Os_IOC_ChannelLenght       */    2U,
    /* Os_IOC_ChannelBuffer       */    IocNto1Channel,
    /* Os_IOC_ChannelElementSize  */    (uint16) OS_SIZEOF(IocNto1ChannelType),
    /* Os_IOC_DataCount           */    2U,
    /* Os_IOC_DataDescriptor      */    NULL_PTR,
    /* Os_IOC_LockResourceAddress */    NULL_PTR
};

static CONST (Os_IOC_ChannelStatType, OS_CONST) OsIocCommunication_Stat =
{
    /* Os_IOC_ChannelDyn          */    &OsIocCommunication_Dyn,
    /* Os_IOC_ChannelLenght       */    1U,
    /* Os_IOC_ChannelBuffer       */    OsIocCommunicationChannel,
    /* Os_IOC_ChannelElementSize  */    (uint16) OS_SIZEOF(OsIocCommunicationChannelType),
    /* Os_IOC_DataCount           */    1U,
    /* Os_IOC_DataDescriptor      */    NULL_PTR,
    /* Os_IOC_LockResourceAddress */    NULL_PTR
};

#define  OS_STOP_SEC_CONST
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

/*====================== EXTERNAL FUNCTION DEFINITIONS ======================*/
#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */
/* ============================== */

FUNC (void, OS_CODE) OS_IOC_Init ( VAR (void, AUTOMATIC) ) /* KW METRICS.E.Number_of_statements */
{
    /* Initialize all Ioc resources */

    OS_IOC_HEAD   ( IOC_MasterToMaster ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_MCOUNT ( IOC_MasterToMaster ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_STATUS ( IOC_MasterToMaster ) = IOC_E_OK;

    OS_IOC_HEAD   ( IocNto1 ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_MCOUNT ( IocNto1 ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_STATUS ( IocNto1 ) = IOC_E_OK;

    OS_IOC_HEAD   ( OsIocCommunication ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_MCOUNT ( OsIocCommunication ) = (Os_IOC_ChannelSizeType) 0U; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_STATUS ( OsIocCommunication ) = IOC_E_OK;

    /* Setup OsIocInitValue if any */

    /* IocNto1 */
    {
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (IocNto1ChannelType, AUTOMATIC, OS_APPL_DATA) newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_NEXTHEAD(IocNto1); /* KW MISRA.CAST.INT */
        OS_IOC_HEAD   ( IocNto1 ) = newIndex;
        OS_IOC_MCOUNT ( IocNto1 ) ++;

        newDataPtr = &( (IocNto1ChannelType * ) OS_IOC_DATAPTR ( IocNto1 ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        newDataPtr->IocNto1_0 = (uint32)~0; /* KW PORTING.CAST.PTR STRONG.TYPE.ASSIGN.CONSTMISRA.LITERAL.UNSIGNED.SUFFIX */
        newDataPtr->IocNto1_1 = (uint8)~0; /* KW PORTING.CAST.PTR STRONG.TYPE.ASSIGN.CONSTMISRA.LITERAL.UNSIGNED.SUFFIX */
    }

    /* OsIocCommunication */
    {
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (OsIocCommunicationChannelType, AUTOMATIC, OS_APPL_DATA) newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_NEXTHEAD(OsIocCommunication); /* KW MISRA.CAST.INT */
        OS_IOC_HEAD   ( OsIocCommunication ) = newIndex;
        OS_IOC_MCOUNT ( OsIocCommunication ) ++;

        newDataPtr = &( (OsIocCommunicationChannelType * ) OS_IOC_DATAPTR ( OsIocCommunication ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        newDataPtr->OsIocCommunication_0 = (uint32)~0; /* KW PORTING.CAST.PTR STRONG.TYPE.ASSIGN.CONSTMISRA.LITERAL.UNSIGNED.SUFFIX */
    }
}

#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


/* IOC_MasterToMaster */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocWrite_IOC_MasterToMaster (
        P2VAR (sint32, AUTOMATIC, OS_APPL_DATA) IN0 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    ( (IOC_MasterToMasterChannelType * ) OS_IOC_DATAPTR ( IOC_MasterToMaster ) )->IOC_MasterToMaster_0 = IN0; /* KW MISRA.EXPR.PARENS MISRA.CAST.CONST */
    OS_IOC_MCOUNT ( IOC_MasterToMaster ) = (Os_IOC_ChannelSizeType)1U; /* KW STRONG.TYPE.ASSIGN.CONST */
    retVal = IOC_E_OK;
    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}

#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocRead_IOC_MasterToMaster (
        P2VAR (sint32, AUTOMATIC, OS_APPL_DATA) OUT0 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( (Os_IOC_ChannelSizeType)0 == OS_IOC_MCOUNT ( IOC_MasterToMaster ) )
    {
        retVal = IOC_E_NO_DATA; 
    }
    else
    {
        * OUT0 = ( (IOC_MasterToMasterChannelType * ) OS_IOC_DATAPTR ( IOC_MasterToMaster ) )->IOC_MasterToMaster_0; /* MISRA.EXPR.PARENS KW MISRA.CAST.CONST */
        OS_IOC_MCOUNT ( IOC_MasterToMaster ) = (Os_IOC_ChannelSizeType)0; /* KW STRONG.TYPE.ASSIGN.CONST STRONG.TYPE.ASSIGN.ZERO */

        retVal = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}


#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

/* end of IOC_MasterToMaster */

/* IocNto1 */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocSendGroup_IocNto1_0 (
        P2VAR (uint32, AUTOMATIC, OS_APPL_DATA) IN0,
        P2VAR (uint8, AUTOMATIC, OS_APPL_DATA) IN1 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( OS_IOC_MCOUNT ( IocNto1 ) == OS_IOC_LENGTH ( IocNto1 ) )     {
        /* There is no more room in the queue. */
        retVal = IOC_E_LIMIT;         OS_IOC_STATUS ( IocNto1 ) = IOC_E_LOST_DATA;
    }
    else
    {
        /* Insert new item into the queue. */
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (IocNto1ChannelType, AUTOMATIC, OS_APPL_DATA)  newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_NEXTHEAD( IocNto1 ); /* KW MISRA.CAST.INT */
        OS_IOC_HEAD   ( IocNto1 ) = newIndex;
        OS_IOC_MCOUNT ( IocNto1 ) ++;
        newDataPtr = &( (IocNto1ChannelType* ) OS_IOC_DATAPTR ( IocNto1 ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        newDataPtr->IocNto1_0 = IN0;
        newDataPtr->IocNto1_1 = IN1;
        retVal = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}

#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocSendGroup_IocNto1_1 (
        P2VAR (uint32, AUTOMATIC, OS_APPL_DATA) IN0,
        P2VAR (uint8, AUTOMATIC, OS_APPL_DATA) IN1 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( OS_IOC_MCOUNT ( IocNto1 ) == OS_IOC_LENGTH ( IocNto1 ) )     {
        /* There is no more room in the queue. */
        retVal = IOC_E_LIMIT;         OS_IOC_STATUS ( IocNto1 ) = IOC_E_LOST_DATA;
    }
    else
    {
        /* Insert new item into the queue. */
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (IocNto1ChannelType, AUTOMATIC, OS_APPL_DATA)  newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_NEXTHEAD( IocNto1 ); /* KW MISRA.CAST.INT */
        OS_IOC_HEAD   ( IocNto1 ) = newIndex;
        OS_IOC_MCOUNT ( IocNto1 ) ++;
        newDataPtr = &( (IocNto1ChannelType* ) OS_IOC_DATAPTR ( IocNto1 ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        newDataPtr->IocNto1_0 = IN0;
        newDataPtr->IocNto1_1 = IN1;
        retVal = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}

#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocReceiveGroup_IocNto1 (
        P2VAR (uint32, AUTOMATIC, OS_APPL_DATA) OUT0,
        P2VAR (uint8, AUTOMATIC, OS_APPL_DATA) OUT1 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( (Os_IOC_ChannelSizeType)0 == OS_IOC_MCOUNT ( IocNto1 ) )
    {
        /* There is no data in the queue right now. */
        retVal = IOC_E_NO_DATA; 
    }
    else
    {
        /* Return the first item in the queue. */
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (IocNto1ChannelType, AUTOMATIC, OS_APPL_DATA)  newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_TAIL( IocNto1 ); /* KW MISRA.CAST.INT */
        OS_IOC_MCOUNT ( IocNto1 ) --;
        newDataPtr = &( (IocNto1ChannelType * ) OS_IOC_DATAPTR ( IocNto1 ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        * OUT0 = newDataPtr->IocNto1_0;
        * OUT1 = newDataPtr->IocNto1_1;

        retVal = OS_IOC_STATUS ( IocNto1 );
        OS_IOC_STATUS ( IocNto1 ) = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}


#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PUBLIC_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocEmptyQueue_IocNto1 ( void )
{
    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    OS_IOC_HEAD   ( IocNto1 ) = (Os_IOC_ChannelSizeType)0; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_MCOUNT ( IocNto1 ) = (Os_IOC_ChannelSizeType)0; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_STATUS ( IocNto1 ) = IOC_E_OK;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return IOC_E_OK;
}

#define  OS_STOP_SEC_PUBLIC_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

/* end of IocNto1 */

/* OsIocCommunication */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocSend_OsIocCommunication (
        P2VAR (uint32, AUTOMATIC, OS_APPL_DATA) IN0 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( OS_IOC_MCOUNT ( OsIocCommunication ) == OS_IOC_LENGTH ( OsIocCommunication ) )     {
        /* There is no more room in the queue. */
        retVal = IOC_E_LIMIT;         OS_IOC_STATUS ( OsIocCommunication ) = IOC_E_LOST_DATA;
    }
    else
    {
        /* Insert new item into the queue. */
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (OsIocCommunicationChannelType, AUTOMATIC, OS_APPL_DATA)  newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_NEXTHEAD( OsIocCommunication ); /* KW MISRA.CAST.INT */
        OS_IOC_HEAD   ( OsIocCommunication ) = newIndex;
        OS_IOC_MCOUNT ( OsIocCommunication ) ++;
        newDataPtr = &( (OsIocCommunicationChannelType* ) OS_IOC_DATAPTR ( OsIocCommunication ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        newDataPtr->OsIocCommunication_0 = IN0;
        retVal = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}

#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocReceive_OsIocCommunication (
        P2VAR (uint32, AUTOMATIC, OS_APPL_DATA) OUT0 ) /* KW MISRA.PPARAM.NEEDS.CONST */
{
    VAR (Std_ReturnType, AUTOMATIC)  retVal;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    if ( (Os_IOC_ChannelSizeType)0 == OS_IOC_MCOUNT ( OsIocCommunication ) )
    {
        /* There is no data in the queue right now. */
        retVal = IOC_E_NO_DATA; 
    }
    else
    {
        /* Return the first item in the queue. */
        VAR   (Os_IOC_ChannelSizeType, AUTOMATIC)  newIndex;
        P2VAR (OsIocCommunicationChannelType, AUTOMATIC, OS_APPL_DATA)  newDataPtr;

        newIndex = (Os_IOC_ChannelSizeType)OS_IOC_TAIL( OsIocCommunication ); /* KW MISRA.CAST.INT */
        OS_IOC_MCOUNT ( OsIocCommunication ) --;
        newDataPtr = &( (OsIocCommunicationChannelType * ) OS_IOC_DATAPTR ( OsIocCommunication ) )[ newIndex ]; /* KW MISRA.EXPR.PARENS MISRA.PTR.ARITH MISRA.CAST.CONST */
        * OUT0 = newDataPtr->OsIocCommunication_0;

        retVal = OS_IOC_STATUS ( OsIocCommunication );
        OS_IOC_STATUS ( OsIocCommunication ) = IOC_E_OK;
    }

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return retVal;
}


#define  OS_STOP_SEC_PRIVATE_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */


#define  OS_START_SEC_PUBLIC_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

FUNC (Std_ReturnType, OS_CODE) IocEmptyQueue_OsIocCommunication ( void )
{
    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_SusAllInt();

    OS_IOC_HEAD   ( OsIocCommunication ) = (Os_IOC_ChannelSizeType)0; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_MCOUNT ( OsIocCommunication ) = (Os_IOC_ChannelSizeType)0; /* KW STRONG.TYPE.ASSIGN.ZERO */
    OS_IOC_STATUS ( OsIocCommunication ) = IOC_E_OK;

    Os_PublicData[OS_GETCOREIDASUSER()].Os_PublicDataVarInitRef->Os_ISRServices->Os_ResAllInt();

    return IOC_E_OK;
}

#define  OS_STOP_SEC_PUBLIC_CODE
#include OS_MEMMAP_HEADER /* KW MISRA.INCL.INSIDE */

/* end of OsIocCommunication */



/*====================== INTERNAL FUNCTION DEFINITIONS ======================*/

/*****************************************************************************/
/*****************************************************************************/
/* End of Ioc.c */
