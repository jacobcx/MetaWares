/******************************************************************************
 *
 *             Copyright 2016 Mentor Graphics Corporation
 *                        All rights reserved
 *
 * THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE
 * PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO
 * LICENSE TERMS.
 *
 ******************************************************************************
 * This file is automatically generated by Configuration tool.
 * Do not edit manually.
 * Generated by VSC tool Version 2.5.4
 * 
 *=============================================================================
 *
 * Module:       CanIf
 *
 * File Name:    CanIf_LCfg.c
 *
 * Description:  Lists the link time configurable parameters.
 *
 *****************************************************************************/

/*=============================== INCLUSIONS ================================*/
#define CANIF_SYM_NOT_NEEDED /* Disable inclusion of symbolic name information */
#include "CanIf.h"
#include "CanIf_Private.h"
#include "CanIf_Cbk.h"
#include "PduR_CanIf.h"
#include "SchM_CanIf.h"
#include "CanSM_Cbk.h"
#include "CanTp_Cbk.h"
#include "EcuM_Cbk.h"
#include "CanTrcv_31_TJA1145.h"
#include "CanTrcv_31_UJA1132.h"
#include "Can.h"


/*============================== VERSION CHECK ==============================*/



/*=========================== EXTERNAL CONSTANTS ============================*/

#define CANIF_START_SEC_CONFIG_DATA_8  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief This parameter specifies the number of served CAN hardware units
  *
  */
CONST(uint8, CANIF_CONST) CanIf_NumberOfCanHwUnits_u8 = 0U;

/**
  * \brief This parameter specifies the number of served CAN transceiver units
  *
  */
CONST(uint8, CANIF_CONST) CanIf_NumberOfCanTrcvUnits_u8 = 3U;

/**
  * \brief This parameter specifies the number of served CAN controller units
  *
  */
CONST(uint8, CANIF_CONST) CanIf_NumberOfCanCtrlUnits_u8 = 1U;

#define CANIF_STOP_SEC_CONFIG_DATA_8  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


/**
  * \brief This container contains the callback configuration
  *  of each transmit CAN L-PDU
  *
  */
CONST(CanIfTxPduCbkConfig_t, CANIF_CONST) CanIf_TxPduCbkConfig_a[2] =
{
    /* TxPduCbk0 */
    {
        /* CanIfTxPduUserTxConfirmationUL */
        CANIF_CANTP,
        /* CanIfTxPduUserTxConfirmationName */
        &CanTp_TxConfirmation

    } ,  
    /* TxPduCbk1 */
    {
        /* CanIfTxPduUserTxConfirmationUL */
        CANIF_PDUR,
        /* CanIfTxPduUserTxConfirmationName */
        &PduR_CanIfTxConfirmation

    }  
};


/**
  * \brief This container contains the callback configuration
  *  of each receive CAN L-PDU
  *
  */
CONST(CanIfRxPduCbkConfig_t, CANIF_CONST) CanIf_RxPduCbkConfig_a[2] =
{
    /* RxPduCbkConfig0 */
    {
        /* CanIfRxPduUserRxIndicationUL */
        CANIF_CANTP,
        /* CanIfUserRxIndication_p */
        &CanTp_RxIndication
    
    } ,     
    /* RxPduCbkConfig1 */
    {
        /* CanIfRxPduUserRxIndicationUL */
        CANIF_PDUR,
        /* CanIfUserRxIndication_p */
        &PduR_CanIfRxIndication
    
    }     
};


/**
  * \brief This container contains the controller specific
  *  configuration of each CAN HTHs
  *
  */
static CONST(CanIfHthControllerConfig_t, CANIF_CONST)
CanIf_HthControllerConfig0_a[9] =
{
    /* HthControllerConfig 0 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        58,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 1 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        59,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 2 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        60,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 3 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        61,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 4 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        62,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 5 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        63,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 6 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        64,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 7 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        65,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }, 
    /* HthControllerConfig 8 in HohCfg 0 */
    {
    /**< The parameter refers to a particular HTH object in the
         CAN Driver Module configuration */
        66,
    /**< Reference to controller Id to which the HTH belongs to */
        0,
    }
};

/**
  * \brief This parameter points to controller specific
  *  configuration of each CAN HTHs
  *
  */
CONSTP2CONST(CanIfHthControllerConfig_t, CANIF_CONST, CANIF_APPL_CONST)
CanIf_HthControllerConfig_p = CanIf_HthControllerConfig0_a;
#define CANIF_STOP_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

#define CANIF_START_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */
/**
  * \brief This pointer holds the Postbuild time configurable
  *  parameters of each CAN HRHs
  *
  */
CONSTP2CONST(CanIfHrhConfigInfo_t, CANIF_CONST, CANIF_APPL_CONST)*
CanIf_HrhConfigInfo_pp = NULL_PTR;

#define CANIF_STOP_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


/**
  * \brief This container contains index to controllers corresponding
  *  to CAN HRHs of Driver 0
  *
  */
static CONST(uint8, CANIF_CONST) CanIf_HrhControllerDrv0_au8[58] =
/* HRHs for CAN Driver 0 */
{ 
    /* CanIfCanControllerHrhIdRef_u8 for HRH0 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH1 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH2 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH3 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH4 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH5 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH6 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH7 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH8 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH9 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH10 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH11 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH12 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH13 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH14 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH15 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH16 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH17 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH18 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH19 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH20 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH21 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH22 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH23 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH24 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH25 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH26 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH27 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH28 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH29 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH30 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH31 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH32 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH33 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH34 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH35 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH36 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH37 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH38 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH39 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH40 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH41 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH42 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH43 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH44 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH45 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH46 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH47 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH48 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH49 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH50 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH51 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH52 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH53 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH54 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH55 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH56 */
    0,
    /* CanIfCanControllerHrhIdRef_u8 for HRH57 */
    0
};

/**
  * \brief This container contains index to controllers corresponding
  *  to each CAN HRHs
  *
  */
static CONSTP2CONST(uint8, CANIF_CONST, CANIF_APPL_CONST)
CanIf_HrhControllerConfig_au8[1] =
{
    /* HRHs for CAN Driver 0 */
    CanIf_HrhControllerDrv0_au8
 
};


/**
  * \brief Points to the link time configurable controller id
  *  parameter of each CAN HRH
  *
  */
CONSTP2CONST(CanIf_CanControllerHrhIdRefType, CANIF_CONST, CANIF_APPL_CONST)
CanIf_HrhControllerConfig_ppcu8 = CanIf_HrhControllerConfig_au8;
/**
  * \brief This variable contains the information related to number of
  *  CAN HRHs for each CAN controller
  *
  */
static CONST(Can_HwHandleType, CANIF_CONST) CanIf_NumberOfHrh_a[1] = 
{
    /* For Driver 0*/
    58
};

/**
  * \brief Points to the information related to number of
  *  CAN HRHs for each CAN controller
  *
  */
CONSTP2CONST(Can_HwHandleType, CANIF_CONST, CANIF_APPL_CONST)
CanIf_NumberOfHrh_p = CanIf_NumberOfHrh_a;
/**
  * \brief This variable contains the information related to number of
  *  CAN HTHs
  *
  */
CONST(CanIf_HthIndexType, CANIF_CONST) CanIf_NumberOfHth = 9U;

#define CANIF_STOP_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief This container contains the RAM configuration parameters of each
  *  addressed controllers by each underlying CAN driver
  *
  */
#if (CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_API == STD_ON || CANIF_PN_SUPPORT == STD_ON)

static VAR(CanIfControllerConfigRAM_t, CANIF_VAR)
CanIf_ControllerConfigRAM0 = {
#if (CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_API == STD_ON)
/**< Boolean to indicate that Controller entered Sleep Mode */
     CANIF_FALSE,
 /**< Internal counter for maximum validation notification for a ctrl-trcv pair */
     0,
#endif
#if (CANIF_PN_SUPPORT == STD_ON) 
/**< Indicate Pn Communication mode is used or not*/
     CANIF_FALSE
#endif
};

#endif

#define CANIF_STOP_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief This container contains the callout functions with respect to
  *  upper layer
  *
  */

CONST(CanIfDispatchConfig_t, CANIF_CONST) CanIf_DispatchConfig =
{
    /* CanIfDispatchUserCtrlBusOffName */
    &CanSM_ControllerBusOff,
    /* CanIfDispatchUserValidateWakeupEventName */
    NULL_PTR,
    /* CanIfDispatchUserCtrlModeIndicationName */
    &CanSM_ControllerModeIndication,
    
    #if (CANIF_TRANSCEIVER_SUPPORT == STD_ON)
    /* CanIfDispatchUserTrcvModeIndicationName */
    &CanSM_TransceiverModeIndication,
    #endif
    
    #if (CANIF_TRANSCEIVER_SUPPORT == STD_ON && CANIF_PN_SUPPORT == STD_ON)
    /* CanIfDispatchUserCheckTrcvWakeFlagIndicationName */
    NULL_PTR,
    /* CanIfDispatchUserClearTrcvWufFlagIndicationName */
    NULL_PTR,
    #endif

    #if (CANIF_PN_SUPPORT == STD_ON)
    /* CanIfDispatchUserConfirmPnAvailabilityName */
    NULL_PTR,
    #endif

    #if (CANIF_CHECKSUM_RX_CALLOUT_SUPPORT == STD_ON)
    /* CanIfChecksumRxCalloutName */
     NULL_PTR,    
    #endif
    
    #if (CANIF_CHECKSUM_TX_CALLOUT_SUPPORT == STD_ON)
    /* CanIfChecksumTxCalloutName */
     NULL_PTR,    
    #endif
};

/**
  * \brief This container contains the configuration parameters of all
  *  addressed controllers by each underlying CAN driver
  *
  */
CONST(CanIfControllerConfig_t, CANIF_CONST)
CanIf_ControllerConfig_a[1] =
{
    /* ControllerConfig 0 - FCU_CanCluster*/
    {
        /* CanIfCtrlrEcuMWakeupSource */
        0,
        /* CanIfTrcvEcuMWakeupSource */
        0,
#if (CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_API == STD_ON || CANIF_PN_SUPPORT == STD_ON)
        /* Pointer to the RAM structure */
        &CanIf_ControllerConfigRAM0,

#endif
        /* CanIfWakeupSupport_b */
        STD_OFF,
        /* CanIfWakeupValidationSupport_b */
        STD_OFF,
        /* CanIfControllerIdRef_u8 */
        0,
        /* CanIfDriverNameRef_u8 */
        0,
        /* CanIfTrcvMapped_b */
        STD_OFF,
        /* CanIfTransceiverId_u8 */
        0,
#if (CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_API == STD_ON)
        /* Max allowed validation notification number */
        0
#endif
    }
};


/**
  * \brief This container contains the configuration parameters of all
  *  underlying CAN drivers
  *
  */
CONST(CanIfDriverConfig_t, CANIF_CONST) CanIf_DriverConfig_a[1] =
{
    /* DriverConfig 0 */
    {
        /* Pointer to CanSetControllerMode*/
        &Can_SetControllerMode,
        /* Pointer to CanWrite function of CAN driver*/
        &Can_Write,
        /* Pointer to CheckWakeup function of CAN driver*/
         NULL_PTR,
#if(CANIF_CHANGE_BAUDRATE_SUPPORT == STD_ON)
        /* Pointer to CheckBaudrate function of CAN driver*/
        &Can_CheckBaudrate,
        /* Pointer to ChangeBaudrate function of CAN driver*/
        &Can_ChangeBaudrate,
#endif

        /* Reference to the Init Hoh Configuration */
        0,

    }
};


/**
  * \brief This contains the configuration parameters of all
  *  underlying CAN transceivers addressed by each CAN transceiver driver
  *
  */
CONST(CanIfTransceiverDrvConfig_t, CANIF_CONST)
CanIf_TransceiverDrvConfig_a[3] =
{
    /* CanIfTrcvDrvCfg 0 */
    {
        /* Wakeup source ID of the underlying CAN transceiver obtained
           from EcuM */
        0,
        /* The reference to CanTrcv_SetOpMode function of CAN driver */
        &CanTrcv_31_UJA1132_SetOpMode,
        /* The reference to CanTrcv_GetOpMode function of CAN driver */
        &CanTrcv_31_UJA1132_GetOpMode,
        /* The reference to CanTrcv_GetBusWuReason function of CAN driver */
        &CanTrcv_31_UJA1132_GetBusWuReason,
        /* The reference to CanTrcv_SetWakeupMode function of CAN driver */
        &CanTrcv_31_UJA1132_SetWakeupMode,
        /* The reference to CanTrcv_CheckWakeup function of CAN driver */
        &CanTrcv_31_UJA1132_CheckWakeup,
#if(CANIF_PN_SUPPORT == STD_ON)
        /* The reference to CanTrcv_ClearTrcvWufFlag function of CAN driver */
        NULL_PTR,
        /* The reference to CanTrcv_CheckTrcvWakeFlag function of CAN driver */
        NULL_PTR,
#endif
        /* CanIfCtrlWakeupSourceIntIdx */
        0,
        /* Selects whether wakeup is supported */
        STD_OFF,
        /* Logical handle of the underlying CAN transceiver to be
         served by the CAN Interface */
        0,
        /* Logical handle of the underlying CAN transceiver driver to be
           served by the CAN Interface */
        0
    },    /* CanIfTrcvDrvCfg 1 */
    {
        /* Wakeup source ID of the underlying CAN transceiver obtained
           from EcuM */
        0,
        /* The reference to CanTrcv_SetOpMode function of CAN driver */
        &CanTrcv_31_TJA1145_SetOpMode,
        /* The reference to CanTrcv_GetOpMode function of CAN driver */
        &CanTrcv_31_TJA1145_GetOpMode,
        /* The reference to CanTrcv_GetBusWuReason function of CAN driver */
        &CanTrcv_31_TJA1145_GetBusWuReason,
        /* The reference to CanTrcv_SetWakeupMode function of CAN driver */
        &CanTrcv_31_TJA1145_SetWakeupMode,
        /* The reference to CanTrcv_CheckWakeup function of CAN driver */
        &CanTrcv_31_TJA1145_CheckWakeup,
#if(CANIF_PN_SUPPORT == STD_ON)
        /* The reference to CanTrcv_ClearTrcvWufFlag function of CAN driver */
        NULL_PTR,
        /* The reference to CanTrcv_CheckTrcvWakeFlag function of CAN driver */
        NULL_PTR,
#endif
        /* CanIfCtrlWakeupSourceIntIdx */
        0,
        /* Selects whether wakeup is supported */
        STD_OFF,
        /* Logical handle of the underlying CAN transceiver to be
         served by the CAN Interface */
        0,
        /* Logical handle of the underlying CAN transceiver driver to be
           served by the CAN Interface */
        1
    },    /* CanIfTrcvDrvCfg 2 */
    {
        /* Wakeup source ID of the underlying CAN transceiver obtained
           from EcuM */
        0,
        /* The reference to CanTrcv_SetOpMode function of CAN driver */
        &CanTrcv_31_TJA1145_SetOpMode,
        /* The reference to CanTrcv_GetOpMode function of CAN driver */
        &CanTrcv_31_TJA1145_GetOpMode,
        /* The reference to CanTrcv_GetBusWuReason function of CAN driver */
        &CanTrcv_31_TJA1145_GetBusWuReason,
        /* The reference to CanTrcv_SetWakeupMode function of CAN driver */
        &CanTrcv_31_TJA1145_SetWakeupMode,
        /* The reference to CanTrcv_CheckWakeup function of CAN driver */
        &CanTrcv_31_TJA1145_CheckWakeup,
#if(CANIF_PN_SUPPORT == STD_ON)
        /* The reference to CanTrcv_ClearTrcvWufFlag function of CAN driver */
        NULL_PTR,
        /* The reference to CanTrcv_CheckTrcvWakeFlag function of CAN driver */
        NULL_PTR,
#endif
        /* CanIfCtrlWakeupSourceIntIdx */
        0,
        /* Selects whether wakeup is supported */
        STD_OFF,
        /* Logical handle of the underlying CAN transceiver to be
         served by the CAN Interface */
        1,
        /* Logical handle of the underlying CAN transceiver driver to be
           served by the CAN Interface */
        1
    }};


/**
  * \brief Number of Wakeup sources
  *
  */
CONST(uint8, CANIF_CONST) CanIf_WakeupSourceCount = 0U;

#define CANIF_STOP_SEC_CONFIG_DATA_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_VAR_NO_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief This buffer stores the CAN controller modes
  *
  */
VAR(CanIf_ControllerModeType, CANIF_VAR)
CanIf_ControllerMode_a[1];

/**
  * \brief This buffer stores the CAN controller PDU modes
  *
  */
VAR(CanIf_PduModeType, CANIF_VAR) CanIf_PduMode_a[1];

/* if CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT is enabled  */
#if (CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT == STD_ON)
/**
  * \brief This buffer stores the CAN controller
  * Tx confirmation states
  *
  */

VAR(CanIf_NotifStatusType, CANIF_VAR)
CanIf_TxConfirmationState_a[1];

#endif /* End #if (CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT == STD_ON) */

#define CANIF_STOP_SEC_VAR_NO_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/* if CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT is enabled  */
#if (CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT == STD_ON)
/**
  * \brief This buffer stores the CAN controller
  * Tx confirmation states
  *
  */

P2VAR(CanIf_NotifStatusType, CANIF_VAR, CANIF_APPL_DATA)
CanIf_TxConfirmationState_p = CanIf_TxConfirmationState_a;

#endif /* End #if (CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT == STD_ON) */

/**
  * \brief This buffer holds the total no. of pending requests
  *  to be transmitted in each TxPdu
  *
  */
static VAR(uint8, CANIF_VAR)CanIf_NoOfPendingRequests_au8[9] = {0};

/**
  * \brief This buffer holds the total no. of pending requests
  *  to be transmitted in each TxPdu
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_NoOfPendingRequests_pu8 = CanIf_NoOfPendingRequests_au8;


#define CANIF_STOP_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_CONFIG_DATA_32  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief Hash key between Link Time and Pre Comile
  *
  */
CONST(uint32, CANIF_CONST) CanIf_LTtoPCHashValue = (uint32)912334548U;

/**
  * \brief Link Time hash key
  *
  */
CONST(uint32, CANIF_CONST) CanIf_LTHashValue = (uint32)3465002331U;

#define CANIF_STOP_SEC_CONFIG_DATA_32 /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


#define CANIF_START_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
  * \brief This pointer holds the init parameters of the CAN Interface
  *  It contains Postbuild time configurable parameters
  *
  */
P2CONST(CanIfInitConfiguration_t, CANIF_VAR, CANIF_APPL_CONST)
CanIf_InitConfiguration_p = NULL_PTR;


/**
  * \brief This pointer holds the Postbuild time configurable
  *  parameters of each transmit CAN L-PDU
  *
  */
P2CONST(CanIfTxPduConfigInfo_t, CANIF_VAR, CANIF_APPL_CONST)
CanIf_TxPduConfigInfo_p = NULL_PTR;


/**
  * \brief This pointer holds the Postbuild time configurable
  *  parameters of each receive CAN L-PDU
  *
  */
P2CONST(CanIfRxPduConfigInfo_t, CANIF_VAR, CANIF_APPL_CONST)
CanIf_RxPduConfigInfo_p = NULL_PTR;


/**
  * \brief This container contains the information related to transmit and
  *  receive buffers. It contains Link time configurable parameters
  *
  */
P2CONST(CanIfBufferInfo_t, CANIF_VAR, CANIF_APPL_CONST)
CanIf_BufferInfo_p = NULL_PTR;


/* if RxInterruptDecoupling is enabled */
#if (CANIF_RX_INT_DECOUPLING == STD_ON)

/**
  * \brief Points to inetrrupt decoupling data RAM buffer
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_RxPduIntDecDataBuf_pu8 = NULL_PTR;

/**
  * \brief Points to RxPdu inetrrupt decoupling indication status RAM buffer
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_RxPduIntDecNotifySt_pu8 = NULL_PTR;

#endif /* End #if (CANIF_RX_INT_DECOUPLING == STD_ON) */

/* if ReadRxPduData API is enabled */
#if (CANIF_READRXPDU_DATA_API == STD_ON)

/**
  * \brief Points to RxPdu data RAM buffer
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_RxPduDataBuffer_pu8 = NULL_PTR;

#endif /* End #if (CANIF_READRXPDU_DATA_API == STD_ON) */

/* if ReadRxPduNotifyStatus API is enabled  */
#if (CANIF_READRXPDU_NOTIF_STATUS_API == STD_ON)

/**
  * \brief Points to RxPdu notify status RAM buffer
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_ReadRxPduNotifySt_pu8 = NULL_PTR;

#endif /* End #if (CANIF_READRXPDU_NOTIF_STATUS_API == STD_ON) */

/* if ReadTxPduNotifyStatus API is enabled  */
#if (CANIF_READTXPDU_NOTIF_STATUS_API == STD_ON)

/**
  * \brief Points to TxPdu notify status RAM buffer
  *
  */
P2VAR(uint8, CANIF_VAR, CANIF_APPL_DATA)
CanIf_ReadTxPduNotifySt_pu8 = NULL_PTR;

#endif /* End #if (CANIF_READTXPDU_NOTIF_STATUS_API == STD_ON) */


/**
  * \brief Points to transmit data ROM buffer
  *
  */
P2CONST(CanIfBufferConfig_t, CANIF_VAR, CANIF_APPL_DATA)
CanIf_TxBuffer_p = NULL_PTR;

/**
  * \brief This variable holds Dynamic TxPduIds of all the Dynamic
  * Can Pdus
  *
  */
/* if SetDynamicTxId API is enabled  */
#if (CANIF_SETDYNAMICTXID_API == STD_ON)

P2VAR(CanIfCanId_t, CANIF_VAR, CANIF_APPL_DATA)
CanIf_DynTxPduId_p = NULL_PTR;

#endif /* End #if (CANIF_SETDYNAMICTXID_API == STD_ON) */

/**
  * \brief Pointer to the total number of Pn Filter Pdus array
  *
  */
/* if PN support is enabled  */
#if (CANIF_PN_SUPPORT == STD_ON)

P2CONST(CanIfLpduId_t, CANIF_VAR, CANIF_APPL_CONST)
CanIf_NoOfPnFilterPduIds_p = NULL_PTR;

#endif /* End #if (CANIF_PN_SUPPORT == STD_ON) */

#define CANIF_STOP_SEC_VAR_INIT_UNSPECIFIED  /* PRQA S 3614 */ 
#include "CanIf_MemMap.h"  /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */


/*========================== STUB FUNCTIONS FOR CANIF_CBK ===================*/
#define CANIF_START_SEC_CODE /* PRQA S 3614 */
#include "CanIf_MemMap.h" /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/**
 * \brief This callout function is called whenever a CAN message is
 *  received in CAN driver.
 */
 /* PRQA S 1503,3227 6 */ /* Misra 14.1 API is defined by the standard */
FUNC(void,CANIF_CODE)CanIf_RxIndication_Can
(
    VAR(Can_HwHandleType,AUTOMATIC)            Hrh,
    VAR(CanIfCanId_t,AUTOMATIC)       CanId,
    VAR(uint8,AUTOMATIC)            CanDlc,
    P2CONST( uint8, AUTOMATIC, CANIF_APPL_CONST )CanSduPtr
)
{
    CanIf_ProcessRxIndication(0U, Hrh, CanId, CanDlc, CanSduPtr);
}


/**
 * \brief This service is called by the CAN Driver after a previous
 *  request for cancellation of a pending L-PDU transmit request
 *  was successfully performed, which in turn calls the
 *  CanIf_ProcessCancelTxConf() API to initiate the
 *  processing of the cancelled TxPdu
 *
 */
 /* If CanIf_CancelTxConfirmation() API is enabled */
#if( CANIF_TX_CANCELLATION_CBK == STD_ON )
/* PRQA S 1503,3227 3 */ /* Misra 14.1 API is defined by the standard */
FUNC( void, CANIF_CODE )CanIf_CancelTxConfirmation_Can
(
    P2CONST( Can_PduType, AUTOMATIC, CANIF_APPL_CONST)PduInfoPtr
)
{
    CanIf_ProcessCancelTxConf(0U, PduInfoPtr);
}
#endif


/**
 * \brief This service is implemented in the CAN Interface and called
 *  by the CAN Driver,after the CAN L-PDU has been transmitted
 *  on the CAN network,which in turn calls the
 *  CanIf_ProcessTxConfirmation() API to report the confirmation
 *  to the upper layers
 *
 */
/* PRQA S 1503,3227 3 */ /* Misra 14.1 API is defined by the standard */
FUNC( void, CANIF_CODE )CanIf_TxConfirmation_Can
(
    VAR(PduIdType,AUTOMATIC) CanTxPduId
)
{
    CanIf_TxConfirmation(CanTxPduId);
}


/**
 * \brief This service indicates a CAN controller BusOff event
 *  of the corresponding CAN controller.
 *
 */
/* PRQA S 1503,3227 3 */ /* Misra 14.1 API is defined by the standard */
FUNC(void, CANIF_CODE)CanIf_ControllerBusOff_Can
(
    VAR(uint8,AUTOMATIC)Controller_u8
)
{
    CanIf_ProcessControllerBusOff(0U, Controller_u8);
}


/**
 * \brief This service indicates a controller state transition referring
 * to the corresponding CAN controller.
 *
 */
/* PRQA S 1503,3227 4 */ /* Misra 14.1 API is defined by the standard */
FUNC(void, CANIF_CODE)CanIf_ControllerModeIndication_Can
(
    VAR(uint8,AUTOMATIC) Controller,
    VAR(CanIf_ControllerModeType,AUTOMATIC) ControllerMode
)
{
    CanIf_ProcessControllerModeIndication(Controller, ControllerMode, 0U);
}


/**
 * \brief This service indicates a transceiver state transition referring
 * to the corresponding CAN transceiver.
 *
 */
/* PRQA S 1503,3227 4 */ /* Misra 14.1 API is defined by the standard */
FUNC(void, CANIF_CODE)CanIf_TrcvModeIndication_CanTrcv_31_UJA1132
(
    VAR(uint8,AUTOMATIC) Transceiver,
    VAR(CanTrcv_TrcvModeType,AUTOMATIC) TransceiverMode
)
{
    CanIf_ProcessTrcvModeIndication(Transceiver, TransceiverMode);
}

/**
 * \brief This service indicates a transceiver state transition referring
 * to the corresponding CAN transceiver.
 *
 */
/* PRQA S 1503,3227 4 */ /* Misra 14.1 API is defined by the standard */
FUNC(void, CANIF_CODE)CanIf_TrcvModeIndication_CanTrcv_31_TJA1145
(
    VAR(uint8,AUTOMATIC) Transceiver,
    VAR(CanTrcv_TrcvModeType,AUTOMATIC) TransceiverMode
)
{
    CanIf_ProcessTrcvModeIndication(Transceiver, TransceiverMode);
}


/**
 * \brief Generated function to enter Exclusive Area correctly
 */
FUNC( void, CANIF_CODE )SchM_Enter_CanIf    
(
    CONST(uint8,AUTOMATIC) ExclusiveArea
)
{
    /* PRQA S 2016 12 */ /* An empty default clause in this switch */
    switch(ExclusiveArea)
    {
        case 0U:
        {
            SchM_Enter_CanIf_EXCLUSIVE_AREA_0();
            break;
        }
        default:
        {
            break;
        }
    }
}

/**
 * \brief Generated function to exit Exclusive Area correctly
 */
FUNC( void, CANIF_CODE )SchM_Exit_CanIf
(
    CONST(uint8,AUTOMATIC) ExclusiveArea
)
{
    /* PRQA S 2016 12 */ /* An empty default clause in this switch */
    switch(ExclusiveArea)
    {
        case 0U:
        {
            SchM_Exit_CanIf_EXCLUSIVE_AREA_0();
            break;
        }
        default:
        {
            break;
        }
    }
}

#define CANIF_STOP_SEC_CODE /* PRQA S 3614 */
#include "CanIf_MemMap.h" /* PRQA S 5087 */ /* KW MISRA.INCL.INSIDE */

/*============================== END OF FILE CanIf_LCfg.c ===================*/
