#$$eb
#$$sz 0		- Size opt info
#$$ss 0		- XO option
#$$sg 1		- Xoptimized-debug-off option and	- g option
#$$fp 0		- Floating point mode
#$$m2		- PowerPC mnemonics
#$$pVLE		- PowerPC VLE encoding
#$$oPPCE200Z4
#$$ko 1		- Reorder info
	.file		"Dcm_Dsp.c"
#$$dg 1
	.section	.PPC.EMB.apuinfo,,@note
	.4byte		8
	.4byte		8+4
	.4byte		2
	.byte		"APUinfo"
	.byte		0
	.align		2
	.4byte		0x01040001
	.4byte		0x00400001
	.4byte		0x01010001

	.section	.text_vle
	.section	.debug_line,,n
.L8:
	.section	.text_vle
#$$ld
.L4:
	.0byte		.L2
	.d2_line_start	.debug_line
	.section	.text_vle
# FUNC(void, DCM_CODE) Dcm_DspStateMachineInit(void)
	.align		2
	.section	.text_vle
	.d2file		"d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\src\\Dcm_Dsp.c"
        .d2line         2395,22
#$$ld
.L3099:

#$$bf	Dcm_DspStateMachineInit,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4
	.globl		Dcm_DspStateMachineInit
	.d2_cfa_start __cie
Dcm_DspStateMachineInit:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_INIT;
	.d2line		2397
	diab.li		r3,0
	lis		r4,(Dcm_DspInstance+8)@ha
	stw		r3,(Dcm_DspInstance+8)@l(r4)
# }
	.d2line		2398
	.d2epilogue_begin
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3100:
	.type		Dcm_DspStateMachineInit,@function
	.size		Dcm_DspStateMachineInit,.-Dcm_DspStateMachineInit
# Number of nodes = 7

# Allocations for Dcm_DspStateMachineInit
# static FUNC(void, DCM_CODE) ResetPeriodicStatusVariables(void)
	.align		1
	.section	.text_vle
        .d2line         13136,29
#$$ld
.L3105:

#$$bf	ResetPeriodicStatusVariables,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5
	.d2_cfa_start __cie
ResetPeriodicStatusVariables:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    Dcm_DspInstance.periodic_status.next_did_to_be_sent = 0;
	.d2line		13138
	diab.li		r5,0
	lis		r3,(Dcm_DspInstance+216)@ha
	sth		r5,(Dcm_DspInstance+216)@l(r3)
#    Dcm_DspInstance.periodic_status.num_ready_dids = 0;
	.d2line		13139
	lis		r3,(Dcm_DspInstance+218)@ha
	sth		r5,(Dcm_DspInstance+218)@l(r3)
#    Dcm_DspInstance.periodic_status.num_confirmed_sent_dids = 0;
	.d2line		13140
	lis		r3,(Dcm_DspInstance+220)@ha
	sth		r5,(Dcm_DspInstance+220)@l(r3)
#    Dcm_DspInstance.periodic_status.num_sent_dids = 0;
	.d2line		13141
	lis		r3,(Dcm_DspInstance+222)@ha
	sth		r5,(Dcm_DspInstance+222)@l(r3)
#    Dcm_DspInstance.periodic_status.current_did_index = 0;
	.d2line		13142
	lis		r3,(Dcm_DspInstance+228)@ha
	sth		r5,(Dcm_DspInstance+228)@l(r3)
#    Dcm_DspInstance.periodic_status.current_source_did_index = 0;
	.d2line		13143
	lis		r3,(Dcm_DspInstance+230)@ha
	stb		r5,(Dcm_DspInstance+230)@l(r3)
#     /* Byte 0 is for the low byte of DID */
#    Dcm_DspInstance.periodic_status.bufferOffset = 1;
	.d2line		13145
	diab.li		r3,1
	lis		r4,(Dcm_DspInstance+232)@ha
	sth		r3,(Dcm_DspInstance+232)@l(r4)
#    Dcm_DspInstance.periodic_status.read_did_info.current_operation = READ_DID_INIT;
	.d2line		13146
	lis		r3,(Dcm_DspInstance+240)@ha
	stw		r5,(Dcm_DspInstance+240)@l(r3)
#    Dcm_DspInstance.periodic_status.read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		13147
	lis		r3,(Dcm_DspInstance+238)@ha
	stb		r5,(Dcm_DspInstance+238)@l(r3)
# }
	.d2line		13148
	.d2epilogue_begin
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3106:
	.type		ResetPeriodicStatusVariables,@function
	.size		ResetPeriodicStatusVariables,.-ResetPeriodicStatusVariables
# Number of nodes = 63

# Allocations for ResetPeriodicStatusVariables
# FUNC(void, DCM_CODE) Dcm_DspResetPeriodicTransmission(void)
	.align		2
	.section	.text_vle
        .d2line         13114,22
#$$ld
.L3110:

#$$bf	Dcm_DspResetPeriodicTransmission,interprocedural,rasave,nostackparams
	.globl		Dcm_DspResetPeriodicTransmission
	.d2_cfa_start __cie
Dcm_DspResetPeriodicTransmission:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    ResetPeriodicStatusVariables();
	.d2line		13116
	bl		ResetPeriodicStatusVariables
#    TimerStop(Dcm_DspInstance.periodic_status.active_timer);
	.d2line		13117
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535
	lis		r3,(Dcm_DspInstance+212)@ha
	sth		r0,(Dcm_DspInstance+212)@l(r3)
	bl		SchM_Exit_Dcm_EaTimers
#    Dcm_DspInstance.periodic_status.timer_expired = FALSE;
	.d2line		13118
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+208)@ha
	stb		r0,(Dcm_DspInstance+208)@l(r3)
#    Dcm_DspInstance.periodic_status.state = PERIODIC_IDLE;
	.d2line		13119
	lis		r3,(Dcm_DspInstance+224)@ha
	stw		r0,(Dcm_DspInstance+224)@l(r3)
#    Dcm_DslClearPeriodicTxConnection();
	.d2line		13120
	bl		Dcm_DslClearPeriodicTxConnection
# }
	.d2line		13121
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3111:
	.type		Dcm_DspResetPeriodicTransmission,@function
	.size		Dcm_DspResetPeriodicTransmission,.-Dcm_DspResetPeriodicTransmission
# Number of nodes = 29

# Allocations for Dcm_DspResetPeriodicTransmission
# static FUNC(void, DCM_CODE) ResetAllDDDiDsAndPeriodicDids(Dcm_Cfg_DDIDInitPolicyType ddidInitPolicy, Dcm_Cfg_DDPRIDInitPolicyType ddpridInitPolicy)
	.align		1
	.section	.text_vle
        .d2line         14230,29
#$$ld
.L3115:

#$$bf	ResetAllDDDiDsAndPeriodicDids,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ResetAllDDDiDsAndPeriodicDids:
.Llo1:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# ddidInitPolicy=r3 ddidInitPolicy=r3
	mr		r0,r4		# ddpridInitPolicy=r0 ddpridInitPolicy=r4
	.d2prologue_end
# {
#    uint16 i;
#    boolean ddpridClear = FALSE;
	.d2line		14233
	diab.li		r7,0		# ddpridClear=r7
# 
#    for (i = 0; i < Dcm_LCfg.num_periodic_dynamic_dids; i++)
	.d2line		14235
.Llo8:
	diab.li		r4,0
.L2996:
.Llo5:
	rlwinm		r6,r4,0,16,31		# i=r4
.Llo6:
	lis		r5,(Dcm_LCfg+72)@ha
	lhz		r5,(Dcm_LCfg+72)@l(r5)
	se_cmp		r6,r5
	bc		0,0,.L2998	# ge
#    {
#       if (NULL_PTR == Dcm_LCfg.periodicDynamicDids[i].pDataSourcesDefine)
	.d2line		14237
	rlwinm		r6,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r5)
	rlwinm		r31,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r31
	se_add		r5,r6
	lwz		r5,12(r5)
	se_cmpi		r5,0
	bc		0,2,.L2999	# ne
#       {
#          /* Store the sources for Statically defined Dids. */
#          *(Dcm_LCfg.periodicDynamicDids[i].pNumberOfDefinedSources) = Dcm_LCfg.periodicDynamicDids[i].pDDDidInfo->max_no_of_requested_sources;
	.d2line		14240
	rlwinm		r6,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r31,(Dcm_LCfg+76)@l(r5)
	rlwinm		r5,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r5
	se_add		r6,r31
	lwz		r5,4(r6)
	lbz		r31,0(r5)
	lwz		r5,16(r6)
	stb		r31,0(r5)
	b		.L3000
.L2999:
#       }
#       else if (PERIODIC_HIGH_BYTE == DcmHiByte(Dcm_LCfg.periodicDynamicDids[i].identifier))
	.d2line		14242
	rlwinm		r6,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r5)
	rlwinm		r31,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r31
	lhzx		r5,r5,r6
	rlwinm		r5,r5,24,24,31
	cmpi		0,0,r5,242
	bc		0,2,.L3001	# ne
#       {
#          if (DDPRID_CLEAR_ALWAYS == ddpridInitPolicy)
	.d2line		14244
	se_cmpi		r0,0		# ddpridInitPolicy=r0
	bc		0,2,.L3002	# ne
#          {
#             /* Clear the current number of defined sources for DDPRID. */
#             *(Dcm_LCfg.periodicDynamicDids[i].pNumberOfDefinedSources) = 0;
	.d2line		14247
	rlwinm		r6,r4,0,16,31		# i=r4
	diab.li		r31,0
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r5)
	rlwinm		r30,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r30
	se_add		r5,r6
	lwz		r5,16(r5)
	stb		r31,0(r5)
# 
#             /* NULL pointer check for safety (source code generator guarantes the pointer is set for this case). */
#             if (NULL_PTR != Dcm_LCfg.p_ddid_init_info->p_ddprid_nvm_hash_ram)
	.d2line		14250
	lis		r5,(Dcm_LCfg+168)@ha
	lwz		r5,(Dcm_LCfg+168)@l(r5)
	lwz		r5,12(r5)
	se_cmpi		r5,0
	bc		1,2,.L3000	# eq
#             {
#                ddpridClear = TRUE;
	.d2line		14252
	diab.li		r7,1		# ddpridClear=r7
	b		.L3000
.L3002:
#             }
#          }
#          else if (DDPRID_CLEAR_NEVER == ddpridInitPolicy)
	.d2line		14255
	se_cmpi		r0,2		# ddpridInitPolicy=r0
	bc		0,2,.L3000	# ne
#          {
#             /* On Internal CRC mismatch, Reset is done.
#              * NULL pointer check for safety (Source code generator guarantes the pointer is set for this case).
#              */
#             if ((NULL_PTR != Dcm_LCfg.p_ddid_init_info->p_ddprid_nvm_hash_ram) &&
	.d2line		14260
	lis		r5,(Dcm_LCfg+168)@ha
	lwz		r5,(Dcm_LCfg+168)@l(r5)
	lwz		r5,12(r5)
	se_cmpi		r5,0
	bc		1,2,.L3000	# eq
	lis		r5,(Dcm_LCfg+168)@ha
	lwz		r5,(Dcm_LCfg+168)@l(r5)
	lwz		r6,8(r5)
	lwz		r5,12(r5)
	lwz		r5,0(r5)
	se_cmpl		r6,r5
	bc		1,2,.L3000	# eq
#                 (Dcm_LCfg.p_ddid_init_info->ddprid_nvm_hash_rom != *Dcm_LCfg.p_ddid_init_info->p_ddprid_nvm_hash_ram))
#             {
#                *Dcm_LCfg.periodicDynamicDids[i].pNumberOfDefinedSources = 0;
	.d2line		14263
	rlwinm		r6,r4,0,16,31		# i=r4
	diab.li		r7,0		# ddpridClear=r7
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r5)
	rlwinm		r31,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r31
	se_add		r5,r6
	lwz		r5,16(r5)
	stb		r7,0(r5)		# ddpridClear=r7
#                ddpridClear = TRUE;
	.d2line		14264
	diab.li		r7,1		# ddpridClear=r7
	b		.L3000
.L3001:
#             }
#          }
#          else
#          {
#             /* Corresponds to DDPRID_CLEAR_ONLY_POWERON. DDPRID's will only be cleared at poweron. */
#          }
#       }
#       else
#       {
#          if (DDID_CLEAR_ALWAYS == ddidInitPolicy)
	.d2line		14274
	se_cmpi		r3,0		# ddidInitPolicy=r3
	bc		0,2,.L3000	# ne
#          {
#            /* Clear the current number of defined sources for DDDid. */
#             *(Dcm_LCfg.periodicDynamicDids[i].pNumberOfDefinedSources) = 0;
	.d2line		14277
	rlwinm		r6,r4,0,16,31		# i=r4
	diab.li		r31,0
	lis		r5,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r5)
	rlwinm		r30,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r30
	se_add		r5,r6
	lwz		r5,16(r5)
	stb		r31,0(r5)
.L3000:
#          }
#          else
#          {
#            /* DDIDs will only be cleared at poweron. */
#          }
#       }
#    }
	.d2line		14284
	diab.addi		r6,r4,1		# i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L2996
.L2998:
#    if (TRUE == ddpridClear)
	.d2line		14285
	rlwinm		r7,r7,0,24,31		# ddpridClear=r7 ddpridClear=r7
	se_cmpi		r7,1		# ddpridClear=r7
	bc		0,2,.L2995	# ne
#    {
#       *Dcm_LCfg.p_ddid_init_info->p_ddprid_nvm_hash_ram = Dcm_LCfg.p_ddid_init_info->ddprid_nvm_hash_rom;
	.d2line		14287
.Llo2:
	lis		r3,(Dcm_LCfg+168)@ha		# ddidInitPolicy=r3
.Llo3:
	lwz		r3,(Dcm_LCfg+168)@l(r3)		# ddidInitPolicy=r3 ddidInitPolicy=r3
	lwz		r0,8(r3)		# ddpridInitPolicy=r0 ddidInitPolicy=r3
.Llo7:
	lwz		r3,12(r3)		# ddidInitPolicy=r3 ddidInitPolicy=r3
	stw		r0,0(r3)		# ddidInitPolicy=r3 ddpridInitPolicy=r0
#       Dcm_NvMSetRamBlockStatus();
	.d2line		14288
	bl		Dcm_NvMSetRamBlockStatus
.L2995:
#    }
# }
	.d2line		14290
	.d2epilogue_begin
.Llo4:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# ddpridInitPolicy=r0
	mtspr		lr,r0		# ddpridInitPolicy=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3116:
	.type		ResetAllDDDiDsAndPeriodicDids,@function
	.size		ResetAllDDDiDsAndPeriodicDids,.-ResetAllDDDiDsAndPeriodicDids
# Number of nodes = 210

# Allocations for ResetAllDDDiDsAndPeriodicDids
#	?a4		ddidInitPolicy
#	?a5		ddpridInitPolicy
#	?a6		$$77
#	?a7		$$76
#	?a8		$$75
#	?a9		$$74
#	?a10		$$73
#	?a11		$$72
#	?a12		$$71
#	?a13		i
#	?a14		ddpridClear
# FUNC(void, DCM_CODE) Dcm_DspInit(void)
	.align		2
	.section	.text_vle
        .d2line         2354,22
#$$ld
.L3134:

#$$bf	Dcm_DspInit,interprocedural,rasave,nostackparams
	.globl		Dcm_DspInit
	.d2_cfa_start __cie
Dcm_DspInit:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    ResetSecurityAccessFailed();
	.d2line		2356
	diab.li		r0,0
	lis		r3,Dcm_DspInstance@ha
	e_add16i		r3,r3,Dcm_DspInstance@l
	stb		r0,0(r3)
#    ResetPendingSecurityLevel();
	.d2line		2357
	lis		r3,(Dcm_DspInstance+4)@ha
	stb		r0,(Dcm_DspInstance+4)@l(r3)
#    Dcm_DspInstance.control_dtc_setting_status.enabled = TRUE;
	.d2line		2358
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+58)@ha
	stb		r0,(Dcm_DspInstance+58)@l(r3)
#    TimerStart(Dcm_DspInstance.sec_acc_data.security_delay_timer, Dcm_LCfg.delay_boot_inv_key);
	.d2line		2359
	bl		SchM_Enter_Dcm_EaTimers
	lis		r3,(Dcm_LCfg+4)@ha
	lhz		r0,(Dcm_LCfg+4)@l(r3)
	lis		r3,(Dcm_DspInstance+2)@ha
	sth		r0,(Dcm_DspInstance+2)@l(r3)
	bl		SchM_Exit_Dcm_EaTimers
# 
#    Dcm_DspInstance.softwareDownloadOperation_status.pendingDataTransferState = DATA_TRANSFER_IDLE;
	.d2line		2361
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+128)@ha
	stw		r0,(Dcm_DspInstance+128)@l(r3)
# 
#    /*
#     * Initialise the number of sources of dynamically defined DiDs
#     * and static periodic DiDs.
#     */
#    ResetAllDDDiDsAndPeriodicDids(Dcm_LCfg.p_ddid_init_info->ddid_init_policy, Dcm_LCfg.p_ddid_init_info->ddprid_init_policy);
	.d2line		2367
	lis		r3,(Dcm_LCfg+168)@ha
	lwz		r3,(Dcm_LCfg+168)@l(r3)
	lwz		r4,4(r3)
	lwz		r3,0(r3)
	bl		ResetAllDDDiDsAndPeriodicDids
# 
#    Dcm_DspResetPeriodicTransmission();
	.d2line		2369
	bl		Dcm_DspResetPeriodicTransmission
# 
#    Dcm_DspStateMachineInit();
	.d2line		2371
	bl		Dcm_DspStateMachineInit
# }
	.d2line		2372
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3135:
	.type		Dcm_DspInit,@function
	.size		Dcm_DspInit,.-Dcm_DspInit
# Number of nodes = 63

# Allocations for Dcm_DspInit
# FUNC(void, DCM_CODE) Dcm_DspHandleTimers(void)
	.align		2
	.section	.text_vle
        .d2line         2377,22
#$$ld
.L3139:

#$$bf	Dcm_DspHandleTimers,interprocedural,rasave,nostackparams
	.globl		Dcm_DspHandleTimers
	.d2_cfa_start __cie
Dcm_DspHandleTimers:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    /*
#     * Reset the number of attempts if the security_delay_timer has run out
#     */
#    TimerProcess(Dcm_DspInstance.sec_acc_data.security_delay_timer);
	.d2line		2382
	bl		SchM_Enter_Dcm_EaTimers
	lis		r3,(Dcm_DspInstance+2)@ha
	lhz		r0,(Dcm_DspInstance+2)@l(r3)
	e_cmphl16i	r0,65535
	diab.li		r3,1
	isel		r3,r3,r0,2
.L612:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L613:
	se_cmpi		r0,0
	bc		0,2,.L607	# ne
	lis		r3,(Dcm_DspInstance+2)@ha
	lhz		r0,(Dcm_DspInstance+2)@l(r3)
	e_cmphl16i	r0,0
	diab.li		r3,1
	isel		r3,r3,r0,2
.L614:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L615:
	se_cmpi		r0,0
	bc		0,2,.L607	# ne
	lis		r3,(Dcm_DspInstance+2)@ha
	lhz		r0,(Dcm_DspInstance+2)@l(r3)
	diab.li		r4,65535
	se_add		r0,r4
	sth		r0,(Dcm_DspInstance+2)@l(r3)
.L607:
	bl		SchM_Exit_Dcm_EaTimers
#    if (FALSE != TimerElapsed(Dcm_DspInstance.sec_acc_data.security_delay_timer))
	.d2line		2383
	lis		r3,(Dcm_DspInstance+2)@ha
	lhz		r0,(Dcm_DspInstance+2)@l(r3)
	e_cmphl16i	r0,0
	diab.li		r3,1
	isel		r3,r3,r0,2
.L616:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L617:
	se_cmpi		r0,0
	bc		1,2,.L608	# eq
#    {
#       TimerStop(Dcm_DspInstance.sec_acc_data.security_delay_timer);
	.d2line		2385
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535
	lis		r3,(Dcm_DspInstance+2)@ha
	sth		r0,(Dcm_DspInstance+2)@l(r3)
	bl		SchM_Exit_Dcm_EaTimers
#       ResetSecurityAccessFailed();
	.d2line		2386
	diab.li		r0,0
	lis		r3,Dcm_DspInstance@ha
	e_add16i		r3,r3,Dcm_DspInstance@l
	stb		r0,0(r3)
.L608:
#    }
# 
#    TimerProcess(Dcm_DspInstance.periodic_status.active_timer);
	.d2line		2389
	bl		SchM_Enter_Dcm_EaTimers
	lis		r3,(Dcm_DspInstance+212)@ha
	lhz		r0,(Dcm_DspInstance+212)@l(r3)
	e_cmphl16i	r0,65535
	diab.li		r3,1
	isel		r3,r3,r0,2
.L618:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L619:
	se_cmpi		r0,0
	bc		0,2,.L611	# ne
	lis		r3,(Dcm_DspInstance+212)@ha
	lhz		r0,(Dcm_DspInstance+212)@l(r3)
	e_cmphl16i	r0,0
	diab.li		r3,1
	isel		r3,r3,r0,2
.L620:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L621:
	se_cmpi		r0,0
	bc		0,2,.L611	# ne
	lis		r3,(Dcm_DspInstance+212)@ha
	lhz		r0,(Dcm_DspInstance+212)@l(r3)
	diab.li		r4,65535
	se_add		r0,r4
	sth		r0,(Dcm_DspInstance+212)@l(r3)
.L611:
	bl		SchM_Exit_Dcm_EaTimers
# }
	.d2line		2390
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3140:
	.type		Dcm_DspHandleTimers,@function
	.size		Dcm_DspHandleTimers,.-Dcm_DspHandleTimers
# Number of nodes = 126

# Allocations for Dcm_DspHandleTimers
#	?a4		$$35
#	?a5		$$34
#	?a6		$$33
#	?a7		$$32
#	?a8		$$31
# FUNC(void, DCM_CODE) Dcm_DspGetPeriodicDataTrigger(void)
	.align		2
	.section	.text_vle
        .d2line         13802,22
#$$ld
.L3144:

#$$bf	Dcm_DspGetPeriodicDataTrigger,interprocedural,rasave,nostackparams
	.globl		Dcm_DspGetPeriodicDataTrigger
	.d2_cfa_start __cie
Dcm_DspGetPeriodicDataTrigger:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    Dcm_LCfg.p_get_periodic_data_trigger();
	.d2line		13804
	lis		r3,(Dcm_LCfg+172)@ha
	lwz		r0,(Dcm_LCfg+172)@l(r3)
	mtspr		ctr,r0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x0 0x0 0x0 0x1
#$$rs 0 s
	bcctrl		20,0
# }
	.d2line		13805
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3145:
	.type		Dcm_DspGetPeriodicDataTrigger,@function
	.size		Dcm_DspGetPeriodicDataTrigger,.-Dcm_DspGetPeriodicDataTrigger
# Number of nodes = 7

# Allocations for Dcm_DspGetPeriodicDataTrigger
# FUNC(void, DCM_CODE) Dcm_DspStateMachine(void)
	.align		2
	.section	.text_vle
        .d2line         2403,22
#$$ld
.L3149:

#$$bf	Dcm_DspStateMachine,interprocedural,rasave,nostackparams
	.globl		Dcm_DspStateMachine
	.d2_cfa_start __cie
Dcm_DspStateMachine:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
	.d2line		2405
	lis		r3,(Dcm_DspInstance+212)@ha
	lhz		r0,(Dcm_DspInstance+212)@l(r3)
	e_cmphl16i	r0,0
# 
#    if (FALSE != TimerElapsed(pStatus->active_timer))
	.d2line		2407
	diab.li		r3,1
	isel		r3,r3,r0,2
.L640:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L641:
	se_cmpi		r0,0
	bc		1,2,.L637	# eq
#    {
#       TimerStart(Dcm_DspInstance.periodic_status.active_timer, Dcm_DspInstance.periodic_status.rate);
	.d2line		2409
	bl		SchM_Enter_Dcm_EaTimers
	lis		r3,(Dcm_DspInstance+210)@ha
	lhz		r0,(Dcm_DspInstance+210)@l(r3)
	lis		r3,(Dcm_DspInstance+212)@ha
	sth		r0,(Dcm_DspInstance+212)@l(r3)
	bl		SchM_Exit_Dcm_EaTimers
	.d2line		2405
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+208)@ha
	stb		r0,(Dcm_DspInstance+208)@l(r3)
.L637:
#       pStatus->timer_expired = TRUE;
#    }
# 
#    if ((FALSE != pStatus->timer_expired) && (0 == pStatus->num_ready_dids))
	.d2line		2413
	lis		r3,(Dcm_DspInstance+208)@ha
	lbz		r0,(Dcm_DspInstance+208)@l(r3)
	se_cmpi		r0,0
	bc		1,2,.L636	# eq
	lis		r3,(Dcm_DspInstance+218)@ha
	lhz		r0,(Dcm_DspInstance+218)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L636	# ne
	.d2line		2405
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+208)@ha
	stb		r0,(Dcm_DspInstance+208)@l(r3)
#    {
#       /* Trigger readout when transmission is finished */
#       pStatus->timer_expired = FALSE;
#       Dcm_DspGetPeriodicDataTrigger();
	.d2line		2417
	bl		Dcm_DspGetPeriodicDataTrigger
.L636:
#    }
# }
	.d2line		2419
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3150:
	.type		Dcm_DspStateMachine,@function
	.size		Dcm_DspStateMachine,.-Dcm_DspStateMachine
# Number of nodes = 65

# Allocations for Dcm_DspStateMachine
#	?a4		$$36
#	not allocated	pStatus
# static FUNC(Std_ReturnType, DCM_CODE) ReadOneDDDidByDid(CONSTP2CONST(Dcm_Cfg_DDDDidSourceType, AUTOMATIC, DCM_APPL_DATA) pSource,
	.align		1
	.section	.text_vle
        .d2line         13153,39
#$$ld
.L3154:

#$$bf	ReadOneDDDidByDid,interprocedural,rasave
	.d2_cfa_start __cie
ReadOneDDDidByDid:
.Llo9:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
.Llo69:
	stmw		r22,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	22,31,1,1
	stw		r0,68(r1)		# compositeHeaderSize=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pSource=r31 pSource=r3
	mr		r30,r4		# sampleBufRemainLen=r30 sampleBufRemainLen=r4
	mr		r3,r5		# activeSession=r3 activeSession=r5
.Llo10:
	mr		r29,r6		# activeSecurityLevel=r29 activeSecurityLevel=r6
	mr		r28,r7		# sourceType=r28 sourceType=r7
	mr		r27,r8		# pReadDidInfo=r27 pReadDidInfo=r8
	mr		r26,r9		# useSampleBuffer=r26 useSampleBuffer=r9
	mr		r25,r10		# didSize=r25 didSize=r10
	lwz		r24,72(r1)		# pErrorCode=r24
	.d2prologue_end
#                                                         uint16 sampleBufRemainLen,
#                                                         Dcm_SesCtrlType activeSession,
#                                                         Dcm_SecLevelType activeSecurityLevel,
#                                                         Dcm_Cfg_DDSourcesType sourceType,
#                                                         CONSTP2VAR(CommonReadDidInfoType, AUTOMATIC, DCM_APPL_DATA) pReadDidInfo,
#                                                         boolean useSampleBuffer,
#                                                         CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) didSize,
#                                                         CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Std_ReturnType                stdReturnVal                  = E_OK;
	.d2line		13163
.Llo55:
	diab.li		r22,0		# stdReturnVal=r22
#    Dcm_NegativeResponseCodeType  conditionCheckReadResponse    = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		13164
	diab.li		r0,0		# compositeHeaderSize=r0
	stb		r0,8(r1)		# compositeHeaderSize=r0
#    CONST(uint8, DCM_CONST) compositeHeaderSize = ((sourceType == DCM_COMP_DID) ? 2U : 0U);
	.d2line		13165
	se_cmpi		r28,4		# sourceType=r28
	diab.li		r4,2		# compositeHeaderSize=r4
.Llo13:
	isel		r4,r4,r0,2		# compositeHeaderSize=r4 compositeHeaderSize=r4 compositeHeaderSize=r0
.L2756:
.Llo11:
	diab.li		r0,0		# compositeHeaderSize=r0
.Llo17:
	isel		r23,r4,r0,2		# compositeHeaderSize=r23 compositeHeaderSize=r4 compositeHeaderSize=r0
.L2757:
#    Dcm_MsgLenType totalLength;
# 
#    if (READ_DID_INIT == pReadDidInfo->current_operation)
	.d2line		13168
.Llo70:
	lwz		r0,4(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
.Llo71:
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2714	# ne
#    {
#       /*
#        * 1. Does the DID have read access configured?
#        */
#       if (NULL_PTR == pSource->pDidRead)
	.d2line		13173
	lwz		r0,16(r31)		# compositeHeaderSize=r0 pSource=r31
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2715	# ne
#       {
#          /*
#           * The requested DID has no read access configured. Report an error and break.
#           */
#          stdReturnVal  = E_NOT_OK;
	.d2line		13178
	diab.li		r22,1		# stdReturnVal=r22
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13179
	diab.li		r0,49		# compositeHeaderSize=r0
	stb		r0,0(r24)		# pErrorCode=r24 compositeHeaderSize=r0
	b		.L2714
.L2715:
#       }
#       else if (!Dcm_LCfg.check_per_source_did)
	.d2line		13181
	lis		r4,(Dcm_LCfg+84)@ha		# compositeHeaderSize=r4
	lbz		r0,(Dcm_LCfg+84)@l(r4)		# compositeHeaderSize=r0 compositeHeaderSize=r4
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2717	# ne
#       {
#          /*
#           * No checks shall be done on individual source.
#           * Change immediately to the next operation step.
#           */
#          pReadDidInfo->current_operation = READ_DID_CONDITION_CHECK;
	.d2line		13187
	diab.li		r0,1		# compositeHeaderSize=r0
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
#          pReadDidInfo->current_opstatus = DCM_INITIAL;
	.d2line		13188
	diab.li		r0,0		# compositeHeaderSize=r0
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
	b		.L2714
.L2717:
#       }
#       /*
#        * 2. Can the DID be read in the current session?
#        */
#       else if (!Dcm_IsLevelSupported(activeSession, pSource->pDidRead->p_session_levels))
	.d2line		13193
.Llo18:
	lwz		r4,16(r31)		# compositeHeaderSize=r4 pSource=r31
.Llo19:
	lwz		r4,16(r4)		# compositeHeaderSize=r4 compositeHeaderSize=r4
	rlwinm		r3,r3,0,24,31		# activeSession=r3 activeSession=r3
	bl		Dcm_IsLevelSupported
.Llo20:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
	bc		0,2,.L2719	# ne
#       {
#          stdReturnVal  = E_NOT_OK;
	.d2line		13195
	diab.li		r22,1		# stdReturnVal=r22
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13196
	diab.li		r0,49		# compositeHeaderSize=r0
	stb		r0,0(r24)		# pErrorCode=r24 compositeHeaderSize=r0
	b		.L2714
.L2719:
#       }
#       /*
#        * 3. Can the DID be read in the current security level?
#        */
#       else if (!Dcm_IsLevelSupported(activeSecurityLevel, pSource->pDidRead->p_security_levels))
	.d2line		13201
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
.Llo21:
	lwz		r4,12(r3)		# compositeHeaderSize=r4 activeSession=r3
	rlwinm		r3,r29,0,24,31		# activeSession=r3 activeSecurityLevel=r29
.Llo22:
	bl		Dcm_IsLevelSupported
.Llo23:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo24:
	bc		0,2,.L2721	# ne
#       {
#          stdReturnVal  = E_NOT_OK;
	.d2line		13203
.Llo45:
	diab.li		r22,1		# stdReturnVal=r22
#          *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		13204
	diab.li		r0,51		# compositeHeaderSize=r0
	stb		r0,0(r24)		# pErrorCode=r24 compositeHeaderSize=r0
	b		.L2714
.L2721:
#       }
#       /*
#        * 4. [SWS_Dcm_00819]: Can the DDDid be read in the current mode conditions?
#        */
#       else if (!Dcm_IsCurrentModesAllowed(pSource->pDidRead->modeRuleFunc, pErrorCode))
	.d2line		13209
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
.Llo25:
	lwz		r3,20(r3)		# activeSession=r3 activeSession=r3
.Llo26:
	mr		r4,r24		# pErrorCode=r4 pErrorCode=r24
	bl		Dcm_IsCurrentModesAllowed
.Llo27:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo28:
	bc		0,2,.L2723	# ne
#       {
#          /*
#           * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#           */
#          if (DCM_INT_NRC_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING == *pErrorCode)
	.d2line		13214
	lbz		r0,0(r24)		# compositeHeaderSize=r0 pErrorCode=r24
	cmpi		0,0,r0,120		# compositeHeaderSize=r0
#          {
#             stdReturnVal = DCM_E_PENDING;
	.d2line		13216
	diab.li		r3,10		# activeSession=r3
.Llo29:
	isel		r3,r3,r22,2		# stdReturnVal=r3 activeSession=r3 stdReturnVal=r22
.L2724:
#          }
#          else
#          {
#             stdReturnVal = E_NOT_OK;
	.d2line		13220
.Llo30:
	diab.li		r0,1		# compositeHeaderSize=r0
.Llo57:
	isel		r22,r3,r0,2		# stdReturnVal=r22 stdReturnVal=r3 compositeHeaderSize=r0
	b		.L2714
.L2723:
#          }
#       }
#       else
#       {
#          pReadDidInfo->current_operation = READ_DID_CONDITION_CHECK;
	.d2line		13225
.Llo56:
	diab.li		r0,1		# compositeHeaderSize=r0
.Llo58:
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
#          pReadDidInfo->current_opstatus = DCM_INITIAL;
	.d2line		13226
	diab.li		r0,0		# compositeHeaderSize=r0
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
.L2714:
#       }
#    }
# 
#    if (READ_DID_CONDITION_CHECK == pReadDidInfo->current_operation)
	.d2line		13230
.Llo31:
	lwz		r0,4(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
	se_cmpi		r0,1		# compositeHeaderSize=r0
	bc		0,2,.L2727	# ne
#    {
#       /*
#        * 5. Does the application allow the DID to be read?
#        */
#       if (NULL_PTR != pSource->pDidRead->ConditionCheckReadFunc)
	.d2line		13235
.Llo32:
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
.Llo33:
	lwz		r0,0(r3)		# compositeHeaderSize=r0 activeSession=r3
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		1,2,.L2728	# eq
#       {
#          stdReturnVal = pSource->pDidRead->ConditionCheckReadFunc(pReadDidInfo->current_opstatus, &conditionCheckReadResponse);
	.d2line		13237
.Llo59:
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,0(r3)		# compositeHeaderSize=r0 activeSession=r3
	mtspr		ctr,r0		# compositeHeaderSize=ctr
	lbz		r3,2(r27)		# activeSession=r3 pReadDidInfo=r27
	diab.addi		r4,r1,8		# compositeHeaderSize=r4
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo34:
	mr		r22,r3		# stdReturnVal=r22 stdReturnVal=r3
	b		.L2729
.L2728:
#       }
#       else
#       {
#          /* No ConditionCheckRead configured so consider it OK to read the data */
#          stdReturnVal  = E_OK;
	.d2line		13242
.Llo35:
	diab.li		r22,0		# stdReturnVal=r22
.L2729:
#       }
# 
#       if (DCM_E_PENDING == stdReturnVal)
	.d2line		13245
.Llo60:
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
	se_cmpi		r0,10		# compositeHeaderSize=r0
	bc		0,2,.L2730	# ne
#       {
#          pReadDidInfo->current_opstatus = DCM_PENDING;
	.d2line		13247
	diab.li		r0,1		# compositeHeaderSize=r0
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
	b		.L2727
.L2730:
#       }
#       else if (E_OK == stdReturnVal)
	.d2line		13249
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2727	# ne
#       {
#          pReadDidInfo->current_operation = READ_DID_LENGTH;
	.d2line		13251
	diab.li		r0,2		# compositeHeaderSize=r0
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
#          pReadDidInfo->current_opstatus = DCM_INITIAL;
	.d2line		13252
	diab.li		r0,0		# compositeHeaderSize=r0
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
.L2727:
#       }
#       else
#       {
#          /*
#           * NOT_OK will be handled by the caller.
#           */
#       }
#    }
# 
#    if (READ_DID_LENGTH == pReadDidInfo->current_operation)
	.d2line		13262
	lwz		r0,4(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
	se_cmpi		r0,2		# compositeHeaderSize=r0
	bc		0,2,.L2734	# ne
#    {
#       if (NULL_PTR == pSource->pDidRead->ReadDataLengthFunc)
	.d2line		13264
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,4(r3)		# compositeHeaderSize=r0 activeSession=r3
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2735	# ne
#       {
#          /*
#           * 6. Will the data to be read fit into the response buffer? Note that paged buffer is currently not supported
#           * If ReadDataLength is NULL_PTR, the DID response is of fixed length. Otherwise, call application
#           * to get the response length.
#           */
# 
#          /*
#           * pSource-memoryId is also used for DID size, the whole length of source DID.
#           */
#          pReadDidInfo->current_size = pSource->memory_id;
	.d2line		13275
.Llo61:
	lhz		r0,4(r31)		# compositeHeaderSize=r0 pSource=r31
	sth		r0,0(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
#          stdReturnVal  = E_OK;
	.d2line		13276
	diab.li		r22,0		# stdReturnVal=r22
.Llo62:
	b		.L2736
.L2735:
#       }
#       else
#       {
#          /*
#           * This will only be used by static periodic DIDs with dynamic length.
#           * - The SCG will make sure that a composite DID doesn't have any sources with a dynamic length.
#           * - The DcmDsp will make sure that anyone is trying to define a DDDID using a source with a dynamic length.
#           *
#           * PENDING is not handled and support for ReadDataLength in this case will be removed.
#           * See BZ #22710 for details.
#           */
#          stdReturnVal = pSource->pDidRead->ReadDataLengthFunc(pReadDidInfo->current_opstatus, &pReadDidInfo->current_size);
	.d2line		13288
.Llo63:
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,4(r3)		# compositeHeaderSize=r0 activeSession=r3
	mtspr		ctr,r0		# compositeHeaderSize=ctr
	lbz		r3,2(r27)		# activeSession=r3 pReadDidInfo=r27
	mr		r4,r27		# pReadDidInfo=r4 pReadDidInfo=r27
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo36:
	mr		r22,r3		# stdReturnVal=r22 stdReturnVal=r3
.L2736:
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		13291
.Llo37:
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
.Llo64:
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2734	# ne
#       {
#          pReadDidInfo->current_operation = READ_DID_BUFFER;
	.d2line		13293
	diab.li		r0,3		# compositeHeaderSize=r0
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
.L2734:
#       }
#       else
#       {
#          /*
#           * NOT_OK will be handled by the caller.
#           */
#       }
#    }
# 
#    if (READ_DID_BUFFER == pReadDidInfo->current_operation)
	.d2line		13303
	lwz		r0,4(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
	se_cmpi		r0,3		# compositeHeaderSize=r0
	bc		0,2,.L2739	# ne
#    {
#       /* For missing sample buffer shall the function request a buffer from DSD */
#       if (useSampleBuffer)
	.d2line		13306
.Llo49:
	rlwinm		r26,r26,0,24,31		# useSampleBuffer=r26 useSampleBuffer=r26
.Llo50:
	se_cmpi		r26,0		# useSampleBuffer=r26
	bc		0,2,.L2741	# ne
#       {
#          /*
#           * Use the provided buffer already assigned to pReadDidInfo->current_res_buffer
#           */
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if ((TRUE == pSource->pDidRead->multiple_signals) && ((0 == pSource->address) || (DCM_COMP_DID == sourceType)))
#       {
#          /*
#           * Multiple signals so the wrapper will allocate it's own buffers if needed.
#           * Only allocate a possible composite header. Asking for zero won't harm.
#           * If not defined for byte position 0, the wrapper cannot handle the buffers (no byte shift)
#           * and the complete signal needs to fit into one page.
#           */
#          totalLength = (Dcm_MsgLenType)compositeHeaderSize;
#          stdReturnVal = Dcm_DsdRequestResponseBuffer(totalLength, &pReadDidInfo->current_res_buffer);
#       }
# #endif
#       else
#       {
#          /*
#           * It's safe to cast since the requested size shall fit into a Dcm_MsgLenType
#           */
#          totalLength = (Dcm_MsgLenType)(pSource->size + compositeHeaderSize);
	.d2line		13330
	lwz		r3,12(r31)		# activeSession=r3 pSource=r31
	rlwinm		r0,r23,0,24,31		# compositeHeaderSize=r0 compositeHeaderSize=r23
	se_add		r0,r3		# compositeHeaderSize=r0 compositeHeaderSize=r0 activeSession=r3
.Llo90:
	mr		r3,r0		# totalLength=r3 totalLength=r0
#          stdReturnVal = Dcm_DsdRequestResponseBuffer(totalLength, &pReadDidInfo->current_res_buffer);
	.d2line		13331
	rlwinm		r3,r3,0,16,31		# totalLength=r3 totalLength=r3
	diab.addi		r4,r27,8		# compositeHeaderSize=r4 pReadDidInfo=r27
	bl		Dcm_DsdRequestResponseBuffer
.Llo38:
	mr		r22,r3		# stdReturnVal=r22 stdReturnVal=r3
.L2741:
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		13334
.Llo39:
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2739	# ne
#       {
#          if (DCM_COMP_DID == sourceType)
	.d2line		13336
	se_cmpi		r28,4		# sourceType=r28
	bc		0,2,.L2743	# ne
#          {
#             /*
#              * Put source Id before its data in case of composite DID
#              */
#             SET_2BYTE_ID(&pReadDidInfo->current_res_buffer[0], DcmLoWord(pSource->address));
	.d2line		13341
	lwz		r0,8(r31)		# compositeHeaderSize=r0 pSource=r31
	rlwinm		r0,r0,24,24,31		# compositeHeaderSize=r0 compositeHeaderSize=r0
	lwz		r3,8(r27)		# activeSession=r3 pReadDidInfo=r27
	stb		r0,0(r3)		# activeSession=r3 compositeHeaderSize=r0
	lwz		r0,8(r31)		# compositeHeaderSize=r0 pSource=r31
	lwz		r3,8(r27)		# activeSession=r3 pReadDidInfo=r27
	stb		r0,1(r3)		# activeSession=r3 compositeHeaderSize=r0
.L2743:
#          }
# 
#          pReadDidInfo->current_operation = READ_DID_DATA;
	.d2line		13344
	diab.li		r0,4		# compositeHeaderSize=r0
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
.L2739:
#       }
#       else
#       {
#          /*
#           * Errors will be handled in the calling function
#           */
#       }
#    }
# 
#    if (READ_DID_DATA == pReadDidInfo->current_operation)
	.d2line		13354
.Llo51:
	lwz		r0,4(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
.Llo52:
	se_cmpi		r0,4		# compositeHeaderSize=r0
	bc		0,2,.L2746	# ne
#    {
#       if ((DCM_COMP_DID == sourceType) || ((0 == pSource->address) && (sampleBufRemainLen >= pReadDidInfo->current_size)))
	.d2line		13356
.Llo53:
	se_cmpi		r28,4		# sourceType=r28
.Llo54:
	bc		1,2,.L2758	# eq
.Llo46:
	lwz		r0,8(r31)		# compositeHeaderSize=r0 pSource=r31
.Llo47:
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2747	# ne
	rlwinm		r30,r30,0,16,31		# sampleBufRemainLen=r30 sampleBufRemainLen=r30
	lhz		r0,0(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
	se_cmp		r30,r0		# sampleBufRemainLen=r30 compositeHeaderSize=r0
	bc		1,0,.L2747	# lt
.L2758:
#       {
#          /*
#           * The remaining buffer is enough and at least the first part of data is required.
#           */
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          if ((FALSE != pSource->pDidRead->multiple_signals) && (FALSE == useSampleBuffer))
#          {
#             /*
#              * For multiple signals will the wrapper handle the buffers by its own.
#              */
#             stdReturnVal = pSource->pDidRead->ReadDataFunc(pReadDidInfo->current_opstatus, NULL_PTR);
#          }
#          else
# #endif
#          {
#             stdReturnVal = pSource->pDidRead->ReadDataFunc(pReadDidInfo->current_opstatus, &pReadDidInfo->current_res_buffer[compositeHeaderSize]);
	.d2line		13372
.Llo72:
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,8(r3)		# compositeHeaderSize=r0 activeSession=r3
	mtspr		ctr,r0		# compositeHeaderSize=ctr
	lwz		r4,8(r27)		# compositeHeaderSize=r4 pReadDidInfo=r27
.Llo73:
	rlwinm		r23,r23,0,24,31		# compositeHeaderSize=r23 compositeHeaderSize=r23
	add		r4,r4,r23		# compositeHeaderSize=r4 compositeHeaderSize=r4 compositeHeaderSize=r23
.Llo74:
	lbz		r3,2(r27)		# activeSession=r3 pReadDidInfo=r27
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo14:
	mr		r22,r3		# stdReturnVal=r22 stdReturnVal=r3
	b		.L2748
.L2747:
#          }
#       }
#       /*
#        * Is the DID to be read not bigger than the temporary buffer?
#        */
#       else if (Dcm_LCfg.sourceBufferSize < pReadDidInfo->current_size)
	.d2line		13378
.Llo15:
	lis		r3,(Dcm_LCfg+24)@ha		# activeSession=r3
	lhz		r0,(Dcm_LCfg+24)@l(r3)		# compositeHeaderSize=r0 activeSession=r3
	lhz		r3,0(r27)		# activeSession=r3 pReadDidInfo=r27
	se_cmp		r0,r3		# compositeHeaderSize=r0 activeSession=r3
	bc		0,0,.L2749	# ge
#       {
#          /*
#           * The data length of DID is too large. Return an error.
#           * No given value according to specification.
#           */
#          stdReturnVal  = E_NOT_OK;
	.d2line		13384
.Llo16:
	diab.li		r22,1		# stdReturnVal=r22
.Llo65:
	b		.L2748
.L2749:
#       }
#       else
#       {
#          /*
#           * Use the temporary buffer to read pReadDidInfo->current_size amount of data.
#           */
#          stdReturnVal = pSource->pDidRead->ReadDataFunc(pReadDidInfo->current_opstatus, Dcm_LCfg.p_dddid_sourceBuffer);
	.d2line		13391
.Llo66:
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,8(r3)		# compositeHeaderSize=r0 activeSession=r3
	mtspr		ctr,r0		# compositeHeaderSize=ctr
	lbz		r3,2(r27)		# activeSession=r3 pReadDidInfo=r27
	lis		r4,(Dcm_LCfg+28)@ha		# compositeHeaderSize=r4
.Llo75:
	lwz		r4,(Dcm_LCfg+28)@l(r4)		# compositeHeaderSize=r4 compositeHeaderSize=r4
.Llo76:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo40:
	mr		r22,r3		# stdReturnVal=r22 stdReturnVal=r3
# 
#          if (E_OK == stdReturnVal)
	.d2line		13393
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
.Llo77:
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2748	# ne
#          {
#             /*
#              * Copy the needed portion of data to the periodic sample buffer.
#              *
#              * For static periodic DIDs with a dynamic length, the *didSize should strictly be used
#              * instead of pSource->size. But since pSource->size always will be greater or equal to
#              * *didSize, the DcmDsp might copy some unnecessary bytes. The actual length is updated below.
#              */
#             Dcm_Memcpy(&pReadDidInfo->current_res_buffer[0], &Dcm_LCfg.p_dddid_sourceBuffer[pSource->address], (Dcm_MsgLenType)pSource->size);
	.d2line		13402
.Llo67:
	lis		r3,(Dcm_LCfg+28)@ha		# activeSession=r3
.Llo41:
	lwz		r4,(Dcm_LCfg+28)@l(r3)		# compositeHeaderSize=r4 activeSession=r3
.Llo78:
	lwz		r0,8(r31)		# compositeHeaderSize=r0 pSource=r31
	se_add		r4,r0		# compositeHeaderSize=r4 compositeHeaderSize=r4 compositeHeaderSize=r0
.Llo79:
	lwz		r5,12(r31)		# pSource=r31
.Llo80:
	rlwinm		r5,r5,0,16,31
	lwz		r3,8(r27)		# activeSession=r3 pReadDidInfo=r27
.Llo42:
	bl		Dcm_Memcpy
.L2748:
#          }
#       }
# 
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#       {
#          /*
#           * Buffer request in wrapper returned pending which only happen during paged buffering.
#           * Wait for the next schedule and see if buffer has been freed.
#           */
#          pReadDidInfo->current_opstatus = DCM_PENDING;
#          stdReturnVal = DCM_E_PENDING;
#       }
#       else
# #endif
#       /* else */ if (DCM_E_PENDING != stdReturnVal)
	.d2line		13418
.Llo43:
	rlwinm		r0,r22,0,24,31		# compositeHeaderSize=r0 stdReturnVal=r22
.Llo81:
	se_cmpi		r0,10		# compositeHeaderSize=r0
	bc		1,2,.L2752	# eq
#       {
#          pReadDidInfo->current_operation = READ_DID_INIT;
	.d2line		13420
.Llo82:
	diab.li		r0,0		# compositeHeaderSize=r0
.Llo83:
	stw		r0,4(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
#          pReadDidInfo->current_opstatus = DCM_INITIAL;
	.d2line		13421
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
# 
#          /*
#           * For static periodic DIDs with dynamic length will *didSize already contain the
#           * actual length to be sent. For DDDID might the defined length be equal or less
#           * to the source DID and therefore shall the *didSize be updated with the defined
#           * one. Composite DID and static periodic DID with fixed length do also need to
#           * update the actual didSize.
#           */
#          if (NULL_PTR == pSource->pDidRead->ReadDataLengthFunc)
	.d2line		13430
	lwz		r3,16(r31)		# activeSession=r3 pSource=r31
	lwz		r0,4(r3)		# compositeHeaderSize=r0 activeSession=r3
	se_cmpi		r0,0		# compositeHeaderSize=r0
	bc		0,2,.L2753	# ne
#          {
#             /*
#              * pSource->size is also used for memory which can be 32 bit big.
#              * A DID is always equal or less to 16 bit. A typecast is therefore safe.
#              */
#             *didSize = (uint16) pSource->size;
	.d2line		13436
.Llo84:
	lwz		r0,12(r31)		# compositeHeaderSize=r0 pSource=r31
.Llo85:
	sth		r0,0(r25)		# didSize=r25 compositeHeaderSize=r0
	b		.L2746
.L2753:
#          }
#          else
#          {
#             *didSize = pReadDidInfo->current_size;
	.d2line		13440
.Llo86:
	lhz		r0,0(r27)		# compositeHeaderSize=r0 pReadDidInfo=r27
.Llo87:
	sth		r0,0(r25)		# didSize=r25 compositeHeaderSize=r0
	b		.L2746
.L2752:
#          }
#       }
#       else
#       {
#          /*
#           * When ReadData returns pending only ReadData will be called again.
#           */
#          pReadDidInfo->current_opstatus = DCM_PENDING;
	.d2line		13448
.Llo88:
	diab.li		r0,1		# compositeHeaderSize=r0
.Llo89:
	stb		r0,2(r27)		# pReadDidInfo=r27 compositeHeaderSize=r0
.L2746:
#       }
#    }
# 
#    return stdReturnVal;
	.d2line		13452
.Llo12:
	rlwinm		r3,r22,0,24,31		# activeSession=r3 stdReturnVal=r22
# }
	.d2line		13453
	.d2epilogue_begin
.Llo48:
	lmw		r22,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
.Llo68:
	lwz		r0,68(r1)		# compositeHeaderSize=r0
	mtspr		lr,r0		# compositeHeaderSize=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo44:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3155:
	.type		ReadOneDDDidByDid,@function
	.size		ReadOneDDDidByDid,.-ReadOneDDDidByDid
# Number of nodes = 504

# Allocations for ReadOneDDDidByDid
#	?a4		pSource
#	?a5		sampleBufRemainLen
#	?a6		activeSession
#	?a7		activeSecurityLevel
#	?a8		sourceType
#	?a9		pReadDidInfo
#	?a10		useSampleBuffer
#	?a11		didSize
#	?a12		pErrorCode
#	?a13		stdReturnVal
#	SP,8		conditionCheckReadResponse
#	?a14		compositeHeaderSize
#	?a15		totalLength
# static FUNC(Dcm_Cfg_MemoryRangePointerType, DCM_CODE) GetMemoryRange(uint8 memoryId,
	.align		1
	.section	.text_vle
        .d2line         12812,55
#$$ld
.L3197:

#$$bf	GetMemoryRange,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetMemoryRange:
.Llo91:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# memoryId=r3 memoryId=r3
	mr		r4,r4		# memoryAddress=r4 memoryAddress=r4
	mr		r5,r5		# memorySize=r5 memorySize=r5
	mr		r6,r6		# p_memory=r6 p_memory=r6
	.d2prologue_end
#                                                                      uint32 memoryAddress,
#                                                                      uint32 memorySize,
#                                                                      CONSTP2CONST(Dcm_Cfg_MemoryType, AUTOMATIC, DCM_APPL_CONST) p_memory)
# {
#    Dcm_Cfg_MemoryRangePointerType memoryRange = NULL_PTR;
	.d2line		12817
	diab.li		r7,0		# memoryRange=r7
#    uint8 rangeIdx;
#    for (rangeIdx = 0; rangeIdx < p_memory->num_memory_ranges; rangeIdx++)
	.d2line		12819
.Llo93:
	diab.li		r31,0
.L2614:
.Llo95:
	rlwinm		r0,r31,0,24,31		# rangeIdx=r31
	lbz		r30,12(r6)		# p_memory=r6
	se_cmp		r0,r30
	bc		0,0,.L2618	# ge
#    {
#       /*
#        * [SWS_Dcm_00489], [SWS_Dcm_01052]
#        * [SWS_Dcm_00493], [SWS_Dcm_01053]
#        * The requested memory id and ranges shall be allowed according to the configuration
#        */
#       if ((memoryId == p_memory->p_memory_ranges[rangeIdx].memid) &&
	.d2line		12826
	rlwinm		r29,r3,0,24,31		# memoryId=r3
	lwz		r30,8(r6)		# p_memory=r6
	rlwinm		r0,r31,0,24,31		# rangeIdx=r31
	e_mulli		r0,r0,20
	lbzx		r0,r30,r0
	se_cmp		r29,r0
	bc		0,2,.L2617	# ne
	lwz		r30,8(r6)		# p_memory=r6
	rlwinm		r0,r31,0,24,31		# rangeIdx=r31
	e_mulli		r0,r0,20
	se_add		r30,r0
	lwz		r0,4(r30)
	se_cmpl		r0,r4		# memoryAddress=r4
	bc		1,1,.L2617	# gt
	lwz		r30,8(r6)		# p_memory=r6
	rlwinm		r0,r31,0,24,31		# rangeIdx=r31
	e_mulli		r0,r0,20
	se_add		r30,r0
	lwz		r0,8(r30)
	add		r30,r4,r5		# memoryAddress=r4 memorySize=r5
	diab.addi		r30,r30,-1
	se_cmpl		r0,r30
	bc		1,0,.L2617	# lt
#          (p_memory->p_memory_ranges[rangeIdx].low <= memoryAddress) &&
#          (p_memory->p_memory_ranges[rangeIdx].high >= (memoryAddress + (memorySize-1U))))
#       {
#          memoryRange = &p_memory->p_memory_ranges[rangeIdx];
	.d2line		12830
.Llo96:
	lwz		r7,8(r6)		# memoryRange=r7 p_memory=r6
.Llo97:
	rlwinm		r31,r31,0,24,31		# rangeIdx=r31 rangeIdx=r31
	e_mulli		r31,r31,20		# rangeIdx=r31 rangeIdx=r31
	se_add		r7,r31		# memoryRange=r7 memoryRange=r7 rangeIdx=r31
	mr		r7,r7		# memoryRange=r7 memoryRange=r7
	b		.L2618
.L2617:
#          break;
#       }
#    }
	.d2line		12833
	diab.addi		r0,r31,1		# rangeIdx=r31
	se_addi		r31,1		# rangeIdx=r31 rangeIdx=r31
	b		.L2614
.L2618:
#    return memoryRange;
	.d2line		12834
.Llo92:
	mr		r3,r7		# memoryRange=r3 memoryRange=r7
# }
	.d2line		12835
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo94:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3198:
	.type		GetMemoryRange,@function
	.size		GetMemoryRange,.-GetMemoryRange
# Number of nodes = 77

# Allocations for GetMemoryRange
#	?a4		memoryId
#	?a5		memoryAddress
#	?a6		memorySize
#	?a7		p_memory
#	?a8		memoryRange
#	?a9		rangeIdx
# static FUNC(boolean, DCM_CODE) IsMemoryRangeAcessible(CONSTP2CONST(Dcm_Cfg_MemoryRangeType, AUTOMATIC, DCM_APPL_CONST) p_memoryRange)
	.align		1
	.section	.text_vle
        .d2line         12840,32
#$$ld
.L3222:

#$$bf	IsMemoryRangeAcessible,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
IsMemoryRangeAcessible:
.Llo98:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# p_memoryRange=r31 p_memoryRange=r3
	.d2prologue_end
# {
#    Dcm_SecLevelType activeSecLevel;
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * [SWS_Dcm_00338] : E_OK shall always be returned.
#     */
#    (void)Dcm_GetSecurityLevel(&activeSecLevel);
	.d2line		12849
.Llo99:
	diab.addi		r3,r1,8
.Llo100:
	bl		Dcm_GetSecurityLevel
# 
#    return Dcm_IsLevelSupported(activeSecLevel, p_memoryRange->p_security_levels);
	.d2line		12851
	lbz		r3,8(r1)
	lwz		r4,12(r31)		# p_memoryRange=r31
	bl		Dcm_IsLevelSupported
	rlwinm		r3,r3,0,24,31
# }
	.d2line		12852
	.d2epilogue_begin
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
.Llo101:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3223:
	.type		IsMemoryRangeAcessible,@function
	.size		IsMemoryRangeAcessible,.-IsMemoryRangeAcessible
# Number of nodes = 16

# Allocations for IsMemoryRangeAcessible
#	?a4		p_memoryRange
#	SP,8		activeSecLevel
# static FUNC(Std_ReturnType, DCM_CODE) ReadOneDDDidByMemory(CONSTP2CONST(Dcm_Cfg_DDDDidSourceType, AUTOMATIC, DCM_APPL_DATA) pSource,
	.align		1
	.section	.text_vle
        .d2line         13458,39
#$$ld
.L3230:

#$$bf	ReadOneDDDidByMemory,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadOneDDDidByMemory:
.Llo102:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pSource=r31 pSource=r3
.Llo103:
	mr		r27,r4		# pSampleBuffer=r27 pSampleBuffer=r4
.Llo104:
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
#                                                            CONSTP2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pSampleBuffer,
#                                                            CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    /*
#     *The memory_id is used for two purposes, depending on the source.
#     * But when used for memory, the id equal or less than 255. A cast is therefore safe.
#     */
#    CONST(Dcm_Cfg_MemoryRangePointerType, DCM_CONST) pSelectedMemoryRange = GetMemoryRange((uint8)pSource->memory_id, pSource->address, pSource->size, Dcm_LCfg.p_read_memory);
#    Std_ReturnType                stdReturnVal = E_OK;
	.d2line		13467
.Llo106:
	diab.li		r28,0		# stdReturnVal=r28
	.d2line		13466
.Llo116:
	lhz		r3,4(r31)		# pSource=r31
	lis		r4,(Dcm_LCfg+156)@ha
	lwz		r6,(Dcm_LCfg+156)@l(r4)
	lwz		r4,8(r31)		# pSource=r31
	lwz		r5,12(r31)		# pSource=r31
.Llo108:
	bl		GetMemoryRange
.Llo110:
	mr		r29,r3		# pSelectedMemoryRange=r29 pSelectedMemoryRange=r3
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pBuf = pSampleBuffer;
	.d2line		13468
	stw		r27,8(r1)		# pSampleBuffer=r27
# 
#    /* For missing sample buffer shall the function request a buffer from DSD */
#    if (NULL_PTR == pSampleBuffer)
	.d2line		13471
	se_cmpi		r27,0		# pSampleBuffer=r27
	bc		0,2,.L2787	# ne
#    {
#       /*
#        * It's safe to cast since the requested size shall fit into a Dcm_MsgLenType
#        */
#       stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)pSource->size, &pBuf);
	.d2line		13476
.Llo107:
	lwz		r3,12(r31)		# pSource=r31
.Llo111:
	rlwinm		r3,r3,0,16,31
	diab.addi		r4,r1,8
	bl		Dcm_DsdRequestResponseBuffer
	mr		r28,r3		# stdReturnVal=r28 stdReturnVal=r3
.L2787:
#    }
#    else
#    {
#       /*
#        * Use the provided buffer
#        */
#    }
# 
#    if (E_OK != stdReturnVal)
	.d2line		13485
	rlwinm		r3,r28,0,24,31		# stdReturnVal=r28
	se_cmpi		r3,0
	bc		0,2,.L2789	# ne
#    {
#       /*
#        * Errors will be handled in the calling function
#        */
#    }
#    /* Check that requested memory range is configured */
#    else if (NULL_PTR == pSelectedMemoryRange)
	.d2line		13492
	se_cmpi		r29,0		# pSelectedMemoryRange=r29
	bc		0,2,.L2790	# ne
#    {
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13494
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
#       stdReturnVal = E_NOT_OK;
	.d2line		13495
	diab.li		r28,1		# stdReturnVal=r28
	b		.L2789
.L2790:
#    }
#    /* Check that requested memory range is accessible in current security level */
#    else if (FALSE == IsMemoryRangeAcessible(pSelectedMemoryRange))
	.d2line		13498
	mr		r3,r29		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r29
	bl		IsMemoryRangeAcessible
	rlwinm		r3,r3,0,24,31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2792	# ne
#    {
#       *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		13500
.Llo112:
	diab.li		r0,51
	stb		r0,0(r30)		# pErrorCode=r30
#       stdReturnVal = E_NOT_OK;
	.d2line		13501
	diab.li		r28,1		# stdReturnVal=r28
	b		.L2789
.L2792:
#    }
#    else if (DCM_MEM_OPERATION_OK != Dcm_LCfg.p_read_memory->MemoryOperationFunc(DCM_INITIAL, DcmLoByte(pSource->memory_id), pSource->address,
	.d2line		13503
	lis		r3,(Dcm_LCfg+156)@ha		# pSelectedMemoryRange=r3
.Llo113:
	lwz		r3,(Dcm_LCfg+156)@l(r3)		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	lwz		r0,4(r3)		# pSelectedMemoryRange=r3
	mtspr		ctr,r0
	lhz		r4,4(r31)		# pSource=r31
	rlwinm		r4,r4,0,24,31
	lwz		r5,8(r31)		# pSource=r31
	lwz		r6,12(r31)		# pSource=r31
	lwz		r7,8(r1)
	diab.li		r3,0		# pSelectedMemoryRange=r3
.Llo114:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo105:
	rlwinm		r3,r3,0,24,31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		1,2,.L2789	# eq
#          pSource->size, pBuf))
#    {
#       /*
#        * PENDING is not handled so no need to release any buffer.
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13509
.Llo115:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
#       stdReturnVal = E_NOT_OK;
	.d2line		13510
	diab.li		r28,1		# stdReturnVal=r28
.L2789:
#    }
#    else
#    {
#       /* Successful to read, just return */
#    }
# 
#    return stdReturnVal;
	.d2line		13517
.Llo109:
	rlwinm		r3,r28,0,24,31		# pSelectedMemoryRange=r3 stdReturnVal=r28
# }
	.d2line		13518
	.d2epilogue_begin
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
.Llo117:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3231:
	.type		ReadOneDDDidByMemory,@function
	.size		ReadOneDDDidByMemory,.-ReadOneDDDidByMemory
# Number of nodes = 125

# Allocations for ReadOneDDDidByMemory
#	?a4		pSource
#	?a5		pSampleBuffer
#	?a6		pErrorCode
#	?a7		pSelectedMemoryRange
#	?a8		stdReturnVal
#	SP,8		pBuf
# static FUNC(boolean, DCM_CODE) ReadOnePeriodicDid( P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid,
	.align		1
	.section	.text_vle
        .d2line         13523,32
#$$ld
.L3246:

#$$bf	ReadOnePeriodicDid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadOnePeriodicDid:
.Llo118:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
.Llo126:
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)		# stdReturnVal=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pDid=r31 pDid=r3
	mr		r30,r4		# activeSession=r30 activeSession=r4
	mr		r29,r5		# activeSecurityLevel=r29 activeSecurityLevel=r5
	.d2prologue_end
#                                                 Dcm_SesCtrlType activeSession,
#                                                 Dcm_SecLevelType activeSecurityLevel)
# {
#    uint8 i;
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		13528
	diab.li		r0,0		# stdReturnVal=r0
	stb		r0,12(r1)		# stdReturnVal=r0
#    Std_ReturnType stdReturnVal = (0 != *pDid->pNumberOfDefinedSources) ? E_OK : E_NOT_OK;
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
#    uint16 sample_idx = pStatus->bufferOffset;
#    uint16 didSize = 0;
	.d2line		13532
	sth		r0,14(r1)		# stdReturnVal=r0
	.d2line		13529
	lwz		r3,16(r31)		# stdReturnVal=r3 pDid=r31
.Llo119:
	lbz		r3,0(r3)		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	isel		r0,r3,r0,2		# stdReturnVal=r0 stdReturnVal=r3 stdReturnVal=r0
.L2815:
.Llo120:
	diab.li		r3,1		# stdReturnVal=r3
.Llo122:
	isel		r3,r3,r0,2		# stdReturnVal=r3 stdReturnVal=r3 stdReturnVal=r0
.L2816:
	.d2line		13531
.Llo127:
	lis		r4,(Dcm_DspInstance+232)@ha
.Llo128:
	lhz		r27,(Dcm_DspInstance+232)@l(r4)
.Llo130:
	mr		r27,r27		# sample_idx=r27 sample_idx=r27
# 
#    if (E_NOT_OK == stdReturnVal)
	.d2line		13534
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,1		# stdReturnVal=r0
	bc		0,2,.L2801	# ne
#    {
#       /*
#        * The cleared DID is treated as a ready DID. SendPeriodicDids() needs to record the sending parameters properly,
#        * since the sending maybe be invoked multiple times.
#        */
#       Dcm_DspInstance.periodic_status.num_ready_dids++;
	.d2line		13540
	lis		r5,(Dcm_DspInstance+218)@ha
	lhz		r4,(Dcm_DspInstance+218)@l(r5)
	se_addi		r4,1
	sth		r4,(Dcm_DspInstance+218)@l(r5)
#       pDid->sample_data->buffer_data_ready = FALSE;
	.d2line		13541
	diab.li		r0,0		# stdReturnVal=r0
	lwz		r4,20(r31)		# pDid=r31
	stb		r0,0(r4)		# stdReturnVal=r0
.L2801:
#    }
# 
#    /*
#     * Loop all data sources of the periodic DiD.
#     */
#    for (i = pStatus->current_source_did_index; (i < *pDid->pNumberOfDefinedSources) && (E_OK == stdReturnVal); i++)
	.d2line		13547
	lis		r4,(Dcm_DspInstance+230)@ha
	lbz		r28,(Dcm_DspInstance+230)@l(r4)
.Llo125:
	mr		r28,r28		# i=r28 i=r28
.L2802:
.Llo131:
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	lwz		r4,16(r31)		# compositeHeaderSize=r4 pDid=r31
	lbz		r4,0(r4)		# compositeHeaderSize=r4 compositeHeaderSize=r4
	se_cmp		r0,r4		# stdReturnVal=r0 compositeHeaderSize=r4
	bc		0,0,.L2804	# ge
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L2804	# ne
	.section	.text_vle
.L3264:
#    {
#       CONST(uint8, DCM_CONST) compositeHeaderSize = ((pDid->pDataSourcesRead[i].record_type == DCM_COMP_DID) ? 2U : 0U);
	.d2line		13549
	lwz		r4,8(r31)		# compositeHeaderSize=r4 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	lwzx		r0,r4,r0		# stdReturnVal=r0 compositeHeaderSize=r4
	se_cmpi		r0,4		# stdReturnVal=r0
	diab.li		r4,2		# compositeHeaderSize=r4
	isel		r4,r4,r26,2		# compositeHeaderSize=r4 compositeHeaderSize=r4 compositeHeaderSize=r26
.L2817:
.Llo132:
	diab.li		r0,0		# stdReturnVal=r0
.Llo133:
	isel		r26,r4,r0,2		# compositeHeaderSize=r26 compositeHeaderSize=r4 stdReturnVal=r0
.L2818:
# 
#       /*
#        * Different data types have different read function
#        */
#       if ((DCM_DD_DID == pDid->pDataSourcesRead[i].record_type) || (DCM_COMP_DID == pDid->pDataSourcesRead[i].record_type))
	.d2line		13554
.Llo134:
	lwz		r4,8(r31)		# compositeHeaderSize=r4 pDid=r31
.Llo135:
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	lwzx		r0,r4,r0		# stdReturnVal=r0 compositeHeaderSize=r4
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		1,2,.L2819	# eq
	lwz		r4,8(r31)		# compositeHeaderSize=r4 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	lwzx		r0,r4,r0		# stdReturnVal=r0 compositeHeaderSize=r4
	se_cmpi		r0,4		# stdReturnVal=r0
	bc		0,2,.L2805	# ne
.L2819:
	.d2line		13530
	lwz		r3,20(r31)		# stdReturnVal=r3 pDid=r31
	lwz		r0,4(r3)		# stdReturnVal=r0 stdReturnVal=r3
	rlwinm		r4,r27,0,16,31		# compositeHeaderSize=r4 sample_idx=r27
	se_add		r0,r4		# stdReturnVal=r0 stdReturnVal=r0 compositeHeaderSize=r4
	lis		r3,(Dcm_DspInstance+244)@ha		# stdReturnVal=r3
	stw		r0,(Dcm_DspInstance+244)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
#       {
#          /*
#           * If stdReturnVal is not OK, the loop will break; sample buffer will be marked as not ready.
#           * ErrorCode will not be checked. However it will be used in UDS service 0x22 to read a dynamically defined Did.
#           */
#          pStatus->read_did_info.current_res_buffer = &pDid->sample_data->data_buffer[sample_idx];
#          stdReturnVal = ReadOneDDDidByDid(&pDid->pDataSourcesRead[i],
	.d2line		13561
	diab.addi		r0,r1,12		# stdReturnVal=r0
	stw		r0,8(r1)		# stdReturnVal=r0
	lwz		r3,8(r31)		# stdReturnVal=r3 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	lwzux		r7,r3,r0		# stdReturnVal=r3
	lwz		r3,8(r31)		# stdReturnVal=r3 pDid=r31
	se_add		r3,r0		# stdReturnVal=r3 stdReturnVal=r3 stdReturnVal=r0
	lhz		r0,2(r31)		# stdReturnVal=r0 pDid=r31
	subf		r4,r27,r0		# compositeHeaderSize=r4 sample_idx=r27 stdReturnVal=r0
	se_addi		r4,1		# compositeHeaderSize=r4 compositeHeaderSize=r4
	lis		r8,(Dcm_DspInstance+236)@ha
	e_add16i		r8,r8,(Dcm_DspInstance+236)@l
	diab.addi		r10,r1,14
	mr		r6,r29		# activeSecurityLevel=r6 activeSecurityLevel=r29
	mr		r5,r30		# activeSession=r5 activeSession=r30
	diab.li		r9,1
	bl		ReadOneDDDidByDid
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
	b		.L2806
.L2805:
#                                           (uint16)((pDid->size + (uint16)1U) - sample_idx),
#                                           activeSession,
#                                           activeSecurityLevel,
#                                           pDid->pDataSourcesRead[i].record_type,
#                                           &pStatus->read_did_info,
#                                           TRUE, /* The sample buffer will be used by the function */
#                                           &didSize,
#                                           &ErrorCode);
#       }
#       else if (DCM_DD_MEMORY == pDid->pDataSourcesRead[i].record_type)
	.d2line		13571
	lwz		r4,8(r31)		# compositeHeaderSize=r4 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	lwzx		r0,r4,r0		# stdReturnVal=r0 compositeHeaderSize=r4
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		0,2,.L2806	# ne
#       {
#          /*
#           * If stdReturnVal is not OK, the loop will break; sample buffer will be marked as not ready.
#           * ErrorCode will not be checked. However it will be used in UDS service 0x22 to read a dynamically defined Did.
#           */
#          stdReturnVal = ReadOneDDDidByMemory(&pDid->pDataSourcesRead[i], &pDid->sample_data->data_buffer[sample_idx], &ErrorCode);
	.d2line		13577
	lwz		r3,20(r31)		# stdReturnVal=r3 pDid=r31
	lwz		r4,4(r3)		# compositeHeaderSize=r4 stdReturnVal=r3
	rlwinm		r0,r27,0,16,31		# stdReturnVal=r0 sample_idx=r27
	se_add		r4,r0		# compositeHeaderSize=r4 compositeHeaderSize=r4 stdReturnVal=r0
	lwz		r3,8(r31)		# stdReturnVal=r3 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	se_add		r3,r0		# stdReturnVal=r3 stdReturnVal=r3 stdReturnVal=r0
	diab.addi		r5,r1,12
	bl		ReadOneDDDidByMemory
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
#          didSize = (uint16) pDid->pDataSourcesRead[i].size;
	.d2line		13578
	lwz		r4,8(r31)		# compositeHeaderSize=r4 pDid=r31
	rlwinm		r0,r28,0,24,31		# stdReturnVal=r0 i=r28
	e_mulli		r0,r0,20		# stdReturnVal=r0 stdReturnVal=r0
	se_add		r4,r0		# compositeHeaderSize=r4 compositeHeaderSize=r4 stdReturnVal=r0
	lwz		r0,12(r4)		# stdReturnVal=r0 compositeHeaderSize=r4
	sth		r0,14(r1)		# stdReturnVal=r0
.L2806:
#       }
#       else
#       {
#          /*DCM_DD_PID*/
#       }
# 
# 
#       /*
#        * Increase the result data length (including the DID identifier)
#        * only if the application accepted the request.
#        */
#       if (E_OK == stdReturnVal)
	.d2line		13590
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L2809	# ne
#       {
#          sample_idx += (uint16) (didSize + compositeHeaderSize);
	.d2line		13592
	lhz		r0,14(r1)		# stdReturnVal=r0
	se_add		r0,r27		# stdReturnVal=r0 stdReturnVal=r0 sample_idx=r27
	rlwinm		r27,r26,0,24,31		# sample_idx=r27 compositeHeaderSize=r26
	se_add		r0,r27		# stdReturnVal=r0 stdReturnVal=r0 sample_idx=r27
	mr		r27,r0		# sample_idx=r27 sample_idx=r0
	.d2line		13530
	lis		r4,(Dcm_DspInstance+232)@ha		# compositeHeaderSize=r4
	sth		r0,(Dcm_DspInstance+232)@l(r4)		# compositeHeaderSize=r4 sample_idx=r0
#          pStatus->bufferOffset = sample_idx;
# 
#          /*
#           * All data sources have been read successfully.
#           * pStatus->current_did_index loops from 0..*pDid->pNumberOfDefinedSources - 1.
#           */
#          if ((uint8)(i+(uint8)1U) == *pDid->pNumberOfDefinedSources)
	.d2line		13599
	diab.addi		r0,r28,1		# sample_idx=r0 i=r28
	rlwinm		r0,r0,0,24,31		# sample_idx=r0 sample_idx=r0
	lwz		r4,16(r31)		# compositeHeaderSize=r4 pDid=r31
	lbz		r4,0(r4)		# compositeHeaderSize=r4 compositeHeaderSize=r4
	se_cmp		r0,r4		# sample_idx=r0 compositeHeaderSize=r4
	bc		0,2,.L2812	# ne
#          {
#             /* Update sample buffer states */
#             pDid->sample_data->buffer_size = pStatus->bufferOffset;
	.d2line		13602
	lis		r4,(Dcm_DspInstance+232)@ha		# compositeHeaderSize=r4
	lhz		r0,(Dcm_DspInstance+232)@l(r4)		# sample_idx=r0 compositeHeaderSize=r4
	lwz		r4,20(r31)		# compositeHeaderSize=r4 pDid=r31
	sth		r0,2(r4)		# compositeHeaderSize=r4 sample_idx=r0
#             pDid->sample_data->data_buffer[0] = DcmLoByte(pDid->identifier);
	.d2line		13603
	lhz		r0,0(r31)		# sample_idx=r0 pDid=r31
	lwz		r4,20(r31)		# compositeHeaderSize=r4 pDid=r31
	lwz		r4,4(r4)		# compositeHeaderSize=r4 compositeHeaderSize=r4
	stb		r0,0(r4)		# compositeHeaderSize=r4 sample_idx=r0
#             pDid->sample_data->buffer_data_ready = TRUE;
	.d2line		13604
	diab.li		r0,1		# sample_idx=r0
	lwz		r4,20(r31)		# compositeHeaderSize=r4 pDid=r31
	stb		r0,0(r4)		# compositeHeaderSize=r4 sample_idx=r0
# 
#             Dcm_DspInstance.periodic_status.num_ready_dids++;
	.d2line		13606
	lis		r5,(Dcm_DspInstance+218)@ha
	lhz		r4,(Dcm_DspInstance+218)@l(r5)		# compositeHeaderSize=r4
	se_addi		r4,1		# compositeHeaderSize=r4 compositeHeaderSize=r4
	sth		r4,(Dcm_DspInstance+218)@l(r5)		# compositeHeaderSize=r4
	b		.L2812
.L2809:
#          }
#          else
#          {
#             /* 
#              * Reset reading status to read next source DID is done in calling function
#              */
#          }
#       }
#       else if (DCM_E_PENDING == stdReturnVal)
	.d2line		13615
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,10		# stdReturnVal=r0
	bc		0,2,.L2813	# ne
	.d2line		13530
	lis		r4,(Dcm_DspInstance+230)@ha		# compositeHeaderSize=r4
	stb		r28,(Dcm_DspInstance+230)@l(r4)		# compositeHeaderSize=r4 i=r28
	b		.L2812
.L2813:
#       {
#          /*
#           * Store the current source index, it will continue to read data later.
#           */
#          pStatus->current_source_did_index = i;
#       }
#       else
#       {
#          /*
#           * The application did not accept the read request. Return an error.
#           * No given value according to specification.
#           */
#          Dcm_DspInstance.periodic_status.num_ready_dids++;
	.d2line		13628
	lis		r5,(Dcm_DspInstance+218)@ha
	lhz		r4,(Dcm_DspInstance+218)@l(r5)		# compositeHeaderSize=r4
	se_addi		r4,1		# compositeHeaderSize=r4 compositeHeaderSize=r4
	sth		r4,(Dcm_DspInstance+218)@l(r5)		# compositeHeaderSize=r4
#          pDid->sample_data->buffer_data_ready = FALSE;
	.d2line		13629
	diab.li		r0,0		# stdReturnVal=r0
	lwz		r4,20(r31)		# compositeHeaderSize=r4 pDid=r31
	stb		r0,0(r4)		# compositeHeaderSize=r4 stdReturnVal=r0
.L2812:
	.section	.text_vle
.L3265:
#       }
#    }
	.d2line		13631
	diab.addi		r0,r28,1		# sample_idx=r0 i=r28
	se_addi		r28,1		# i=r28 i=r28
	b		.L2802
.L2804:
# 
#    return (boolean)(DCM_E_PENDING == stdReturnVal);
	.d2line		13633
.Llo121:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo123:
	xori		r3,r3,10		# stdReturnVal=r3 stdReturnVal=r3
	cntlzw		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
	rlwinm		r3,r3,27,24,31		# stdReturnVal=r3 stdReturnVal=r3
# }
	.d2line		13634
	.d2epilogue_begin
.Llo129:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)		# stdReturnVal=r0
	mtspr		lr,r0		# stdReturnVal=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo124:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3247:
	.type		ReadOnePeriodicDid,@function
	.size		ReadOnePeriodicDid,.-ReadOnePeriodicDid
# Number of nodes = 336

# Allocations for ReadOnePeriodicDid
#	?a4		pDid
#	?a5		activeSession
#	?a6		activeSecurityLevel
#	?a7		i
#	SP,12		ErrorCode
#	?a8		stdReturnVal
#	not allocated	pStatus
#	?a9		sample_idx
#	SP,14		didSize
#	?a10		compositeHeaderSize
# static FUNC(void, DCM_CODE) ReadAllRequestedPeriodicDids(void)
	.align		1
	.section	.text_vle
        .d2line         13639,29
#$$ld
.L3272:

#$$bf	ReadAllRequestedPeriodicDids,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadAllRequestedPeriodicDids:
.Llo144:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    uint16 didIndex;
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid     = NULL_PTR;
	.d2line		13644
	diab.li		r31,0		# pDid=r31
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
#    boolean isPending = FALSE;
# 
#    /*
#     * Do some initiation:
#     * - Get the current session
#     * - Get the current security level
#     */
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * [SWS_Dcm_00339] : E_OK shall always be returned.
#     * [SWS_Dcm_00338] : E_OK shall always be returned.
#     */
#    (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		13660
.Llo145:
	diab.addi		r3,r1,8
	bl		Dcm_GetSesCtrlType
#    (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		13661
	diab.addi		r3,r1,9
	bl		Dcm_GetSecurityLevel
.L2834:
	.d2line		13645
	lis		r3,(Dcm_DspInstance+228)@ha		# isPending=r3
	lhz		r0,(Dcm_DspInstance+228)@l(r3)		# didIndex=r0 isPending=r3
.Llo136:
	lis		r3,(Dcm_DspInstance+214)@ha		# isPending=r3
	lhz		r3,(Dcm_DspInstance+214)@l(r3)		# isPending=r3 isPending=r3
	se_cmp		r0,r3		# didIndex=r0 isPending=r3
	bc		0,0,.L2835	# ge
# 
#    /*
#     * Loop all requested periodic dids.
#     */
#    while ((pStatus->current_did_index < Dcm_DspInstance.periodic_status.num_periodic_id) && (FALSE == isPending))
	.d2line		13666
.Llo137:
	rlwinm		r3,r31,0,24,31		# isPending=r3 isPending=r31
	se_cmpi		r3,0		# isPending=r3
	bc		0,2,.L2835	# ne
#    {
#       didIndex = Dcm_LCfg.requested_periodicDids[pStatus->current_did_index];
	.d2line		13668
	lis		r3,(Dcm_LCfg+80)@ha		# isPending=r3
	lwz		r4,(Dcm_LCfg+80)@l(r3)		# isPending=r3
	lis		r3,(Dcm_DspInstance+228)@ha		# isPending=r3
	lhz		r0,(Dcm_DspInstance+228)@l(r3)		# didIndex=r0 isPending=r3
.Llo138:
	rlwinm		r0,r0,1,15,30		# didIndex=r0 didIndex=r0
	lhzx		r0,r4,r0		# didIndex=r0
	mr		r0,r0		# didIndex=r0 didIndex=r0
#       pDid = &Dcm_LCfg.periodicDynamicDids[didIndex];
	.d2line		13669
	rlwinm		r0,r0,0,16,31		# didIndex=r0 didIndex=r0
	lis		r3,(Dcm_LCfg+76)@ha		# isPending=r3
	lwz		r3,(Dcm_LCfg+76)@l(r3)		# isPending=r3 isPending=r3
	rlwinm		r4,r0,5,0,26		# didIndex=r0
	se_slwi		r0,3		# didIndex=r0 didIndex=r0
	subf		r0,r0,r4		# didIndex=r0 didIndex=r0
	se_add		r0,r3		# didIndex=r0 didIndex=r0 isPending=r3
.Llo139:
	mr		r3,r0		# pDid=r3 pDid=r0
# 
#       isPending = ReadOnePeriodicDid(pDid, activeSession, activeSecurityLevel);
	.d2line		13671
	lbz		r4,8(r1)
	lbz		r5,9(r1)
	mr		r3,r3		# pDid=r3 pDid=r3
	bl		ReadOnePeriodicDid
.Llo146:
	mr		r31,r3		# isPending=r31 isPending=r3
# 
#       /*
#        * Since current DID reading is pending, store the current Did.
#        */
#       if (FALSE == isPending)
	.d2line		13676
	rlwinm		r3,r3,0,24,31		# isPending=r3 isPending=r3
	se_cmpi		r3,0		# isPending=r3
	bc		0,2,.L2836	# ne
	.d2line		13645
	diab.li		r4,0
	lis		r3,(Dcm_DspInstance+240)@ha		# isPending=r3
	stw		r4,(Dcm_DspInstance+240)@l(r3)		# isPending=r3
	lis		r3,(Dcm_DspInstance+238)@ha		# isPending=r3
	stb		r4,(Dcm_DspInstance+238)@l(r3)		# isPending=r3
	diab.li		r0,1		# didIndex=r0
.Llo140:
	lis		r3,(Dcm_DspInstance+232)@ha		# isPending=r3
	sth		r0,(Dcm_DspInstance+232)@l(r3)		# isPending=r3 didIndex=r0
	lis		r3,(Dcm_DspInstance+230)@ha		# isPending=r3
	stb		r4,(Dcm_DspInstance+230)@l(r3)		# isPending=r3
	lis		r4,(Dcm_DspInstance+228)@ha
	lhz		r3,(Dcm_DspInstance+228)@l(r4)		# isPending=r3
	se_addi		r3,1		# isPending=r3 isPending=r3
	sth		r3,(Dcm_DspInstance+228)@l(r4)		# isPending=r3
	b		.L2834
.L2836:
#       {
#          /* Reset pStatus to read next DID. */
#          pStatus->read_did_info.current_operation = READ_DID_INIT;
#          pStatus->read_did_info.current_opstatus = DCM_INITIAL;
#          pStatus->bufferOffset = 1;
#          pStatus->current_source_did_index = 0;
#          pStatus->current_did_index++;
#       }
#       else
#       {
#          /* Pending happened - trigger new schedule */
#          Dcm_DspGetPeriodicDataTrigger();
	.d2line		13688
.Llo141:
	bl		Dcm_DspGetPeriodicDataTrigger
	b		.L2834
.L2835:
#       }
#    }
# 
#    if (FALSE == isPending)
	.d2line		13692
	rlwinm		r31,r31,0,24,31		# isPending=r31 isPending=r31
	se_cmpi		r31,0		# isPending=r31
	bc		0,2,.L2833	# ne
	.d2line		13645
.Llo147:
	diab.li		r0,0		# didIndex=r0
.Llo142:
	lis		r3,(Dcm_DspInstance+228)@ha		# isPending=r3
.Llo148:
	sth		r0,(Dcm_DspInstance+228)@l(r3)		# isPending=r3 didIndex=r0
.L2833:
#    {
#       /*
#          * All DIDs have been read.
#          */
#       pStatus->current_did_index = 0;
#    }
#    else
#    {
#       /* Continue to read at the next schedule. */
#    }
# }
	.d2line		13703
	.d2epilogue_begin
.Llo143:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# didIndex=r0
	mtspr		lr,r0		# didIndex=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3273:
	.type		ReadAllRequestedPeriodicDids,@function
	.size		ReadAllRequestedPeriodicDids,.-ReadAllRequestedPeriodicDids
# Number of nodes = 128

# Allocations for ReadAllRequestedPeriodicDids
#	?a4		$$78
#	?a5		didIndex
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	?a6		pDid
#	not allocated	pStatus
#	?a7		isPending
# FUNC(void, DCM_CODE) Dcm_DspTransmitPeriodicDataTrigger(void)
	.align		2
	.section	.text_vle
        .d2line         13791,22
#$$ld
.L3285:

#$$bf	Dcm_DspTransmitPeriodicDataTrigger,interprocedural,rasave,nostackparams
	.globl		Dcm_DspTransmitPeriodicDataTrigger
	.d2_cfa_start __cie
Dcm_DspTransmitPeriodicDataTrigger:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    if (NULL_PTR != Dcm_LCfg.p_transmit_periodic_data_trigger)
	.d2line		13793
	lis		r3,(Dcm_LCfg+176)@ha
	lwz		r0,(Dcm_LCfg+176)@l(r3)
	se_cmpi		r0,0
	bc		1,2,.L2861	# eq
#    {
#       Dcm_LCfg.p_transmit_periodic_data_trigger();
	.d2line		13795
	lis		r3,(Dcm_LCfg+176)@ha
	lwz		r0,(Dcm_LCfg+176)@l(r3)
	mtspr		ctr,r0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x0 0x0 0x0 0x1
#$$rs 0 s
	bcctrl		20,0
.L2861:
#    }
# }
	.d2line		13797
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3286:
	.type		Dcm_DspTransmitPeriodicDataTrigger,@function
	.size		Dcm_DspTransmitPeriodicDataTrigger,.-Dcm_DspTransmitPeriodicDataTrigger
# Number of nodes = 14

# Allocations for Dcm_DspTransmitPeriodicDataTrigger
# FUNC(void, DCM_CODE) Dcm_SE_GetPeriodicData(void)
	.align		2
	.section	.text_vle
        .d2line         2424,22
#$$ld
.L3290:

#$$bf	Dcm_SE_GetPeriodicData,interprocedural,rasave,nostackparams
	.globl		Dcm_SE_GetPeriodicData
	.d2_cfa_start __cie
Dcm_SE_GetPeriodicData:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
	.d2line		2426
	lis		r3,(Dcm_DspInstance+218)@ha
	lhz		r0,(Dcm_DspInstance+218)@l(r3)
	lis		r3,(Dcm_DspInstance+214)@ha
	lhz		r3,(Dcm_DspInstance+214)@l(r3)
	se_cmp		r0,r3
	bc		0,0,.L647	# ge
# 
#    if (pStatus->num_ready_dids < pStatus->num_periodic_id)
#    {
#       /*
#       * All requested DIDs have handled.
#       */
#       ReadAllRequestedPeriodicDids();
	.d2line		2433
	bl		ReadAllRequestedPeriodicDids
.L647:
	.d2line		2426
	lis		r3,(Dcm_DspInstance+222)@ha
	lhz		r0,(Dcm_DspInstance+222)@l(r3)
	lis		r3,(Dcm_DspInstance+218)@ha
	lhz		r3,(Dcm_DspInstance+218)@l(r3)
	se_cmp		r0,r3
	bc		0,0,.L646	# ge
#    }
# 
#    if (pStatus->num_sent_dids < pStatus->num_ready_dids)
#    {
#       /* There are DIDs ready to be sent - trigger transmission */
#       Dcm_DspTransmitPeriodicDataTrigger();
	.d2line		2439
	bl		Dcm_DspTransmitPeriodicDataTrigger
.L646:
#    }
# }
	.d2line		2441
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3291:
	.type		Dcm_SE_GetPeriodicData,@function
	.size		Dcm_SE_GetPeriodicData,.-Dcm_SE_GetPeriodicData
# Number of nodes = 30

# Allocations for Dcm_SE_GetPeriodicData
#	not allocated	pStatus
# static FUNC(boolean, DCM_CODE) AllSentSamplesConfirmed(CONSTP2CONST(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
	.align		1
	.section	.text_vle
        .d2line         13708,32
#$$ld
.L3295:

#$$bf	AllSentSamplesConfirmed,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4
	.d2_cfa_start __cie
AllSentSamplesConfirmed:
.Llo149:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pStatus=r3 pStatus=r3
	.d2prologue_end
# {
#    return (boolean)(pStatus->num_confirmed_sent_dids == pStatus->num_sent_dids);
	.d2line		13710
	lhz		r4,12(r3)		# pStatus=r3
	lhz		r3,14(r3)		# pStatus=r3 pStatus=r3
	subf		r4,r4,r3		# pStatus=r3
	cntlzw		r3,r4		# pStatus=r3
	diab.srwi		r3,5		# pStatus=r3
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
# }
	.d2line		13711
	.d2epilogue_begin
.Llo150:
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3296:
	.type		AllSentSamplesConfirmed,@function
	.size		AllSentSamplesConfirmed,.-AllSentSamplesConfirmed
# Number of nodes = 12

# Allocations for AllSentSamplesConfirmed
#	?a4		pStatus
# static FUNC(boolean, DCM_CODE) AllPeriodicDIDsSent(CONSTP2CONST(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
	.align		1
	.section	.text_vle
        .d2line         13716,32
#$$ld
.L3306:

#$$bf	AllPeriodicDIDsSent,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4
	.d2_cfa_start __cie
AllPeriodicDIDsSent:
.Llo151:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pStatus=r3 pStatus=r3
	.d2prologue_end
# {
#    return (boolean)(pStatus->next_did_to_be_sent == pStatus->num_periodic_id);
	.d2line		13718
	lhz		r4,8(r3)		# pStatus=r3
	lhz		r3,6(r3)		# pStatus=r3 pStatus=r3
	subf		r4,r4,r3		# pStatus=r3
	cntlzw		r3,r4		# pStatus=r3
	diab.srwi		r3,5		# pStatus=r3
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
# }
	.d2line		13719
	.d2epilogue_begin
.Llo152:
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3307:
	.type		AllPeriodicDIDsSent,@function
	.size		AllPeriodicDIDsSent,.-AllPeriodicDIDsSent
# Number of nodes = 12

# Allocations for AllPeriodicDIDsSent
#	?a4		pStatus
# static FUNC(void, DCM_CODE) SendPeriodicDids(void)
	.align		1
	.section	.text_vle
        .d2line         13724,29
#$$ld
.L3312:

#$$bf	SendPeriodicDids,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
SendPeriodicDids:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    uint16 index;
#    Std_ReturnType sendResult = E_OK;
	.d2line		13727
	diab.li		r31,0		# sendResult=r31
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
# 
#    if ((PERIODIC_WAIT_TO_STOP != pStatus->state) && (PERIODIC_WAIT_TO_RESTART != pStatus->state) && (0 != pStatus->num_ready_dids))
	.d2line		13731
.Llo161:
	lis		r3,(Dcm_DspInstance+224)@ha
	lwz		r0,(Dcm_DspInstance+224)@l(r3)
	se_cmpi		r0,2
	bc		1,2,.L2846	# eq
	lis		r3,(Dcm_DspInstance+224)@ha
	lwz		r0,(Dcm_DspInstance+224)@l(r3)
	se_cmpi		r0,3
	bc		1,2,.L2846	# eq
	lis		r3,(Dcm_DspInstance+218)@ha
	lhz		r0,(Dcm_DspInstance+218)@l(r3)
	se_cmpi		r0,0
	bc		1,2,.L2846	# eq
.L2848:
#    {
#       /**
#        * Continue sending from the previous time.
#        */
#       while ((E_OK == sendResult) && (pStatus->num_sent_dids < pStatus->num_ready_dids))
	.d2line		13736
	rlwinm		r3,r31,0,24,31		# sendResult=r3 sendResult=r31
	se_cmpi		r3,0		# sendResult=r3
	bc		0,2,.L2849	# ne
	.d2line		13729
	lis		r3,(Dcm_DspInstance+222)@ha		# sendResult=r3
	lhz		r0,(Dcm_DspInstance+222)@l(r3)		# index=r0 sendResult=r3
.Llo153:
	lis		r3,(Dcm_DspInstance+218)@ha		# sendResult=r3
	lhz		r3,(Dcm_DspInstance+218)@l(r3)		# sendResult=r3 sendResult=r3
	se_cmp		r0,r3		# index=r0 sendResult=r3
	bc		0,0,.L2849	# ge
#       {
#          index = Dcm_LCfg.requested_periodicDids[pStatus->next_did_to_be_sent];
	.d2line		13738
.Llo154:
	lis		r3,(Dcm_LCfg+80)@ha		# sendResult=r3
	lwz		r4,(Dcm_LCfg+80)@l(r3)		# sendResult=r3
	lis		r3,(Dcm_DspInstance+216)@ha		# sendResult=r3
	lhz		r0,(Dcm_DspInstance+216)@l(r3)		# index=r0 sendResult=r3
.Llo155:
	rlwinm		r0,r0,1,15,30		# index=r0 index=r0
	lhzx		r0,r4,r0		# index=r0
	mr		r0,r0		# index=r0 index=r0
#          pDid = &Dcm_LCfg.periodicDynamicDids[index];
	.d2line		13739
	rlwinm		r0,r0,0,16,31		# index=r0 index=r0
	lis		r3,(Dcm_LCfg+76)@ha		# sendResult=r3
	lwz		r30,(Dcm_LCfg+76)@l(r3)		# pDid=r30 sendResult=r3
.Llo167:
	rlwinm		r3,r0,5,0,26		# sendResult=r3 index=r0
	se_slwi		r0,3		# index=r0 index=r0
	subf		r0,r0,r3		# index=r0 index=r0 sendResult=r3
	se_add		r0,r30		# index=r0 index=r0 pDid=r30
.Llo156:
	mr		r30,r0		# pDid=r30 pDid=r0
# 
#          if (FALSE == pDid->sample_data->buffer_data_ready)
	.d2line		13741
.Llo168:
	lwz		r3,20(r30)		# sendResult=r3 pDid=r30
.Llo169:
	lbz		r0,0(r3)		# index=r0 sendResult=r3
.Llo157:
	se_cmpi		r0,0		# index=r0
	bc		0,2,.L2850	# ne
	.d2line		13729
.Llo158:
	lis		r4,(Dcm_DspInstance+216)@ha
	lhz		r3,(Dcm_DspInstance+216)@l(r4)		# sendResult=r3
	se_addi		r3,1		# sendResult=r3 sendResult=r3
	sth		r3,(Dcm_DspInstance+216)@l(r4)		# sendResult=r3
	lis		r4,(Dcm_DspInstance+222)@ha
	lhz		r3,(Dcm_DspInstance+222)@l(r4)		# sendResult=r3
	se_addi		r3,1		# sendResult=r3 sendResult=r3
	sth		r3,(Dcm_DspInstance+222)@l(r4)		# sendResult=r3
	lis		r4,(Dcm_DspInstance+220)@ha
	lhz		r3,(Dcm_DspInstance+220)@l(r4)		# sendResult=r3
	se_addi		r3,1		# sendResult=r3 sendResult=r3
	sth		r3,(Dcm_DspInstance+220)@l(r4)		# sendResult=r3
	b		.L2848
.L2850:
#          {
#             /*
#              * Sample data is not ready, just skip it.
#              */
#             pStatus->next_did_to_be_sent++;
#             pStatus->num_sent_dids++;
#             pStatus->num_confirmed_sent_dids++;
#          }
#          else
#          {
#             sendResult = Dcm_DslSendPeriodicTxData(pDid->sample_data->data_buffer, pDid->sample_data->buffer_size);
	.d2line		13752
	lwz		r3,20(r30)		# sendResult=r3 pDid=r30
	lhz		r4,2(r3)		# sendResult=r3
	lwz		r3,4(r3)		# sendResult=r3 sendResult=r3
	bl		Dcm_DslSendPeriodicTxData
	mr		r31,r3		# sendResult=r31 sendResult=r3
# 
#             if (E_OK == sendResult)
	.d2line		13754
	rlwinm		r3,r3,0,24,31		# sendResult=r3 sendResult=r3
	se_cmpi		r3,0		# sendResult=r3
	bc		0,2,.L2852	# ne
	.d2line		13729
	lis		r4,(Dcm_DspInstance+222)@ha
	lhz		r3,(Dcm_DspInstance+222)@l(r4)		# sendResult=r3
	se_addi		r3,1		# sendResult=r3 sendResult=r3
	sth		r3,(Dcm_DspInstance+222)@l(r4)		# sendResult=r3
	lis		r4,(Dcm_DspInstance+216)@ha
	lhz		r3,(Dcm_DspInstance+216)@l(r4)		# sendResult=r3
	se_addi		r3,1		# sendResult=r3 sendResult=r3
	sth		r3,(Dcm_DspInstance+216)@l(r4)		# sendResult=r3
#             {
#                pStatus->num_sent_dids++;
#                pStatus->next_did_to_be_sent++;
#                pDid->sample_data->buffer_data_ready = FALSE;
	.d2line		13758
	diab.li		r0,0		# index=r0
.Llo159:
	lwz		r3,20(r30)		# sendResult=r3 pDid=r30
	stb		r0,0(r3)		# sendResult=r3 index=r0
	b		.L2848
.L2852:
#             }
#             else
#             {
#                /*
#                 * Retry at next schedule.
#                 */
#                Dcm_DspTransmitPeriodicDataTrigger();
	.d2line		13765
.Llo160:
	bl		Dcm_DspTransmitPeriodicDataTrigger
	b		.L2848
.L2849:
#             }
#          }
#       }
# 
#       if ((FALSE != AllPeriodicDIDsSent(pStatus)) && (FALSE != AllSentSamplesConfirmed(pStatus)))
	.d2line		13770
.Llo170:
	lis		r3,(Dcm_DspInstance+208)@ha		# sendResult=r3
	e_add16i		r3,r3,(Dcm_DspInstance+208)@l		# sendResult=r3 sendResult=r3
	bl		AllPeriodicDIDsSent
	e_andi.		r3,r3,255		# sendResult=r3 sendResult=r3
	bc		1,2,.L2846	# eq
.Llo162:
	lis		r3,(Dcm_DspInstance+208)@ha		# sendResult=r3
.Llo163:
	e_add16i		r3,r3,(Dcm_DspInstance+208)@l		# sendResult=r3 sendResult=r3
.Llo164:
	bl		AllSentSamplesConfirmed
.Llo165:
	e_andi.		r3,r3,255		# sendResult=r3 sendResult=r3
.Llo166:
	bc		1,2,.L2846	# eq
#       {
#          /*
#           * The requested DIDs list has been gone through. No DIDs were sent.
#           * No need to wait for any confirmation
#           */
#          ResetPeriodicStatusVariables();
	.d2line		13776
	bl		ResetPeriodicStatusVariables
.L2846:
#       }
#    }
#    else
#    {
#       /*
#        * The periodic scheduler is waiting to stop or re-start.
#        * Stop to send more ready DIDs.
#        */
#    }
# }
	.d2line		13786
	.d2epilogue_begin
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# index=r0
	mtspr		lr,r0		# index=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3313:
	.type		SendPeriodicDids,@function
	.size		SendPeriodicDids,.-SendPeriodicDids
# Number of nodes = 172

# Allocations for SendPeriodicDids
#	?a4		$$79
#	?a5		index
#	?a6		sendResult
#	?a7		pDid
#	not allocated	pStatus
# FUNC(void, DCM_CODE) Dcm_SE_TransmitPeriodicData(void)
	.align		2
	.section	.text_vle
        .d2line         2446,22
#$$ld
.L3323:

#$$bf	Dcm_SE_TransmitPeriodicData,interprocedural,rasave,nostackparams
	.globl		Dcm_SE_TransmitPeriodicData
	.d2_cfa_start __cie
Dcm_SE_TransmitPeriodicData:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    CONSTP2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
# 
#    /* Check confirmation */
#    Dcm_DslPeriodicStateMachine();
	.d2line		2451
	bl		Dcm_DslPeriodicStateMachine
# 
#    /* Check if there are more data to send */
#    SendPeriodicDids();
	.d2line		2454
	bl		SendPeriodicDids
	.d2line		2448
	lis		r3,(Dcm_DspInstance+222)@ha
	lhz		r0,(Dcm_DspInstance+222)@l(r3)
	lis		r3,(Dcm_DspInstance+218)@ha
	lhz		r3,(Dcm_DspInstance+218)@l(r3)
	se_cmp		r0,r3
	bc		1,0,.L653	# lt
	lis		r3,(Dcm_DspInstance+220)@ha
	lhz		r0,(Dcm_DspInstance+220)@l(r3)
	lis		r3,(Dcm_DspInstance+222)@ha
	lhz		r3,(Dcm_DspInstance+222)@l(r3)
	se_cmp		r0,r3
	bc		0,0,.L651	# ge
.L653:
# 
#    if ((pStatus->num_sent_dids < pStatus->num_ready_dids) ||
#        (pStatus->num_confirmed_sent_dids < pStatus->num_sent_dids))
#    {
#       /* There are DIDs ready to be sent or to be confirmed */
#       Dcm_DspTransmitPeriodicDataTrigger();
	.d2line		2460
	bl		Dcm_DspTransmitPeriodicDataTrigger
.L651:
#    }
# }
	.d2line		2462
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3324:
	.type		Dcm_SE_TransmitPeriodicData,@function
	.size		Dcm_SE_TransmitPeriodicData,.-Dcm_SE_TransmitPeriodicData
# Number of nodes = 32

# Allocations for Dcm_SE_TransmitPeriodicData
#	not allocated	pStatus
# FUNC(void, DCM_CODE) Dcm_DspConfirmation(Dcm_ConfirmationStatusType Result)
	.align		2
	.section	.text_vle
        .d2line         2467,22
#$$ld
.L3328:

#$$bf	Dcm_DspConfirmation,interprocedural,rasave,nostackparams
	.globl		Dcm_DspConfirmation
	.d2_cfa_start __cie
Dcm_DspConfirmation:
.Llo171:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# Result=r3 Result=r3
	.d2prologue_end
# {
#    if (DCM_RES_POS_OK != Result)
	.d2line		2469
	rlwinm		r3,r3,0,24,31		# Result=r3 Result=r3
	se_cmpi		r3,0		# Result=r3
	bc		0,2,.L656	# ne
#    {
#       /*
#        * Positive response (NOK) or negative response (OK/NOK)
#        * I.e. failure in same way to accept the request. So just clean up but
#        * do not change anything.
#        */
#    }
#    else if (DCM_ASYNCH_STATE_0x10_WAIT_CONF == Dcm_DspInstance.asynch_state)
	.d2line		2477
.Llo172:
	lis		r3,(Dcm_DspInstance+8)@ha		# Result=r3
.Llo173:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# Result=r3
	se_cmpi		r0,5
	bc		0,2,.L659	# ne
#    {
#       Dcm_SetSesCtrlType(Dcm_DspInstance.diag_ses_ctrl_status.pReqSession->session_level);
	.d2line		2479
.Llo174:
	lis		r3,(Dcm_DspInstance+60)@ha		# Result=r3
.Llo175:
	lwz		r3,(Dcm_DspInstance+60)@l(r3)		# Result=r3 Result=r3
	lbz		r3,0(r3)		# Result=r3 Result=r3
.Llo176:
	bl		Dcm_SetSesCtrlType
	b		.L656
.L659:
#    }
#    else if (DCM_ASYNCH_STATE_0x11_WAIT_CONF == Dcm_DspInstance.asynch_state)
	.d2line		2481
	lis		r3,(Dcm_DspInstance+8)@ha		# Result=r3
.Llo177:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# Result=r3
	se_cmpi		r0,6
	bc		0,2,.L661	# ne
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * The return value of the switch is discarded since the DCM has
#        * no possibilities for error handling at this point.
#        * And since the ECU is about the reset, the return value will not matter.
#        */
#       (void)SchM_Switch_Dcm_DcmEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
	.d2line		2490
.Llo178:
	diab.li		r3,6		# Result=r3
	bl		SchM_Switch_Dcm_DcmEcuReset
	b		.L656
.L661:
#    }
#    else if (DCM_ASYNCH_STATE_0x28_WAIT_CONF == Dcm_DspInstance.asynch_state)
	.d2line		2492
	lis		r3,(Dcm_DspInstance+8)@ha		# Result=r3
.Llo179:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# Result=r3
	se_cmpi		r0,7
	bc		0,2,.L663	# ne
#    {
#       BswM_Dcm_CommunicationMode_CurrentState(Dcm_DspInstance.communication_control_status.comNetwork, Dcm_DspInstance.communication_control_status.requestedCommunicationMode);
	.d2line		2494
.Llo180:
	lis		r3,(Dcm_DspInstance+56)@ha		# Result=r3
.Llo181:
	lbz		r3,(Dcm_DspInstance+56)@l(r3)		# Result=r3 Result=r3
.Llo182:
	lis		r4,(Dcm_DspInstance+57)@ha
	lbz		r4,(Dcm_DspInstance+57)@l(r4)
	bl		BswM_Dcm_CommunicationMode_CurrentState
	b		.L656
.L663:
#    }
#    else if (DCM_ASYNCH_STATE_0x85_WAIT_CONF == Dcm_DspInstance.asynch_state)
	.d2line		2496
	lis		r3,(Dcm_DspInstance+8)@ha		# Result=r3
.Llo183:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# Result=r3
	se_cmpi		r0,8
	bc		0,2,.L656	# ne
#    {
#       if (FALSE == Dcm_DspInstance.control_dtc_setting_status.enabled)
	.d2line		2498
.Llo184:
	lis		r3,(Dcm_DspInstance+58)@ha		# Result=r3
.Llo185:
	lbz		r0,(Dcm_DspInstance+58)@l(r3)		# Result=r3
	se_cmpi		r0,0
	bc		0,2,.L666	# ne
#       {
#          /*
#           * MISRA-C:2004 RULE 16.10 VIOLATION:
#           * If a function returns error information, then that error information shall be tested.
#           * The return value of the switch is discarded since the DCM has
#           * no possibilities for error handling at this point.
#           */
#          (void)SchM_Switch_Dcm_DcmControlDTCSetting(RTE_MODE_DcmControlDTCSetting_DISABLEDTCSETTING);
	.d2line		2506
.Llo186:
	diab.li		r3,1		# Result=r3
	bl		SchM_Switch_Dcm_DcmControlDTCSetting
	b		.L656
.L666:
#       }
#       else
#       {
#          /*
#           * MISRA-C:2004 RULE 16.10 VIOLATION:
#           * If a function returns error information, then that error information shall be tested.
#           * The return value of the switch is discarded since the DCM has
#           * no possibilities for error handling at this point.
#           */
#          (void)SchM_Switch_Dcm_DcmControlDTCSetting(RTE_MODE_DcmControlDTCSetting_ENABLEDTCSETTING);
	.d2line		2516
	diab.li		r3,0		# Result=r3
	bl		SchM_Switch_Dcm_DcmControlDTCSetting
.L656:
#       }
#    }
#    else
#    {
#       /* just do nothing */
#    }
# }
	.d2line		2523
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3329:
	.type		Dcm_DspConfirmation,@function
	.size		Dcm_DspConfirmation,.-Dcm_DspConfirmation
# Number of nodes = 83

# Allocations for Dcm_DspConfirmation
#	?a4		Result
# FUNC(void, DCM_CODE) Dcm_DspEnableDtcSetting(void)
	.align		2
	.section	.text_vle
        .d2line         2529,22
#$$ld
.L3335:

#$$bf	Dcm_DspEnableDtcSetting,interprocedural,rasave,nostackparams
	.globl		Dcm_DspEnableDtcSetting
	.d2_cfa_start __cie
Dcm_DspEnableDtcSetting:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    /*
#     * Called from DSD when switching session.
#    */
#    if (FALSE != Dcm_DspInstance.control_dtc_setting_status.enabled)
	.d2line		2534
	lis		r3,(Dcm_DspInstance+58)@ha
	lbz		r0,(Dcm_DspInstance+58)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L674	# ne
#    {
#       /*
#        * DTC setting control is already enabled, do nothing.
#        */
#    }
#    else if (DEM_CONTROL_DTC_SETTING_OK == Dem_DcmEnableDTCSetting(DTC_GROUP_ALL_DTCS, DEM_DTC_KIND_ALL_DTCS))
	.d2line		2540
	diab.li		r3,16777215
	diab.li		r4,1
	bl		Dem_DcmEnableDTCSetting
	e_andi.		r3,r3,255
	bc		0,2,.L674	# ne
#    {
#       Dcm_DspInstance.control_dtc_setting_status.enabled = TRUE;
	.d2line		2542
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+58)@ha
	stb		r0,(Dcm_DspInstance+58)@l(r3)
# 
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * The return value of the switch is discarded since the DCM has
#        * no possibilities for error handling at this point.
#        */
#       (void)SchM_Switch_Dcm_DcmControlDTCSetting(RTE_MODE_DcmControlDTCSetting_ENABLEDTCSETTING);
	.d2line		2550
	diab.li		r3,0
	bl		SchM_Switch_Dcm_DcmControlDTCSetting
.L674:
#    }
#    else
#    {
#       /*
#        * The request was rejected by the DEM, nothing to do.
#        */
#    }
# }
	.d2line		2558
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3336:
	.type		Dcm_DspEnableDtcSetting,@function
	.size		Dcm_DspEnableDtcSetting,.-Dcm_DspEnableDtcSetting
# Number of nodes = 29

# Allocations for Dcm_DspEnableDtcSetting
# FUNC(void, DCM_CODE) Dcm_DspServiceCancelled(void)
	.align		2
	.section	.text_vle
        .d2line         2563,22
#$$ld
.L3340:

#$$bf	Dcm_DspServiceCancelled,interprocedural,rasave,nostackparams
	.globl		Dcm_DspServiceCancelled
	.d2_cfa_start __cie
Dcm_DspServiceCancelled:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_CANCEL;
	.d2line		2565
	diab.li		r0,2
	lis		r3,(Dcm_DspInstance+8)@ha
	stw		r0,(Dcm_DspInstance+8)@l(r3)
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * The service is cancelled so active request to respond an NRC to.
#     *
#     * Make sure no DTC is locked if the current service is cancelled.
#     */
#    (void)Dem_DcmEnableDTCRecordUpdate();
	.d2line		2574
	bl		Dem_DcmEnableDTCRecordUpdate
# }
	.d2line		2575
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3341:
	.type		Dcm_DspServiceCancelled,@function
	.size		Dcm_DspServiceCancelled,.-Dcm_DspServiceCancelled
# Number of nodes = 9

# Allocations for Dcm_DspServiceCancelled
# FUNC(void, DCM_CODE) Dcm_DspResetPendingSecurityLevel(void)
	.align		2
	.section	.text_vle
        .d2line         2580,22
#$$ld
.L3345:

#$$bf	Dcm_DspResetPendingSecurityLevel,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4
	.globl		Dcm_DspResetPendingSecurityLevel
	.d2_cfa_start __cie
Dcm_DspResetPendingSecurityLevel:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    ResetPendingSecurityLevel();
	.d2line		2582
	diab.li		r3,0
	lis		r4,(Dcm_DspInstance+4)@ha
	stb		r3,(Dcm_DspInstance+4)@l(r4)
# }
	.d2line		2583
	.d2epilogue_begin
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3346:
	.type		Dcm_DspResetPendingSecurityLevel,@function
	.size		Dcm_DspResetPendingSecurityLevel,.-Dcm_DspResetPendingSecurityLevel
# Number of nodes = 7

# Allocations for Dcm_DspResetPendingSecurityLevel
# FUNC(Std_ReturnType, DCM_CODE) Dcm_EcuReset(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         2588,32
#$$ld
.L3350:

#$$bf	Dcm_EcuReset,interprocedural,rasave,nostackparams
	.globl		Dcm_EcuReset
	.d2_cfa_start __cie
Dcm_EcuReset:
.Llo187:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    CONST(uint8, DCM_CONST) resetType = pMsgContext->subServiceId;
	.d2line		2590
	lbz		r29,26(r31)		# pMsgContext=r31
.Llo193:
	mr		r29,r29		# resetType=r29 resetType=r29
# 
#    /*
#     * Check the lenght of the data
#     */
#    if (1 != pMsgContext->reqDataLen)
	.d2line		2595
	lhz		r0,4(r31)		# pMsgContext=r31
	se_cmpi		r0,1
	bc		1,2,.L683	# eq
#    {
#       /*
#        * The length of the request is not correct.
#        */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		2600
.Llo188:
	diab.li		r0,19
.Llo189:
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L684
.L683:
#    }
#    /*
#     * Handle reset modes
#     */
#    else if ((LEV_RT_HR == resetType) || (LEV_RT_KOFFONR == resetType) || (LEV_RT_SR == resetType))
	.d2line		2605
	rlwinm		r0,r29,0,24,31		# resetType=r29
	se_cmpi		r0,1
	bc		1,2,.L689	# eq
	rlwinm		r0,r29,0,24,31		# resetType=r29
	se_cmpi		r0,2
	bc		1,2,.L689	# eq
	rlwinm		r0,r29,0,24,31		# resetType=r29
	se_cmpi		r0,3
	bc		0,2,.L685	# ne
.L689:
#    {
#       /*
#        * Notify the SchM and wait for Tx confirmation
#        */
#       Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x11_WAIT_CONF;
	.d2line		2610
	diab.li		r0,6
	lis		r3,(Dcm_DspInstance+8)@ha
	stw		r0,(Dcm_DspInstance+8)@l(r3)
# 
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * The return value of the switch is discarded since the DCM has
#        * no possibilities for error handling at this point.
#        */
#       (void)SchM_Switch_Dcm_DcmEcuReset(resetToMode[resetType-1U]);
	.d2line		2618
	lis		r3,(resetToMode-1)@ha
	e_add16i		r3,r3,(resetToMode-1)@l
	rlwinm		r0,r29,0,24,31		# resetType=r29
	lbzx		r3,r3,r0
	bl		SchM_Switch_Dcm_DcmEcuReset
# 
#       /*
#        * Prepare response
#        */
#       pMsgContext->resData[0]   = resetType;
	.d2line		2623
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r29,0(r3)		# resetType=r29
#       pMsgContext->resDataLen  = 1;
	.d2line		2624
	diab.li		r0,1
	sth		r0,12(r31)		# pMsgContext=r31
	b		.L684
.L685:
#    }
#    /*
#     * Handle enable/disable rapid power shutdown
#     *
#     * The SCG guarantees that the only reset types left are
#     *   0x04: ENABLE_RAPIDPOWERSHUTDOWN
#     *   0x05: DISABLE_RAPIDPOWERSHUTDOWN
#     * No check is therefore needed.
#     */
#    else
#    {
#       /*
#        * Notify the SchM and send the response
#        * The conversion table is zero based but the only resetTypes left are 0x04 and 0x05
#        *
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * The return value of the switch is discarded since the DCM has
#        * no possibilities for error handling at this point.
#        */
#       (void)SchM_Switch_Dcm_DcmModeRapidPowerShutDown(powerShutdownToMode[resetType - 0x04U]);
	.d2line		2645
	lis		r3,(powerShutdownToMode-4)@ha
	e_add16i		r3,r3,(powerShutdownToMode-4)@l
	rlwinm		r0,r29,0,24,31		# resetType=r29
	lbzx		r3,r3,r0
	bl		SchM_Switch_Dcm_DcmModeRapidPowerShutDown
# 
# 
#       /*
#        * [SWS_Dcm_00589]: The power down time shall only be present if enabled
#        * But according to ISO 14229-6 shall power down time always be present if resetType is equal to 0x04 (enableRapidPowerShutDown).
#        */
#       pMsgContext->resData[0] = resetType;
	.d2line		2652
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r29,0(r3)		# resetType=r29
#       if (LEV_RT_ERPSD == resetType)
	.d2line		2653
	rlwinm		r29,r29,0,24,31		# resetType=r29 resetType=r29
	se_cmpi		r29,4		# resetType=r29
	bc		0,2,.L687	# ne
#       {
#          pMsgContext->resData[1]   = Dcm_LCfg.power_down_time;
	.d2line		2655
.Llo194:
	lis		r3,(Dcm_LCfg+3)@ha
	lbz		r0,(Dcm_LCfg+3)@l(r3)
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,1(r3)
#          pMsgContext->resDataLen  = 2;
	.d2line		2656
	diab.li		r0,2
	sth		r0,12(r31)		# pMsgContext=r31
	b		.L684
.L687:
#       }
#       else
#       {
#          pMsgContext->resDataLen = 1;
	.d2line		2660
	diab.li		r0,1
	sth		r0,12(r31)		# pMsgContext=r31
.L684:
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		2664
.Llo190:
	lbz		r3,0(r30)		# pErrorCode=r30
.Llo191:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo192:
	rlwinm		r3,r3,0,24,31
# }
	.d2line		2665
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3351:
	.type		Dcm_EcuReset,@function
	.size		Dcm_EcuReset,.-Dcm_EcuReset
# Number of nodes = 119

# Allocations for Dcm_EcuReset
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		resetType
# static FUNC(Dcm_Cfg_RxChannelPointerType, DCM_CODE) FindPduRxChannel(PduIdType pPdu)
	.align		1
	.section	.text_vle
        .d2line         3001,53
#$$ld
.L3363:

#$$bf	FindPduRxChannel,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,cr0,lr
	.d2_cfa_start __cie
FindPduRxChannel:
.Llo195:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r0,r3		# pPdu=r0 pPdu=r3
	.d2prologue_end
# {
#    uint16 i;
#    P2CONST(Dcm_Cfg_RxChannelType, AUTOMATIC, DCM_APPL_DATA) channel = NULL_PTR;
	.d2line		3004
	diab.li		r4,0		# channel=r4
# 
#    for (i = (uint16)0U; i < Dcm_pPbCfg->num_rx_channels; i++)
	.d2line		3006
.Llo203:
	diab.li		r3,0
.L757:
.Llo196:
	rlwinm		r6,r3,0,16,31		# i=r3
.Llo197:
	lis		r5,Dcm_pPbCfg@ha
	lwz		r5,Dcm_pPbCfg@l(r5)
	lhz		r5,6(r5)
	se_cmp		r6,r5
	bc		0,0,.L761	# ge
#    {
#       if (pPdu == Dcm_pPbCfg->p_rx_channels[i].pdu_id)
	.d2line		3008
	rlwinm		r7,r0,0,16,31		# pPdu=r0
	lis		r5,Dcm_pPbCfg@ha
	lwz		r5,Dcm_pPbCfg@l(r5)
	lwz		r5,8(r5)
	rlwinm		r6,r3,0,16,31		# i=r3
	e_mulli		r6,r6,44
	lhzx		r5,r5,r6
	se_cmp		r7,r5
	bc		0,2,.L760	# ne
#       {
#          channel = &Dcm_pPbCfg->p_rx_channels[i];
	.d2line		3010
.Llo199:
	lis		r4,Dcm_pPbCfg@ha		# channel=r4
	lwz		r4,Dcm_pPbCfg@l(r4)		# channel=r4 channel=r4
	lwz		r4,8(r4)		# channel=r4 channel=r4
.Llo200:
	rlwinm		r3,r3,0,16,31		# i=r3 i=r3
	e_mulli		r3,r3,44		# i=r3 i=r3
	se_add		r3,r4		# i=r3 i=r3 channel=r4
.Llo201:
	mr		r4,r3		# channel=r4 channel=r3
	b		.L761
.L760:
#          break;
#       }
#    }
	.d2line		3013
.Llo202:
	diab.addi		r6,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L757
.L761:
#    return channel;
	.d2line		3014
.Llo198:
	mr		r3,r4		# channel=r3 channel=r4
# }
	.d2line		3015
	.d2epilogue_begin
	lwz		r0,20(r1)		# pPdu=r0
	mtspr		lr,r0		# pPdu=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo204:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3364:
	.type		FindPduRxChannel,@function
	.size		FindPduRxChannel,.-FindPduRxChannel
# Number of nodes = 45

# Allocations for FindPduRxChannel
#	?a4		pPdu
#	?a5		i
#	?a6		channel
# FUNC(Dcm_Cfg_SessionPointerType, DCM_CODE) Dcm_DspGetSessionConfiguration(Dcm_SesCtrlType requestedSession)
	.align		2
	.section	.text_vle
        .d2line         14295,44
#$$ld
.L3379:

#$$bf	Dcm_DspGetSessionConfiguration,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,cr0,lr
	.globl		Dcm_DspGetSessionConfiguration
	.d2_cfa_start __cie
Dcm_DspGetSessionConfiguration:
.Llo205:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r6,r3		# requestedSession=r6 requestedSession=r3
	.d2prologue_end
# {
#    uint8 i;
#    P2CONST(Dcm_Cfg_SessionType, AUTOMATIC, DCM_APPL_DATA) pSession = NULL_PTR;
	.d2line		14298
	diab.li		r4,0		# pSession=r4
# 
#    /*
#     * Find the session if any
#     */
#    for (i = 0; i < Dcm_LCfg.num_sessions; i++)
	.d2line		14303
.Llo213:
	diab.li		r3,0
.L3020:
.Llo206:
	rlwinm		r0,r3,0,24,31		# i=r3
.Llo207:
	lis		r5,(Dcm_LCfg+32)@ha
	lbz		r5,(Dcm_LCfg+32)@l(r5)
	se_cmp		r0,r5
	bc		0,0,.L3024	# ge
#    {
#       if (Dcm_LCfg.sessions[i].session_level == requestedSession)
	.d2line		14305
	lis		r5,(Dcm_LCfg+36)@ha
	lwz		r5,(Dcm_LCfg+36)@l(r5)
	rlwinm		r0,r3,4,20,27		# i=r3
	lbzx		r0,r5,r0
	rlwinm		r5,r6,0,24,31		# requestedSession=r6
	se_cmp		r0,r5
	bc		0,2,.L3023	# ne
#       {
#          pSession = &Dcm_LCfg.sessions[i];
	.d2line		14307
.Llo209:
	lis		r4,(Dcm_LCfg+36)@ha		# pSession=r4
	lwz		r4,(Dcm_LCfg+36)@l(r4)		# pSession=r4 pSession=r4
.Llo210:
	rlwinm		r3,r3,4,20,27		# i=r3 i=r3
	se_add		r3,r4		# i=r3 i=r3 pSession=r4
.Llo211:
	mr		r4,r3		# pSession=r4 pSession=r3
	b		.L3024
.L3023:
#          break;
#       }
#    }
	.d2line		14310
.Llo212:
	diab.addi		r0,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L3020
.L3024:
# 
#    return pSession;
	.d2line		14312
.Llo208:
	mr		r3,r4		# pSession=r3 pSession=r4
# }
	.d2line		14313
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo214:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3380:
	.type		Dcm_DspGetSessionConfiguration,@function
	.size		Dcm_DspGetSessionConfiguration,.-Dcm_DspGetSessionConfiguration
# Number of nodes = 48

# Allocations for Dcm_DspGetSessionConfiguration
#	?a4		requestedSession
#	?a5		i
#	?a6		pSession
# FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagnosticSessionControl(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         2670,32
#$$ld
.L3394:

#$$bf	Dcm_DiagnosticSessionControl,interprocedural,rasave,nostackparams
	.globl		Dcm_DiagnosticSessionControl
	.d2_cfa_start __cie
Dcm_DiagnosticSessionControl:
.Llo215:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# OpStatus=r31 OpStatus=r3
.Llo216:
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
.Llo217:
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
# {
#    CONSTP2VAR(DiagnosticSessionControlType, AUTOMATIC, DCM_APPL_DATA) pStat = &Dcm_DspInstance.diag_ses_ctrl_status;
# 
#    Dcm_Cfg_RxChannelPointerType pRxChannel = FindPduRxChannel(pMsgContext->dcmRxPduId);
	.d2line		2674
	lhz		r3,24(r30)		# pMsgContext=r30
	bl		FindPduRxChannel
.Llo219:
	mr		r28,r3		# pRxChannel=r28 pRxChannel=r3
# 
#    /*
#     * No need to handle DCM_CANCEL since the Dcm_SetProgConditions, that might return pending,
#     * hasn't any OpStatus and thus cannot be cancelled.
#     */
# 
#    /*
#     * Only used for boot sessions
#     *
#     * Confirmation on the NRC 0x78 has been recevied so it's time to set the programming conditions and execute the reset.
#     * Or when no NRC 0x78 was sent, this is executed directly the next schedule.
#     */
#    if ((DCM_PENDING == OpStatus) || (DCM_FORCE_RCRRP_OK == OpStatus))
	.d2line		2687
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
.Llo223:
	se_cmpi		r3,1
	bc		1,2,.L718	# eq
.Llo220:
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
	se_cmpi		r3,3
	bc		0,2,.L696	# ne
.L718:
	.d2line		2672
	lis		r3,(Dcm_DspInstance+74)@ha
	lbz		r0,(Dcm_DspInstance+74)@l(r3)
	se_cmpi		r0,0
	bc		1,2,.L697	# eq
#    {
#       if (pStat->bootload_interaction_finished)
#       {
#          /*
#          * Reset has been notified and waiting to be executed.
#          * Don't finalize the service so NRC 0x78 possibly will be sent.
#          */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		2695
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L696
.L697:
	.section	.text_vle
.L3402:
#       }
#       else
#       {
#          CONST(Std_ReturnType, AUTOMATIC) stdRetVal = Dcm_SetProgConditions(&pStat->progCond);
	.d2line		2699
	lis		r3,(Dcm_DspInstance+64)@ha		# stdRetVal=r3
.Llo225:
	e_add16i		r3,r3,(Dcm_DspInstance+64)@l		# stdRetVal=r3 stdRetVal=r3
.Llo226:
	bl		Dcm_SetProgConditions
.Llo227:
	mr		r3,r3		# stdRetVal=r3 stdRetVal=r3
#          if (E_OK == stdRetVal)
	.d2line		2700
	rlwinm		r0,r3,0,24,31		# stdRetVal=r3
	se_cmpi		r0,0
	bc		0,2,.L699	# ne
#          {
#             /*
#              * Successfully set the programming conditions and finally execute the reset
#              *
#              * MISRA-C:2004 RULE 16.10 VIOLATION:
#              * If a function returns error information, then that error information shall be tested.
#              * The return value of the switch is discarded since the DCM has
#              * no possibilities for error handling at this point.
#              * And since the ECU is about the reset, the return value will not matter.
#              */
#             (void)SchM_Switch_Dcm_DcmEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
	.d2line		2711
.Llo228:
	diab.li		r3,6		# stdRetVal=r3
	bl		SchM_Switch_Dcm_DcmEcuReset
	.d2line		2672
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+74)@ha		# stdRetVal=r3
.Llo229:
	stb		r0,(Dcm_DspInstance+74)@l(r3)		# stdRetVal=r3
# 
#             /*
#              * This state is only used to avoid further calls to Dcm_SetProgConditions
#              * and SchM_Switch_Dcm_DcmEcuReset while waiting for the ECU to reset.
#              */
#             pStat->bootload_interaction_finished = TRUE;
# 
#             /*
#              * The service handler shall be called again to possibly trigger P2 until reset is actually happen.
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		2722
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L696
.L699:
#          }
#          else if (DCM_E_PENDING == stdRetVal)
	.d2line		2724
	rlwinm		r3,r3,0,24,31		# stdRetVal=r3 stdRetVal=r3
	se_cmpi		r3,10		# stdRetVal=r3
	bc		0,2,.L701	# ne
#          {
#             /*
#              * Conditions set is in progress, a further call to
#              * this API is needed to end the setting.
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		2730
.Llo230:
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L696
.L701:
#          }
#          else
#          {
#             /*
#              * All other return values are considered to be errors.
#              */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		2737
	diab.li		r0,34
	stb		r0,0(r29)		# pErrorCode=r29
	.section	.text_vle
.L3403:
.L696:
#          }
#       }
#    }
# 
#    if (DCM_INITIAL == OpStatus)
	.d2line		2742
	rlwinm		r31,r31,0,24,31		# OpStatus=r31 OpStatus=r31
	se_cmpi		r31,0		# OpStatus=r31
	bc		0,2,.L703	# ne
	.section	.text_vle
.L3409:
#    {
#       /*
#        * Safe to do, checks on input are done later
#        */
#       CONST(Dcm_SesCtrlType, DCM_CONST) requestedSession = (Dcm_SesCtrlType)pMsgContext->subServiceId;
	.d2line		2747
.Llo218:
	lbz		r7,26(r30)		# pMsgContext=r30
.Llo251:
	mr		r7,r7		# requestedSession=r7 requestedSession=r7
	.d2line		2672
	mr		r3,r7		# requestedSession=r3 requestedSession=r7
	bl		Dcm_DspGetSessionConfiguration
.Llo231:
	lis		r4,(Dcm_DspInstance+60)@ha
	stw		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
#       pStat->pReqSession = Dcm_DspGetSessionConfiguration(requestedSession);
# 
#       /*
#       * Per design has pMsgContext->dcmRxPduId always a valid value,
#       * i.e.from 0 up to maximum number of RxChannels.Therefore will FindPduRxChannel
#       * always return a valid pointer. It will therefore not be possible to test but
#       * kept to avoid Klocwork warnings.
#       */
#       if (NULL_PTR == pRxChannel)
	.d2line		2756
	se_cmpi		r28,0		# pRxChannel=r28
	bc		0,2,.L704	# ne
#       {
#          *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		2758
.Llo232:
	diab.li		r0,34
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L703
.L704:
#       }
#       /*
#        * Only one byte, the session, is allowed.
#        */
#       else if (1 != pMsgContext->reqDataLen)
	.d2line		2763
	lhz		r0,4(r30)		# pMsgContext=r30
	se_cmpi		r0,1
	bc		1,2,.L706	# eq
#       {
#          /*
#           * The length of the request is not correct.
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		2768
	diab.li		r0,19
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L703
.L706:
#       }
#       /*
#        * There is no need to check if the session is found since the SCG
#        * ensures that all configured sessions results in service 0x10 with correct subservices.
#        * But keep the check to make SCA happy.
#        */
#       else if (NULL_PTR != pStat->pReqSession)
	.d2line		2775
	lis		r3,(Dcm_DspInstance+60)@ha		# stdRetVal=r3
.Llo233:
	lwz		r0,(Dcm_DspInstance+60)@l(r3)		# stdRetVal=r3
	se_cmpi		r0,0
	bc		1,2,.L703	# eq
	.d2line		2672
.Llo234:
	diab.li		r0,16
	lis		r3,(Dcm_DspInstance+68)@ha		# stdRetVal=r3
.Llo235:
	stb		r0,(Dcm_DspInstance+68)@l(r3)		# stdRetVal=r3
	lwz		r3,20(r28)		# stdRetVal=r3 pRxChannel=r28
	lbz		r0,0(r3)		# stdRetVal=r3
	lis		r3,(Dcm_DspInstance+64)@ha		# stdRetVal=r3
	stb		r0,(Dcm_DspInstance+64)@l(r3)		# stdRetVal=r3
	lhz		r0,4(r28)		# pRxChannel=r28
	lis		r3,(Dcm_DspInstance+66)@ha		# stdRetVal=r3
	sth		r0,(Dcm_DspInstance+66)@l(r3)		# stdRetVal=r3
#       {
#          /*
#           * Programming conditions can be added regardless if used or not.
#           * The easy way to avoid duplicated code below.
#           */
#          pStat->progCond.Sid              = 0x10; /* Diagnostic session control */
#          pStat->progCond.ProtocolId       = pRxChannel->p_protocol->identifier;
#          pStat->progCond.TesterSourceAddr = pRxChannel->tester_source_addr;
# 
#          if ((0 == pMsgContext->msgAddInfo.suppressPosResponse) || (TRUE == pRxChannel->p_protocol->send_resp_pend_on_trans_to_boot))
	.d2line		2785
	lwz		r0,16(r30)		# pMsgContext=r30
	se_btsti		r0,1
	bc		1,2,.L719	# eq
.Llo236:
	lwz		r3,20(r28)		# stdRetVal=r3 pRxChannel=r28
.Llo237:
	lbz		r0,3(r3)		# stdRetVal=r3
	se_cmpi		r0,1
	bc		0,2,.L709	# ne
.L719:
	.d2line		2672
.Llo238:
	lis		r3,(Dcm_DspInstance+69)@ha		# stdRetVal=r3
.Llo239:
	stb		r7,(Dcm_DspInstance+69)@l(r3)		# stdRetVal=r3 requestedSession=r7
	b		.L710
.L709:
.Llo240:
	.diab.bseti		r7,24
	lis		r3,(Dcm_DspInstance+69)@ha		# stdRetVal=r3
.Llo241:
	stb		r7,(Dcm_DspInstance+69)@l(r3)		# stdRetVal=r3
.L710:
#          {
#             /*
#              * The subfunction (aka requested session) without the suppress positive response bit, or
#              * the DCM shall send a NRC 0x78 before boot which implies a positive response. See ISO 14229 7.5.2.1 and 7.5.2.2 for details.
#              */
#             pStat->progCond.SubFncId      = requestedSession;
#          }
#          else
#          {
#            /*
#             * The subfunction aka requested session with the suppress positive response bit.
#             * The suppress bit was lost in DSD and has to be added again.
#             */
#             pStat->progCond.SubFncId      = requestedSession | 0x80U;
#          }
# 
#          /*
#           * Is the requested session and standard session or used for jump to bootloader?
#           */
#          if (DCM_NO_BOOT == pStat->pReqSession->jump_to_bootloader)
	.d2line		2805
.Llo242:
	lis		r3,(Dcm_DspInstance+60)@ha		# stdRetVal=r3
.Llo243:
	lwz		r3,(Dcm_DspInstance+60)@l(r3)		# stdRetVal=r3 stdRetVal=r3
	lwz		r0,12(r3)		# stdRetVal=r3
	se_cmpi		r0,0
	bc		0,2,.L711	# ne
#          {
#             /*
#              * Change state so the session will be updated upon Tx confirmation
#              */
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x10_WAIT_CONF;
	.d2line		2810
.Llo244:
	diab.li		r0,5
	lis		r3,(Dcm_DspInstance+8)@ha		# stdRetVal=r3
.Llo245:
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# stdRetVal=r3
# 
#             /*
#              * Prepare and send response
#              */
#             pMsgContext->resData[0] = pStat->pReqSession->session_level;
	.d2line		2815
	lis		r4,(Dcm_DspInstance+60)@ha
	lwz		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
	lbz		r5,0(r3)		# stdRetVal=r3
	lwz		r3,8(r30)		# stdRetVal=r3 pMsgContext=r30
	stb		r5,0(r3)		# stdRetVal=r3
# 
#             /*
#              * Add P2ServerMax which shall have the resolution 1ms according to ISO15765-3
#              * Already stored correctly by the SCG
#              */
#             pMsgContext->resData[1] = DcmHiByte(pStat->pReqSession->client_p2_server_max);
	.d2line		2821
	lwz		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
	lhz		r5,6(r3)		# stdRetVal=r3
	rlwinm		r5,r5,24,24,31
	lwz		r3,8(r30)		# stdRetVal=r3 pMsgContext=r30
	stb		r5,1(r3)		# stdRetVal=r3
#             pMsgContext->resData[2] = DcmLoByte(pStat->pReqSession->client_p2_server_max);
	.d2line		2822
	lwz		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
	lbz		r5,7(r3)		# stdRetVal=r3
	lwz		r3,8(r30)		# stdRetVal=r3 pMsgContext=r30
	stb		r5,2(r3)		# stdRetVal=r3
# 
#             /*
#              * Add P2StarServerMax which shall have the resolution 10ms according to ISO15765-3
#              * Already stored correctly by the SCG
#              */
#             pMsgContext->resData[3] = DcmHiByte(pStat->pReqSession->client_p2_star_server_max);
	.d2line		2828
	lwz		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
	lhz		r5,8(r3)		# stdRetVal=r3
	rlwinm		r5,r5,24,24,31
	lwz		r3,8(r30)		# stdRetVal=r3 pMsgContext=r30
	stb		r5,3(r3)		# stdRetVal=r3
#             pMsgContext->resData[4] = DcmLoByte(pStat->pReqSession->client_p2_star_server_max);
	.d2line		2829
	lwz		r3,(Dcm_DspInstance+60)@l(r4)		# stdRetVal=r3
	lbz		r4,9(r3)		# stdRetVal=r3
	lwz		r3,8(r30)		# stdRetVal=r3 pMsgContext=r30
	stb		r4,4(r3)		# stdRetVal=r3
# 
#             pMsgContext->resDataLen = 5;
	.d2line		2831
	sth		r0,12(r30)		# pMsgContext=r30
	b		.L703
.L711:
	.d2line		2672
.Llo246:
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+74)@ha		# stdRetVal=r3
.Llo247:
	stb		r0,(Dcm_DspInstance+74)@l(r3)		# stdRetVal=r3
#          }
#          /*
#           * Boot loader interaction
#           */
#          else
#          {
#             pStat->bootload_interaction_finished = FALSE;
# 
#             if (DCM_OEM_BOOT == pStat->pReqSession->jump_to_bootloader)
	.d2line		2840
	lis		r3,(Dcm_DspInstance+60)@ha		# stdRetVal=r3
	lwz		r3,(Dcm_DspInstance+60)@l(r3)		# stdRetVal=r3 stdRetVal=r3
	lwz		r0,12(r3)		# stdRetVal=r3
	se_cmpi		r0,1
	bc		0,2,.L713	# ne
#             {
#                /*
#                 * Use the ECU reset status to store the requested reset
#                 * When accepted or rejected, only Dcm_DspInstance.asynch_state will be changed and
#                 * this service handler will be called again.
#                 *
#                 * MISRA-C:2004 RULE 16.10 VIOLATION:
#                 * If a function returns error information, then that error information shall be tested.
#                 * The return value of the switch is discarded since the DCM has
#                 * no possibilities for error handling at this point.
#                 * And since the ECU is about the reset, the return value will not matter.
#                 */
#                (void)SchM_Switch_Dcm_DcmEcuReset(RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER);
	.d2line		2853
.Llo221:
	diab.li		r3,4		# stdRetVal=r3
	bl		SchM_Switch_Dcm_DcmEcuReset
	b		.L714
.L713:
#             }
#             /*
#              * System supplier bootloader jump.
#              * The SCG does not allow any other jump to bootloader enumerations
#              */
#             else
#             {
#                /*
#                 * Use the ECU reset status to store the requested reset
#                 * When accepted or rejected, only Dcm_DspInstance.asynch_state will be changed and
#                 * this service handler will be called again.
#                 *
#                 * MISRA-C:2004 RULE 16.10 VIOLATION:
#                 * If a function returns error information, then that error information shall be tested.
#                 * The return value of the switch is discarded since the DCM has
#                 * no possibilities for error handling at this point.
#                 */
#                (void)SchM_Switch_Dcm_DcmEcuReset(RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER);
	.d2line		2871
	diab.li		r3,5		# stdRetVal=r3
	bl		SchM_Switch_Dcm_DcmEcuReset
.L714:
#             }
# 
#             /*
#              * Depending on the configuration, NRC 0x78 shall be sent or just execute reset the next schedule
#              */
#             if (pRxChannel->p_protocol->send_resp_pend_on_trans_to_boot)
	.d2line		2877
	lwz		r3,20(r28)		# stdRetVal=r3 pRxChannel=r28
.Llo248:
	lbz		r0,3(r3)		# stdRetVal=r3
	se_cmpi		r0,0
	bc		1,2,.L715	# eq
#             {
#                /*
#                 * Force a NRC 0x78 (requestCorrectlyReceived-ResponsePending) and wait for the confirm
#                 * Upon confirm shall the programming conditions be set and the reset is to be executed.
#                 */
#                *pErrorCode = DCM_INT_NRC_API_RETURNED_FORCE_RCRRP;
	.d2line		2883
.Llo224:
	diab.li		r0,163
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L703
.L715:
#             }
#             else
#             {
#                /*
#                 * The service handler shall be called again (without NRC 0x78) 
#                 * to finish the bootloader interaction.
#                 */
#                *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		2891
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	.section	.text_vle
.L3410:
.L703:
#             }
# 
#          }
#       }
#       else
#       {
#          /*
#           * Will never end up here. If incorrect subservice, the request will be stopped in DSD
#           */
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		2904
	lbz		r3,0(r29)		# stdRetVal=r3 pErrorCode=r29
	bl		Dcm_ErrorCodeToStdReturnType
.Llo249:
	rlwinm		r3,r3,0,24,31		# stdRetVal=r3 stdRetVal=r3
# }
	.d2line		2905
	.d2epilogue_begin
.Llo250:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
.Llo222:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3395:
	.type		Dcm_DiagnosticSessionControl,@function
	.size		Dcm_DiagnosticSessionControl,.-Dcm_DiagnosticSessionControl
# Number of nodes = 353

# Allocations for Dcm_DiagnosticSessionControl
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	not allocated	pStat
#	?a7		pRxChannel
#	?a8		stdRetVal
#	?a9		requestedSession
# static FUNC(Dcm_Cfg_SecurityPointerType, DCM_CODE) IsSecurityLevelSupported(uint8 SecurityLevel)
	.align		1
	.section	.text_vle
        .d2line         7074,52
#$$ld
.L3418:

#$$bf	IsSecurityLevelSupported,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,cr0,lr
	.d2_cfa_start __cie
IsSecurityLevelSupported:
.Llo252:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r0,r3		# SecurityLevel=r0 SecurityLevel=r3
	.d2prologue_end
# {
#    uint8 i;
#    P2CONST(Dcm_Cfg_SecurityType, AUTOMATIC, DCM_APPL_DATA) pSecurityType = NULL_PTR;
	.d2line		7077
	diab.li		r4,0		# pSecurityType=r4
# 
#    for (i = 0; (i < Dcm_LCfg.num_securities) && (NULL_PTR == pSecurityType); i++)
	.d2line		7079
.Llo256:
	diab.li		r3,0
.L1622:
.Llo253:
	rlwinm		r6,r3,0,24,31		# i=r3
.Llo254:
	lis		r5,(Dcm_LCfg+40)@ha
	lbz		r5,(Dcm_LCfg+40)@l(r5)
	se_cmp		r6,r5
	bc		0,0,.L1624	# ge
	se_cmpi		r4,0		# pSecurityType=r4
	bc		0,2,.L1624	# ne
#    {
#       if (Dcm_LCfg.securities[i].security_level == SecurityLevel)
	.d2line		7081
	rlwinm		r6,r3,0,24,31		# i=r3
	lis		r5,(Dcm_LCfg+44)@ha
	lwz		r5,(Dcm_LCfg+44)@l(r5)
	rlwinm		r7,r6,5,0,26
	se_slwi		r6,3
	subf		r6,r6,r7
	lbzx		r5,r5,r6
	rlwinm		r6,r0,0,24,31		# SecurityLevel=r0
	se_cmp		r5,r6
	bc		0,2,.L1625	# ne
#       {
#          pSecurityType = &(Dcm_LCfg.securities[i]);
	.d2line		7083
	rlwinm		r6,r3,0,24,31		# i=r3
	lis		r4,(Dcm_LCfg+44)@ha		# pSecurityType=r4
	lwz		r5,(Dcm_LCfg+44)@l(r4)		# pSecurityType=r4
	rlwinm		r4,r6,5,0,26		# pSecurityType=r4
	se_slwi		r6,3
	subf		r6,r6,r4		# pSecurityType=r4
	add		r4,r5,r6		# pSecurityType=r4
	mr		r4,r4		# pSecurityType=r4 pSecurityType=r4
.L1625:
#       }
#    }
	.d2line		7085
	diab.addi		r6,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L1622
.L1624:
# 
#    return pSecurityType;
	.d2line		7087
.Llo255:
	mr		r3,r4		# pSecurityType=r3 pSecurityType=r4
# }
	.d2line		7088
	.d2epilogue_begin
	lwz		r0,20(r1)		# SecurityLevel=r0
	mtspr		lr,r0		# SecurityLevel=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo257:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3419:
	.type		IsSecurityLevelSupported,@function
	.size		IsSecurityLevelSupported,.-IsSecurityLevelSupported
# Number of nodes = 50

# Allocations for IsSecurityLevelSupported
#	?a4		SecurityLevel
#	?a5		$$81
#	?a6		$$80
#	?a7		i
#	?a8		pSecurityType
# static FUNC(void, DCM_CODE) SecurityAccessGetSeed(
	.align		1
	.section	.text_vle
        .d2line         10588,29
#$$ld
.L3433:

#$$bf	SecurityAccessGetSeed,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
SecurityAccessGetSeed:
.Llo258:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
.Llo259:
	mr		r30,r4		# SecurityLevel=r30 SecurityLevel=r4
.Llo260:
	mr		r29,r5		# OpStatus=r29 OpStatus=r5
	mr		r28,r6		# pErrorCode=r28 pErrorCode=r6
	.d2prologue_end
#                                  CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                  uint8 SecurityLevel,
#                                  Dcm_OpStatusType OpStatus,
#                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(Dcm_Cfg_SecurityPointerType, DCM_CONST) pSecurityType = IsSecurityLevelSupported(SecurityLevel);
	.d2line		10594
	mr		r3,r30		# SecurityLevel=r3 SecurityLevel=r30
	bl		IsSecurityLevelSupported
.Llo264:
	mr		r27,r3		# pSecurityType=r27 pSecurityType=r3
#    Dcm_SecLevelType activeSecurityLevel;
# 
#    /*
#     * Always safe to use reqData[1] since the buffer will at least be 8 bytes.
#     * If it's used or not is a later question
#     */
#    CONSTP2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) securityAccesDataRecord = &(pMsgContext->reqData[1]);
	.d2line		10601
	lwz		r26,0(r31)		# pMsgContext=r31
	se_addi		r26,1
.Llo272:
	mr		r26,r26		# securityAccesDataRecord=r26 securityAccesDataRecord=r26
# 
#    /*
#     * Do some preparations
#     */
#    ResetPendingSecurityLevel();
	.d2line		10606
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+4)@ha
.Llo271:
	stb		r0,(Dcm_DspInstance+4)@l(r3)
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * [SWS_Dcm_00338] : E_OK shall always be returned.
#     */
#    (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		10613
	diab.addi		r3,r1,8
	bl		Dcm_GetSecurityLevel
# 
#    if (FALSE == TimerStopped(Dcm_DspInstance.sec_acc_data.security_delay_timer))
	.d2line		10615
	lis		r3,(Dcm_DspInstance+2)@ha
	lhz		r0,(Dcm_DspInstance+2)@l(r3)
	e_cmphl16i	r0,65535
	diab.li		r3,1
	.d2line		10594
	isel		r3,r3,r0,2
.L2160:
	.d2line		10615
.Llo265:
	diab.li		r0,0
	isel		r0,r3,r0,2
.L2161:
	se_cmpi		r0,0
	bc		0,2,.L2143	# ne
#    {
#       *pErrorCode = DCM_E_REQUIREDTIMEDELAYNOTEXPIRED;
	.d2line		10617
	diab.li		r0,55
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L2142
.L2143:
#    }
#    /*
#     * Actually there's no need to check if the requested security level is supported or not.
#     * The SCG guarantees a match between configured security levels and configured 0x27 subservices.
#     * So a request for a non configured security level will result in a DCM_E_SUBFUNCTIONNOTSUPPORTED
#     * on DSD level. So this check for NULL_PTR is only to satisfy some compilers and SCA.
#     */
#    else if (NULL_PTR == pSecurityType)
	.d2line		10625
	se_cmpi		r27,0		# pSecurityType=r27
	bc		0,2,.L2145	# ne
#    {
#       *pErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;
	.d2line		10627
	diab.li		r0,18
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L2142
.L2145:
#    }
#    /*
#     * The request shall match the expected length,
#     * i.e. subfunction plus any possible AccessDataRecord
#     */
#    else if (pMsgContext->reqDataLen != (pSecurityType->address_size + 1))
	.d2line		10633
	lhz		r0,4(r31)		# pMsgContext=r31
	lbz		r3,20(r27)		# pSecurityType=r27
	se_addi		r3,1
	se_cmp		r0,r3
	bc		1,2,.L2147	# eq
#    {
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		10635
	diab.li		r0,19
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L2142
.L2147:
#    }
#    /*
#     * Return 0x00 as seed if the requested security level is already active
#     */
#    else if (SecurityLevel == activeSecurityLevel)
	.d2line		10640
	rlwinm		r3,r30,0,24,31		# SecurityLevel=r30
	lbz		r0,8(r1)
	se_cmp		r3,r0
	bc		0,2,.L2149	# ne
	.section	.text_vle
.L3447:
#    {
#       uint16 i;
#       for (i = 0; i < pSecurityType->num_seed; i++)
	.d2line		10643
.Llo266:
	diab.li		r3,0		# i=r3
.L2150:
.Llo273:
	rlwinm		r4,r3,0,16,31		# i=r3
	lhz		r0,16(r27)		# pSecurityType=r27
	se_cmp		r4,r0
	bc		0,0,.L2152	# ge
#       {
#          pMsgContext->resData[i+1U] = (Dcm_MsgItemType)0x00U;
	.d2line		10645
	diab.li		r0,0
	lwz		r5,8(r31)		# pMsgContext=r31
	rlwinm		r4,r3,0,16,31		# i=r3
	se_add		r4,r5
	stb		r0,1(r4)
#       }
	.d2line		10646
	diab.addi		r4,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L2150
.L2152:
# 
#       /*
#        * resDataLen has the initial value of 1 from the caller
#        */
#       pMsgContext->resDataLen += pSecurityType->num_seed;
	.d2line		10651
.Llo274:
	lhz		r0,12(r31)		# pMsgContext=r31
	lhz		r3,16(r27)		# i=r3 pSecurityType=r27
.Llo275:
	se_add		r0,r3		# i=r3
	sth		r0,12(r31)		# pMsgContext=r31
	.section	.text_vle
.L3448:
.Llo261:
	b		.L2142
.L2149:
	.section	.text_vle
.L3453:
#    }
#    else
#    {
#       CONST(Std_ReturnType, AUTOMATIC) stdRetVal = pSecurityType->GetSeedFunc(securityAccesDataRecord, OpStatus, &(pMsgContext->resData[1]), pErrorCode);
	.d2line		10655
.Llo262:
	lwz		r0,4(r27)		# pSecurityType=r27
	mtspr		ctr,r0
	lwz		r5,8(r31)		# pMsgContext=r31
	se_addi		r5,1
	rlwinm		r4,r29,0,24,31		# OpStatus=r29
	mr		r3,r26		# securityAccesDataRecord=r3 securityAccesDataRecord=r26
	mr		r6,r28		# pErrorCode=r6 pErrorCode=r28
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo267:
	mr		r3,r3		# stdRetVal=r3 stdRetVal=r3
# 
#       if (DCM_CANCEL == OpStatus)
	.d2line		10657
.Llo268:
	rlwinm		r29,r29,0,24,31		# OpStatus=r29 OpStatus=r29
	se_cmpi		r29,2		# OpStatus=r29
	bc		0,2,.L2154	# ne
#       {
#          /*
#           * Just complete the service and ignore any possible NRC.
#           */
#          *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		10662
.Llo269:
	diab.li		r0,0
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L2142
.L2154:
#       }
#       else if (E_OK == stdRetVal)
	.d2line		10664
	rlwinm		r0,r3,0,24,31		# stdRetVal=r3
	se_cmpi		r0,0
	bc		0,2,.L2156	# ne
#       {
#          /*
#           * resDataLen has the initial value of 1 from the caller
#           */
#          pMsgContext->resDataLen += pSecurityType->num_seed;
	.d2line		10669
.Llo276:
	lhz		r0,12(r31)		# pMsgContext=r31
	lhz		r3,16(r27)		# stdRetVal=r3 pSecurityType=r27
.Llo277:
	se_add		r0,r3		# stdRetVal=r3
	sth		r0,12(r31)		# pMsgContext=r31
# 
#          /*
#           * Function returned OK, all response data is already set.
#           */
#          Dcm_DspInstance.sec_acc_data.pending_security_level = SecurityLevel;
	.d2line		10674
	lis		r3,(Dcm_DspInstance+4)@ha		# stdRetVal=r3
	stb		r30,(Dcm_DspInstance+4)@l(r3)		# stdRetVal=r3 SecurityLevel=r30
	b		.L2142
.L2156:
#       }
#       else if (DCM_E_PENDING == stdRetVal)
	.d2line		10676
	rlwinm		r3,r3,0,24,31		# stdRetVal=r3 stdRetVal=r3
	se_cmpi		r3,10		# stdRetVal=r3
	bc		0,2,.L2158	# ne
#       {
#          /*
#           * Function returned pending, just try again the next schedule.
#           * The DCM will automatically send NRC 0x78 upon P2 (or P2star) timeout
#           */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		10682
.Llo263:
	diab.li		r0,162
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L2142
.L2158:
#       }
#       else
#       {
#          /*
#           * [SWS_Dcm_00659]
#           * Consider all other responses (including E_NOT_OK and DCM_FORCE_RCRRP_OK) as error.
#           */
#          Dcm_CheckAndPossiblyConvertErrorCode(pErrorCode);
	.d2line		10690
	mr		r3,r28		# pErrorCode=r3 pErrorCode=r28
	bl		Dcm_CheckAndPossiblyConvertErrorCode
	.section	.text_vle
.L3454:
.L2142:
#       }
#    }
# }
	.d2line		10693
	.d2epilogue_begin
.Llo270:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3434:
	.type		SecurityAccessGetSeed,@function
	.size		SecurityAccessGetSeed,.-SecurityAccessGetSeed
# Number of nodes = 180

# Allocations for SecurityAccessGetSeed
#	?a4		pMsgContext
#	?a5		SecurityLevel
#	?a6		OpStatus
#	?a7		pErrorCode
#	?a8		$$58
#	?a9		pSecurityType
#	SP,8		activeSecurityLevel
#	?a10		securityAccesDataRecord
#	?a11		i
#	?a12		stdRetVal
# static FUNC(void, DCM_CODE) SecurityAccessCompareKey(
	.align		1
	.section	.text_vle
        .d2line         10699,29
#$$ld
.L3461:

#$$bf	SecurityAccessCompareKey,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
SecurityAccessCompareKey:
.Llo278:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r27,r3		# pMsgContext=r27 pMsgContext=r3
	mr		r31,r4		# SecurityLevel=r31 SecurityLevel=r4
	mr		r30,r5		# OpStatus=r30 OpStatus=r5
	mr		r29,r6		# pErrorCode=r29 pErrorCode=r6
	.d2prologue_end
#                                  CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                  uint8 SecurityLevel,
#                                  Dcm_OpStatusType OpStatus,
#                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(Dcm_Cfg_SecurityPointerType, DCM_CONST) pSecurityType = IsSecurityLevelSupported(SecurityLevel);
	.d2line		10705
	mr		r3,r31		# SecurityLevel=r3 SecurityLevel=r31
.Llo279:
	bl		IsSecurityLevelSupported
	.d2line		10713
.Llo282:
	mr.		r28,r3		# pSecurityType=?a9 pSecurityType=r3
# 
#    /*
#     * Actually there's no need to check if the requested security level is supported or not.
#     * The SCG guarantees a match between configured security levels and configured 0x27 subservices.
#     * So a request for a non configured security level will result in a DCM_E_SUBFUNCTIONNOTSUPPORTED
#     * on DSD level. So this check for NULL_PTR is only to satisfy some compilers and SCA.
#     */
#    if (NULL_PTR == pSecurityType)
.Llo287:
	bc		0,2,.L2175	# ne
#    {
#       *pErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;
	.d2line		10715
.Llo280:
	diab.li		r0,18
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2176
.L2175:
#    }
#    /*
#     * The request shall match the expected length,
#     * i.e. subfunction plus the key itself
#     */
#    else if (pMsgContext->reqDataLen != (pSecurityType->num_key + 1))
	.d2line		10721
	lhz		r0,4(r27)		# pMsgContext=r27
	lhz		r3,18(r28)		# pSecurityType=r28
	se_addi		r3,1
	se_cmp		r0,r3
	bc		1,2,.L2177	# eq
#    {
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		10723
	diab.li		r0,19
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2176
.L2177:
#    }
#    else if ((0 == Dcm_DspInstance.sec_acc_data.pending_security_level) || /* No GetSeed has been successfully processed */
	.d2line		10725
	lis		r3,(Dcm_DspInstance+4)@ha
	lbz		r0,(Dcm_DspInstance+4)@l(r3)
	se_cmpi		r0,0
	bc		1,2,.L2192	# eq
	rlwinm		r4,r31,0,24,31		# SecurityLevel=r31
	lis		r3,(Dcm_DspInstance+4)@ha
	lbz		r0,(Dcm_DspInstance+4)@l(r3)
	se_cmp		r4,r0
	bc		1,2,.L2179	# eq
.L2192:
#        (SecurityLevel != Dcm_DspInstance.sec_acc_data.pending_security_level)) /* Security level doesn't agree with previous GetSeed */
#    {
#       *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		10728
	diab.li		r0,36
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2176
.L2179:
	.section	.text_vle
.L3473:
#    }
#    else
#    {
#       /*
#        * In-parameters shall always be zero if OpStatus not equal to DCM_INITIAL
#        */
#       CONSTP2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pKey = &pMsgContext->reqData[1];
	.d2line		10735
	lwz		r3,0(r27)		# pMsgContext=r27
	se_addi		r3,1
.Llo289:
	mr		r3,r3		# pKey=r3 pKey=r3
#       CONST(Std_ReturnType, DCM_CONST) stdRetVal = pSecurityType->CompareKeyFunc(pKey, OpStatus, pErrorCode);
	.d2line		10736
	lwz		r0,8(r28)		# pSecurityType=r28
	mtspr		ctr,r0
	rlwinm		r4,r30,0,24,31		# OpStatus=r30
	mr		r3,r3		# pKey=r3 pKey=r3
.Llo290:
	mr		r5,r29		# pErrorCode=r5 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo281:
	mr		r3,r3		# stdRetVal=r3 stdRetVal=r3
# 
#       if (DCM_CANCEL == OpStatus)
	.d2line		10738
.Llo284:
	rlwinm		r30,r30,0,24,31		# OpStatus=r30 OpStatus=r30
	se_cmpi		r30,2		# OpStatus=r30
	bc		0,2,.L2181	# ne
#       {
#          /*
#           * Just complete the service and ignore any possible NRC.
#           */
#          *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		10743
.Llo285:
	diab.li		r0,0
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2176
.L2181:
#       }
#       else if (E_OK == stdRetVal)
	.d2line		10745
	rlwinm		r0,r3,0,24,31		# stdRetVal=r3
	se_cmpi		r0,0
	bc		0,2,.L2183	# ne
#       {
#          /*
#           * Function returned OK, all response data is already set.
#           */
#          ResetPendingSecurityLevel();
	.d2line		10750
.Llo291:
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+4)@ha		# stdRetVal=r3
.Llo292:
	stb		r0,(Dcm_DspInstance+4)@l(r3)		# stdRetVal=r3
#          ResetSecurityAccessFailed();
	.d2line		10751
	lis		r3,Dcm_DspInstance@ha		# stdRetVal=r3
	e_add16i		r3,r3,Dcm_DspInstance@l		# stdRetVal=r3 stdRetVal=r3
	stb		r0,0(r3)		# stdRetVal=r3
#          Dcm_SetSecurityLevel(SecurityLevel);
	.d2line		10752
	rlwinm		r3,r31,0,24,31		# stdRetVal=r3 SecurityLevel=r31
.Llo293:
	bl		Dcm_SetSecurityLevel
	b		.L2176
.L2183:
#       }
#       else if (DCM_E_PENDING == stdRetVal)
	.d2line		10754
.Llo294:
	rlwinm		r0,r3,0,24,31		# stdRetVal=r3
	se_cmpi		r0,10
	bc		0,2,.L2185	# ne
#       {
#          /*
#           * Function returned pending, just try again the next schedule.
#           * The DCM will automatically send NRC 0x78 upon P2 (or P2star) timeout
#           */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		10760
.Llo283:
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2176
.L2185:
#       }
#       else if (DCM_E_COMPARE_KEY_FAILED == stdRetVal)
	.d2line		10762
	rlwinm		r3,r3,0,24,31		# stdRetVal=r3 stdRetVal=r3
	se_cmpi		r3,11		# stdRetVal=r3
	bc		0,2,.L2187	# ne
#       {
#          /* 
#           * [SWS_Dcm_00660]
#           * Count the number of failed security accesses. After DcmDspSecurityNumAttDelay [DcmDspSecurityNumAttDelay] retries 
#           * will a delay of DcmDspSecurityDelayTime [ECUC_Dcm_00757] before the next attempt can be done.
#           */
#          Dcm_DspInstance.sec_acc_data.security_access_failed++;
	.d2line		10769
.Llo295:
	lis		r4,Dcm_DspInstance@ha
	e_add16i		r4,r4,Dcm_DspInstance@l
	lbz		r3,0(r4)		# stdRetVal=r3
.Llo296:
	se_addi		r3,1		# stdRetVal=r3 stdRetVal=r3
	stb		r3,0(r4)		# stdRetVal=r3
#          *pErrorCode = DCM_E_INVALIDKEY;
	.d2line		10770
	diab.li		r0,53
	stb		r0,0(r29)		# pErrorCode=r29
# 
#          if (Dcm_DspInstance.sec_acc_data.security_access_failed >= pSecurityType->num_max_att_delay)
	.d2line		10772
	lis		r3,Dcm_DspInstance@ha		# stdRetVal=r3
	lbz		r0,Dcm_DspInstance@l(r3)		# stdRetVal=r3
	lbz		r3,12(r28)		# stdRetVal=r3 pSecurityType=r28
	se_cmp		r0,r3		# stdRetVal=r3
	bc		1,0,.L2176	# lt
#          {
#             /*
#              * The number of attempts to get security access exceeds DcmDspSecurityNumAttDelay,
#              * thus return NRC 0x36 (ExceedNumberOfAttempts) and start the delay time.
#              */
#             *pErrorCode = DCM_E_EXCEEDNUMBEROFATTEMPTS;
	.d2line		10778
.Llo297:
	diab.li		r0,54
	stb		r0,0(r29)		# pErrorCode=r29
#             TimerStart(Dcm_DspInstance.sec_acc_data.security_delay_timer, pSecurityType->delay_inv_key);
	.d2line		10779
	bl		SchM_Enter_Dcm_EaTimers
	lhz		r0,14(r28)		# pSecurityType=r28
	lis		r3,(Dcm_DspInstance+2)@ha		# stdRetVal=r3
.Llo298:
	sth		r0,(Dcm_DspInstance+2)@l(r3)		# stdRetVal=r3
	bl		SchM_Exit_Dcm_EaTimers
.Llo299:
	b		.L2176
.L2187:
#          }
#       }
#       else
#       {
#          /*
#           * [SWS_Dcm_01150]
#           * Consider all other responses (including E_NOT_OK and DCM_FORCE_RCRRP_OK) as error.
#           */
#          Dcm_CheckAndPossiblyConvertErrorCode(pErrorCode);
	.d2line		10788
	mr		r3,r29		# pErrorCode=r3 pErrorCode=r29
	bl		Dcm_CheckAndPossiblyConvertErrorCode
	.section	.text_vle
.L3474:
.L2176:
#       }
#    }
# 
#    if ((DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode) &&
	.d2line		10792
	lbz		r0,0(r29)		# pErrorCode=r29
	se_cmpi		r0,0
	bc		1,2,.L2174	# eq
.Llo288:
	lbz		r0,0(r29)		# pErrorCode=r29
	cmpi		0,0,r0,162
	bc		1,2,.L2174	# eq
#        (DCM_INT_NRC_API_RETURNED_PENDING != *pErrorCode))
#    {
#       /*
#        * Handle all negative responses (pending is not a negative response).
#        * Since some kind of failure has occurred is GetSeed needed again.
#        * Therefore shall the pending security level be set to zero.
#        */
#       ResetPendingSecurityLevel();
	.d2line		10800
.Llo286:
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+4)@ha		# stdRetVal=r3
.Llo300:
	stb		r0,(Dcm_DspInstance+4)@l(r3)		# stdRetVal=r3
.L2174:
#    }
# }
	.d2line		10802
	.d2epilogue_begin
.Llo301:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3462:
	.type		SecurityAccessCompareKey,@function
	.size		SecurityAccessCompareKey,.-SecurityAccessCompareKey
# Number of nodes = 178

# Allocations for SecurityAccessCompareKey
#	?a4		pMsgContext
#	?a5		SecurityLevel
#	?a6		OpStatus
#	?a7		pErrorCode
#	?a8		$$59
#	?a9		pSecurityType
#	?a10		pKey
#	?a11		stdRetVal
# FUNC(Std_ReturnType, DCM_CODE) Dcm_SecurityAccess(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         2910,32
#$$ld
.L3483:

#$$bf	Dcm_SecurityAccess,interprocedural,rasave,nostackparams
	.globl		Dcm_SecurityAccess
	.d2_cfa_start __cie
Dcm_SecurityAccess:
.Llo302:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# OpStatus=r3 OpStatus=r3
	mr		r4,r4		# pMsgContext=r4 pMsgContext=r4
	mr		r31,r5		# pErrorCode=r31 pErrorCode=r5
	.d2prologue_end
# {
#    CONST(uint8, DCM_CONST) SecurityAccessType = pMsgContext->subServiceId;
	.d2line		2912
	lbz		r7,26(r4)		# SecurityAccessType=r7 pMsgContext=r4
.Llo313:
	mr		r6,r7		# SecurityAccessType=r6 SecurityAccessType=r7
#    CONST(uint8, DCM_CONST) SecurityLevel = (SecurityAccessType + 1U) / 2U;
	.d2line		2913
	rlwinm		r5,r6,0,24,31		# SecurityAccessType=r6
.Llo310:
	se_addi		r5,1
	rlwinm		r0,r5,31,1,31
.Llo314:
	mr		r0,r0		# SecurityLevel=r0 SecurityLevel=r0
# 
#    /* Set up the mandatory response parameters */
#    pMsgContext->resData[0] = SecurityAccessType;
	.d2line		2916
	lwz		r5,8(r4)		# pMsgContext=r4
	stb		r7,0(r5)		# SecurityAccessType=r7
#    pMsgContext->resDataLen = 1;
	.d2line		2917
	diab.li		r5,1
	sth		r5,12(r4)		# pMsgContext=r4
# 
#    if ((uint8)0U != (uint8)(SecurityAccessType & 0x01U))
	.d2line		2919
	rlwinm		r6,r6,0,31,31		# SecurityAccessType=r6 SecurityAccessType=r6
	se_cmpi		r6,0		# SecurityAccessType=r6
	bc		1,2,.L736	# eq
#    {
#       /*
#        * Get Seed
#        */
#       SecurityAccessGetSeed(pMsgContext, SecurityLevel, OpStatus, pErrorCode);
	.d2line		2924
.Llo311:
	mr		r6,r31		# pErrorCode=r6 pErrorCode=r31
	mr		r5,r3		# OpStatus=r5 OpStatus=r3
	mr		r3,r4		# pMsgContext=r3 pMsgContext=r4
.Llo303:
	mr		r4,r0		# SecurityLevel=r4 SecurityLevel=r0
.Llo306:
	bl		SecurityAccessGetSeed
.Llo315:
	b		.L737
.L736:
#    }
#    else
#    {
#       /*
#        * Compare key
#        */
#       SecurityAccessCompareKey(pMsgContext, SecurityLevel, OpStatus, pErrorCode);
	.d2line		2931
.Llo304:
	mr		r6,r31		# pErrorCode=r6 pErrorCode=r31
	mr		r5,r3		# OpStatus=r5 OpStatus=r3
	mr		r3,r4		# pMsgContext=r3 pMsgContext=r4
.Llo305:
	mr		r4,r0		# SecurityLevel=r4 SecurityLevel=r0
.Llo307:
	bl		SecurityAccessCompareKey
.L737:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		2934
.Llo316:
	lbz		r3,0(r31)		# pMsgContext=r3 pErrorCode=r31
	bl		Dcm_ErrorCodeToStdReturnType
.Llo308:
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
# }
	.d2line		2935
	.d2epilogue_begin
.Llo309:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
.Llo312:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3484:
	.type		Dcm_SecurityAccess,@function
	.size		Dcm_SecurityAccess,.-Dcm_SecurityAccess
# Number of nodes = 66

# Allocations for Dcm_SecurityAccess
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		SecurityAccessType
#	?a8		SecurityLevel
# static FUNC(Dcm_CommunicationModeType, DCM_CODE) GetCommunicationMode(uint8 pSubFunction, uint8 pCommunicationType)
	.align		1
	.section	.text_vle
        .d2line         3020,50
#$$ld
.L3498:

#$$bf	GetCommunicationMode,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetCommunicationMode:
.Llo317:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
.Llo343:
	stw		r0,20(r1)		# subFunctionCommunicationType=r0
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pSubFunction=r3 pSubFunction=r3
	mr		r4,r4		# pCommunicationType=r4 pCommunicationType=r4
	.d2prologue_end
# {
#    Dcm_CommunicationModeType communicationMode = 0;
	.d2line		3022
	diab.li		r0,0		# communicationMode=r0
#    CONST(uint16, AUTOMATIC) subFunctionCommunicationType = (uint16)((uint16)pSubFunction << 8) | (uint16)pCommunicationType;
	.d2line		3023
.Llo344:
	rlwinm		r3,r3,8,16,23		# pSubFunction=r3 pSubFunction=r3
	rlwinm		r4,r4,0,24,31		# pCommunicationType=r4 pCommunicationType=r4
	or		r0,r3,r4		# communicationMode=r0 pSubFunction=r3 pCommunicationType=r4
.Llo345:
	mr		r0,r0		# subFunctionCommunicationType=r0 subFunctionCommunicationType=r0
# 
#    switch (subFunctionCommunicationType)
	.d2line		3025
	rlwinm		r6,r0,0,16,31		# subFunctionCommunicationType=r0
	cmpi		0,0,r6,259
	bc		1,1,.L3509	# gt
.Llo318:
	bc		1,2,.L776	# eq
	se_cmpi		r6,3
	bc		1,1,.L3510	# gt
	bc		1,2,.L775	# eq
	se_cmpi		r6,1
	bc		1,2,.L766	# eq
	se_cmpi		r6,2
	bc		1,2,.L771	# eq
	b		.L778
.L3510:
	cmpi		0,0,r6,257
	bc		1,2,.L768	# eq
	cmpi		0,0,r6,258
	bc		1,2,.L772	# eq
	b		.L778
.L3509:
	cmpi		0,0,r6,515
	bc		1,1,.L3511	# gt
	bc		1,2,.L777	# eq
	cmpi		0,0,r6,513
	bc		1,2,.L769	# eq
	cmpi		0,0,r6,514
	bc		1,2,.L773	# eq
	b		.L778
.L3511:
	cmpi		0,0,r6,769
	bc		1,2,.L770	# eq
	cmpi		0,0,r6,770
	bc		1,2,.L774	# eq
	b		.L778
.L766:
#    {
#       /* Communication type 0x01: Normal communication */
#       case 0x0001U:
#          communicationMode = DCM_ENABLE_RX_TX_NORM;
	.d2line		3029
	diab.li		r3,0		# communicationMode=r3
.Llo319:
	b		.L767
.L768:
#          break;
#       case 0x0101U:
#          communicationMode = DCM_ENABLE_RX_DISABLE_TX_NORM;
	.d2line		3032
.Llo320:
	diab.li		r3,1		# communicationMode=r3
.Llo321:
	b		.L767
.L769:
#          break;
#       case 0x0201U:
#          communicationMode = DCM_DISABLE_RX_ENABLE_TX_NORM;
	.d2line		3035
.Llo322:
	diab.li		r3,2		# communicationMode=r3
.Llo323:
	b		.L767
.L770:
#          break;
#       case 0x0301U:
#          communicationMode = DCM_DISABLE_RX_TX_NORMAL;
	.d2line		3038
.Llo324:
	diab.li		r3,3		# communicationMode=r3
.Llo325:
	b		.L767
.L771:
#          break;
# 
#       /* Communication type 0x02: Network manager communication */
#       case 0x0002U:
#          communicationMode = DCM_ENABLE_RX_TX_NM;
	.d2line		3043
.Llo326:
	diab.li		r3,4		# communicationMode=r3
.Llo327:
	b		.L767
.L772:
#          break;
#       case 0x0102U:
#          communicationMode = DCM_ENABLE_RX_DISABLE_TX_NM;
	.d2line		3046
.Llo328:
	diab.li		r3,5		# communicationMode=r3
.Llo329:
	b		.L767
.L773:
#          break;
#       case 0x0202U:
#          communicationMode = DCM_DISABLE_RX_ENABLE_TX_NM;
	.d2line		3049
.Llo330:
	diab.li		r3,6		# communicationMode=r3
.Llo331:
	b		.L767
.L774:
#          break;
#       case 0x0302U:
#          communicationMode = DCM_DISABLE_RX_TX_NM;
	.d2line		3052
.Llo332:
	diab.li		r3,7		# communicationMode=r3
.Llo333:
	b		.L767
.L775:
#          break;
# 
#       /* Communication type 0x03: Both normal and network manager communication */
#       case 0x0003U:
#          communicationMode = DCM_ENABLE_RX_TX_NORM_NM;
	.d2line		3057
.Llo334:
	diab.li		r3,8		# communicationMode=r3
.Llo335:
	b		.L767
.L776:
#          break;
#       case 0x0103U:
#          communicationMode = DCM_ENABLE_RX_DISABLE_TX_NORM_NM;
	.d2line		3060
.Llo336:
	diab.li		r3,9		# communicationMode=r3
.Llo337:
	b		.L767
.L777:
#          break;
#       case 0x0203U:
#          communicationMode = DCM_DISABLE_RX_ENABLE_TX_NORM_NM;
	.d2line		3063
.Llo338:
	diab.li		r3,10		# communicationMode=r3
.Llo339:
	b		.L767
.L778:
#          break;
#       default:
#          /* Shall always be 0x0303U, all other possible values are covered above. */
#          DCM_ASSERT_STATE(SID_MAINFUNCTION, 0x0303U == subFunctionCommunicationType)
	.d2line		3067
.Llo340:
	e_cmphl16i	r0,771		# subFunctionCommunicationType=r0
	bc		1,2,.L779	# eq
.Llo346:
	diab.li		r3,53		# pSubFunction=r3
	diab.li		r4,0		# pCommunicationType=r4
	diab.li		r5,37
	diab.li		r6,34
	bl		Det_ReportError
.L779:
# 
#          communicationMode = DCM_DISABLE_RX_TX_NORM_NM;
	.d2line		3069
	diab.li		r3,11		# communicationMode=r3
.L767:
#          break;
#    }
# 
#    return communicationMode;
	.d2line		3073
.Llo341:
	rlwinm		r3,r3,0,24,31		# communicationMode=r3 communicationMode=r3
# }
	.d2line		3074
	.d2epilogue_begin
.Llo342:
	lwz		r0,20(r1)		# subFunctionCommunicationType=r0
	mtspr		lr,r0		# subFunctionCommunicationType=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3499:
	.type		GetCommunicationMode,@function
	.size		GetCommunicationMode,.-GetCommunicationMode
# Number of nodes = 78

# Allocations for GetCommunicationMode
#	?a4		pSubFunction
#	?a5		pCommunicationType
#	?a6		communicationMode
#	?a7		subFunctionCommunicationType
# FUNC(Std_ReturnType, DCM_CODE) Dcm_CommunicationControl(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         2940,32
#$$ld
.L3514:

#$$bf	Dcm_CommunicationControl,interprocedural,rasave,nostackparams
	.globl		Dcm_CommunicationControl
	.d2_cfa_start __cie
Dcm_CommunicationControl:
.Llo347:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    uint8 communicationType;
#    uint8 subnetNumber;
#    Dcm_CommunicationModeType communicationMode;
#    NetworkHandleType network;
#    Dcm_Cfg_RxChannelPointerType pRxChannel = FindPduRxChannel(pMsgContext->dcmRxPduId);
	.d2line		2946
	lhz		r3,24(r31)		# pMsgContext=r31
	bl		FindPduRxChannel
	.d2line		2948
.Llo348:
	mr.		r28,r3		# pRxChannel=?a10 pRxChannel=r3
# 
#    if (NULL_PTR == pRxChannel)
	bc		0,2,.L741	# ne
#    {
#       /*
#        * Per design has pMsgContext->dcmRxPduId always a valid value,
#        * i.e.from 0 up to maximum number of RxChannels.Therefore will FindPduRxChannel
#        * always return a valid pointer. A check for NULL_PTR cannot be tested but
#        * is used anyway for safety purpose.
#        */
#       *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		2956
.Llo349:
	diab.li		r0,34
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L742
.L741:
#    }
#    else if (2 != pMsgContext->reqDataLen)
	.d2line		2958
	lhz		r0,4(r31)		# pMsgContext=r31
	se_cmpi		r0,2
	bc		1,2,.L743	# eq
#    {
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		2960
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L742
.L743:
#    }
#    else
#    {
#       communicationType = pMsgContext->reqData[1] & 0x0FU;
	.d2line		2964
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r29,1(r3)
	rlwinm		r0,r29,0,28,31		# communicationType=r0
.Llo352:
	mr		r0,r0		# communicationType=r0 communicationType=r0
#       subnetNumber = pMsgContext->reqData[1] >> 4U;
	.d2line		2965
	se_srwi		r29,4
.Llo359:
	mr		r29,r29		# subnetNumber=r29 subnetNumber=r29
# 
#       if ((communicationType < 1U) || (communicationType > 3U))
	.d2line		2967
.Llo364:
	rlwinm		r4,r0,0,24,31		# communicationType=r0
	diab.addi		r4,r4,-1
	se_cmpli	r4,2
	bc		0,1,.L745	# le
#       {
#          /* CommunicationType parameter out of range */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		2970
.Llo353:
	diab.li		r0,49		# communicationType=r0
.Llo354:
	stb		r0,0(r30)		# pErrorCode=r30 communicationType=r0
	b		.L742
.L745:
#       }
#       else
#       {
#          communicationMode = GetCommunicationMode(pMsgContext->subServiceId, communicationType);
	.d2line		2974
	lbz		r3,26(r31)		# pMsgContext=r31
	mr		r4,r0		# communicationType=r4 communicationType=r0
	bl		GetCommunicationMode
.Llo355:
	mr		r3,r3		# communicationMode=r3 communicationMode=r3
# 
#          if (0x0FU == subnetNumber)
	.d2line		2976
	rlwinm		r0,r29,0,24,31		# communicationType=r0 subnetNumber=r29
.Llo356:
	se_cmpi		r0,15		# communicationType=r0
	bc		0,2,.L747	# ne
#          {
#              network = pRxChannel->networkId;
	.d2line		2978
.Llo357:
	lbz		r29,2(r28)		# subnetNumber=r29 pRxChannel=r28
.Llo365:
	mr		r29,r29		# network=r29 network=r29
	b		.L748
.L747:
#          }
#          else
#          {
#             network = subnetNumber;
	.d2line		2982
.Llo360:
	mr		r29,r29		# network=r29 network=r29
.L748:
#          }
# 
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x28_WAIT_CONF;
	.d2line		2985
.Llo361:
	diab.li		r0,7		# communicationType=r0
.Llo358:
	lis		r4,(Dcm_DspInstance+8)@ha		# communicationType=r4
	stw		r0,(Dcm_DspInstance+8)@l(r4)		# communicationType=r4 communicationType=r0
# 
#          Dcm_DspInstance.communication_control_status.comNetwork = network;
	.d2line		2987
	lis		r4,(Dcm_DspInstance+56)@ha		# communicationType=r4
	stb		r29,(Dcm_DspInstance+56)@l(r4)		# communicationType=r4 network=r29
#          Dcm_DspInstance.communication_control_status.requestedCommunicationMode = communicationMode;
	.d2line		2988
	lis		r4,(Dcm_DspInstance+57)@ha		# communicationType=r4
	stb		r3,(Dcm_DspInstance+57)@l(r4)		# communicationType=r4 communicationMode=r3
# 
#          pMsgContext->resData[0] = pMsgContext->subServiceId;
	.d2line		2990
	lbz		r0,26(r31)		# communicationType=r0 pMsgContext=r31
	lwz		r3,8(r31)		# communicationMode=r3 pMsgContext=r31
	stb		r0,0(r3)		# communicationMode=r3 communicationType=r0
#          pMsgContext->resDataLen = 1;
	.d2line		2991
	diab.li		r0,1		# communicationType=r0
	sth		r0,12(r31)		# pMsgContext=r31 communicationType=r0
.L742:
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		2995
.Llo350:
	lbz		r3,0(r30)		# communicationMode=r3 pErrorCode=r30
	bl		Dcm_ErrorCodeToStdReturnType
.Llo362:
	rlwinm		r3,r3,0,24,31		# communicationMode=r3 communicationMode=r3
# }
	.d2line		2996
	.d2epilogue_begin
.Llo363:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
.Llo351:
	lwz		r0,36(r1)		# communicationType=r0
	mtspr		lr,r0		# communicationType=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3515:
	.type		Dcm_CommunicationControl,@function
	.size		Dcm_CommunicationControl,.-Dcm_CommunicationControl
# Number of nodes = 130

# Allocations for Dcm_CommunicationControl
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		communicationType
#	?a7		subnetNumber
#	?a8		communicationMode
#	?a9		network
#	?a10		pRxChannel
# FUNC(Std_ReturnType, DCM_CODE) Dcm_TesterPresent(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         3079,32
#$$ld
.L3532:

#$$bf	Dcm_TesterPresent,interprocedural,rasave,nostackparams
	.globl		Dcm_TesterPresent
	.d2_cfa_start __cie
Dcm_TesterPresent:
.Llo366:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r4,r4		# pMsgContext=r4 pMsgContext=r4
	mr		r5,r5		# pErrorCode=r5 pErrorCode=r5
	.d2prologue_end
# {
#    /*
#     * Actually there's no need to check the requested subservice is supported or not.
#     * The SCG guarantees that at least sub service 0x00 always is created. So a request
#     * for a non configured subservice will result in a DCM_E_SUBFUNCTIONNOTSUPPORTED
#     * on DSD level.
#     *
#     * A check for a valid length is needed since DSD will only check if the subfunction is
#     * present and correct.
#     */
#    if (1 == pMsgContext->reqDataLen)
	.d2line		3090
	lhz		r0,4(r4)		# pMsgContext=r4
	se_cmpi		r0,1
	bc		0,2,.L795	# ne
#    {
#       pMsgContext->resData[0] = pMsgContext->reqData[0];
	.d2line		3092
	lwz		r3,0(r4)		# pMsgContext=r4
	lbz		r0,0(r3)
	lwz		r3,8(r4)		# pMsgContext=r4
	stb		r0,0(r3)
#       pMsgContext->resDataLen = 1;
	.d2line		3093
	diab.li		r0,1
	sth		r0,12(r4)		# pMsgContext=r4
	b		.L796
.L795:
#    }
#    else
#    {
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		3097
	diab.li		r0,19
	stb		r0,0(r5)		# pErrorCode=r5
.L796:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		3100
.Llo367:
	lbz		r3,0(r5)		# pErrorCode=r5
	bl		Dcm_ErrorCodeToStdReturnType
.Llo368:
	rlwinm		r3,r3,0,24,31
# }
	.d2line		3101
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3533:
	.type		Dcm_TesterPresent,@function
	.size		Dcm_TesterPresent,.-Dcm_TesterPresent
# Number of nodes = 34

# Allocations for Dcm_TesterPresent
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ControlDTCSetting(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         3107,32
#$$ld
.L3539:

#$$bf	Dcm_ControlDTCSetting,interprocedural,rasave,nostackparams
	.globl		Dcm_ControlDTCSetting
	.d2_cfa_start __cie
Dcm_ControlDTCSetting:
.Llo369:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r4,r4		# pMsgContext=r4 pMsgContext=r4
	mr		r31,r5		# pErrorCode=r31 pErrorCode=r5
	.d2prologue_end
# {
#    CONST(uint8, AUTOMATIC) DTCSettingType = pMsgContext->subServiceId;
	.d2line		3109
	lbz		r0,26(r4)		# pMsgContext=r4
.Llo376:
	mr		r0,r0		# DTCSettingType=r0 DTCSettingType=r0
# 
# #if (DCM_OPTIONAL_DTCSCOR_ENABLED == STD_ON)
#    /* 
#     * The option record will always be three bytes if it's present
#     * The SCG guarantees the Rx buffer is at least eight bytes.
#     * If the data is valid or not is checked later.
#     */
#    CONST(boolean, AUTOMATIC) optionRecordPresent = (boolean)((1U /* subServiceId */ + 3U /* option record */) == pMsgContext->reqDataLen);
#    CONST(uint32, AUTOMATIC) dtcGroupType = (uint32)(optionRecordPresent ? CONVERT_BE_TO_U32(&pMsgContext->reqData[1]) : DTC_GROUP_ALL_DTCS);
# 
#    if ((1 != pMsgContext->reqDataLen) && (4 != pMsgContext->reqDataLen))
# #else
#    /* There will never be any option record. */
#    CONST(uint32, AUTOMATIC) dtcGroupType = DTC_GROUP_ALL_DTCS;
# 
#    if (1 != pMsgContext->reqDataLen)
	.d2line		3125
	lhz		r3,4(r4)		# pMsgContext=r4
	se_cmpi		r3,1
	bc		1,2,.L800	# eq
# #endif
#    {
#       /*
#        * The length of the request is not correct.
#        */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		3131
.Llo371:
	diab.li		r0,19
.Llo372:
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L801
.L800:
#    }
#    else
#    {
#       /*
#        * Preparation of a positive response can always be done.
#        * If, by some reason, there's a negative response the data and response length
#        * will be adjusted accordingly.
#        */
#       pMsgContext->resData[0] = pMsgContext->reqData[0];
	.d2line		3140
	lwz		r3,0(r4)		# pMsgContext=r4
	lbz		r5,0(r3)
	lwz		r3,8(r4)		# pMsgContext=r4
	stb		r5,0(r3)
#       pMsgContext->resDataLen = 1;
	.d2line		3141
	diab.li		r3,1
	sth		r3,12(r4)		# pMsgContext=r4
# 
#       /*
#        * ON
#        */
#       if (LEV_DTCSTP_ON == DTCSettingType)
	.d2line		3146
.Llo377:
	rlwinm		r0,r0,0,24,31		# DTCSettingType=r0 DTCSettingType=r0
	se_cmpi		r0,1		# DTCSettingType=r0
	bc		0,2,.L802	# ne
	.section	.text_vle
.L3546:
#       {
#          CONST(Dem_ReturnControlDTCSettingType, AUTOMATIC) dtcSettingsResult = Dem_DcmEnableDTCSetting(dtcGroupType, DEM_DTC_KIND_ALL_DTCS);
	.d2line		3148
.Llo370:
	diab.li		r3,16777215		# dtcSettingsResult=r3
	diab.li		r4,1		# pMsgContext=r4
	bl		Dem_DcmEnableDTCSetting
.Llo393:
	mr		r3,r3		# dtcSettingsResult=r3 dtcSettingsResult=r3
#          if (DEM_CONTROL_DTC_SETTING_OK == dtcSettingsResult)
	.d2line		3149
	rlwinm		r0,r3,0,24,31		# DTCSettingType=r0 dtcSettingsResult=r3
.Llo378:
	se_cmpi		r0,0		# DTCSettingType=r0
	bc		0,2,.L803	# ne
#          {
#             /*
#              * A positive response has already been created.
#              * Switch state and wait for confirm to change mode
#              */
#             Dcm_DspInstance.control_dtc_setting_status.enabled = TRUE;
	.d2line		3155
.Llo379:
	diab.li		r0,1		# DTCSettingType=r0
.Llo380:
	lis		r3,(Dcm_DspInstance+58)@ha		# dtcSettingsResult=r3
.Llo394:
	stb		r0,(Dcm_DspInstance+58)@l(r3)		# dtcSettingsResult=r3 DTCSettingType=r0
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x85_WAIT_CONF;
	.d2line		3156
	diab.li		r0,8		# DTCSettingType=r0
	lis		r3,(Dcm_DspInstance+8)@ha		# dtcSettingsResult=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# dtcSettingsResult=r3 DTCSettingType=r0
	b		.L801
.L803:
#          }
#          else if (DEM_CONTROL_DTC_WRONG_DTCGROUP == dtcSettingsResult)
	.d2line		3158
.Llo381:
	rlwinm		r3,r3,0,24,31		# dtcSettingsResult=r3 dtcSettingsResult=r3
	se_cmpi		r3,2		# dtcSettingsResult=r3
	bc		0,2,.L805	# ne
#          {
#             /*
#              * Wrong DTC group, respond with NRC 0x31
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		3163
.Llo395:
	diab.li		r0,49		# DTCSettingType=r0
.Llo382:
	stb		r0,0(r31)		# pErrorCode=r31 DTCSettingType=r0
	b		.L801
.L805:
#          }
#          else
#          {
#             /*
#              * The request was rejected by the DEM, respond with NRC 0x22
#              */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		3170
.Llo383:
	diab.li		r0,34		# DTCSettingType=r0
.Llo384:
	stb		r0,0(r31)		# pErrorCode=r31 DTCSettingType=r0
	.section	.text_vle
.L3547:
.Llo385:
	b		.L801
.L802:
	.section	.text_vle
.L3554:
#          }
#       }
#       /*
#        * LEV_DTCSTP_OFF
#        *
#        * The SCG guarantees that only sub functions 0x01 (ON) and 0x02 (OFF) can be configured.
#        * Therefore will every other requested subfunction be rejected by DSD.
#        */
#       else
#       {
#          CONST(Dem_ReturnControlDTCSettingType, AUTOMATIC) dtcSettingsResult = Dem_DcmDisableDTCSetting(dtcGroupType, DEM_DTC_KIND_ALL_DTCS);
	.d2line		3181
	diab.li		r3,16777215		# dtcSettingsResult=r3
	diab.li		r4,1		# pMsgContext=r4
	bl		Dem_DcmDisableDTCSetting
.Llo397:
	mr		r3,r3		# dtcSettingsResult=r3 dtcSettingsResult=r3
#          if (DEM_CONTROL_DTC_SETTING_OK == dtcSettingsResult)
	.d2line		3182
	rlwinm		r0,r3,0,24,31		# DTCSettingType=r0 dtcSettingsResult=r3
.Llo386:
	se_cmpi		r0,0		# DTCSettingType=r0
	bc		0,2,.L808	# ne
#          {
#             /*
#              * A positive response has already been created.
#              * Switch state and wait for confirm to change mode
#              */
#             Dcm_DspInstance.control_dtc_setting_status.enabled = FALSE;
	.d2line		3188
.Llo387:
	diab.li		r0,0		# DTCSettingType=r0
.Llo388:
	lis		r3,(Dcm_DspInstance+58)@ha		# dtcSettingsResult=r3
.Llo398:
	stb		r0,(Dcm_DspInstance+58)@l(r3)		# dtcSettingsResult=r3 DTCSettingType=r0
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x85_WAIT_CONF;
	.d2line		3189
	diab.li		r0,8		# DTCSettingType=r0
	lis		r3,(Dcm_DspInstance+8)@ha		# dtcSettingsResult=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# dtcSettingsResult=r3 DTCSettingType=r0
	b		.L801
.L808:
#          }
#          else if (DEM_CONTROL_DTC_WRONG_DTCGROUP == dtcSettingsResult)
	.d2line		3191
.Llo389:
	rlwinm		r3,r3,0,24,31		# dtcSettingsResult=r3 dtcSettingsResult=r3
	se_cmpi		r3,2		# dtcSettingsResult=r3
	bc		0,2,.L810	# ne
#          {
#             /*
#              * Wrong DTC group, respond with NRC 0x31
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		3196
.Llo399:
	diab.li		r0,49		# DTCSettingType=r0
.Llo390:
	stb		r0,0(r31)		# pErrorCode=r31 DTCSettingType=r0
	b		.L801
.L810:
#          }
#          else
#          {
#             /*
#              * The request was rejected by the DEM, respond with NRC 0x22
#              */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		3203
.Llo391:
	diab.li		r0,34		# DTCSettingType=r0
.Llo392:
	stb		r0,0(r31)		# pErrorCode=r31 DTCSettingType=r0
	.section	.text_vle
.L3555:
.L801:
#          }
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		3208
.Llo373:
	lbz		r3,0(r31)		# dtcSettingsResult=r3 pErrorCode=r31
.Llo374:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo375:
	rlwinm		r3,r3,0,24,31		# dtcSettingsResult=r3 dtcSettingsResult=r3
# }
	.d2line		3209
	.d2epilogue_begin
.Llo396:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# DTCSettingType=r0
	mtspr		lr,r0		# DTCSettingType=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3540:
	.type		Dcm_ControlDTCSetting,@function
	.size		Dcm_ControlDTCSetting,.-Dcm_ControlDTCSetting
# Number of nodes = 125

# Allocations for Dcm_ControlDTCSetting
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		DTCSettingType
#	not allocated	dtcGroupType
#	?a7		dtcSettingsResult
#	?a8		dtcSettingsResult
# static FUNC(void, DCM_CODE) ClearDtcInformation(P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         12093,29
#$$ld
.L3563:

#$$bf	ClearDtcInformation,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ClearDtcInformation:
.Llo400:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r3,r4		# groupOfDtc=r3 groupOfDtc=r4
.Llo401:
	mr		r4,r5		# dtcFormat=r4 dtcFormat=r5
.Llo410:
	mr		r30,r6		# clearMemoryErrorCode=r30 clearMemoryErrorCode=r6
	mr		r29,r7		# pErrorCode=r29 pErrorCode=r7
	.d2prologue_end
#                                                 CONST(uint32, AUTOMATIC) groupOfDtc, CONST(Dem_DTCFormatType, AUTOMATIC) dtcFormat,
#                                                 CONST(Dcm_NegativeResponseCodeType, AUTOMATIC) clearMemoryErrorCode,
#                                                 CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(Dem_ReturnClearDTCType, AUTOMATIC) Status = Dem_DcmClearDTC(groupOfDtc, dtcFormat, DEM_DTC_ORIGIN_PRIMARY_MEMORY /* [SWS_Dcm_00005] [SWS_Dcm_00004] */);
	.d2line		12098
	rlwinm		r4,r4,0,24,31		# dtcFormat=r4 dtcFormat=r4
.Llo411:
	mr		r3,r3		# groupOfDtc=r3 groupOfDtc=r3
.Llo412:
	diab.li		r5,1
.Llo413:
	bl		Dem_DcmClearDTC
.Llo414:
	mr		r6,r3		# Status=r6 Status=r3
# 
#    switch (Status)
	.d2line		12100
	rlwinm		r6,r6,0,24,31		# Status=r6 Status=r6
	se_cmpi		r6,4		# Status=r6
	bc		1,1,.L3579	# gt
.Llo402:
	bc		1,2,.L2493	# eq
.Llo415:
	se_cmpi		r6,0		# Status=r6
	bc		1,2,.L2489	# eq
	se_cmpi		r6,3		# Status=r6
	bc		1,2,.L2492	# eq
.Llo403:
	b		.L2495
.L3579:
.Llo404:
	se_cmpi		r6,5		# Status=r6
	bc		1,2,.L2492	# eq
.Llo405:
	se_cmpi		r6,6		# Status=r6
	bc		1,2,.L2494	# eq
.Llo418:
	b		.L2495
.L2489:
#    {
#       case DEM_CLEAR_OK: /* [SWS_Dcm_00705] [SWS_Dcm_00413] */
#          {
#             /*
#                * Prepare positive response
#                */
#             pMsgContext->resDataLen = 0;
	.d2line		12107
.Llo406:
	diab.li		r0,0
	sth		r0,12(r31)		# pMsgContext=r31
	b		.L2488
.L2492:
#             break;
#          }
# 
#       case DEM_CLEAR_FAILED: /* [SWS_Dcm_00707] [SWS_Dcm_00704] */
#       case DEM_CLEAR_BUSY:   /* [SWS_Dcm_00966] [SWS_Dcm_00967] */
#          {
#             /*
#                * The clear operation failed or was busy for some reason.
#                */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		12117
.Llo407:
	diab.li		r0,34
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2488
.L2493:
#             break;
#          }
# 
#       case DEM_CLEAR_PENDING: /* [SWS_Dcm_00706] [SWS_Dcm_00703] */
#          {
#             /* 
#                * Do nothing and try later. DSL will take care of any possible NRC 0x78
#                */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		12126
.Llo408:
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L2488
.L2494:
#             break;
#          }
# 
#       case DEM_CLEAR_MEMORY_ERROR: /* [SWS_Dcm_01060] [SWS_Dcm_01067] */
#          {
#             /*
#                * The clear operation failed for some reason.
#                */
#             *pErrorCode = clearMemoryErrorCode;
	.d2line		12135
.Llo409:
	stb		r30,0(r29)		# pErrorCode=r29 clearMemoryErrorCode=r30
	b		.L2488
.L2495:
#             break;
#          }
# 
#       default:
#          {
#             /*
#                * All other type of faults will end up here including
#                *   DEM_CLEAR_WRONG_DTC (only for UDS) [SWS_Dcm_00708]
#                *   DEM_CLEAR_WRONG_DTCORIGIN (shall never happen in production)
#                */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12146
.Llo416:
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
.L2488:
#             break;
#          }
#    }
# }
	.d2line		12150
	.d2epilogue_begin
.Llo417:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3564:
	.type		ClearDtcInformation,@function
	.size		ClearDtcInformation,.-ClearDtcInformation
# Number of nodes = 41

# Allocations for ClearDtcInformation
#	?a4		pMsgContext
#	?a5		groupOfDtc
#	?a6		dtcFormat
#	?a7		clearMemoryErrorCode
#	?a8		pErrorCode
#	?a9		Status
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ClearDiagnosticInformation(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         3215,32
#$$ld
.L3582:

#$$bf	Dcm_ClearDiagnosticInformation,interprocedural,rasave,nostackparams
	.globl		Dcm_ClearDiagnosticInformation
	.d2_cfa_start __cie
Dcm_ClearDiagnosticInformation:
.Llo419:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# OpStatus=r3 OpStatus=r3
	mr		r4,r4		# pMsgContext=r4 pMsgContext=r4
	mr		r31,r5		# pErrorCode=r31 pErrorCode=r5
	.d2prologue_end
# {
#    if (DCM_CANCEL == OpStatus)
	.d2line		3217
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
	se_cmpi		r3,2		# OpStatus=r3
	bc		1,2,.L821	# eq
#    {
#       /*
#        * It's currently not possible to cancel Dem operations.
#        * Thus immediately return OK.
#        */
#    }
#    else if (3 != pMsgContext->reqDataLen)
	.d2line		3224
.Llo420:
	lhz		r0,4(r4)		# pMsgContext=r4
.Llo426:
	se_cmpi		r0,3
	bc		1,2,.L822	# eq
#    {
#       /*
#        * The length of the request is not correct.
#        */
# 
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		3230
	diab.li		r0,19
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L821
.L822:
	.section	.text_vle
.L3588:
#    }
#    else
#    {
#       /*
#        * [SWS_Dcm_00005]
#        * Fetch the requested DTC group from the request 
#        */
#       CONST(uint32, AUTOMATIC) groupOfDTC = CONVERT_BE_TO_U32(&pMsgContext->reqData[0]);
	.d2line		3238
	lwz		r3,0(r4)		# OpStatus=r3 pMsgContext=r4
.Llo421:
	lbz		r5,0(r3)		# OpStatus=r3
	rlwinm		r5,r5,16,8,15
	lbz		r0,1(r3)		# OpStatus=r3
	se_slwi		r0,8
	or		r5,r5,r0
	lbz		r3,2(r3)		# OpStatus=r3 OpStatus=r3
	or		r0,r5,r3		# OpStatus=r3
	rlwinm		r0,r0,0,8,31
.Llo429:
	mr		r0,r0		# groupOfDTC=r0 groupOfDTC=r0
#       ClearDtcInformation(pMsgContext,
	.d2line		3239
	mr		r3,r4		# pMsgContext=r3 pMsgContext=r4
.Llo422:
	mr		r4,r0		# groupOfDTC=r4 groupOfDTC=r0
.Llo423:
	mr		r7,r31		# pErrorCode=r7 pErrorCode=r31
	diab.li		r5,11
	diab.li		r6,114
	bl		ClearDtcInformation
	.section	.text_vle
.L3589:
.L821:
#                           groupOfDTC,
#                           DEM_DTC_FORMAT_UDS, /* [SWS_Dcm_00005] */
#                           DCM_E_GENERALPROGRAMMINGFAILURE, /* [SWS_Dcm_01060] */
#                           pErrorCode);
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		3246
.Llo427:
	lbz		r3,0(r31)		# OpStatus=r3 pErrorCode=r31
.Llo428:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo424:
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
# }
	.d2line		3247
	.d2epilogue_begin
.Llo425:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3583:
	.type		Dcm_ClearDiagnosticInformation,@function
	.size		Dcm_ClearDiagnosticInformation,.-Dcm_ClearDiagnosticInformation
# Number of nodes = 61

# Allocations for Dcm_ClearDiagnosticInformation
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		groupOfDTC
# static FUNC(Dem_DTCSeverityType, DCM_CODE) GetSeverityType(CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
	.align		1
	.section	.text_vle
        .d2line         7094,44
#$$ld
.L3596:

#$$bf	GetSeverityType,interprocedural,nostackparams

# Regs written: r0,r1,r3,r6,cr0,lr
	.d2_cfa_start __cie
GetSeverityType:
.Llo430:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
	.d2prologue_end
# {
#    Dem_DTCSeverityType RetValue;
# 
#    if ( (DCM_S19_SF07_NUMBEROFDTCBYSEVERITYMASKRECORD == pMsgContext->subServiceId) ||
	.d2line		7098
	lbz		r0,26(r3)		# pMsgContext=r3
	se_cmpi		r0,7
	bc		1,2,.L1637	# eq
	lbz		r0,26(r3)		# pMsgContext=r3
	se_cmpi		r0,8
	bc		0,2,.L1630	# ne
.L1637:
#         (DCM_S19_SF08_DTCBYSEVERITYMASKRECORD         == pMsgContext->subServiceId) )
#    {
#       switch (pMsgContext->reqData[1] & 0xE0U)
	.d2line		7101
	lwz		r3,0(r3)		# pMsgContext=r3 pMsgContext=r3
	lbz		r6,1(r3)		# pMsgContext=r3
	rlwinm		r6,r6,0,24,26
	cmpi		0,0,r6,32
	bc		1,2,.L1631	# eq
.Llo431:
	cmpi		0,0,r6,64
	bc		1,2,.L1633	# eq
	cmpi		0,0,r6,128
	bc		1,2,.L1634	# eq
	b		.L1635
.L1631:
#       {
#          case 0x20U:
#          {
#             RetValue = DEM_SEVERITY_MAINTENANCE_ONLY;
	.d2line		7105
	diab.li		r3,32		# RetValue=r3
.Llo432:
	b		.L1636
.L1633:
#             break;
#          }
#          case 0x40U:
#          {
#             RetValue = DEM_SEVERITY_CHECK_AT_NEXT_HALT;
	.d2line		7110
.Llo433:
	diab.li		r3,64		# RetValue=r3
.Llo434:
	b		.L1636
.L1634:
#             break;
#          }
#          case 0x80U:
#          {
#             RetValue = DEM_SEVERITY_CHECK_IMMEDIATELY;
	.d2line		7115
.Llo435:
	diab.li		r3,128		# RetValue=r3
.Llo436:
	b		.L1636
.L1635:
#             break;
#          }
#          default:
#          {
#             RetValue = DEM_SEVERITY_NO_SEVERITY;
	.d2line		7120
.Llo437:
	diab.li		r3,0		# RetValue=r3
.Llo438:
	b		.L1636
.L1630:
#             break;
#          }
#       }
#    }
#    else
#    {
#       RetValue = DEM_SEVERITY_NO_SEVERITY;
	.d2line		7127
.Llo439:
	diab.li		r3,0		# RetValue=r3
.L1636:
#    }
# 
#    return RetValue;
	.d2line		7130
.Llo440:
	rlwinm		r3,r3,0,24,31		# RetValue=r3 RetValue=r3
# }
	.d2line		7131
	.d2epilogue_begin
.Llo441:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3597:
	.type		GetSeverityType,@function
	.size		GetSeverityType,.-GetSeverityType
# Number of nodes = 44

# Allocations for GetSeverityType
#	?a4		pMsgContext
#	?a5		RetValue
# static FUNC(Dem_DTCOriginType, DCM_CODE) GetDTCOriginReadDTCInformation(CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
	.align		1
	.section	.text_vle
        .d2line         8258,42
#$$ld
.L3606:

#$$bf	GetDTCOriginReadDTCInformation,interprocedural,nostackparams

# Regs written: r0,r1,r3,r6,r7,cr0,lr,ctr
	.d2_cfa_start __cie
GetDTCOriginReadDTCInformation:
.Llo442:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
	.d2prologue_end
# {
#    Dem_DTCOriginType retVal;
# 
#    switch (pMsgContext->subServiceId)
	.d2line		8262
	lbz		r6,26(r3)		# pMsgContext=r3
	se_cmpli	r6,25
	se_slwi		r6,2
	e_add2is		r6,.L3613@ha
	bc		1,1,.L1913	# gt
	lwz		r7,.L3613@l(r6)
	mtspr		ctr,r7
	bcctr		20,0
.L3613:
#$$sl
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1892
	.long		.L1892
	.long		.L1892
	.long		.L1913
	.long		.L1913
	.long		.L1913
	.long		.L1894
	.long		.L1913
	.long		.L1895
	.long		.L1897
	.long		.L1897
#$$se
.L1892:
#    {
#       case DCM_S19_SF0F_MIRRORMEMORYDTCBYSTATUSMASK:                  /* Intentional fall through */
#       case DCM_S19_SF10_MIRRORMEMORYDTCEXTENDEDDATARECORDBYDTCNUMBER:
#       case DCM_S19_SF11_NUMBEROFMIRRORMEMORYDTCBYSTATUSMASK:
#       {
#          retVal =  DEM_DTC_ORIGIN_MIRROR_MEMORY;
	.d2line		8268
.Llo443:
	diab.li		r3,2		# retVal=r3
.Llo448:
	b		.L1893
.L1894:
#          break;
#       }
# 
#       case DCM_S19_SF15_DTCWITHPERMANENTSTATUS:
#       {
#          retVal =  DEM_DTC_ORIGIN_PERMANENT_MEMORY;
	.d2line		8274
.Llo449:
	diab.li		r3,3		# retVal=r3
.Llo450:
	b		.L1893
.L1895:
#          break;
#       }
# 
#       case DCM_S19_SF17_USERDEFMEMORYDTCBYSTATUSMASK:
#       {
#          /*
#          * Index 2 because according to ISO spec it is in byte #4
#          * but reqData does not hold the serviceId and is indexed from 0.
#          * (not 1 as in the ISO spec)
#          */
#          retVal =  (Dem_DTCOriginType)pMsgContext->reqData[2];
	.d2line		8285
.Llo444:
	lwz		r3,0(r3)		# pMsgContext=r3 pMsgContext=r3
	lbz		r3,2(r3)		# pMsgContext=r3 pMsgContext=r3
.Llo445:
	mr		r3,r3		# retVal=r3 retVal=r3
	b		.L1893
.L1897:
#          break;
#       }
# 
#       case DCM_S19_SF18_USERDEFMEMORYDTCSNAPSHOTRECORDBYDTCNUMBER: /* Intentional fall through */
#       case DCM_S19_SF19_USERDEFMEMORYDTCEXTDATARECORDBYDTCNUMBER:
#       {
#          /* 
#           * Index 5 because according to ISO spec it is in byte #7,
#           * but reqData does not hold the serviceId and is indexed from 0.
#           * (not 1 as in the ISO spec)
#           */
#          retVal =  (Dem_DTCOriginType)pMsgContext->reqData[5];
	.d2line		8297
.Llo446:
	lwz		r3,0(r3)		# pMsgContext=r3 pMsgContext=r3
	lbz		r3,5(r3)		# pMsgContext=r3 pMsgContext=r3
.Llo447:
	mr		r3,r3		# retVal=r3 retVal=r3
	b		.L1893
.L1913:
#          break;
#       }
# 
#       case DCM_S19_SF01_NUMBEROFDTCBYSTATUSMASK:                    /* Intentional fall through */
#       case DCM_S19_SF02_DTCBYSTATUSMASK:                            /* Intentional fall through */
#       case DCM_S19_SF04_DTCSNAPSHOTRECORDBYDTCNUMBER:               /* Intentional fall through */
#       case DCM_S19_SF05_DTCSNAPSHOTRECORDBYRECORDNUMBER:            /* Intentional fall through */ /* [SWS_Dcm_00388] [SWS_Dcm_00389] */
#       case DCM_S19_SF06_DTCEXTENDEDDATARECORDBYDTCNUMBER:           /* Intentional fall through */
#       case DCM_S19_SF07_NUMBEROFDTCBYSEVERITYMASKRECORD:            /* Intentional fall through */
#       case DCM_S19_SF09_SEVERITYINFORMATIONOFDTC:                   /* Intentional fall through */
#       case DCM_S19_SF0A_SUPPORTEDDTCS:                              /* Intentional fall through */
#       case DCM_S19_SF0B_FIRSTTESTFAILEDDTC:                         /* Intentional fall through */
#       case DCM_S19_SF0C_FIRSTCONFIRMEDDTC:                          /* Intentional fall through */
#       case DCM_S19_SF0D_MOSTRECENTTESTFAILEDDTC:                    /* Intentional fall through */
#       case DCM_S19_SF0E_MOSTRECENTCONFIRMEDDTC:                     /* Intentional fall through */
#       case DCM_S19_SF12_NUMBEROFEMISSIONSRELATEDOBDDTCBYSTATUSMASK: /* Intentional fall through */
#       case DCM_S19_SF13_EMISSIONSRELATEDOBDDTCBYSTATUSMASK:         /* Intentional fall through */
#       case DCM_S19_SF14_DTCFAULTDETECTIONCOUNTER:                   /* Intentional fall through */
#       default:
#       {
#          /*
#           * If this function is called in the following sub function context,
#           * a safe vale will be returned:
#           * 0x03 D/C (DCM_S19_SUBFN_REPORTDTCSNAPSHOTIDENTIFICATION)
#           * 0x08 D/C (DCM_S19_SUBFN_REPORTDTCBYSEVERITYMASKRECORD)
#           * 0x16 Not supported
#           */
#          retVal = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
	.d2line		8325
.Llo451:
	diab.li		r3,1		# retVal=r3
.L1893:
#          break;
#       }
#    }
# 
#    return retVal;
	.d2line		8330
.Llo452:
	rlwinm		r3,r3,0,24,31		# retVal=r3 retVal=r3
# }
	.d2line		8331
	.d2epilogue_begin
.Llo453:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3607:
	.type		GetDTCOriginReadDTCInformation,@function
	.size		GetDTCOriginReadDTCInformation,.-GetDTCOriginReadDTCInformation
# Number of nodes = 35

# Allocations for GetDTCOriginReadDTCInformation
#	?a4		pMsgContext
#	?a5		retVal
# static FUNC(void, DCM_CODE) ReportNumberOfDTCsByStatusMask(
	.align		1
	.section	.text_vle
        .d2line         7137,29
#$$ld
.L3616:

#$$bf	ReportNumberOfDTCsByStatusMask,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportNumberOfDTCsByStatusMask:
.Llo454:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r30,r4		# DtcKind=r30 DtcKind=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
#                                  P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                  Dem_DTCKindType            DtcKind,
#                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint16                               NumOfDtc;
#    Dem_UdsStatusByteType                DtcStatusMask;
#    Dem_UdsStatusByteType                StatusAvailabilityMask;
#    Dem_ReturnGetNumberOfFilteredDTCType Status;
#    boolean                              FilterWithSeverity = FALSE;
	.d2line		7146
	diab.li		r28,0		# FilterWithSeverity=r28
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		7148
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo455:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1646	# ne
#    {
#       if (E_OK != Dem_DcmGetDTCStatusAvailabilityMask(&StatusAvailabilityMask)) /* E_OK, E_NOT_OK Synchronous*/
	.d2line		7150
.Llo456:
	diab.addi		r3,r1,8
.Llo458:
	bl		Dem_DcmGetDTCStatusAvailabilityMask
	e_andi.		r3,r3,255
	bc		1,2,.L1647	# eq
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7152
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1646
.L1647:
#       }
#       else
#       {
#          /*
#             * Subfunction 0x07 (reportNumberOfDTCBySeverityMaskRecord) has a severity mask before the status mask
#             */
#          if (DCM_S19_SF07_NUMBEROFDTCBYSEVERITYMASKRECORD == pMsgContext->subServiceId)
	.d2line		7159
	lbz		r0,26(r31)		# pMsgContext=r31
	se_cmpi		r0,7
	bc		0,2,.L1649	# ne
#          {
#             DtcStatusMask = (Dem_UdsStatusByteType)(pMsgContext->reqData[2] & (Dcm_MsgItemType)StatusAvailabilityMask);
	.d2line		7161
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r4,2(r3)
	lbz		r0,8(r1)
	and		r0,r0,r4
.Llo467:
	mr		r4,r0		# DtcStatusMask=r4 DtcStatusMask=r0
#             FilterWithSeverity = TRUE;
	.d2line		7162
	diab.li		r28,1		# FilterWithSeverity=r28
	b		.L1650
.L1649:
#          }
#          else
#          {
#             DtcStatusMask = (Dem_UdsStatusByteType)(pMsgContext->reqData[1] & (Dcm_MsgItemType)StatusAvailabilityMask);
	.d2line		7166
.Llo468:
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r4,1(r3)
	lbz		r0,8(r1)
	and		r0,r0,r4
.Llo469:
	mr		r4,r0		# DtcStatusMask=r4 DtcStatusMask=r0
.L1650:
#          }
# 
#          /*
#             * [SWS_Dcm_00700]: If the the DtcStatusMask is 0x00, the DCM shall respond
#             * with an empty positive response
#             */
#          if (0x00 == DtcStatusMask)
	.d2line		7173
.Llo470:
	rlwinm		r3,r4,0,24,31		# DtcStatusMask=r4
.Llo471:
	se_cmpi		r3,0
	bc		0,2,.L1651	# ne
#          {
#             pMsgContext->resData[0] = pMsgContext->subServiceId;
	.d2line		7175
	lbz		r0,26(r31)		# pMsgContext=r31
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,0(r3)
#             pMsgContext->resData[1] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		7176
	lbz		r0,8(r1)
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,1(r3)
#             pMsgContext->resDataLen = 2;
	.d2line		7177
	diab.li		r0,2
	sth		r0,12(r31)		# pMsgContext=r31
	b		.L1646
.L1651:
#          }
#          else if (DEM_FILTER_ACCEPTED == Dem_DcmSetDTCFilter(DtcStatusMask,
	.d2line		7179
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetSeverityType
	mr		r5,r3		# pMsgContext=r5
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetDTCOriginReadDTCInformation
	mr		r6,r3		# pMsgContext=r6
	rlwinm		r3,r4,0,24,31		# pMsgContext=r3 DtcStatusMask=r4
	rlwinm		r4,r30,0,24,31		# DtcStatusMask=r4 DtcKind=r30
.Llo472:
	rlwinm		r6,r6,0,24,31		# pMsgContext=r6 pMsgContext=r6
	rlwinm		r7,r28,0,24,31		# FilterWithSeverity=r28
	rlwinm		r8,r5,0,24,31		# pMsgContext=r5
	diab.li		r5,11		# pMsgContext=r5
	diab.li		r9,0
	bl		Dem_DcmSetDTCFilter
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		0,2,.L1653	# ne
#             DtcKind,
#             DEM_DTC_FORMAT_UDS,
#             GetDTCOriginReadDTCInformation(pMsgContext),
#             FilterWithSeverity,
#             GetSeverityType(pMsgContext),
#             FALSE)) /* DEM_FILTER_ACCEPTED DEM_WRONG_FILTER Synchronous*/
#          {
#             /*
#                * fill the subfunction id and the StatusAvailabilityMask in the response buffer
#                */
#             pMsgContext->resData[0] = pMsgContext->subServiceId;
	.d2line		7190
.Llo459:
	lbz		r0,26(r31)		# pMsgContext=r31
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,0(r3)		# pMsgContext=r3
#             pMsgContext->resData[1] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		7191
	lbz		r0,8(r1)
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,1(r3)		# pMsgContext=r3
# 
#             /*  The total answersize is always 5 for this subfunction:
#                *  1 byte for the subfunction ID
#                *  1 byte for the StatusAvailabilityMask
#                *  1 byte for DTCFormatId
#                *  2 bytes for the number of DTCs
#                */
#             pMsgContext->resDataLen = DCM_REPORTNUMBERROFDTCBYSTATMASK_ANSWERSIZE;
	.d2line		7199
	diab.li		r0,5
	sth		r0,12(r31)		# pMsgContext=r31
# 
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		7201
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3
	b		.L1646
.L1653:
#          }
#          else
#          {
#             /*
#                * The following was returned:
#                *     DEM_WRONG_FILTER
#                */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7209
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
.L1646:
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		7214
.Llo460:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3
	se_cmpi		r0,1
	bc		0,2,.L1645	# ne
#    {
#       /* The DTC filter is already set, so now just fetch the number of DTC that matched the filter */
#       Status = Dem_DcmGetNumberOfFilteredDTC(&NumOfDtc); /* Asynchronous DEM_NUMBER_OK, DEM_NUMBER_FAILED, DEM_NUMBER_PENDING */
	.d2line		7217
.Llo461:
	diab.addi		r3,r1,10		# pMsgContext=r3
.Llo462:
	bl		Dem_DcmGetNumberOfFilteredDTC
.Llo463:
	mr		r3,r3		# Status=r3 Status=r3
#       if (DEM_NUMBER_OK == Status )
	.d2line		7218
	rlwinm		r0,r3,0,24,31		# Status=r3
	se_cmpi		r0,0
	bc		0,2,.L1656	# ne
#       {
#          /*
#             * The return value of Dem_DcmGetTranslationType() - Dem_DTCTranslationFormatType - is
#             * currently defined as an uint8. Therefore is a typecast safe.
#             */
#          pMsgContext->resData[2] = (uint8)Dem_DcmGetTranslationType();
	.d2line		7224
.Llo475:
	bl		Dem_DcmGetTranslationType
	lwz		r4,8(r31)		# DtcStatusMask=r4 pMsgContext=r31
.Llo473:
	stb		r3,2(r4)		# DtcStatusMask=r4 pMsgContext=r3
#          pMsgContext->resData[3] = DcmHiByte(NumOfDtc);
	.d2line		7225
	lhz		r0,10(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,3(r3)		# pMsgContext=r3
#          pMsgContext->resData[4] = DcmLoByte(NumOfDtc);
	.d2line		7226
	lbz		r0,11(r1)
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,4(r3)		# pMsgContext=r3
	b		.L1645
.L1656:
#       }
#       else if (DEM_NUMBER_FAILED == Status)
	.d2line		7228
.Llo474:
	rlwinm		r3,r3,0,24,31		# Status=r3 Status=r3
	se_cmpi		r3,1		# Status=r3
	bc		0,2,.L1658	# ne
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7230
.Llo457:
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1645
.L1658:
#       }
#       else
#       {
#          /* Pending, do nothing */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		7235
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
.L1645:
#       }
#    }
# }
	.d2line		7238
	.d2epilogue_begin
.Llo464:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
.Llo466:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo465:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3617:
	.type		ReportNumberOfDTCsByStatusMask,@function
	.size		ReportNumberOfDTCsByStatusMask,.-ReportNumberOfDTCsByStatusMask
# Number of nodes = 224

# Allocations for ReportNumberOfDTCsByStatusMask
#	?a4		pMsgContext
#	?a5		DtcKind
#	?a6		pErrorCode
#	?a7		$$45
#	?a8		$$44
#	SP,10		NumOfDtc
#	?a9		DtcStatusMask
#	SP,8		StatusAvailabilityMask
#	?a10		Status
#	?a11		FilterWithSeverity
# static FUNC(void,DCM_CODE) ReportDTCFaultDetectionCounter(
	.align		1
	.section	.text_vle
        .d2line         7243,28
#$$ld
.L3635:

#$$bf	ReportDTCFaultDetectionCounter,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCFaultDetectionCounter:
.Llo476:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r28,32(r1)		# offset r1+32  0x20
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r4,r4		# DtcKind=r4 DtcKind=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
#                                        CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA)pMsgContext,
#                                        Dem_DTCKindType               DtcKind,
#                                        CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    boolean                          GetNextDtc = TRUE;
	.d2line		7248
	diab.li		r29,1		# GetNextDtc=r29
#    uint16                           NumberOfDtc = 0;
	.d2line		7249
.Llo488:
	diab.li		r28,0
.Llo500:
	sth		r28,10(r1)
#    Dcm_MsgLenType                   TotalAnswerSize = 0;
# 
#    Std_ReturnType           getBufferRes = E_OK;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  resBuffer;
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		7255
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo477:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1670	# ne
#    {
#       if (DEM_FILTER_ACCEPTED != Dem_DcmSetDTCFilter((Dem_UdsStatusByteType)0x00U,
	.d2line		7257
.Llo478:
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
.Llo484:
	bl		GetDTCOriginReadDTCInformation
	rlwinm		r6,r3,0,24,31
.Llo482:
	rlwinm		r4,r4,0,24,31		# DtcKind=r4 DtcKind=r4
.Llo483:
	diab.li		r3,0
	diab.li		r5,11
	diab.li		r7,0
	mr		r8,r3
	diab.li		r9,1
	bl		Dem_DcmSetDTCFilter
	e_andi.		r3,r3,255
	bc		1,2,.L1671	# eq
#                                                    DtcKind,
#                                                    DEM_DTC_FORMAT_UDS,
#                                                    GetDTCOriginReadDTCInformation(pMsgContext),
#                                                    FALSE,
#                                                    DEM_SEVERITY_NO_SEVERITY,
#                                                    TRUE))
#       {
#          /*
#             * The following was returned:
#             *     DEM_WRONG_FILTER
#             */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7269
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1670
.L1671:
#       }
#       else if (DEM_NUMBER_OK != Dem_DcmGetNumberOfFilteredDTC(&NumberOfDtc))
	.d2line		7271
	diab.addi		r3,r1,10
	bl		Dem_DcmGetNumberOfFilteredDTC
	e_andi.		r3,r3,255
	bc		1,2,.L1673	# eq
#       {
#          /*
#             * The following were returned:
#             *     DEM_NUMBER_FAILED
#             *     DEM_NUMBER_PENDING
#             */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7278
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1670
.L1673:
#       }
#       else
#       {
#          /*
#             * Every DTC includes 4 bytes of data. Plus byte for subfunction ID
#             */
#          TotalAnswerSize = ((NumberOfDtc) * (DCM_REPORT_DTC_FAULT_DETECTION_COUNTER)) + 1U;
	.d2line		7285
	lhz		r3,10(r1)		# TotalAnswerSize=r3
.Llo493:
	se_slwi		r3,2		# TotalAnswerSize=r3 TotalAnswerSize=r3
	se_addi		r3,1		# TotalAnswerSize=r3 TotalAnswerSize=r3
	.d2line		7290
	rlwinm		r3,r3,0,16,31		# TotalAnswerSize=r3 TotalAnswerSize=r3
# 
#          /*
#             * Start response
#             */
#          if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(TotalAnswerSize))
.Llo494:
	bl		Dcm_DsdStartResponse
.Llo495:
	rlwinm		r3,r3,0,24,31		# TotalAnswerSize=r3 TotalAnswerSize=r3
	cmpi		0,0,r3,200		# TotalAnswerSize=r3
	bc		0,2,.L1675	# ne
#          {
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7292
.Llo496:
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1670
.L1675:
#          }
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer will never return anything else than E_OK
#              *
#              * MISRA-C:2004 RULE 16.10 VIOLATION:
#              * If a function returns error information, then that error information shall be tested.
#              * Since the request is always two bytes and that will fit into the minimum
#              * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#              */
#             (void)Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)1U, &resBuffer);
	.d2line		7304
	diab.addi		r4,r1,12		# DtcKind=r4
	diab.li		r3,1		# TotalAnswerSize=r3
	bl		Dcm_DsdRequestResponseBuffer
# 
#             /*
#                * Fill in mandatory response data
#                */
#             resBuffer[0] = pMsgContext->subServiceId;
	.d2line		7309
	lbz		r0,26(r31)		# pMsgContext=r31
	lwz		r3,12(r1)		# TotalAnswerSize=r3
.Llo497:
	stb		r0,0(r3)		# TotalAnswerSize=r3
# 
#             if (0 != NumberOfDtc)
	.d2line		7311
	lhz		r0,10(r1)
	se_cmpi		r0,0
	bc		1,2,.L1670	# eq
#             {
#                Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		7313
.Llo479:
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+8)@ha		# TotalAnswerSize=r3
.Llo498:
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# TotalAnswerSize=r3
.L1670:
#             }
#             else
#             {
#                /*
#                 * No Dtc available, just send a positive response.
#                 */
#             }
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		7325
.Llo480:
	lis		r3,(Dcm_DspInstance+8)@ha		# TotalAnswerSize=r3
.Llo499:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# TotalAnswerSize=r3
	se_cmpi		r0,1
	bc		0,2,.L1669	# ne
.L1680:
#    {
#       while ((TRUE == GetNextDtc) && (E_OK == getBufferRes))
	.d2line		7327
.Llo481:
	rlwinm		r0,r29,0,24,31		# GetNextDtc=r29
	se_cmpi		r0,1
	bc		0,2,.L1669	# ne
	rlwinm		r28,r28,0,24,31		# getBufferRes=r28 getBufferRes=r28
	se_cmpi		r28,0		# getBufferRes=r28
	bc		0,2,.L1669	# ne
#       {
#          getBufferRes =  Dcm_DsdRequestResponseBuffer(DCM_REPORT_DTC_BY_STATUSMASK_ANSWERSIZE, &resBuffer);
	.d2line		7329
.Llo501:
	diab.addi		r4,r1,12		# DtcKind=r4
	diab.li		r3,4		# TotalAnswerSize=r3
	bl		Dcm_DsdRequestResponseBuffer
.Llo502:
	mr		r28,r3		# getBufferRes=r28 getBufferRes=r3
# 
#          if (E_OK == getBufferRes)
	.d2line		7331
	rlwinm		r3,r3,0,24,31		# getBufferRes=r3 getBufferRes=r3
	se_cmpi		r3,0		# getBufferRes=r3
	bc		0,2,.L1682	# ne
	.section	.text_vle
.L3649:
#          {
#             uint32 Dtc;
#             sint8 DtcFDC;
#             CONST(Dem_ReturnGetNextFilteredElementType, AUTOMATIC) Status = Dem_DcmGetNextFilteredDTCAndFDC(&Dtc, &DtcFDC);
	.d2line		7335
.Llo503:
	diab.addi		r3,r1,16		# getBufferRes=r3
.Llo504:
	diab.addi		r4,r1,8		# DtcKind=r4
	bl		Dem_DcmGetNextFilteredDTCAndFDC
.Llo505:
	mr		r6,r3		# Status=r6 Status=r3
# 
#             switch (Status)
	.d2line		7337
	rlwinm		r6,r6,0,24,31		# Status=r6 Status=r6
	se_cmpi		r6,0		# Status=r6
	bc		1,2,.L1685	# eq
.Llo506:
	se_cmpi		r6,1		# Status=r6
.Llo507:
	bc		1,2,.L1683	# eq
.Llo489:
	b		.L1687
.L1683:
#             {
#                case DEM_FILTERED_NO_MATCHING_ELEMENT:
#                {
#                   /*
#                    * All matching dtcs were successfully received.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DSD will handle the freed buffer.
#                    */
#                   GetNextDtc = FALSE;
	.d2line		7347
	diab.li		r29,0		# GetNextDtc=r29
#                   Dcm_DsdReleaseResponseBuffer(DCM_REPORT_DTC_FAULT_DETECTION_COUNTER);
	.d2line		7348
.Llo490:
	diab.li		r3,4		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L1680
.L1685:
#                   break;
#                }
# 
#                case DEM_FILTERED_OK:
#                {
#                   SET_RESPONSE_DTC(&resBuffer[0], Dtc);
	.d2line		7354
.Llo508:
	lwz		r0,16(r1)
	rlwinm		r0,r0,16,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,0(r3)		# getBufferRes=r3
	lhz		r0,18(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,1(r3)		# getBufferRes=r3
	lbz		r0,19(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,2(r3)		# getBufferRes=r3
#                   /*
#                    * DtcFDC is type of Dem_FaultDetectionCounterType which has type sint8.
#                    * If DtcFDC < 0, resBuffer[3] if filled with (UINT_MAX + 1 + DtcFDC).
#                    * If DtcFDC >= 0, resBuffer[3] is filled with DtcFDC.
#                    */
#                   resBuffer[3] = (uint8)DtcFDC;
	.d2line		7360
	lbz		r0,8(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,3(r3)		# getBufferRes=r3
	b		.L1680
.L1687:
#                   break;
#                }
# 
#                default:
#                {
#                   /*
#                    * All other type of faults will end up here.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DsD will handle the freed buffer.
#                    */
#                   Dcm_DsdReleaseResponseBuffer(DCM_REPORT_DTC_FAULT_DETECTION_COUNTER);
	.d2line		7372
.Llo491:
	diab.li		r3,4		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                   *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7373
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
#                   GetNextDtc = FALSE;
	.d2line		7374
	diab.li		r29,0		# GetNextDtc=r29
.Llo492:
	b		.L1680
	.section	.text_vle
.L3650:
.L1682:
#                   break;
#                }
#             }
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_PENDING == getBufferRes)
#          {
#             /*
#              * Do nothing, it will continue to read data later.
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#          }
#          else if (DCM_INT_E_RESPONSE_FULL == getBufferRes)
#          {
#             /*
#              * The whole length of the originally calculated response length has been filled.
#              */
#          }
#          else if (E_NOT_OK == getBufferRes)
#          {
#             /*
#              * Abort, make sense to retrieve the data.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
#          }
# #endif
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer returned
#              *  DCM_INT_E_RESPONSE_TOO_LONG
#              *
#              * Abort, requested size can't possible fit in buffer.
#              */
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7409
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1680
.L1669:
#          }
# 
#       }/* while */
#    }
# }
	.d2line		7414
	.d2epilogue_begin
.Llo485:
	lmw		r28,32(r1)		# offset r1+32  0x20
	.d2_cfa_restore_list	3,10
.Llo486:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo487:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3636:
	.type		ReportDTCFaultDetectionCounter,@function
	.size		ReportDTCFaultDetectionCounter,.-ReportDTCFaultDetectionCounter
# Number of nodes = 221

# Allocations for ReportDTCFaultDetectionCounter
#	?a4		pMsgContext
#	?a5		DtcKind
#	?a6		pErrorCode
#	?a7		$$46
#	?a8		GetNextDtc
#	SP,10		NumberOfDtc
#	?a9		TotalAnswerSize
#	?a10		getBufferRes
#	SP,12		resBuffer
#	SP,16		Dtc
#	SP,8		DtcFDC
#	?a11		Status
# static FUNC(void,DCM_CODE) ReportSeverityInformationOfDTC(CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         7419,28
#$$ld
.L3663:

#$$bf	ReportSeverityInformationOfDTC,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportSeverityInformationOfDTC:
.Llo509:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r30,r4		# pErrorCode=r30 pErrorCode=r4
	.d2prologue_end
#                                                           CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Dem_UdsStatusByteType      StatusAvailabilityMask = 0;
	.d2line		7422
.Llo513:
	diab.li		r0,0
	.d2line		7425
.Llo514:
	stw		r0,8(r1)
#    uint8                      DtcFunctionalUnit = 0;
#    uint8                      DtcStatus = 0;
#    Dem_DTCSeverityType        DtcSeverity = 0;
#    CONST(uint32, DCM_CONST)   RequestedDtc = CONVERT_BE_TO_U32(&pMsgContext->reqData[1]);
	.d2line		7426
	lwz		r3,0(r31)		# pMsgContext=r31
.Llo510:
	lbz		r4,1(r3)
	rlwinm		r4,r4,16,8,15
	lbz		r0,2(r3)
	se_slwi		r0,8
	or		r4,r4,r0
	lbz		r3,3(r3)
	or		r29,r4,r3
	rlwinm		r29,r29,0,8,31
.Llo515:
	mr		r29,r29		# RequestedDtc=r29 RequestedDtc=r29
# 
#    *pErrorCode = DCM_E_REQUESTOUTOFRANGE; /* Assume error */
	.d2line		7428
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
# 
#    if (E_OK != Dem_DcmGetDTCStatusAvailabilityMask(&StatusAvailabilityMask))
	.d2line		7430
	diab.addi		r3,r1,8
	bl		Dem_DcmGetDTCStatusAvailabilityMask
	e_andi.		r3,r3,255
	bc		0,2,.L1699	# ne
#    {
#       /*
#        * Failed to get information, error response already set.
#        */
#    }
#    else if (DEM_STATUS_OK != Dem_DcmGetStatusOfDTC(RequestedDtc, GetDTCOriginReadDTCInformation(pMsgContext), &DtcStatus))
	.d2line		7436
.Llo511:
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetDTCOriginReadDTCInformation
	mr		r4,r3		# pMsgContext=r4
	rlwinm		r4,r4,0,24,31		# pMsgContext=r4 pMsgContext=r4
	diab.addi		r5,r1,10
	mr		r3,r29		# RequestedDtc=r3 RequestedDtc=r29
	bl		Dem_DcmGetStatusOfDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		0,2,.L1699	# ne
#    {
#       /*
#        * Failed to get information, error response already set.
#        */
#    }
#    else if (DEM_GET_SEVERITYOFDTC_OK != Dem_DcmGetSeverityOfDTC(RequestedDtc, &DtcSeverity))
	.d2line		7442
	diab.addi		r4,r1,11		# pMsgContext=r4
	mr		r3,r29		# RequestedDtc=r3 RequestedDtc=r29
	bl		Dem_DcmGetSeverityOfDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		0,2,.L1699	# ne
#    {
#       /*
#        * Failed to get information, error response already set.
#        */
#    }
#    else if (DEM_GET_FUNCTIONALUNITOFDTC_OK != Dem_DcmGetFunctionalUnitOfDTC(RequestedDtc, &DtcFunctionalUnit))
	.d2line		7448
	diab.addi		r4,r1,9		# pMsgContext=r4
	mr		r3,r29		# RequestedDtc=r3 RequestedDtc=r29
	bl		Dem_DcmGetFunctionalUnitOfDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		0,2,.L1699	# ne
	.section	.text_vle
.L3674:
#    {
#       /*
#        * Failed to get information, error response already set.
#        */
#    }
#    else
#    {
#       uint8 StartIndex = 0;
	.d2line		7456
	diab.li		r5,0		# StartIndex=r5
# 
#       /* Write the mandatory data */
#       pMsgContext->resData[StartIndex] = (Dcm_MsgItemType)0x09U; /* Subfunction ID */
	.d2line		7459
	diab.li		r0,9		# RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,0(r3)		# pMsgContext=r3 RequestedDtc=r0
#       StartIndex++;
	.d2line		7460
	diab.li		r0,1		# StartIndex=r0
#       pMsgContext->resData[StartIndex] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		7461
	lbz		r0,8(r1)		# RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,1(r3)		# pMsgContext=r3 RequestedDtc=r0
#       StartIndex++;
	.d2line		7462
	diab.li		r0,2		# StartIndex=r0
# 
#       pMsgContext->resData[StartIndex] = DtcSeverity;
	.d2line		7464
	lbz		r0,11(r1)		# RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,2(r3)		# pMsgContext=r3 RequestedDtc=r0
#       StartIndex++;
	.d2line		7465
	diab.li		r0,3		# StartIndex=r0
#       pMsgContext->resData[StartIndex] = DtcFunctionalUnit;
	.d2line		7466
	lbz		r0,9(r1)		# RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,3(r3)		# pMsgContext=r3 RequestedDtc=r0
#       StartIndex++;
	.d2line		7467
	diab.li		r0,4		# StartIndex=r0
#       SET_RESPONSE_DTC(&pMsgContext->resData[StartIndex], RequestedDtc);
	.d2line		7468
	rlwinm		r0,r29,16,24,31		# StartIndex=r0 RequestedDtc=r29
.Llo516:
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,4(r3)		# pMsgContext=r3 StartIndex=r0
	mr		r0,r29		# RequestedDtc=r0 RequestedDtc=r29
.Llo517:
	rlwinm		r4,r0,24,24,31		# pMsgContext=r4 RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r4,5(r3)		# pMsgContext=r3 pMsgContext=r4
	rlwinm		r0,r0,0,24,31		# RequestedDtc=r0 RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r29,6(r3)		# pMsgContext=r3 RequestedDtc=r29
#       StartIndex += 3U;
	.d2line		7469
	diab.li		r0,7		# StartIndex=r0
#       pMsgContext->resData[StartIndex] = DtcStatus;
	.d2line		7470
	lbz		r0,10(r1)		# RequestedDtc=r0
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,7(r3)		# pMsgContext=r3 RequestedDtc=r0
#       StartIndex++;
	.d2line		7471
	diab.li		r3,8		# pMsgContext=r3
# 
#       pMsgContext->resDataLen = StartIndex;
	.d2line		7473
	sth		r3,12(r31)		# pMsgContext=r31 RequestedDtc=r3
# 
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		7475
	stb		r5,0(r30)		# pErrorCode=r30 RequestedDtc=r5
	.section	.text_vle
.L3675:
.L1699:
#    }
# }
	.d2line		7477
	.d2epilogue_begin
.Llo512:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# RequestedDtc=r0
	mtspr		lr,r0		# RequestedDtc=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3664:
	.type		ReportSeverityInformationOfDTC,@function
	.size		ReportSeverityInformationOfDTC,.-ReportSeverityInformationOfDTC
# Number of nodes = 222

# Allocations for ReportSeverityInformationOfDTC
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$47
#	SP,8		StatusAvailabilityMask
#	SP,9		DtcFunctionalUnit
#	SP,10		DtcStatus
#	SP,11		DtcSeverity
#	?a7		RequestedDtc
#	?a8		StartIndex
# static FUNC(void, DCM_CODE) ReportDTCsByStatusMask(
	.align		1
	.section	.text_vle
        .d2line         7482,29
#$$ld
.L3682:

#$$bf	ReportDTCsByStatusMask,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCsByStatusMask:
.Llo518:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
	stmw		r25,36(r1)		# offset r1+36  0x24
	.d2_cfa_offset_list	25,31,1,1
	stw		r0,68(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r30,r4		# DtcKind=r30 DtcKind=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
#                                  CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                  Dem_DTCKindType              DtcKind,
#                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)                  resBuffer;
#    Std_ReturnType          getBufferRes      = E_OK;
	.d2line		7488
	diab.li		r25,0		# getBufferRes=r25
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		7490
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo519:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1711	# ne
	.section	.text_vle
.L3691:
#    {
#       Dem_UdsStatusByteType StatusAvailabilityMask;
#       if (E_OK != Dem_DcmGetDTCStatusAvailabilityMask(&StatusAvailabilityMask))
	.d2line		7493
.Llo520:
	diab.addi		r3,r1,8
.Llo532:
	bl		Dem_DcmGetDTCStatusAvailabilityMask
	e_andi.		r3,r3,255
	bc		1,2,.L1712	# eq
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7495
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1711
.L1712:
	.section	.text_vle
.L3696:
#       }
#       else
#       {
#          CONST(boolean, AUTOMATIC) subFunction0x0Aor0x15 = (boolean)((DCM_S19_SF0A_SUPPORTEDDTCS == pMsgContext->subServiceId) ||
	.d2line		7499
	lbz		r0,26(r31)		# pMsgContext=r31
	se_cmpi		r0,10
	bc		1,2,.L1740	# eq
	lbz		r0,26(r31)		# pMsgContext=r31
	se_cmpi		r0,21
	bc		1,2,.L1740	# eq
	diab.li		r0,0
.Llo543:
	b		.L1741
.L1740:
.Llo544:
	diab.li		r0,1
.L1741:
.Llo545:
	mr		r0,r0		# subFunction0x0Aor0x15=r0 subFunction0x0Aor0x15=r0
#             (DCM_S19_SF15_DTCWITHPERMANENTSTATUS == pMsgContext->subServiceId));
#          CONST(boolean, AUTOMATIC) includeMemorySelection = (boolean)(DCM_S19_SF17_USERDEFMEMORYDTCBYSTATUSMASK == pMsgContext->subServiceId);
	.d2line		7501
	lbz		r3,26(r31)		# positiveResponseHeaderSize=r3 pMsgContext=r31
.Llo576:
	xori		r3,r3,23		# positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r3
	cntlzw		r28,r3		# includeMemorySelection=r28 positiveResponseHeaderSize=r3
.Llo573:
	se_srwi		r28,5		# includeMemorySelection=r28 includeMemorySelection=r28
	mr		r28,r28		# includeMemorySelection=r28 includeMemorySelection=r28
#          CONST(Dcm_MsgLenType, AUTOMATIC) positiveResponseHeaderSize = (Dcm_MsgLenType)(includeMemorySelection ? 3U : 2U);
	.d2line		7502
	rlwinm		r3,r28,0,24,31		# positiveResponseHeaderSize=r3 includeMemorySelection=r28
	se_cmpi		r3,0		# positiveResponseHeaderSize=r3
	diab.li		r4,3		# positiveResponseHeaderSize=r4
	isel		r4,r3,r4,2		# positiveResponseHeaderSize=r4 positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r4
.L1742:
.Llo577:
	diab.li		r27,2		# positiveResponseHeaderSize=r27
.Llo578:
	isel		r27,r27,r4,2		# positiveResponseHeaderSize=r27 positiveResponseHeaderSize=r27 positiveResponseHeaderSize=r4
.L1743:
#          CONST(uint8, AUTOMATIC) memorySelection = (uint8)pMsgContext->reqData[2]; /* Assume MEMYS is available, it will not be used if not correct SF */
	.d2line		7503
.Llo579:
	lwz		r3,0(r31)		# positiveResponseHeaderSize=r3 pMsgContext=r31
.Llo580:
	lbz		r26,2(r3)		# positiveResponseHeaderSize=r3
.Llo584:
	mr		r26,r26		# memorySelection=r26 memorySelection=r26
# 
#          Dem_UdsStatusByteType DtcStatusMask;
#          uint16 NumDTC;
# 
#          /*
#             * [SWS_Dcm_00378]: Is this a subfunction 0x0A or 0x15 request?
#             * If so, the DtcStatusMask used when calling Dem_DcmSetDTCFilter shall always be zero.
#             */
#          if (subFunction0x0Aor0x15)
	.d2line		7512
	rlwinm		r3,r0,0,24,31		# positiveResponseHeaderSize=r3 subFunction0x0Aor0x15=r0
	se_cmpi		r3,0		# positiveResponseHeaderSize=r3
	bc		1,2,.L1714	# eq
#          {
#             /* Report All supported DTCs */
#             DtcStatusMask = (Dem_UdsStatusByteType)0x00U;
	.d2line		7515
	diab.li		r4,0		# DtcStatusMask=r4
.Llo585:
	b		.L1715
.L1714:
#          }
#          else
#          {
#             /* [SWS_Dcm_00008] */
#             DtcStatusMask = (Dem_UdsStatusByteType)(pMsgContext->reqData[1] & StatusAvailabilityMask);
	.d2line		7520
.Llo586:
	lwz		r3,0(r31)		# positiveResponseHeaderSize=r3 pMsgContext=r31
	lbz		r4,1(r3)		# positiveResponseHeaderSize=r4 positiveResponseHeaderSize=r3
	lbz		r3,8(r1)		# positiveResponseHeaderSize=r3
	and		r3,r3,r4		# positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r4
.Llo587:
	mr		r4,r3		# DtcStatusMask=r4 DtcStatusMask=r3
.L1715:
#          }
# 
#          /*
#           * [SWS_Dcm_00700]
#           * If the DtcStatusMask is 0x00, the DCM shall respond
#           * with an empty positive response except if the sub service was 0x0A and 0x15
#           *
#           * [SWS_Dcm_00008]
#           * If the result of the bitwise AND operation
#           * between the DTCStatusMask received within the request message and the
#           * DTCStatusAvailabilityMask reported by the DEM is equal to 0, the Dcm module shall
#           * answer positively with 0 DTC.
#           */
#          if ((0x00 == DtcStatusMask) && !subFunction0x0Aor0x15)
	.d2line		7534
.Llo588:
	rlwinm		r3,r4,0,24,31		# positiveResponseHeaderSize=r3 DtcStatusMask=r4
.Llo589:
	se_cmpi		r3,0		# positiveResponseHeaderSize=r3
	bc		0,2,.L1716	# ne
	rlwinm		r0,r0,0,24,31		# subFunction0x0Aor0x15=r0 subFunction0x0Aor0x15=r0
	se_cmpi		r0,0		# subFunction0x0Aor0x15=r0
	bc		0,2,.L1716	# ne
#          {
#             /*
#              * Dcm_DsdStartResponse and Dcm_DsdRequestResponseBuffer will never return anything
#              * else than E_OK and E_OK
#              *
#              * MISRA-C:2004 RULE 16.10 VIOLATION:
#              * If a function returns error information, then that error information shall be tested.
#              * Since the request is always two bytes and that will fit into the minimum
#              * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#              */
#             (void)Dcm_DsdStartResponse(positiveResponseHeaderSize);
	.d2line		7545
.Llo546:
	rlwinm		r3,r27,0,16,31		# positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r27
	bl		Dcm_DsdStartResponse
#             (void)Dcm_DsdRequestResponseBuffer(positiveResponseHeaderSize, &resBuffer);
	.d2line		7546
	rlwinm		r3,r27,0,16,31		# positiveResponseHeaderSize=r3 positiveResponseHeaderSize=r27
	diab.addi		r4,r1,12		# DtcStatusMask=r4
	bl		Dcm_DsdRequestResponseBuffer
# 
#             /*
#              * Fill in mandatory response data
#              */
#             resBuffer[0] = pMsgContext->subServiceId;
	.d2line		7551
	lbz		r0,26(r31)		# subFunction0x0Aor0x15=r0 pMsgContext=r31
.Llo547:
	lwz		r3,12(r1)		# positiveResponseHeaderSize=r3
	stb		r0,0(r3)		# positiveResponseHeaderSize=r3 subFunction0x0Aor0x15=r0
# 
#             /*
#              * Add an echo of the memory selection in case of SF 0x17 [SWS_Dcm_00377]
#              */
#             if (includeMemorySelection)
	.d2line		7556
.Llo574:
	rlwinm		r28,r28,0,24,31		# includeMemorySelection=r28 includeMemorySelection=r28
	se_cmpi		r28,0		# includeMemorySelection=r28
	bc		1,2,.L1717	# eq
#             {
#                resBuffer[1] = memorySelection;
	.d2line		7558
.Llo521:
	lwz		r3,12(r1)		# positiveResponseHeaderSize=r3
.Llo581:
	stb		r26,1(r3)		# positiveResponseHeaderSize=r3 memorySelection=r26
#                resBuffer[2] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		7559
	lbz		r0,8(r1)		# subFunction0x0Aor0x15=r0
.Llo548:
	lwz		r3,12(r1)		# positiveResponseHeaderSize=r3
	stb		r0,2(r3)		# positiveResponseHeaderSize=r3 subFunction0x0Aor0x15=r0
	b		.L1711
.L1717:
#             }
#             else
#             {
#                resBuffer[1] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		7563
.Llo549:
	lbz		r0,8(r1)		# subFunction0x0Aor0x15=r0
.Llo550:
	lwz		r3,12(r1)		# positiveResponseHeaderSize=r3
.Llo582:
	stb		r0,1(r3)		# positiveResponseHeaderSize=r3 subFunction0x0Aor0x15=r0
	b		.L1711
.L1716:
#             }
#          }
#          else if (DEM_FILTER_ACCEPTED != Dem_DcmSetDTCFilter(DtcStatusMask,
	.d2line		7566
.Llo522:
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
.Llo583:
	bl		GetDTCOriginReadDTCInformation
	mr		r6,r3		# pMsgContext=r6
	rlwinm		r3,r4,0,24,31		# pMsgContext=r3 DtcStatusMask=r4
	rlwinm		r4,r30,0,24,31		# DtcStatusMask=r4 DtcKind=r30
.Llo590:
	rlwinm		r6,r6,0,24,31		# pMsgContext=r6 pMsgContext=r6
	diab.li		r5,11
	diab.li		r7,0
	mr		r8,r7
	mr		r9,r7
	bl		Dem_DcmSetDTCFilter
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1720	# eq
#                                                             DtcKind,
#                                                             DEM_DTC_FORMAT_UDS,
#                                                             GetDTCOriginReadDTCInformation(pMsgContext),
#                                                             FALSE,
#                                                             DEM_SEVERITY_NO_SEVERITY,
#                                                             FALSE))
#          {
#             /*
#              * The following was returned:
#              *     DEM_WRONG_FILTER
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7578
.Llo533:
	diab.li		r0,49		# subFunction0x0Aor0x15=r0
.Llo551:
	stb		r0,0(r29)		# pErrorCode=r29 subFunction0x0Aor0x15=r0
	b		.L1711
.L1720:
#          }
#          /* Get the number of filtered DTCs */
#          else if (DEM_NUMBER_OK != Dem_DcmGetNumberOfFilteredDTC(&NumDTC))
	.d2line		7581
.Llo552:
	diab.addi		r3,r1,10		# pMsgContext=r3
	bl		Dem_DcmGetNumberOfFilteredDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1722	# eq
#          {
#             /*
#              * The following were returned:
#              *     DEM_NUMBER_FAILED
#              *     DEM_NUMBER_PENDING
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7588
	diab.li		r0,49		# subFunction0x0Aor0x15=r0
.Llo553:
	stb		r0,0(r29)		# pErrorCode=r29 subFunction0x0Aor0x15=r0
	b		.L1711
.L1722:
	.section	.text_vle
.L3713:
#          }
#          else
#          {
#             /*
#              * Every DTC includes 4 bytes of data. Plus 1 byte for StatusAvailabilityMask,
#              * and 1 byte for subfunction ID
#              */
#             CONST(Dcm_MsgLenType, AUTOMATIC) TotalAnswerSize = (NumDTC * DCM_REPORT_DTC_BY_STATUSMASK_ANSWERSIZE) + positiveResponseHeaderSize;
	.d2line		7596
.Llo554:
	lhz		r0,10(r1)		# subFunction0x0Aor0x15=r0
.Llo555:
	se_slwi		r0,2		# subFunction0x0Aor0x15=r0 subFunction0x0Aor0x15=r0
	add		r3,r0,r27		# pMsgContext=r3 subFunction0x0Aor0x15=r0 positiveResponseHeaderSize=r27
.Llo591:
	mr		r3,r3		# TotalAnswerSize=r3 TotalAnswerSize=r3
# 
#             /*
#              * Start response
#              */
#             if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(TotalAnswerSize))
	.d2line		7601
	rlwinm		r3,r3,0,16,31		# TotalAnswerSize=r3 TotalAnswerSize=r3
.Llo592:
	bl		Dcm_DsdStartResponse
.Llo556:
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	cmpi		0,0,r3,200		# pMsgContext=r3
	bc		0,2,.L1724	# ne
#             {
#                *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7603
	diab.li		r0,20		# subFunction0x0Aor0x15=r0
.Llo557:
	stb		r0,0(r29)		# pErrorCode=r29 subFunction0x0Aor0x15=r0
	b		.L1711
.L1724:
#             }
#             else
#             {
#                /*
#                 * Dcm_DsdRequestResponseBuffer will never return anything else than E_OK
#                 *
#                 * MISRA-C:2004 RULE 16.10 VIOLATION:
#                 * If a function returns error information, then that error information shall be tested.
#                 * Since the request is always two bytes and that will fit into the minimum
#                 * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#                 */
#                (void)Dcm_DsdRequestResponseBuffer(positiveResponseHeaderSize, &resBuffer);
	.d2line		7615
.Llo558:
	rlwinm		r3,r27,0,16,31		# pMsgContext=r3 positiveResponseHeaderSize=r27
	diab.addi		r4,r1,12		# DtcStatusMask=r4
	bl		Dcm_DsdRequestResponseBuffer
# 
#                /*
#                 * Fill in mandatory response data
#                 */
#                resBuffer[0] = pMsgContext->subServiceId;
	.d2line		7620
	lbz		r0,26(r31)		# subFunction0x0Aor0x15=r0 pMsgContext=r31
.Llo559:
	lwz		r3,12(r1)		# pMsgContext=r3
	stb		r0,0(r3)		# pMsgContext=r3 subFunction0x0Aor0x15=r0
# 
#                /*
#                 * Add an echo of the memory selection in case of SF 0x17 [SWS_Dcm_00377]
#                 */
#                if (includeMemorySelection)
	.d2line		7625
.Llo575:
	rlwinm		r28,r28,0,24,31		# includeMemorySelection=r28 includeMemorySelection=r28
	se_cmpi		r28,0		# includeMemorySelection=r28
	bc		1,2,.L1726	# eq
#                {
#                   resBuffer[1] = memorySelection;
	.d2line		7627
.Llo523:
	lwz		r3,12(r1)		# pMsgContext=r3
.Llo524:
	stb		r26,1(r3)		# pMsgContext=r3 memorySelection=r26
#                   resBuffer[2] = StatusAvailabilityMask;
	.d2line		7628
	lbz		r0,8(r1)		# subFunction0x0Aor0x15=r0
.Llo560:
	lwz		r3,12(r1)		# pMsgContext=r3
	stb		r0,2(r3)		# pMsgContext=r3 subFunction0x0Aor0x15=r0
	b		.L1727
.L1726:
#                }
#                else
#                {
#                   resBuffer[1] = StatusAvailabilityMask;
	.d2line		7632
.Llo525:
	lbz		r0,8(r1)		# subFunction0x0Aor0x15=r0
.Llo561:
	lwz		r3,12(r1)		# pMsgContext=r3
.Llo526:
	stb		r0,1(r3)		# pMsgContext=r3 subFunction0x0Aor0x15=r0
.L1727:
#                }
# 
#                if (0 != NumDTC)
	.d2line		7635
.Llo527:
	lhz		r0,10(r1)		# subFunction0x0Aor0x15=r0
.Llo562:
	se_cmpi		r0,0		# subFunction0x0Aor0x15=r0
	bc		1,2,.L1711	# eq
#                {
#                   Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		7637
.Llo563:
	diab.li		r0,1		# subFunction0x0Aor0x15=r0
.Llo564:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
.Llo528:
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3 subFunction0x0Aor0x15=r0
	.section	.text_vle
.L3714:
	.section	.text_vle
.L3697:
	.section	.text_vle
.L3692:
.L1711:
#                }
#                else
#                {
#                   /*
#                    * No Dtc available, just send a positive response.
#                    */
#                }
#             }
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		7650
.Llo529:
	lis		r3,(Dcm_DspInstance+8)@ha		# positiveResponseHeaderSize=r3
.Llo530:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# subFunction0x0Aor0x15=r0 positiveResponseHeaderSize=r3
.Llo565:
	se_cmpi		r0,1		# subFunction0x0Aor0x15=r0
	bc		0,2,.L1710	# ne
	.section	.text_vle
.L3719:
#    {
#       boolean GetNextDtc = TRUE;
	.d2line		7652
.Llo531:
	diab.li		r31,1		# GetNextDtc=r31
.L1731:
#       while (GetNextDtc && (E_OK == getBufferRes))
	.d2line		7653
.Llo534:
	rlwinm		r0,r31,0,24,31		# subFunction0x0Aor0x15=r0 GetNextDtc=r31
.Llo566:
	se_cmpi		r0,0		# subFunction0x0Aor0x15=r0
	bc		1,2,.L1710	# eq
.Llo567:
	rlwinm		r25,r25,0,24,31		# getBufferRes=r25 getBufferRes=r25
	se_cmpi		r25,0		# getBufferRes=r25
	bc		0,2,.L1710	# ne
#       {
#          getBufferRes =  Dcm_DsdRequestResponseBuffer(DCM_REPORT_DTC_BY_STATUSMASK_ANSWERSIZE, &resBuffer);
	.d2line		7655
.Llo539:
	diab.addi		r4,r1,12		# DtcStatusMask=r4
.Llo535:
	diab.li		r3,4		# pMsgContext=r3
	bl		Dcm_DsdRequestResponseBuffer
.Llo540:
	mr		r25,r3		# getBufferRes=r25 getBufferRes=r3
# 
#          if (E_OK == getBufferRes)
	.d2line		7657
	rlwinm		r3,r3,0,24,31		# getBufferRes=r3 getBufferRes=r3
	se_cmpi		r3,0		# getBufferRes=r3
	bc		0,2,.L1733	# ne
	.section	.text_vle
.L3725:
#          {
#             uint32 Dtc;
#             Dem_UdsStatusByteType DtcStatus;
#             CONST(Dem_ReturnGetNextFilteredElementType, AUTOMATIC) Status = Dem_DcmGetNextFilteredDTC(&Dtc, &DtcStatus);
	.d2line		7661
.Llo541:
	diab.addi		r3,r1,16		# getBufferRes=r3
.Llo542:
	diab.addi		r4,r1,9		# DtcStatusMask=r4
	bl		Dem_DcmGetNextFilteredDTC
.Llo596:
	mr		r6,r3		# Status=r6 Status=r3
# 
#             switch (Status)
	.d2line		7663
	rlwinm		r6,r6,0,24,31		# Status=r6 Status=r6
	se_cmpi		r6,0		# Status=r6
	bc		1,2,.L1736	# eq
.Llo597:
	se_cmpi		r6,1		# Status=r6
.Llo598:
	bc		1,2,.L1734	# eq
.Llo593:
	b		.L1738
.L1734:
#             {
#                case DEM_FILTERED_NO_MATCHING_ELEMENT:
#                {
#                   /*
#                    * All matching dtcs were successfully received.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DSD will handle the freed buffer.
#                    */
#                   GetNextDtc = FALSE;
	.d2line		7673
	diab.li		r31,0		# GetNextDtc=r31
#                   Dcm_DsdReleaseResponseBuffer(DCM_REPORT_DTC_BY_STATUSMASK_ANSWERSIZE);
	.d2line		7674
.Llo594:
	diab.li		r3,4		# pMsgContext=r3
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L1731
.L1736:
#                   break;
#                }
# 
#                case DEM_FILTERED_OK:
#                {
#                   SET_RESPONSE_DTC(&resBuffer[0], Dtc);
	.d2line		7680
.Llo599:
	lwz		r0,16(r1)		# subFunction0x0Aor0x15=r0
.Llo568:
	rlwinm		r0,r0,16,24,31		# subFunction0x0Aor0x15=r0 subFunction0x0Aor0x15=r0
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,0(r3)		# getBufferRes=r3 subFunction0x0Aor0x15=r0
	lhz		r0,18(r1)		# subFunction0x0Aor0x15=r0
	rlwinm		r0,r0,24,24,31		# subFunction0x0Aor0x15=r0 subFunction0x0Aor0x15=r0
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,1(r3)		# getBufferRes=r3 subFunction0x0Aor0x15=r0
	lbz		r0,19(r1)		# subFunction0x0Aor0x15=r0
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,2(r3)		# getBufferRes=r3 subFunction0x0Aor0x15=r0
#                   resBuffer[3] = (uint8)DtcStatus;
	.d2line		7681
	lbz		r0,9(r1)		# subFunction0x0Aor0x15=r0
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,3(r3)		# getBufferRes=r3 subFunction0x0Aor0x15=r0
	b		.L1731
.L1738:
#                   break;
#                }
# 
#                default:
#                {
#                   /*
#                    * All other type of faults will end up here.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DsD will handle the freed buffer.
#                    */
#                   Dcm_DsdReleaseResponseBuffer(DCM_REPORT_DTC_BY_STATUSMASK_ANSWERSIZE);
	.d2line		7693
.Llo569:
	diab.li		r3,4		# pMsgContext=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                   *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7694
	diab.li		r0,49		# subFunction0x0Aor0x15=r0
.Llo570:
	stb		r0,0(r29)		# pErrorCode=r29 subFunction0x0Aor0x15=r0
#                   GetNextDtc = FALSE;
	.d2line		7695
	diab.li		r31,0		# GetNextDtc=r31
.Llo595:
	b		.L1731
	.section	.text_vle
.L3726:
.L1733:
#                   break;
#                }
#             }
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_PENDING == getBufferRes)
#          {
#             /*
#              * Do nothing, it will continue to read data later.
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#          }
#          else if (DCM_INT_E_RESPONSE_FULL == getBufferRes)
#          {
#             /*
#              * The whole length of the originally calculated response length has been filled.
#              */
#          }
#          else if (E_NOT_OK == getBufferRes)
#          {
#             /*
#              * Abort, make sense to retrieve the data.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
#       }
# #endif
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer returned
#              *  DCM_INT_E_RESPONSE_TOO_LONG
#              *
#              * Abort, requested size can't possible fit in buffer.
#              */
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7730
.Llo571:
	diab.li		r0,20		# subFunction0x0Aor0x15=r0
.Llo572:
	stb		r0,0(r29)		# pErrorCode=r29 subFunction0x0Aor0x15=r0
	b		.L1731
	.section	.text_vle
.L3720:
.L1710:
#          }
#       }
#    }
# }
	.d2line		7734
	.d2epilogue_begin
.Llo536:
	lmw		r25,36(r1)		# offset r1+36  0x24
	.d2_cfa_restore_list	2,10
.Llo538:
	lwz		r0,68(r1)		# subFunction0x0Aor0x15=r0
	mtspr		lr,r0		# subFunction0x0Aor0x15=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo537:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3683:
	.type		ReportDTCsByStatusMask,@function
	.size		ReportDTCsByStatusMask,.-ReportDTCsByStatusMask
# Number of nodes = 374

# Allocations for ReportDTCsByStatusMask
#	?a4		pMsgContext
#	?a5		DtcKind
#	?a6		pErrorCode
#	?a7		$$49
#	?a8		$$48
#	SP,12		resBuffer
#	?a9		getBufferRes
#	SP,8		StatusAvailabilityMask
#	?a10		subFunction0x0Aor0x15
#	?a11		includeMemorySelection
#	?a12		positiveResponseHeaderSize
#	?a13		memorySelection
#	?a14		DtcStatusMask
#	SP,10		NumDTC
#	?a15		TotalAnswerSize
#	?a16		GetNextDtc
#	SP,16		Dtc
#	SP,9		DtcStatus
#	?a17		Status
# static FUNC(void, DCM_CODE) ReportDTCSnapshotIdentification(
	.align		1
	.section	.text_vle
        .d2line         7739,29
#$$ld
.L3735:

#$$bf	ReportDTCSnapshotIdentification,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCSnapshotIdentification:
.Llo600:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r28,32(r1)		# offset r1+32  0x20
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r30,r4		# pErrorCode=r30 pErrorCode=r4
	.d2prologue_end
#                                  CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint16  NumDtc;
#    Dcm_MsgLenType TotalAnswerSize;
#    boolean GetNextRecord = TRUE;
	.d2line		7745
	diab.li		r29,1		# GetNextRecord=r29
# 
#    Std_ReturnType                          getBufferRes     = E_OK;
	.d2line		7747
.Llo617:
	diab.li		r28,0		# getBufferRes=r28
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  resBuffer;
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		7750
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo601:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1766	# ne
#    {
#       if (DEM_WRONG_FILTER == Dem_DcmSetFreezeFrameRecordFilter(DEM_DTC_FORMAT_UDS, &NumDtc))
	.d2line		7752
.Llo602:
	diab.addi		r4,r1,10
.Llo606:
	diab.li		r3,11
	bl		Dem_DcmSetFreezeFrameRecordFilter
	rlwinm		r3,r3,0,24,31
	se_cmpi		r3,1
	bc		0,2,.L1767	# ne
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7754
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1766
.L1767:
#       }
#       else
#       {
#          /* Calculate the total answer size + 1 byte for subfunction ID*/
#          TotalAnswerSize = (NumDtc * DEM_DTC_SNAPSHOT_RECORD_ID_ANSWERSIZE) + 1U;
	.d2line		7759
	lhz		r3,10(r1)		# TotalAnswerSize=r3
.Llo610:
	se_slwi		r3,2		# TotalAnswerSize=r3 TotalAnswerSize=r3
	se_addi		r3,1		# TotalAnswerSize=r3 TotalAnswerSize=r3
	.d2line		7764
	rlwinm		r3,r3,0,16,31		# TotalAnswerSize=r3 TotalAnswerSize=r3
# 
#          /*
#           * Start response
#           */
#          if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(TotalAnswerSize))
.Llo611:
	bl		Dcm_DsdStartResponse
.Llo612:
	rlwinm		r3,r3,0,24,31		# TotalAnswerSize=r3 TotalAnswerSize=r3
	cmpi		0,0,r3,200		# TotalAnswerSize=r3
	bc		0,2,.L1769	# ne
#          {
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7766
.Llo613:
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1766
.L1769:
#          }
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer will never return anything else than E_OK
#              *
#              * MISRA-C:2004 RULE 16.10 VIOLATION:
#              * If a function returns error information, then that error information shall be tested.
#              * Since the request is always two bytes and that will fit into the minimum
#              * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#              */
#             (void)Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)1U, &resBuffer);
	.d2line		7778
	diab.addi		r4,r1,12
	diab.li		r3,1		# TotalAnswerSize=r3
	bl		Dcm_DsdRequestResponseBuffer
# 
#             /*
#                * Fill in mandatory response data
#                */
#             resBuffer[0] = pMsgContext->subServiceId;
	.d2line		7783
	lbz		r0,26(r31)		# pMsgContext=r31
	lwz		r3,12(r1)		# TotalAnswerSize=r3
.Llo614:
	stb		r0,0(r3)		# TotalAnswerSize=r3
# 
#             if (0 == NumDtc)
	.d2line		7785
	lhz		r0,10(r1)
	se_cmpi		r0,0
	bc		1,2,.L1766	# eq
#             {
#                /*
#                 * No DTCs so send an empty response.
#                 */
#             }
#             else
#             {
#                Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		7793
.Llo603:
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+8)@ha		# TotalAnswerSize=r3
.Llo615:
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# TotalAnswerSize=r3
.L1766:
#             }
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		7799
.Llo604:
	lis		r3,(Dcm_DspInstance+8)@ha		# TotalAnswerSize=r3
.Llo616:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# TotalAnswerSize=r3
	se_cmpi		r0,1
	bc		0,2,.L1765	# ne
.L1774:
#    {
#       while ((TRUE == GetNextRecord) && (E_OK == getBufferRes))
	.d2line		7801
.Llo605:
	rlwinm		r0,r29,0,24,31		# GetNextRecord=r29
	se_cmpi		r0,1
	bc		0,2,.L1765	# ne
	rlwinm		r28,r28,0,24,31		# getBufferRes=r28 getBufferRes=r28
	se_cmpi		r28,0		# getBufferRes=r28
	bc		0,2,.L1765	# ne
#       {
#          getBufferRes =  Dcm_DsdRequestResponseBuffer(DEM_DTC_SNAPSHOT_RECORD_ID_ANSWERSIZE, &resBuffer);
	.d2line		7803
.Llo622:
	diab.addi		r4,r1,12
	diab.li		r3,4		# TotalAnswerSize=r3
	bl		Dcm_DsdRequestResponseBuffer
.Llo623:
	mr		r28,r3		# getBufferRes=r28 getBufferRes=r3
# 
#          if (E_OK == getBufferRes)
	.d2line		7805
	rlwinm		r3,r3,0,24,31		# getBufferRes=r3 getBufferRes=r3
	se_cmpi		r3,0		# getBufferRes=r3
	bc		0,2,.L1776	# ne
	.section	.text_vle
.L3748:
#          {
#             uint32 Dtc;
#             uint8 recordNumber;
#             CONST(Dem_ReturnGetNextFilteredElementType, AUTOMATIC) Status = Dem_DcmGetNextFilteredRecord(&Dtc, &recordNumber);
	.d2line		7809
.Llo624:
	diab.addi		r3,r1,16		# getBufferRes=r3
.Llo625:
	diab.addi		r4,r1,8
	bl		Dem_DcmGetNextFilteredRecord
.Llo626:
	mr		r6,r3		# Status=r6 Status=r3
# 
#             switch (Status)
	.d2line		7811
	rlwinm		r6,r6,0,24,31		# Status=r6 Status=r6
	se_cmpi		r6,0		# Status=r6
	bc		1,2,.L1779	# eq
.Llo627:
	se_cmpi		r6,1		# Status=r6
.Llo628:
	bc		1,2,.L1777	# eq
.Llo618:
	b		.L1781
.L1777:
#             {
#                case DEM_FILTERED_NO_MATCHING_ELEMENT:
#                {
#                   /*
#                    * All matching dtcs were successfully received.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DSD will handle the freed buffer.
#                    */
#                   GetNextRecord = FALSE;
	.d2line		7821
	diab.li		r29,0		# GetNextRecord=r29
#                   Dcm_DsdReleaseResponseBuffer(DEM_DTC_SNAPSHOT_RECORD_ID_ANSWERSIZE);
	.d2line		7822
.Llo619:
	diab.li		r3,4		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L1774
.L1779:
#                   break;
#                }
# 
#                case DEM_FILTERED_OK:
#                {
#                   SET_RESPONSE_DTC(&resBuffer[0], Dtc);
	.d2line		7828
.Llo629:
	lwz		r0,16(r1)
	rlwinm		r0,r0,16,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,0(r3)		# getBufferRes=r3
	lhz		r0,18(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,1(r3)		# getBufferRes=r3
	lbz		r0,19(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,2(r3)		# getBufferRes=r3
#                   resBuffer[3] = recordNumber;
	.d2line		7829
	lbz		r0,8(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,3(r3)		# getBufferRes=r3
	b		.L1774
.L1781:
#                   break;
#                }
# 
#                default:
#                {
#                   /*
#                    * All other type of faults will end up here.
#                    *
#                    * Release the requested buffer if no data is available.
#                    * DsD will handle the freed buffer.
#                    */
#                   Dcm_DsdReleaseResponseBuffer(DEM_DTC_SNAPSHOT_RECORD_ID_ANSWERSIZE);
	.d2line		7841
.Llo620:
	diab.li		r3,4		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                   *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7842
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
#                   GetNextRecord = FALSE;
	.d2line		7843
	diab.li		r29,0		# GetNextRecord=r29
.Llo621:
	b		.L1774
	.section	.text_vle
.L3749:
.L1776:
#                   break;
#                }
#             }
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_PENDING == getBufferRes)
#          {
#             /*
#              * Do nothing, it will continue to read data later.
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#          }
#          else if (DCM_INT_E_RESPONSE_FULL == getBufferRes)
#          {
#             /*
#              * The whole length of the originally calculated response length has been filled.
#              */
#          }
#          else if (E_NOT_OK == getBufferRes)
#          {
#             /*
#              * Abort, make sense to retrieve the data.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
#          }
# #endif
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer returned
#              *  DCM_INT_E_RESPONSE_TOO_LONG
#              *
#              * Abort, requested size can't possible fit in buffer.
#              */
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7878
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1774
.L1765:
#          }
#       }/* while */
#    }
# }
	.d2line		7882
	.d2epilogue_begin
.Llo607:
	lmw		r28,32(r1)		# offset r1+32  0x20
	.d2_cfa_restore_list	3,10
.Llo608:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo609:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3736:
	.type		ReportDTCSnapshotIdentification,@function
	.size		ReportDTCSnapshotIdentification,.-ReportDTCSnapshotIdentification
# Number of nodes = 185

# Allocations for ReportDTCSnapshotIdentification
#	?a4		pMsgContext
#	?a5		pErrorCode
#	SP,10		NumDtc
#	?a6		TotalAnswerSize
#	?a7		GetNextRecord
#	?a8		getBufferRes
#	SP,12		resBuffer
#	SP,16		Dtc
#	SP,8		recordNumber
#	?a9		Status
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) GetOneSnapShotDataRecord(uint32 dtc,
	.align		1
	.section	.text_vle
        .d2line         8561,53
#$$ld
.L3758:

#$$bf	GetOneSnapShotDataRecord,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetOneSnapShotDataRecord:
.Llo630:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
.Llo666:
	stmw		r23,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	23,31,1,1
	stw		r0,68(r1)		# headerLen=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# dtc=r31 dtc=r3
	mr		r30,r4		# dtcStatus=r30 dtcStatus=r4
	mr		r29,r5		# dtcStatusIndicators=r29 dtcStatusIndicators=r5
	mr		r28,r6		# dataRecordNumber=r28 dataRecordNumber=r6
	mr		r27,r7		# DtcOrigin=r27 DtcOrigin=r7
	mr		r26,r8		# isService19=r26 isService19=r8
	mr		r25,r9		# pDataState=r25 pDataState=r9
	.d2prologue_end
#                                                                              uint8  dtcStatus,
#                                                                              uint8  dtcStatusIndicators,
#                                                                              uint8  dataRecordNumber,
#                                                                              Dem_DTCOriginType DtcOrigin,
#                                                                              CONST(boolean, DCM_CONST) isService19,
#                                                                              CONSTP2VAR(ReadExtendedOrSnapshotDataRecordByDTCStatusType, AUTOMATIC, DCM_APPL_DATA) pDataState)
# {
#    uint16                                  dataRecordSize;
#    Dem_ReturnGetSizeOfDataByDTCType demGetSizeRetVal;
#    Dcm_NegativeResponseCodeType  ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		8571
	diab.li		r24,0		# ErrorCode=r24
#    Std_ReturnType       responseBufferResult;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) responseBuffer;
#    Dem_ReturnGetFreezeFrameDataByDTCType getSnapshotRetVal;
# 
# #if (DCM_READ_GENERIC_INFORMATION_ENABLED == STD_ON)
#    /*
#     * Storage for DTC/data records status information
#      */
#    CONSTP2VAR(ReportAllDtcDataRecordByDTCNumberStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.dtc_data_records_status;
# #endif
# 
#    /*
#     * If service 0x19, 0x04, only data record number is added in the front of every data record.
#     * If service 0xAF, 0x04, dtc, dtc status, dtc indicator and data record number are added in
#     * the front of each data record.
#     */
#    CONST(uint8, DCM_CONST) headerLen = (TRUE == isService19) ? 0 : DCM_RGI_RGS_HEADERSIZE;
	.d2line		8588
.Llo648:
	rlwinm		r8,r26,0,24,31		# isService19=r26
.Llo643:
	cmpi		0,0,r8,1
	isel		r3,0,r0,2		# headerLen=r3 headerLen=r0
.L2005:
.Llo631:
	diab.li		r0,5		# headerLen=r0
.Llo632:
	isel		r23,r3,r0,2		# headerLen=r23 headerLen=r3 headerLen=r0
.L2006:
#    /*
#     * Fetch the size for the specific record number
#     */
#    demGetSizeRetVal = Dem_DcmGetSizeOfFreezeFrameByDTC(dtc,
	.d2line		8592
.Llo667:
	rlwinm		r4,r27,0,24,31		# DtcOrigin=r27
.Llo668:
	rlwinm		r5,r28,0,24,31		# dataRecordNumber=r28
	diab.addi		r6,r1,8
	mr		r3,r31		# dtc=r3 dtc=r31
	bl		Dem_DcmGetSizeOfFreezeFrameByDTC
.Llo644:
	mr		r3,r3		# demGetSizeRetVal=r3 demGetSizeRetVal=r3
#                                                     DtcOrigin,
#                                                     dataRecordNumber,
#                                                     &dataRecordSize);
#    if (DEM_GETSIZEBYDTC_OK == demGetSizeRetVal)
	.d2line		8596
	rlwinm		r0,r3,0,24,31		# headerLen=r0 demGetSizeRetVal=r3
	se_cmpi		r0,0		# headerLen=r0
	bc		0,2,.L1987	# ne
#    {
#       /* The record was found and size was returned */
#       pDataState->dataRecordFound = TRUE;
	.d2line		8599
	diab.li		r0,1		# headerLen=r0
	stb		r0,5(r25)		# pDataState=r25 headerLen=r0
	b		.L1988
.L1987:
#    }
#    else if (DEM_GETSIZEBYDTC_WRONG_RECNUM == demGetSizeRetVal)
	.d2line		8601
	rlwinm		r3,r3,0,24,31		# demGetSizeRetVal=r3 demGetSizeRetVal=r3
	se_cmpi		r3,3		# demGetSizeRetVal=r3
	bc		0,2,.L1989	# ne
#    {
#       /* No record found, set size to zero */
#       dataRecordSize = 0;
	.d2line		8604
.Llo645:
	diab.li		r0,0		# headerLen=r0
	sth		r0,8(r1)		# headerLen=r0
	b		.L1988
.L1989:
#    }
#    else
#    {
#      /*
#       * Dem_DcmGetSizeOfFreezeFrameByDTC returned one of the following:
#       *  DEM_GETSIZEBYDTC_WRONG_RECNUM
#       *  DEM_GETSIZEBYDTC_WRONG_DTC
#       *  DEM_GET_SIZEOFFF_WRONG_DTCOR
#       *  DEM_GET_SIZEOFFF_WRONG_DTCKIND
#       *  DEM_GETSIZEBYDTC_PENDING
#       *
#       * Abort, failure will be handled by the caller
#       */
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8618
	diab.li		r24,49		# ErrorCode=r24
.L1988:
#    }
# 
#    /* Get the size of the requested dataRecord */
#    if (DCM_INT_NRC_POSITIVERESPONSE != ErrorCode)
	.d2line		8622
	rlwinm		r0,r24,0,24,31		# headerLen=r0 ErrorCode=r24
	se_cmpi		r0,0		# headerLen=r0
	bc		0,2,.L1992	# ne
#    {
#       /* Abort, failure will be handled by the caller */
#    }
#    else if (0 == dataRecordSize)
	.d2line		8626
	lhz		r0,8(r1)		# headerLen=r0
	se_cmpi		r0,0		# headerLen=r0
	bc		1,2,.L1992	# eq
#    {
#       /*
#        * No stored data, skip the readout but do not consider it as a failure.
#        */
#    }
#    else
#    {
# #if (DCM_READ_GENERIC_INFORMATION_ENABLED == STD_ON)
#       /*
#        * Update the total size.
#        */
#       pStatus->total_size = pStatus->total_size + dataRecordSize;
# #endif
#       /* Get Response buffer */
#       responseBufferResult = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)(dataRecordSize + headerLen), &responseBuffer);
	.d2line		8641
	lhz		r3,8(r1)		# demGetSizeRetVal=r3
.Llo646:
	rlwinm		r0,r23,0,24,31		# headerLen=r0 headerLen=r23
	se_add		r3,r0		# demGetSizeRetVal=r3 demGetSizeRetVal=r3 headerLen=r0
	rlwinm		r3,r3,0,16,31		# demGetSizeRetVal=r3 demGetSizeRetVal=r3
.Llo647:
	diab.addi		r4,r1,12
	bl		Dcm_DsdRequestResponseBuffer
.Llo651:
	mr		r3,r3		# responseBufferResult=r3 responseBufferResult=r3
# 
#       if (E_OK == responseBufferResult)
	.d2line		8643
	rlwinm		r3,r3,0,24,31		# responseBufferResult=r3 responseBufferResult=r3
	se_cmpi		r3,0		# responseBufferResult=r3
	bc		0,2,.L1995	# ne
#       {
#          getSnapshotRetVal = Dem_DcmGetFreezeFrameDataByDTC(dtc,
	.d2line		8645
.Llo652:
	lwz		r6,12(r1)		# getSnapshotRetVal=r6
.Llo661:
	rlwinm		r0,r23,0,24,31		# headerLen=r0 headerLen=r23
	se_add		r6,r0		# getSnapshotRetVal=r6 getSnapshotRetVal=r6 headerLen=r0
.Llo662:
	rlwinm		r4,r27,0,24,31		# DtcOrigin=r27
	rlwinm		r5,r28,0,24,31		# dataRecordNumber=r28
	diab.addi		r7,r1,8
	mr		r3,r31		# dtc=r3 dtc=r31
	bl		Dem_DcmGetFreezeFrameDataByDTC
.Llo663:
	mr		r6,r3		# getSnapshotRetVal=r6 getSnapshotRetVal=r3
#                                                             DtcOrigin,
#                                                             dataRecordNumber,
#                                                             &responseBuffer[headerLen], /* Try to add the snapshot data record, but make room for the five byte DTC header. */
#                                                             &dataRecordSize);
# 
#          switch (getSnapshotRetVal)
	.d2line		8651
	rlwinm		r6,r6,0,24,31		# getSnapshotRetVal=r6 getSnapshotRetVal=r6
	se_cmpi		r6,0		# getSnapshotRetVal=r6
	bc		1,2,.L1996	# eq
.Llo642:
	se_cmpi		r6,3		# getSnapshotRetVal=r6
.Llo664:
	bc		1,2,.L2001	# eq
.Llo633:
	se_cmpi		r6,4		# getSnapshotRetVal=r6
	bc		1,2,.L2001	# eq
	se_cmpi		r6,5		# getSnapshotRetVal=r6
	bc		1,2,.L2002	# eq
.Llo665:
	b		.L2003
.L1996:
#          {
#             case DEM_GET_FFDATABYDTC_OK:
#             {
#                if (FALSE == isService19)
	.d2line		8655
.Llo634:
	rlwinm		r26,r26,0,24,31		# isService19=r26 isService19=r26
	se_cmpi		r26,0		# isService19=r26
	bc		0,2,.L1997	# ne
#                {
#                   /*
#                    * Reading snapshot data record OK, and data was copied in the DEM request.
#                    */
#                   SET_RESPONSE_DTC(&responseBuffer[0], dtc);
	.d2line		8660
.Llo640:
	rlwinm		r0,r31,16,24,31		# headerLen=r0 dtc=r31
.Llo669:
	lwz		r3,12(r1)		# responseBufferResult=r3
.Llo653:
	stb		r0,0(r3)		# responseBufferResult=r3 headerLen=r0
	mr		r0,r31		# dtc=r0 dtc=r31
.Llo670:
	rlwinm		r4,r0,24,24,31		# dtc=r0
	lwz		r3,12(r1)		# responseBufferResult=r3
	stb		r4,1(r3)		# responseBufferResult=r3
	rlwinm		r0,r0,0,24,31		# dtc=r0 dtc=r0
	lwz		r3,12(r1)		# responseBufferResult=r3
	stb		r31,2(r3)		# responseBufferResult=r3 dtc=r31
#                   responseBuffer[3] = dtcStatus;
	.d2line		8661
	lwz		r3,12(r1)		# dtc=r3
.Llo654:
	stb		r30,3(r3)		# dtc=r3 dtcStatus=r30
#                   responseBuffer[4] = dtcStatusIndicators;
	.d2line		8662
	lwz		r3,12(r1)		# dtc=r3
	stb		r29,4(r3)		# dtc=r3 dtcStatusIndicators=r29
.L1997:
#                }
# 
#                pDataState->dataPending = FALSE;
	.d2line		8665
	diab.li		r0,0		# dtc=r0
	stb		r0,1(r25)		# pDataState=r25 dtc=r0
	b		.L1992
.L2001:
#                break;
#             }
# 
#             case DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER:
#                /*
#                 * Record wasn't missing between call to get size and
#                 * get freeze frame data record, but no error since we are looping
#                 * through all records. Release the previous requested memory.
#                 */
#             case DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE:
#                /*
#                 * Should abort and retry with new buffer next schedule perhaps
#                 * (slight risk of an infinite loop), but just ignore and
#                 * continue with next extended data record for now.
#                 * Release the previous requested memory.
#                 */
#             {
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)(dataRecordSize + headerLen));
	.d2line		8683
.Llo635:
	lhz		r3,8(r1)		# responseBufferResult=r3
.Llo655:
	rlwinm		r23,r23,0,24,31		# headerLen=r23 headerLen=r23
	add		r3,r3,r23		# responseBufferResult=r3 responseBufferResult=r3 headerLen=r23
	rlwinm		r3,r3,0,16,31		# responseBufferResult=r3 responseBufferResult=r3
.Llo656:
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L1992
.L2002:
#                break;
#             }
# 
#             case DEM_GET_FFDATABYDTC_PENDING:
#             {
#                /*
#                 * Retry next schedule, release the previous requested memory.
#                 *
#                 * Store last processed extended data record number and stay in this state.
#                 */
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)(dataRecordSize + headerLen));
	.d2line		8694
.Llo671:
	lhz		r3,8(r1)		# responseBufferResult=r3
.Llo657:
	rlwinm		r23,r23,0,24,31		# headerLen=r23 headerLen=r23
	add		r3,r3,r23		# responseBufferResult=r3 responseBufferResult=r3 headerLen=r23
	rlwinm		r3,r3,0,16,31		# responseBufferResult=r3 responseBufferResult=r3
.Llo658:
	bl		Dcm_DsdReleaseResponseBuffer
#                pDataState->current_data_record_number = dataRecordNumber;
	.d2line		8695
	stb		r28,3(r25)		# pDataState=r25 dataRecordNumber=r28
#                pDataState->dataPending = TRUE;
	.d2line		8696
	diab.li		r0,1		# headerLen=r0
	stb		r0,1(r25)		# pDataState=r25 headerLen=r0
	b		.L1992
.L2003:
#                break;
#             }
# 
#             default:
#             {
#                /* Dem_DcmGetFreezeFrameDataByDTC returned one of:
#                 *  DEM_GET_FFDATABYDTC_WRONG_DTC
#                 *  DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN
#                 */
#                /*
#                 * Release the previously located buffer.
#                 */
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)(dataRecordSize + headerLen));
	.d2line		8709
.Llo641:
	lhz		r3,8(r1)		# responseBufferResult=r3
.Llo659:
	rlwinm		r23,r23,0,24,31		# headerLen=r23 headerLen=r23
	add		r3,r3,r23		# responseBufferResult=r3 responseBufferResult=r3 headerLen=r23
	rlwinm		r3,r3,0,16,31		# responseBufferResult=r3 responseBufferResult=r3
.Llo660:
	bl		Dcm_DsdReleaseResponseBuffer
#                ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8710
	diab.li		r24,49		# ErrorCode=r24
.Llo649:
	b		.L1992
.L1995:
#                break;
#             }
# 
#          }
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == responseBufferResult)
#       {
#          /* Store last processed extended data record number and stay in this state.
#             * Retry buffer request next schedule */
#          pDataState->current_data_record_number = dataRecordNumber;
#          pDataState->dataPending = TRUE;
#       }
#       else if (DCM_INT_E_RESPONSE_FULL == responseBufferResult)
#       {
#          /*
#           * The whole length of the originally calculated response length have been filled
#           * Interrupt reading data and send a positive response directly.
#           */
#          pDataState->sendPositiveResponse = TRUE;
#       }
#       else if (E_NOT_OK == responseBufferResult)
#       {
#          /*
#           * Abort, make sense to retrieve the data.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned
#           *  DCM_INT_E_RESPONSE_TOO_LONG
#           *
#           * Abort, requested size can't possible fit in buffer.
#           */
#          ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		8748
.Llo636:
	diab.li		r24,20		# ErrorCode=r24
.L1992:
#       }
#    }
# 
#    return ErrorCode;
	.d2line		8752
.Llo637:
	rlwinm		r3,r24,0,24,31		# dtc=r3 ErrorCode=r24
.Llo638:
	mr		r3,r3		# dtc=r3
# }
	.d2line		8753
	.d2epilogue_begin
.Llo639:
	lmw		r23,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	2,10
.Llo650:
	lwz		r0,68(r1)		# headerLen=r0
	mtspr		lr,r0		# headerLen=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3759:
	.type		GetOneSnapShotDataRecord,@function
	.size		GetOneSnapShotDataRecord,.-GetOneSnapShotDataRecord
# Number of nodes = 208

# Allocations for GetOneSnapShotDataRecord
#	?a4		dtc
#	?a5		dtcStatus
#	?a6		dtcStatusIndicators
#	?a7		dataRecordNumber
#	?a8		DtcOrigin
#	?a9		isService19
#	?a10		pDataState
#	SP,8		dataRecordSize
#	?a11		demGetSizeRetVal
#	?a12		ErrorCode
#	?a13		responseBufferResult
#	SP,12		responseBuffer
#	?a14		getSnapshotRetVal
#	?a15		headerLen
# static FUNC(void, DCM_CODE) ReportDTCSnapshotRecordByDTCNumber(
	.align		1
	.section	.text_vle
        .d2line         7887,29
#$$ld
.L3788:

#$$bf	ReportDTCSnapshotRecordByDTCNumber,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCSnapshotRecordByDTCNumber:
.Llo672:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	25,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r25,r4		# pErrorCode=r25 pErrorCode=r4
	.d2prologue_end
#                                    CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                    CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    /*
#     * Storage for DTC/data records status information in case of paging
#     */
#    CONSTP2VAR(ReportAllDtcDataRecordByDTCNumberStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.dtc_data_records_status;
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		7896
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo673:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1793	# ne
	.section	.text_vle
.L3793:
#    {
#       /*
#        * Fetch data from request and store in service state
#        */
#       CONST(uint32, AUTOMATIC) Dtc = CONVERT_BE_TO_U32(&pMsgContext->reqData[1]);
	.d2line		7901
.Llo674:
	lwz		r3,0(r31)		# additionalHeaderSize=r3 pMsgContext=r31
.Llo682:
	lbz		r0,1(r3)		# additionalHeaderSize=r0 additionalHeaderSize=r3
	rlwinm		r0,r0,16,8,15		# additionalHeaderSize=r0 additionalHeaderSize=r0
	lbz		r4,2(r3)		# additionalHeaderSize=r3
	se_slwi		r4,8
	or		r4,r4,r0		# additionalHeaderSize=r0
	lbz		r0,3(r3)		# additionalHeaderSize=r0 additionalHeaderSize=r3
	or		r4,r4,r0		# additionalHeaderSize=r0
	rlwinm		r30,r4,0,8,31
.Llo686:
	mr		r30,r30		# Dtc=r30 Dtc=r30
#       CONST(uint8, AUTOMATIC) dataRecordNumber = pMsgContext->reqData[4];
	.d2line		7902
	lbz		r29,4(r3)		# additionalHeaderSize=r3
.Llo737:
	mr		r29,r29		# dataRecordNumber=r29 dataRecordNumber=r29
#       CONST(boolean, AUTOMATIC) includeMemorySelection = (boolean)(DCM_S19_SF18_USERDEFMEMORYDTCSNAPSHOTRECORDBYDTCNUMBER == pMsgContext->subServiceId);
	.d2line		7903
	lbz		r0,26(r31)		# additionalHeaderSize=r0 pMsgContext=r31
	xori		r0,r0,24		# additionalHeaderSize=r0 additionalHeaderSize=r0
	cntlzw		r28,r0		# includeMemorySelection=r28 additionalHeaderSize=r0
.Llo740:
	se_srwi		r28,5		# includeMemorySelection=r28 includeMemorySelection=r28
	mr		r28,r28		# includeMemorySelection=r28 includeMemorySelection=r28
#       CONST(Dcm_MsgLenType, AUTOMATIC) additionalHeaderSize = (Dcm_MsgLenType)(includeMemorySelection ? 1U : 0U); /* Add on extra byte to header for the MEMYS if available. */
	.d2line		7904
	rlwinm		r0,r28,0,24,31		# additionalHeaderSize=r0 includeMemorySelection=r28
	se_cmpi		r0,0		# additionalHeaderSize=r0
	diab.li		r0,1		# additionalHeaderSize=r0
	isel		r0,r3,r0,2		# additionalHeaderSize=r0 additionalHeaderSize=r3 additionalHeaderSize=r0
.L1832:
.Llo743:
	isel		r27,0,r0,2		# additionalHeaderSize=r27 additionalHeaderSize=r0
.L1833:
#       CONST(uint8, AUTOMATIC) memorySelection = (uint8)pMsgContext->reqData[5]; /* Assume MEMYS is available, it will not be used if not correct SF */
	.d2line		7905
.Llo744:
	lwz		r3,0(r31)		# additionalHeaderSize=r3 pMsgContext=r31
	lbz		r26,5(r3)		# additionalHeaderSize=r3
.Llo753:
	mr		r26,r26		# memorySelection=r26 memorySelection=r26
	.d2line		7894
	lis		r3,(Dcm_DspInstance+156)@ha		# additionalHeaderSize=r3
	stw		r30,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r3 Dtc=r30
	diab.li		r0,0		# additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+167)@ha		# additionalHeaderSize=r3
	stb		r0,(Dcm_DspInstance+167)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+166)@ha		# additionalHeaderSize=r3
	stb		r0,(Dcm_DspInstance+166)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+168)@ha		# additionalHeaderSize=r3
	stb		r29,(Dcm_DspInstance+168)@l(r3)		# additionalHeaderSize=r3 dataRecordNumber=r29
	lis		r3,(Dcm_DspInstance+171)@ha		# additionalHeaderSize=r3
	stb		r0,(Dcm_DspInstance+171)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r0
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetDTCOriginReadDTCInformation
	lis		r4,(Dcm_DspInstance+173)@ha
	stb		r3,(Dcm_DspInstance+173)@l(r4)		# pMsgContext=r3
# 
#       Dcm_MsgLenType totalAnswerSize;
#       P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) responseBuffer;
#       uint8    dtcStatus;
# 
#       pStatus->dtc_id = Dtc;
#       pStatus->dataState.dataPending = FALSE;
#       pStatus->dataState.sendPositiveResponse = FALSE;
#       pStatus->dataState.request_data_record_number = dataRecordNumber;
#       pStatus->dataState.dataRecordFound = FALSE;
#       pStatus->dtc_origin = GetDTCOriginReadDTCInformation(pMsgContext);
# 
#       if (DCM_ALL_DATA_RECORD_REQ == dataRecordNumber)
	.d2line		7918
	rlwinm		r5,r29,0,24,31		# dataRecordNumber=r29
	cmpi		0,0,r5,255
	bc		0,2,.L1794	# ne
	.d2line		7894
	diab.li		r0,0		# additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+169)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+169)@l(r3)		# pMsgContext=r3 additionalHeaderSize=r0
	b		.L1795
.L1794:
	lis		r3,(Dcm_DspInstance+169)@ha		# pMsgContext=r3
	stb		r29,(Dcm_DspInstance+169)@l(r3)		# pMsgContext=r3 dataRecordNumber=r29
.L1795:
#       {
#          pStatus->dataState.current_data_record_number = DCM_FIRST_SNAPSHOT_DATA_RECORD;
#       }
#       else
#       {
#          pStatus->dataState.current_data_record_number = dataRecordNumber;
#       }
# 
#       /* The length of request has been validated in Dcm_ReadDTCInformation. */
#       if (DTC_GROUP_ALL_DTCS == Dtc)
	.d2line		7928
	diab.li		r0,16777215		# additionalHeaderSize=r0
	se_cmpl		r30,r0		# Dtc=r30 additionalHeaderSize=r0
	bc		0,2,.L1796	# ne
#       {
#          /*
#           * Shall never be 0xFFFFFF.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7933
	diab.li		r0,49		# additionalHeaderSize=r0
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1796:
#       }
#       /*
#        * Avoid updates during reading.
#        */
#       else if (DEM_DISABLE_DTCRECUP_OK != Dem_DcmDisableDTCRecordUpdate(Dtc, pStatus->dtc_origin))
	.d2line		7938
	lis		r3,(Dcm_DspInstance+173)@ha		# pMsgContext=r3
	lbz		r4,(Dcm_DspInstance+173)@l(r3)		# pMsgContext=r3
	mr		r3,r30		# Dtc=r3 Dtc=r30
	bl		Dem_DcmDisableDTCRecordUpdate
	rlwinm		r3,r3,0,24,31		# Dtc=r3 Dtc=r3
	se_cmpi		r3,0		# Dtc=r3
	bc		1,2,.L1798	# eq
#       {
#          /*
#           * DEM_DISABLE_DTCRECUP_WRONG_DTC
#           * DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7944
	diab.li		r0,49		# additionalHeaderSize=r0
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1798:
#       }
#       /*
#        * Get DTC statusbits
#        */
#       else if (DEM_STATUS_OK != Dem_DcmGetStatusOfDTC(Dtc,
	.d2line		7949
	lis		r3,(Dcm_DspInstance+173)@ha		# Dtc=r3
	lbz		r4,(Dcm_DspInstance+173)@l(r3)		# Dtc=r3
	diab.addi		r5,r1,8
	mr		r3,r30		# Dtc=r3 Dtc=r30
	bl		Dem_DcmGetStatusOfDTC
	rlwinm		r3,r3,0,24,31		# Dtc=r3 Dtc=r3
	se_cmpi		r3,0		# Dtc=r3
	bc		1,2,.L1800	# eq
#                                                    pStatus->dtc_origin,
#                                                    &dtcStatus))
#       {
#          /* Error reading DTC status bits */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7954
	diab.li		r0,49		# additionalHeaderSize=r0
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1800:
#       }
#       else if (DEM_GETSIZEBYDTC_OK != Dem_DcmGetSizeOfFreezeFrameByDTC(Dtc,
	.d2line		7956
	lis		r3,(Dcm_DspInstance+173)@ha		# Dtc=r3
	lbz		r4,(Dcm_DspInstance+173)@l(r3)		# Dtc=r3
	rlwinm		r5,r29,0,24,31		# dataRecordNumber=r29
	diab.addi		r6,r1,10
	mr		r3,r30		# Dtc=r3 Dtc=r30
	bl		Dem_DcmGetSizeOfFreezeFrameByDTC
	rlwinm		r3,r3,0,24,31		# Dtc=r3 Dtc=r3
	se_cmpi		r3,0		# Dtc=r3
	bc		1,2,.L1802	# eq
#                                                                     pStatus->dtc_origin,
#                                                                     dataRecordNumber,
#                                                                     &totalAnswerSize))
#       {
#          /*
#           * Dem_DcmGetSizeOfFreezeFrameByDTC returned one of the following:
#           *  DEM_GETSIZEBYDTC_WRONG_DTC
#           *  DEM_GETSIZEBYDTC_WRONG_DTCORIGIN
#           *  DEM_GETSIZEBYDTC_WRONG_RECNUM
#           *  DEM_GETSIZEBYDTC_PENDING
#           *
#           * Abort, failure will be handled below
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7970
	diab.li		r0,49		# additionalHeaderSize=r0
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1802:
#       }
#       else if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(totalAnswerSize + DCM_REPORTSNAPSHOTDATARECORDBYDTC_ANSWERSIZE + additionalHeaderSize))
	.d2line		7972
	lhz		r3,10(r1)		# Dtc=r3
	se_add		r3,r27		# Dtc=r3 Dtc=r3 additionalHeaderSize=r27
	se_addi		r3,5		# Dtc=r3 Dtc=r3
	rlwinm		r3,r3,0,16,31		# Dtc=r3 Dtc=r3
	bl		Dcm_DsdStartResponse
	rlwinm		r3,r3,0,24,31		# Dtc=r3 Dtc=r3
	cmpi		0,0,r3,200		# Dtc=r3
	bc		0,2,.L1804	# ne
#       {
#          *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		7974
	diab.li		r0,20		# additionalHeaderSize=r0
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1804:
#       }
#       else if (E_OK != Dcm_DsdRequestResponseBuffer(DCM_REPORTSNAPSHOTDATARECORDBYDTC_ANSWERSIZE + additionalHeaderSize, &responseBuffer))
	.d2line		7976
	diab.addi		r3,r27,5		# Dtc=r3 additionalHeaderSize=r27
	rlwinm		r3,r3,0,16,31		# Dtc=r3 Dtc=r3
	diab.addi		r4,r1,12
	bl		Dcm_DsdRequestResponseBuffer
	rlwinm		r3,r3,0,24,31		# Dtc=r3 Dtc=r3
	se_cmpi		r3,0		# Dtc=r3
	bc		1,2,.L1806	# eq
#       {
#          /*
#           * This shall not happen since SCG guarantee the response buffer is at least 8 bytes.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		7981
.Llo745:
	diab.li		r0,49		# additionalHeaderSize=r0
.Llo746:
	stb		r0,0(r25)		# pErrorCode=r25 additionalHeaderSize=r0
	b		.L1793
.L1806:
#       }
#       else
#       {
#          /*
#           * Fill in mandatory response data
#           */
#          responseBuffer[0] = pMsgContext->subServiceId;
	.d2line		7988
.Llo741:
	lbz		r0,26(r31)		# additionalHeaderSize=r0 pMsgContext=r31
.Llo747:
	lwz		r3,12(r1)		# Dtc=r3
	stb		r0,0(r3)		# Dtc=r3 additionalHeaderSize=r0
# 
#          /*
#           * Add an echo of the memory selection in case of SF 0x18 [SWS_Dcm_00302] [SWS_Dcm_00387]
#           */
#          if (includeMemorySelection)
	.d2line		7993
.Llo742:
	rlwinm		r28,r28,0,24,31		# includeMemorySelection=r28 includeMemorySelection=r28
	se_cmpi		r28,0		# includeMemorySelection=r28
	bc		1,2,.L1808	# eq
#          {
#             responseBuffer[1] = memorySelection;
	.d2line		7995
.Llo675:
	lwz		r3,12(r1)		# Dtc=r3
	stb		r26,1(r3)		# Dtc=r3 memorySelection=r26
#             SET_RESPONSE_DTC(&responseBuffer[2], Dtc);
	.d2line		7996
	rlwinm		r0,r30,16,24,31		# additionalHeaderSize=r0 Dtc=r30
.Llo748:
	lwz		r3,12(r1)		# Dtc=r3
	stb		r0,2(r3)		# Dtc=r3 additionalHeaderSize=r0
	mr		r0,r30		# Dtc=r0 Dtc=r30
.Llo749:
	rlwinm		r4,r0,24,24,31		# Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r4,3(r3)		# Dtc=r3
	rlwinm		r0,r0,0,24,31		# Dtc=r0 Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r30,4(r3)		# Dtc=r3 Dtc=r30
#             responseBuffer[5] = dtcStatus;
	.d2line		7997
	lbz		r0,8(r1)		# Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r0,5(r3)		# Dtc=r3 Dtc=r0
	b		.L1810
.L1808:
#          }
#          else
#          {
#             SET_RESPONSE_DTC(&responseBuffer[1], Dtc);
	.d2line		8001
	rlwinm		r0,r30,16,24,31		# additionalHeaderSize=r0 Dtc=r30
.Llo750:
	lwz		r3,12(r1)		# Dtc=r3
	stb		r0,1(r3)		# Dtc=r3 additionalHeaderSize=r0
	mr		r0,r30		# Dtc=r0 Dtc=r30
.Llo751:
	rlwinm		r4,r0,24,24,31		# Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r4,2(r3)		# Dtc=r3
	rlwinm		r0,r0,0,24,31		# Dtc=r0 Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r30,3(r3)		# Dtc=r3 Dtc=r30
#             responseBuffer[4] = dtcStatus;
	.d2line		8002
	lbz		r0,8(r1)		# Dtc=r0
	lwz		r3,12(r1)		# Dtc=r3
	stb		r0,4(r3)		# Dtc=r3 Dtc=r0
.L1810:
#          }
# 
#          if ((0 == totalAnswerSize) && (dataRecordNumber != DCM_ALL_DATA_RECORD_REQ))
	.d2line		8005
.Llo687:
	lhz		r0,10(r1)		# Dtc=r0
.Llo688:
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1812	# ne
	rlwinm		r29,r29,0,24,31		# Dtc=r29 dataRecordNumber=r29
.Llo738:
	cmpi		0,0,r29,255		# Dtc=r29
	bc		0,2,.L1793	# ne
.L1812:
#          {
#             /*
#              * If a valid snapshot record has no data an empty positive response is returned
#              */
#          }
#          else
#          {
#             /*
#              * If a request for all records returns no data further processing is required to determine
#              * whether all records are invalid, if so NRC 0x31 shall be returned
#              */
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		8017
.Llo739:
	diab.li		r0,1		# Dtc=r0
	lis		r3,(Dcm_DspInstance+8)@ha		# Dtc=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# Dtc=r3 Dtc=r0
	.section	.text_vle
.L3794:
.L1793:
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		8022
.Llo676:
	lis		r3,(Dcm_DspInstance+8)@ha		# Dtc=r3
.Llo689:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# additionalHeaderSize=r0 Dtc=r3
.Llo752:
	se_cmpi		r0,1		# additionalHeaderSize=r0
	bc		0,2,.L1814	# ne
	.d2line		7894
.Llo677:
	diab.li		r0,0		# Dtc=r0
.Llo690:
	lis		r3,(Dcm_DspInstance+164)@ha		# Dtc=r3
	sth		r0,(Dcm_DspInstance+164)@l(r3)		# Dtc=r3 Dtc=r0
	lis		r3,(Dcm_DspInstance+167)@ha		# Dtc=r3
	stb		r0,(Dcm_DspInstance+167)@l(r3)		# Dtc=r3 Dtc=r0
#    {
#       pStatus->maxNumberRecordsCounter = 0;
# 
#       /*
#        * Reset dataPending before starting to read data.
#        */
#       pStatus->dataState.dataPending = FALSE;
# 
#       if (DCM_ALL_DATA_RECORD_REQ == pStatus->dataState.request_data_record_number)
	.d2line		8031
	lis		r3,(Dcm_DspInstance+168)@ha		# Dtc=r3
	lbz		r0,(Dcm_DspInstance+168)@l(r3)		# Dtc=r0 Dtc=r3
	cmpi		0,0,r0,255		# Dtc=r0
	bc		0,2,.L1815	# ne
	.section	.text_vle
.L3810:
#       {
#          uint8 snapDataNumberLoop;
#          uint8 recordNumber = 0;
	.d2line		8034
.Llo691:
	diab.li		r0,0		# recordNumber=r0
#          for (snapDataNumberLoop = pStatus->dataState.current_data_record_number;
	.d2line		8035
	lis		r3,(Dcm_DspInstance+169)@ha		# Dtc=r3
.Llo692:
	lbz		r31,(Dcm_DspInstance+169)@l(r3)		# pMsgContext=r31 Dtc=r3
.Llo754:
	mr		r31,r31		# snapDataNumberLoop=r31 snapDataNumberLoop=r31
.L1816:
.Llo693:
	rlwinm		r0,r31,0,24,31		# Dtc=r0 snapDataNumberLoop=r31
.Llo694:
	lis		r3,(Dcm_LCfg+128)@ha		# Dtc=r3
	lbz		r3,(Dcm_LCfg+128)@l(r3)		# Dtc=r3 Dtc=r3
	se_cmp		r0,r3		# Dtc=r0 Dtc=r3
	bc		0,0,.L1818	# ge
.Llo695:
	lbz		r0,0(r25)		# Dtc=r0 pErrorCode=r25
.Llo696:
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1818	# ne
.Llo697:
	lis		r3,(Dcm_DspInstance+166)@ha		# Dtc=r3
.Llo698:
	lbz		r0,(Dcm_DspInstance+166)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1818	# ne
.Llo699:
	lis		r3,(Dcm_DspInstance+167)@ha		# Dtc=r3
.Llo700:
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1818	# ne
	.d2line		7894
.Llo701:
	lis		r3,(Dcm_DspInstance+164)@ha		# Dtc=r3
.Llo702:
	lhz		r0,(Dcm_DspInstance+164)@l(r3)		# Dtc=r0 Dtc=r3
	lis		r3,Dcm_LCfg@ha		# Dtc=r3
.Llo703:
	lhz		r3,Dcm_LCfg@l(r3)		# Dtc=r3 Dtc=r3
.Llo704:
	se_cmp		r0,r3		# Dtc=r0 Dtc=r3
	bc		0,0,.L1818	# ge
#              (snapDataNumberLoop < Dcm_LCfg.num_freezeframe_records) &&
#              (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode) &&
#              (FALSE == pStatus->dataState.sendPositiveResponse) && /* More data produced under reading. */
#              (FALSE == pStatus->dataState.dataPending) &&           /* Response buffer is not available. */
#              (pStatus->maxNumberRecordsCounter < Dcm_LCfg.maxNumberOfRecords); /* If maximum number of records during one schedule has reached? */
#              snapDataNumberLoop++)
#          {
#             /*
#              * Start to read all data.
#              * Typecasting below is safe as record number shall not be greater than FF.
#              */
#             recordNumber = (uint8)((NULL_PTR == Dcm_LCfg.p_freezeframe_records) ?
	.d2line		8047
.Llo705:
	lis		r3,(Dcm_LCfg+132)@ha		# Dtc=r3
.Llo706:
	lwz		r0,(Dcm_LCfg+132)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1834	# ne
.Llo707:
	mr		r6,r31		# snapDataNumberLoop=r6 snapDataNumberLoop=r31
.Llo755:
	b		.L1835
.L1834:
.Llo756:
	lis		r3,(Dcm_LCfg+132)@ha		# Dtc=r3
.Llo708:
	lwz		r3,(Dcm_LCfg+132)@l(r3)		# Dtc=r3 Dtc=r3
	rlwinm		r0,r31,0,24,31		# Dtc=r0 snapDataNumberLoop=r31
	lbzx		r6,r3,r0		# snapDataNumberLoop=r6 Dtc=r3
.L1835:
.Llo709:
	mr		r6,r6		# recordNumber=r6 recordNumber=r6
#                            snapDataNumberLoop : Dcm_LCfg.p_freezeframe_records[snapDataNumberLoop]);
# 
#             *pErrorCode = GetOneSnapShotDataRecord(pStatus->dtc_id,
	.d2line		8050
.Llo757:
	lis		r3,(Dcm_DspInstance+156)@ha		# Dtc=r3
.Llo710:
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# Dtc=r3 Dtc=r3
.Llo711:
	lis		r4,(Dcm_DspInstance+173)@ha		# Dtc=r4
.Llo712:
	lbz		r7,(Dcm_DspInstance+173)@l(r4)		# Dtc=r4
	lis		r9,(Dcm_DspInstance+166)@ha
	e_add16i		r9,r9,(Dcm_DspInstance+166)@l
	diab.li		r4,0		# Dtc=r4
.Llo713:
	diab.li		r5,0
	mr		r6,r6		# snapDataNumberLoop=r6 snapDataNumberLoop=r6
	diab.li		r8,1
	bl		GetOneSnapShotDataRecord
.Llo678:
	stb		r3,0(r25)		# pErrorCode=r25 pMsgContext=r3
	.d2line		7894
	lis		r4,(Dcm_DspInstance+164)@ha		# Dtc=r4
.Llo714:
	lhz		r3,(Dcm_DspInstance+164)@l(r4)		# pMsgContext=r3 Dtc=r4
	se_addi		r3,1		# pMsgContext=r3 pMsgContext=r3
	sth		r3,(Dcm_DspInstance+164)@l(r4)		# Dtc=r4 pMsgContext=r3
#                                                         0, /* dtcStatus, not used for service 0x19, subfunction 0x04 */
#                                                         0, /* dtcStatusIndicators, not used for service 0x19, subfunction 0x04*/
#                                                         recordNumber, /* dataRecordNumber*/
#                                                         pStatus->dtc_origin,
#                                                         TRUE,
#                                                         &pStatus->dataState);
#             pStatus->maxNumberRecordsCounter++;
#          }
	.d2line		8058
	diab.addi		r0,r31,1		# Dtc=r0 snapDataNumberLoop=r31
	se_addi		r31,1		# snapDataNumberLoop=r31 snapDataNumberLoop=r31
	b		.L1816
.L1818:
# 
#          if (DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode)
	.d2line		8060
.Llo679:
	lbz		r0,0(r25)		# Dtc=r0 pErrorCode=r25
.Llo715:
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1814	# ne
#          {
#             /* A negative response will be sent later. */
#          }
#          else if (FALSE != pStatus->dataState.dataPending)
	.d2line		8064
.Llo716:
	lis		r3,(Dcm_DspInstance+167)@ha		# Dtc=r3
.Llo717:
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		1,2,.L1821	# eq
#          {
#             /* Continue to read later. */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8067
.Llo718:
	diab.li		r0,162		# Dtc=r0
.Llo719:
	stb		r0,0(r25)		# pErrorCode=r25 Dtc=r0
	b		.L1814
.L1821:
#          }
#          else if (FALSE != pStatus->dataState.sendPositiveResponse)
	.d2line		8069
.Llo720:
	lis		r3,(Dcm_DspInstance+166)@ha		# Dtc=r3
.Llo721:
	lbz		r0,(Dcm_DspInstance+166)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1814	# ne
#          {
#             /* A positive response will be sent later. */
#          }
#          else if (snapDataNumberLoop >= Dcm_LCfg.num_freezeframe_records)
	.d2line		8073
.Llo722:
	rlwinm		r0,r31,0,24,31		# Dtc=r0 snapDataNumberLoop=r31
.Llo723:
	lis		r3,(Dcm_LCfg+128)@ha		# Dtc=r3
	lbz		r3,(Dcm_LCfg+128)@l(r3)		# Dtc=r3 Dtc=r3
	se_cmp		r0,r3		# Dtc=r0 Dtc=r3
	bc		1,0,.L1825	# lt
#          {
#             /* All records processed with no fatal errors, send response */
#             if (FALSE == pStatus->dataState.dataRecordFound)
	.d2line		8076
.Llo724:
	lis		r3,(Dcm_DspInstance+171)@ha		# Dtc=r3
.Llo725:
	lbz		r0,(Dcm_DspInstance+171)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		0,2,.L1814	# ne
#             {
#                /*
#                 * No valid data record was found
#                 */
#                *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8081
.Llo726:
	diab.li		r0,49		# Dtc=r0
.Llo727:
	stb		r0,0(r25)		# pErrorCode=r25 Dtc=r0
	b		.L1814
.L1825:
	.d2line		7894
.Llo728:
	lis		r3,(Dcm_DspInstance+169)@ha		# Dtc=r3
.Llo729:
	stb		r31,(Dcm_DspInstance+169)@l(r3)		# Dtc=r3 snapDataNumberLoop=r31
#             }
#          }
#          else
#          {
#             /*
#              * Break when maxNumberOfRecords has been reached and try later.
#              */
#             pStatus->dataState.current_data_record_number = snapDataNumberLoop;
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8090
	diab.li		r0,162		# Dtc=r0
	stb		r0,0(r25)		# pErrorCode=r25 Dtc=r0
	.section	.text_vle
.L3811:
.Llo730:
	b		.L1814
.L1815:
#          }
#       }
#       else
#       {
#          *pErrorCode = GetOneSnapShotDataRecord(pStatus->dtc_id,
	.d2line		8095
	lis		r3,(Dcm_DspInstance+156)@ha		# Dtc=r3
.Llo731:
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# Dtc=r3 Dtc=r3
.Llo732:
	lis		r4,(Dcm_DspInstance+168)@ha
	lbz		r6,(Dcm_DspInstance+168)@l(r4)
	lis		r4,(Dcm_DspInstance+173)@ha
	lbz		r7,(Dcm_DspInstance+173)@l(r4)
	lis		r9,(Dcm_DspInstance+166)@ha
	e_add16i		r9,r9,(Dcm_DspInstance+166)@l
	diab.li		r4,0
	diab.li		r5,0
	diab.li		r8,1
	bl		GetOneSnapShotDataRecord
.Llo680:
	stb		r3,0(r25)		# pErrorCode=r25 pMsgContext=r3
	.d2line		7894
	lis		r3,(Dcm_DspInstance+167)@ha		# Dtc=r3
.Llo681:
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# Dtc=r0 Dtc=r3
	se_cmpi		r0,0		# Dtc=r0
	bc		1,2,.L1814	# eq
#                                                      0, /* dtcStatus, not used for service 0x19, subfunction 0x04 */
#                                                      0, /*  dtcStatusIndicators, not used for service 0x19, subfunction 0x04*/
#                                                      pStatus->dataState.request_data_record_number, /* dataRecordNumber*/
#                                                      pStatus->dtc_origin,
#                                                      TRUE,
#                                                      &pStatus->dataState);
# 
#          if (pStatus->dataState.dataPending)
#          {
#             /*
#              * More data to fetch
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8108
.Llo733:
	diab.li		r0,162		# Dtc=r0
.Llo734:
	stb		r0,0(r25)		# pErrorCode=r25 Dtc=r0
.L1814:
#          }
#       }
#    }
# 
#    /*
#     * Generic handling for all cases when execution shall terminate.
#     * Enable dtc record updates and send response.
#     */
#    if (DCM_INT_NRC_API_RETURNED_PENDING != *pErrorCode)
	.d2line		8117
.Llo735:
	lbz		r0,0(r25)		# Dtc=r0 pErrorCode=r25
.Llo736:
	cmpi		0,0,r0,162		# Dtc=r0
	bc		1,2,.L1792	# eq
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Service completed, enable the DTC record update again, too late to send an NRC.
#        */
#       (void)Dem_DcmEnableDTCRecordUpdate();
	.d2line		8124
.Llo683:
	bl		Dem_DcmEnableDTCRecordUpdate
.L1792:
#    }
#    else
#    {
#       /* No termination requested, service will execute again next schedule */
#    }
# }
	.d2line		8130
	.d2epilogue_begin
.Llo684:
	lmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)		# Dtc=r0
	mtspr		lr,r0		# Dtc=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo685:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3789:
	.type		ReportDTCSnapshotRecordByDTCNumber,@function
	.size		ReportDTCSnapshotRecordByDTCNumber,.-ReportDTCSnapshotRecordByDTCNumber
# Number of nodes = 631

# Allocations for ReportDTCSnapshotRecordByDTCNumber
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$50
#	not allocated	pStatus
#	?a7		Dtc
#	?a8		dataRecordNumber
#	?a9		includeMemorySelection
#	?a10		additionalHeaderSize
#	?a11		memorySelection
#	SP,10		totalAnswerSize
#	SP,12		responseBuffer
#	SP,8		dtcStatus
#	?a12		snapDataNumberLoop
#	?a13		recordNumber
# static FUNC(void, DCM_CODE) ReportDTCSnapshotRecordByRecordNumber(P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         8135,29
#$$ld
.L3820:

#$$bf	ReportDTCSnapshotRecordByRecordNumber,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCSnapshotRecordByRecordNumber:
.Llo758:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
.Llo759:
	mr		r30,r4		# pErrorCode=r30 pErrorCode=r4
	.d2prologue_end
#                                                                   CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(Dcm_MsgItemType, AUTOMATIC) recordNumber = pMsgContext->reqData[1]; /* Length already checked in Dcm_ReadDTCInformation */
	.d2line		8138
.Llo760:
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r29,1(r3)		# recordNumber=r29
	mr		r29,r29		# recordNumber=r29 recordNumber=r29
#    uint32   Dtc;
#    uint8    DtcStatus;
# 
#    /*
#     * dtcIndex = 2 (subfunction + record number) bytes
#     * shall be squeezed in before the DTC if a snapshot data record is found.
#     */
#    CONST(uint16, AUTOMATIC) dtcIndex = (uint16)2U;
# 
#    /*
#     * dataIndex = 2 (subfunction + record number) + 3 (DTC) + 1 (DTC status) = 6 bytes
#     * shall be squeezed in before the data if a snapshot data record is found.
#     */
#    CONST(uint16, AUTOMATIC) dataIndex = (uint16)6U;
# 
#    /*
#     * The available bufSize (after removing subfunction, record number, DTC and DTC status)
#     * shall be fed to Dem_DcmGetOBDFreezeFrameData
#     */
#    uint16 bufSize = (uint16)(pMsgContext->resMaxDataLen - dataIndex);
	.d2line		8158
	lhz		r0,20(r31)		# pMsgContext=r31
	diab.li		r3,65530
	se_add		r0,r3
	sth		r0,10(r1)
# 
#    /*
#     * [SWS_Dcm_00632]
#     * Only record number 0x00 is allowed.
#     */
#    if (0x00 != recordNumber)
	.d2line		8164
	rlwinm		r0,r29,0,24,31		# recordNumber=r29
	se_cmpi		r0,0
	bc		1,2,.L1860	# eq
#    {
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8166
.Llo762:
	diab.li		r0,49
.Llo763:
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1859
.L1860:
#    }
#    /*
#     * [SWS_Dcm_00388]
#     */
#    else if (E_OK != Dem_DcmGetOBDFreezeFrameData(&Dtc, &(pMsgContext->resData[dataIndex]), &bufSize))
	.d2line		8171
	lwz		r4,8(r31)		# pMsgContext=r31
	se_addi		r4,6
	diab.addi		r3,r1,12
	diab.addi		r5,r1,10
	bl		Dem_DcmGetOBDFreezeFrameData
	e_andi.		r3,r3,255
	bc		1,2,.L1862	# eq
#    {
#       /*
#        * Failed to retreive data. Return error according to ISO 14229:2013, Table 286
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8176
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1859
.L1862:
#    }
#    /*
#     * [SWS_Dcm_00389]
#     * Snapshot data was received, DTC (3 bytes) and DTC status shall be included in the response.
#     */
#    else if (DEM_STATUS_OK != Dem_DcmGetStatusOfDTC(Dtc,
	.d2line		8182
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetDTCOriginReadDTCInformation
	mr		r4,r3		# pMsgContext=r4
	lwz		r3,12(r1)		# pMsgContext=r3
	rlwinm		r4,r4,0,24,31		# pMsgContext=r4 pMsgContext=r4
	diab.addi		r5,r1,8
	bl		Dem_DcmGetStatusOfDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1864	# eq
#                                                    GetDTCOriginReadDTCInformation(pMsgContext),
#                                                    &DtcStatus))
#    {
#       /*
#        * Failed to retreive DTC status. Return error according to ISO 14229:2013, Table 286
#        * One of the following error codes:
#        *   DEM_STATUS_WRONG_DTC
#        *   DEM_STATUS_WRONG_DTCORIGIN
#        *   DEM_STATUS_FAILED
#        *   DEM_STATUS_PENDING (not yet supported by the DEM)
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8194
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1859
.L1864:
#    }
#    else
#    {
#       /*
#        * [SWS_Dcm_00574]
#        * Create the positive response with the fetched data.
#        */
#       pMsgContext->resData[0] = (Dcm_MsgItemType)DCM_S19_SF05_DTCSNAPSHOTRECORDBYRECORDNUMBER;
	.d2line		8202
	diab.li		r0,5
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,0(r3)		# pMsgContext=r3
#       pMsgContext->resData[1] = recordNumber; /* Record number */
	.d2line		8203
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r29,1(r3)		# pMsgContext=r3 recordNumber=r29
# 
#       SET_RESPONSE_DTC(&pMsgContext->resData[dtcIndex], Dtc);
	.d2line		8205
	lwz		r0,12(r1)
	rlwinm		r0,r0,16,24,31
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,2(r3)		# pMsgContext=r3
	lhz		r0,14(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,3(r3)		# pMsgContext=r3
	lbz		r0,15(r1)
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,4(r3)		# pMsgContext=r3
#       pMsgContext->resData[dtcIndex + 3U] = (Dcm_MsgItemType)DtcStatus;
	.d2line		8206
	lbz		r0,8(r1)
	lwz		r3,8(r31)		# pMsgContext=r3 pMsgContext=r31
	stb		r0,5(r3)		# pMsgContext=r3
# 
#       pMsgContext->resDataLen = dataIndex + bufSize; /* bufSize is updated during the call to Dem_DcmGetOBDFreezeFrameData */
	.d2line		8208
	lhz		r3,10(r1)		# pMsgContext=r3
	se_addi		r3,6		# pMsgContext=r3 pMsgContext=r3
	sth		r3,12(r31)		# pMsgContext=r31 pMsgContext=r3
.L1859:
#    }
# }
	.d2line		8210
	.d2epilogue_begin
.Llo761:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
.Llo764:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo765:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3821:
	.type		ReportDTCSnapshotRecordByRecordNumber,@function
	.size		ReportDTCSnapshotRecordByRecordNumber,.-ReportDTCSnapshotRecordByRecordNumber
# Number of nodes = 154

# Allocations for ReportDTCSnapshotRecordByRecordNumber
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$51
#	?a7		recordNumber
#	SP,12		Dtc
#	SP,8		DtcStatus
#	not allocated	dtcIndex
#	not allocated	dataIndex
#	SP,10		bufSize
# static FUNC(uint8, DCM_CODE) GetStartIndexOfEDR(uint8 subServiceIdentifier, uint8 reqDataNumber)
	.align		1
	.section	.text_vle
        .d2line         8215,30
#$$ld
.L3834:

#$$bf	GetStartIndexOfEDR,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,cr0,lr
	.d2_cfa_start __cie
GetStartIndexOfEDR:
.Llo766:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
.Llo781:
	stw		r0,20(r1)		# startindex=r0
	.d2_cfa_offset    108,-1
	mr		r3,r3		# subServiceIdentifier=r3 subServiceIdentifier=r3
	mr		r4,r4		# reqDataNumber=r4 reqDataNumber=r4
	.d2prologue_end
# {
#    uint8 startindex = 0;
	.d2line		8217
	diab.li		r0,0		# startindex=r0
# 
#    if (DCM_S19_SF04_DTCSNAPSHOTRECORDBYDTCNUMBER == subServiceIdentifier)
	.d2line		8219
	rlwinm		r3,r3,0,24,31		# subServiceIdentifier=r3 subServiceIdentifier=r3
	se_cmpi		r3,4		# subServiceIdentifier=r3
	bc		0,2,.L1872	# ne
#    {
#       /*
#        * sub-service: 0x04
#        */
#       startindex = DCM_FIRST_SNAPSHOT_DATA_RECORD;
	.d2line		8224
.Llo767:
	diab.li		r3,0		# startindex=r3
	b		.L1873
.L1872:
#    }
#    else if (NULL_PTR == Dcm_LCfg.p_extendeddata_records)
	.d2line		8226
	lis		r3,(Dcm_LCfg+140)@ha		# subServiceIdentifier=r3
.Llo768:
	lwz		r3,(Dcm_LCfg+140)@l(r3)		# subServiceIdentifier=r3 subServiceIdentifier=r3
	se_cmpi		r3,0		# subServiceIdentifier=r3
	bc		0,2,.L1874	# ne
#    {
#       /*
#        * No Dem configuration available, get the start index according to Dem076
#        */
#       startindex = (DCM_ALL_DATA_RECORD_REQ == reqDataNumber) ? DCM_FIRST_ALL_EXT_DATA_RECORD : DCM_FIRST_OBD_EXT_DATA_RECORD;
	.d2line		8231
.Llo769:
	rlwinm		r4,r4,0,24,31		# reqDataNumber=r4 reqDataNumber=r4
	cmpi		0,0,r4,255		# reqDataNumber=r4
	diab.li		r3,1		# subServiceIdentifier=r3
.Llo770:
	isel		r3,r3,r0,2		# subServiceIdentifier=r3 subServiceIdentifier=r3 startindex=r0
.L1880:
.Llo778:
	diab.li		r0,144		# startindex=r0
.Llo782:
	isel		r3,r3,r0,2		# subServiceIdentifier=r3 subServiceIdentifier=r3 startindex=r0
.L1881:
.Llo771:
	mr		r3,r3		# startindex=r3 startindex=r3
.Llo783:
	b		.L1873
.L1874:
#    }
#    else if (DCM_ALL_OBD_DATA_RECORD_REQ == reqDataNumber)
	.d2line		8233
.Llo779:
	rlwinm		r3,r4,0,24,31		# subServiceIdentifier=r3 reqDataNumber=r4
.Llo772:
	cmpi		0,0,r3,254		# subServiceIdentifier=r3
	bc		0,2,.L1876	# ne
#    {
#       /*
#        * Require only OBD data: only allowed in service 0x19.
#        * see comments in IsExtendedDataRecordValid.
#        */
#       startindex = Dcm_LCfg.index_obdedr_start;
	.d2line		8239
.Llo773:
	lis		r3,(Dcm_LCfg+144)@ha		# subServiceIdentifier=r3
.Llo774:
	lbz		r3,(Dcm_LCfg+144)@l(r3)		# subServiceIdentifier=r3 subServiceIdentifier=r3
.Llo775:
	mr		r3,r3		# startindex=r3 startindex=r3
	b		.L1873
.L1876:
#    }
#    else if (DCM_ALL_DATA_RECORD_REQ == reqDataNumber)
	.d2line		8241
	rlwinm		r3,r4,0,24,31		# subServiceIdentifier=r3 reqDataNumber=r4
.Llo776:
	cmpi		0,0,r3,255		# subServiceIdentifier=r3
#    {
#       /* The start index is 0 of the array p_extendeddata_records. */
#       startindex = 0x00;
	.d2line		8244
	isel		r3,0,r0,2		# startindex=r3 startindex=r0
.L1878:
#    }
#    else
#    {
#       /* Require a specific extended data record. */
#       startindex = reqDataNumber;
	.d2line		8249
.Llo777:
	isel		r3,r3,r4,2		# startindex=r3 startindex=r3 reqDataNumber=r4
.L1873:
#    }
# 
#    return startindex;
	.d2line		8252
.Llo780:
	rlwinm		r3,r3,0,24,31		# startindex=r3 startindex=r3
# }
	.d2line		8253
	.d2epilogue_begin
.Llo784:
	lwz		r0,20(r1)		# startindex=r0
	mtspr		lr,r0		# startindex=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3835:
	.type		GetStartIndexOfEDR,@function
	.size		GetStartIndexOfEDR,.-GetStartIndexOfEDR
# Number of nodes = 58

# Allocations for GetStartIndexOfEDR
#	?a4		subServiceIdentifier
#	?a5		reqDataNumber
#	?a6		$$52
#	?a7		startindex
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) GetOneExtendedDataRecordByDtc(uint32               Dtc,
	.align		1
	.section	.text_vle
        .d2line         8759,53
#$$ld
.L3843:

#$$bf	GetOneExtendedDataRecordByDtc,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetOneExtendedDataRecordByDtc:
.Llo785:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# Dtc=r31 Dtc=r3
.Llo786:
	mr		r30,r4		# DtcOrigin=r30 DtcOrigin=r4
.Llo787:
	mr		r29,r5		# recordNumber=r29 recordNumber=r5
	mr		r28,r6		# pDataState=r28 pDataState=r6
	.d2prologue_end
#                                                                                   Dem_DTCOriginType    DtcOrigin,
#                                                                                   uint8                recordNumber,
#                                                                                   CONSTP2VAR(ReadExtendedOrSnapshotDataRecordByDTCStatusType, AUTOMATIC, DCM_APPL_DATA) pDataState)
# {
#    Dem_ReturnGetSizeOfDataByDTCType demGetSizeRetVal;
#    Dem_ReturnGetExtendedDataRecordByDTCType       demGetEDRetVal;
#    uint16                        ExtendedDataRecordSize = 0;
	.d2line		8766
	diab.li		r3,0		# demGetSizeRetVal=r3
.Llo796:
	sth		r3,8(r1)		# demGetSizeRetVal=r3
#    Std_ReturnType       responseBufferResult;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  responseBuffer;
#    Dcm_NegativeResponseCodeType  ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;  /* Finish execution and respond with negative response */
	.d2line		8769
	diab.li		r27,0
# 
# #if (DCM_READ_GENERIC_INFORMATION_ENABLED == STD_ON)
#    /*
#     * Storage for DTC/data records status information
#      */
#    CONSTP2VAR(ReportAllDtcDataRecordByDTCNumberStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.dtc_data_records_status;
# #endif
# 
#    pDataState->dataPending = FALSE;
	.d2line		8778
.Llo814:
	stb		r3,1(r28)		# pDataState=r28 demGetSizeRetVal=r3
# 
#    /*
#     * Fetch the size for the specific record number
#     */
#    demGetSizeRetVal = Dem_DcmGetSizeOfExtendedDataRecordByDTC(Dtc,
	.d2line		8783
	rlwinm		r4,r4,0,24,31		# DtcOrigin=r4 DtcOrigin=r4
.Llo791:
	rlwinm		r5,r5,0,24,31		# recordNumber=r5 recordNumber=r5
.Llo793:
	diab.addi		r6,r1,8
.Llo795:
	mr		r3,r31		# Dtc=r3 Dtc=r31
.Llo797:
	bl		Dem_DcmGetSizeOfExtendedDataRecordByDTC
.Llo798:
	mr		r3,r3		# demGetSizeRetVal=r3 demGetSizeRetVal=r3
#                                                            DtcOrigin,
#                                                            recordNumber,
#                                                            &ExtendedDataRecordSize);
#    if (DEM_GETSIZEBYDTC_OK == demGetSizeRetVal)
	.d2line		8787
	rlwinm		r0,r3,0,24,31		# demGetSizeRetVal=r3
	se_cmpi		r0,0
	bc		1,2,.L2021	# eq
#    {
#       /* The record was found and size was returned */
#    }
#    else if (DEM_GETSIZEBYDTC_WRONG_RECNUM == demGetSizeRetVal)
	.d2line		8791
.Llo792:
	rlwinm		r3,r3,0,24,31		# demGetSizeRetVal=r3 demGetSizeRetVal=r3
	se_cmpi		r3,3		# demGetSizeRetVal=r3
	bc		0,2,.L2022	# ne
#    {
#       /* No record found, set size to zero */
#       ExtendedDataRecordSize    = 0;
	.d2line		8794
.Llo799:
	diab.li		r0,0
	sth		r0,8(r1)
	b		.L2021
.L2022:
#    }
#    else
#    {
#      /*
#       * Dem_DcmGetSizeOfExtendedDataRecordByDTC returned one of the following:
#       *  DEM_GETSIZEBYDTC_WRONG_DTC
#       *  DEM_GETSIZEBYDTC_WRONG_DTCORIGIN
#       *  DEM_GETSIZEBYDTC_PENDING
#       *
#       * Abort, failure will be handled by the caller
#       */
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8806
	diab.li		r27,49		# ErrorCode=r27
.L2021:
#    }
# 
#    /*Set the flag if the EDR size is greater than zero.*/
#    pDataState->dataRecordFoundWithSize = (ExtendedDataRecordSize != 0) ? TRUE : pDataState->dataRecordFoundWithSize;
	.d2line		8810
.Llo800:
	lhz		r0,8(r1)
	se_cmpi		r0,0
	bc		1,2,.L2036	# eq
.Llo801:
	diab.li		r0,1
	b		.L2037
.L2036:
	lbz		r0,4(r28)		# pDataState=r28
.L2037:
	stb		r0,4(r28)		# pDataState=r28
# 
#    /* Get the size of the requested dataRecord */
#    if (DCM_INT_NRC_POSITIVERESPONSE != ErrorCode)
	.d2line		8813
	rlwinm		r3,r27,0,24,31		# demGetSizeRetVal=r3 ErrorCode=r27
.Llo802:
	se_cmpi		r3,0		# demGetSizeRetVal=r3
	bc		0,2,.L2025	# ne
#    {
#       /* Abort, failure will be handled by the caller */
#    }
#    else if (0 == ExtendedDataRecordSize)
	.d2line		8817
.Llo803:
	lhz		r0,8(r1)
	se_cmpi		r0,0
	bc		1,2,.L2025	# eq
#    {
#       /*
#        * No stored data, skip the readout but do not consider it as a failure.
#        */
#    }
#    else
#    {
#       /*
#        * Store the extended data record size, the identifier is included in ExtendedDataRecordSize if found. [SWS_Dem_00076] 
#        */
# 
# #if (DCM_READ_GENERIC_INFORMATION_ENABLED == STD_ON)
#       /*
#        * Update the total size.
#        */
#       pStatus->total_size = pStatus->total_size + (Dcm_MsgLenType)ExtendedDataRecordSize;
# #endif
#       responseBufferResult = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)ExtendedDataRecordSize, &responseBuffer);
	.d2line		8835
	lhz		r3,8(r1)		# demGetSizeRetVal=r3
	diab.addi		r4,r1,12		# DtcOrigin=r4
	bl		Dcm_DsdRequestResponseBuffer
.Llo811:
	mr		r3,r3		# responseBufferResult=r3 responseBufferResult=r3
# 
#       if (E_OK == responseBufferResult)
	.d2line		8837
	rlwinm		r3,r3,0,24,31		# responseBufferResult=r3 responseBufferResult=r3
	se_cmpi		r3,0		# responseBufferResult=r3
	bc		0,2,.L2028	# ne
	.section	.text_vle
.L3861:
#       {
#          /*
#           * Temporary buffer size to be used with DEM call.
#           * ExtendedDataRecordSize cannot be used since DEM might touch the value
#           * and it needs to be untouched in case of Dcm_DsdReleaseResponseBuffer.
#           */
#          uint16 tempBufSize = ExtendedDataRecordSize;
	.d2line		8844
.Llo812:
	lhz		r0,8(r1)
	sth		r0,10(r1)
# 
#          demGetEDRetVal = Dem_DcmGetExtendedDataRecordByDTC(Dtc,
	.d2line		8846
	lwz		r6,12(r1)		# demGetEDRetVal=r6
.Llo804:
	se_addi		r6,1		# demGetEDRetVal=r6 demGetEDRetVal=r6
.Llo805:
	rlwinm		r4,r30,0,24,31		# DtcOrigin=r4 DtcOrigin=r30
	rlwinm		r5,r29,0,24,31		# recordNumber=r5 recordNumber=r29
	diab.addi		r7,r1,10
	mr		r3,r31		# Dtc=r3 Dtc=r31
	bl		Dem_DcmGetExtendedDataRecordByDTC
.Llo806:
	mr		r6,r3		# demGetEDRetVal=r6 demGetEDRetVal=r3
#                                                             DtcOrigin,
#                                                             recordNumber,
#                                                             &responseBuffer[1],
#                                                             &tempBufSize);
# 
#          switch (demGetEDRetVal)
	.d2line		8852
	rlwinm		r6,r6,0,24,31		# demGetEDRetVal=r6 demGetEDRetVal=r6
	se_cmpi		r6,0		# demGetEDRetVal=r6
	bc		1,2,.L2029	# eq
.Llo788:
	se_cmpi		r6,3		# demGetEDRetVal=r6
.Llo807:
	bc		1,2,.L2032	# eq
	se_cmpi		r6,4		# demGetEDRetVal=r6
	bc		1,2,.L2032	# eq
	se_cmpi		r6,5		# demGetEDRetVal=r6
	bc		1,2,.L2033	# eq
.Llo808:
	b		.L2034
.L2029:
#          {
#             case DEM_RECORD_OK:
#             {
#                /*
#                 *  Fill in extended data record
#                 */
#                responseBuffer[0] = recordNumber;
	.d2line		8859
.Llo809:
	lwz		r3,12(r1)		# responseBufferResult=r3
.Llo813:
	stb		r29,0(r3)		# responseBufferResult=r3 recordNumber=r29
	b		.L2025
.L2032:
#                break;
#             }
#             case DEM_RECORD_WRONG_NUMBER:
#                /*
#                 * Record wasn't missing between call to get size and
#                 * get freeze frame data record, but no error since we are looping
#                 * through all records. Release the previous requested memory.
#                 */
#             case DEM_RECORD_WRONG_BUFFERSIZE:
#                /*
#                 * Should abort and retry with new buffer next schedule perhaps
#                 * (slight risk of an infinite loop), but just ignore and
#                 * continue with next extended data record for now.
#                 * Release the previous requested memory.
#                 */
#             {
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)ExtendedDataRecordSize);
	.d2line		8876
.Llo810:
	lhz		r3,8(r1)		# responseBufferResult=r3
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L2025
.L2033:
#                break;
#             }
#             case DEM_RECORD_PENDING:
#             {
#                /*
#                 * Retry next schedule, release the previous requested memory.
#                 *
#                 * Store last processed extended data record number and stay in this state.
#                 */
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)ExtendedDataRecordSize);
	.d2line		8886
	lhz		r3,8(r1)		# responseBufferResult=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                pDataState->dataPending = TRUE;
	.d2line		8887
	diab.li		r0,1
	stb		r0,1(r28)		# pDataState=r28
#                pDataState->current_data_record_number = recordNumber;
	.d2line		8888
	stb		r29,3(r28)		# pDataState=r28 recordNumber=r29
	b		.L2025
.L2034:
# 
#                break;
#             }
#             default:
#             {
#                /* Dem_DcmGetFreezeFrameDataByDTC returned one of:
#                 *  DEM_RECORD_WRONG_DTC
#                 *  DEM_RECORD_WRONG_DTCORIGIN
#                 */
#                /*
#                 * Release the previously located buffer.
#                 */
#                Dcm_DsdReleaseResponseBuffer((Dcm_MsgLenType)ExtendedDataRecordSize);
	.d2line		8901
.Llo794:
	lhz		r3,8(r1)		# responseBufferResult=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8902
	diab.li		r27,49		# ErrorCode=r27
.Llo815:
	b		.L2025
	.section	.text_vle
.L3862:
.L2028:
#                break;
#             }
#          }
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == responseBufferResult)
#       {
#          /* Store last processed extended data record number and stay in this state.
#           * Retry buffer request next schedule */
#          pDataState->dataPending = TRUE;
#          pDataState->current_data_record_number = recordNumber;
#       }
#       else if (DCM_INT_E_RESPONSE_FULL == responseBufferResult)
#       {
#          /* The whole length of the originally calculated response length has been filled.
#           */
#          pDataState->sendPositiveResponse = TRUE;
#       }
#       else if (E_NOT_OK == responseBufferResult)
#       {
#          /* 
#           * Abort, make sense for a single extended data record request.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned
#           *  E_NOT_OK
#           *
#           * Abort, requested size can't possible fit in buffer.
#           */
#          ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		8937
.Llo789:
	diab.li		r27,20		# ErrorCode=r27
.L2025:
#       }
#    }
# 
#    return ErrorCode;
	.d2line		8941
.Llo790:
	rlwinm		r3,r27,0,24,31		# demGetSizeRetVal=r3 ErrorCode=r27
# }
	.d2line		8942
	.d2epilogue_begin
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
.Llo816:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3844:
	.type		GetOneExtendedDataRecordByDtc,@function
	.size		GetOneExtendedDataRecordByDtc,.-GetOneExtendedDataRecordByDtc
# Number of nodes = 152

# Allocations for GetOneExtendedDataRecordByDtc
#	?a4		Dtc
#	?a5		DtcOrigin
#	?a6		recordNumber
#	?a7		pDataState
#	?a8		$$53
#	?a9		demGetSizeRetVal
#	?a10		demGetEDRetVal
#	SP,8		ExtendedDataRecordSize
#	?a11		responseBufferResult
#	SP,12		responseBuffer
#	?a12		ErrorCode
#	SP,10		tempBufSize
# static FUNC(void, DCM_CODE) GetTotalSizeOfExtendedDataRecordByDtc(Dem_DTCOriginType DtcOrigin,
	.align		1
	.section	.text_vle
        .d2line         8947,29
#$$ld
.L3868:

#$$bf	GetTotalSizeOfExtendedDataRecordByDtc,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetTotalSizeOfExtendedDataRecordByDtc:
.Llo817:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
.Llo857:
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)		# extDataNumberLoop=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# DtcOrigin=r31 DtcOrigin=r3
	mr		r30,r4		# pStatus=r30 pStatus=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
#                                                                   CONSTP2VAR(ReportAllDtcDataRecordByDTCNumberStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus,
#                                                                   CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint16 dataRecordSize;
#    Dem_ReturnGetSizeOfDataByDTCType getSizeRetVal;
#    uint8 extDataNumberLoop = 0;
	.d2line		8953
	diab.li		r0,0		# extDataNumberLoop=r0
#    uint8 recordNumber = 0;
# 
#    /*
#     * Calculate the total extended data record size for one specific DTC
#     */
#    if ((DCM_ALL_DATA_RECORD_REQ == pStatus->dataState.request_data_record_number) || (DCM_ALL_OBD_DATA_RECORD_REQ == pStatus->dataState.request_data_record_number))
	.d2line		8959
.Llo858:
	lbz		r0,16(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo859:
	cmpi		0,0,r0,255		# extDataNumberLoop=r0
	bc		1,2,.L2067	# eq
.Llo818:
	lbz		r0,16(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo819:
	cmpi		0,0,r0,254		# extDataNumberLoop=r0
	bc		0,2,.L2049	# ne
.L2067:
#    {
#       /*
#        * The data record number is 0xFF, go through all data record numbers
#        * Extended data record starts at one.
#        * Since requesting all records will the total available data size decide 
#        * if error or not, not if any EDRs are available or not.
#        */
#       for (extDataNumberLoop = pStatus->dataState.current_data_record_number;
	.d2line		8967
.Llo860:
	lbz		r28,17(r30)		# pStatus=r30
.Llo861:
	mr		r28,r28		# extDataNumberLoop=r28 extDataNumberLoop=r28
.L2050:
	rlwinm		r0,r28,0,24,31		# extDataNumberLoop=r0 extDataNumberLoop=r28
	lis		r3,(Dcm_LCfg+136)@ha		# getSizeRetVal=r3
.Llo832:
	lbz		r3,(Dcm_LCfg+136)@l(r3)		# getSizeRetVal=r3 getSizeRetVal=r3
	se_cmp		r0,r3		# extDataNumberLoop=r0 getSizeRetVal=r3
	bc		0,0,.L2052	# ge
.Llo833:
	lbz		r0,0(r29)		# extDataNumberLoop=r0 pErrorCode=r29
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2052	# ne
	lhz		r0,12(r30)		# extDataNumberLoop=r0 pStatus=r30
	lis		r3,Dcm_LCfg@ha		# getSizeRetVal=r3
.Llo834:
	lhz		r3,Dcm_LCfg@l(r3)		# getSizeRetVal=r3 getSizeRetVal=r3
	se_cmp		r0,r3		# extDataNumberLoop=r0 getSizeRetVal=r3
	bc		0,0,.L2052	# ge
#            (extDataNumberLoop < Dcm_LCfg.num_extendeddata_records)
#            && (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
#            && (pStatus->maxNumberRecordsCounter < Dcm_LCfg.maxNumberOfRecords); /* If maximum number of records during one schedule has reached? */
#            extDataNumberLoop++)
#       {
#          /* Get the extended record number.
#           * Typecasting below is safe as record number shall not be greater than FF.
#           */
#          recordNumber = (NULL_PTR == Dcm_LCfg.p_extendeddata_records) ?
	.d2line		8976
.Llo835:
	lis		r3,(Dcm_LCfg+140)@ha		# getSizeRetVal=r3
.Llo836:
	lwz		r0,(Dcm_LCfg+140)@l(r3)		# extDataNumberLoop=r0 getSizeRetVal=r3
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2068	# ne
.Llo837:
	mr		r5,r28		# extDataNumberLoop=r5 extDataNumberLoop=r28
.Llo873:
	b		.L2069
.L2068:
.Llo874:
	lis		r3,(Dcm_LCfg+140)@ha		# getSizeRetVal=r3
.Llo838:
	lwz		r3,(Dcm_LCfg+140)@l(r3)		# getSizeRetVal=r3 getSizeRetVal=r3
	rlwinm		r0,r28,0,24,31		# extDataNumberLoop=r0 extDataNumberLoop=r28
	lbzx		r5,r3,r0		# extDataNumberLoop=r5 getSizeRetVal=r3
.L2069:
.Llo839:
	mr		r5,r5		# recordNumber=r5 recordNumber=r5
#                         extDataNumberLoop : Dcm_LCfg.p_extendeddata_records[extDataNumberLoop];
# 
#          getSizeRetVal = Dem_DcmGetSizeOfExtendedDataRecordByDTC(pStatus->current_dtc_id,
	.d2line		8979
.Llo875:
	lwz		r3,0(r30)		# getSizeRetVal=r3 pStatus=r30
	rlwinm		r4,r31,0,24,31		# DtcOrigin=r31
	rlwinm		r5,r5,0,24,31		# extDataNumberLoop=r5 extDataNumberLoop=r5
	diab.addi		r6,r1,8
	bl		Dem_DcmGetSizeOfExtendedDataRecordByDTC
.Llo840:
	mr		r3,r3		# getSizeRetVal=r3 getSizeRetVal=r3
#                                                               DtcOrigin,
#                                                               recordNumber,
#                                                               &dataRecordSize);
#          if (DEM_GETSIZEBYDTC_OK == getSizeRetVal)
	.d2line		8983
	rlwinm		r0,r3,0,24,31		# extDataNumberLoop=r0 getSizeRetVal=r3
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2053	# ne
#          {
#             /*
#              * Store the extended data record size, the identifier is included in dataRecordSize if found. [SWS_Dem_00076]
#              */
#             pStatus->total_size += dataRecordSize;
	.d2line		8988
.Llo841:
	lhz		r0,10(r30)		# extDataNumberLoop=r0 pStatus=r30
	lhz		r3,8(r1)		# getSizeRetVal=r3
.Llo842:
	se_add		r0,r3		# extDataNumberLoop=r0 extDataNumberLoop=r0 getSizeRetVal=r3
	sth		r0,10(r30)		# pStatus=r30 extDataNumberLoop=r0
#             pStatus->dataState.dataRecordFoundWithSize = (dataRecordSize != 0) ? TRUE : pStatus->dataState.dataRecordFoundWithSize;
	.d2line		8989
	lhz		r0,8(r1)		# extDataNumberLoop=r0
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		1,2,.L2070	# eq
.Llo843:
	diab.li		r0,1		# extDataNumberLoop=r0
	b		.L2071
.L2070:
	lbz		r0,18(r30)		# extDataNumberLoop=r0 pStatus=r30
.L2071:
	stb		r0,18(r30)		# pStatus=r30 extDataNumberLoop=r0
#             pStatus->dataState.dataRecordFound = TRUE;
	.d2line		8990
	diab.li		r0,1		# extDataNumberLoop=r0
	stb		r0,19(r30)		# pStatus=r30 extDataNumberLoop=r0
	b		.L2054
.L2053:
#          }
#          else if (DEM_GETSIZEBYDTC_WRONG_RECNUM == getSizeRetVal)
	.d2line		8992
.Llo844:
	rlwinm		r3,r3,0,24,31		# getSizeRetVal=r3 getSizeRetVal=r3
	se_cmpi		r3,3		# getSizeRetVal=r3
	bc		1,2,.L2054	# eq
#          {
#             /*
#              * No record found, don't increase the total size
#              * but no error since we are looping through all records.
#              */
#          }
#          else
#          {
#             /*
#              * Dem_DcmGetSizeOfExtendedDataRecordByDTC returned one of the following:
#              *  DEM_GETSIZEBYDTC_WRONG_DTC
#              *  DEM_GETSIZEBYDTC_WRONG_DTCORIGIN
#              *  DEM_GET_SIZEOFEDRBYDTC_W_DTCKIND
#              *  DEM_GETSIZEBYDTC_PENDING
#              *
#              * Abort, failure will be handled below
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		9010
.Llo845:
	diab.li		r0,49		# extDataNumberLoop=r0
	stb		r0,0(r29)		# pErrorCode=r29 extDataNumberLoop=r0
.L2054:
#          }
# 
#          pStatus->maxNumberRecordsCounter++;
	.d2line		9013
	lhz		r3,12(r30)		# getSizeRetVal=r3 pStatus=r30
.Llo846:
	se_addi		r3,1		# getSizeRetVal=r3 getSizeRetVal=r3
	sth		r3,12(r30)		# pStatus=r30 getSizeRetVal=r3
#       }
	.d2line		9014
	diab.addi		r0,r28,1		# extDataNumberLoop=r0 extDataNumberLoop=r28
	se_addi		r28,1		# extDataNumberLoop=r28 extDataNumberLoop=r28
	b		.L2050
.L2052:
# 
#       if (DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode)
	.d2line		9016
.Llo847:
	lbz		r0,0(r29)		# extDataNumberLoop=r0 pErrorCode=r29
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2061	# ne
#       {
#          /* A negative response will be sent later. */
#       }
#       else if (extDataNumberLoop >= Dcm_LCfg.num_extendeddata_records)
	.d2line		9020
.Llo820:
	rlwinm		r0,r28,0,24,31		# extDataNumberLoop=r0 extDataNumberLoop=r28
.Llo826:
	lis		r3,(Dcm_LCfg+136)@ha		# getSizeRetVal=r3
.Llo848:
	lbz		r3,(Dcm_LCfg+136)@l(r3)		# getSizeRetVal=r3 getSizeRetVal=r3
	se_cmp		r0,r3		# extDataNumberLoop=r0 getSizeRetVal=r3
	bc		1,0,.L2059	# lt
#       {
#          pStatus->dataState.dataPending = FALSE;
	.d2line		9022
.Llo849:
	diab.li		r0,0		# extDataNumberLoop=r0
	stb		r0,15(r30)		# pStatus=r30 extDataNumberLoop=r0
	b		.L2061
.L2059:
#       }
#       else
#       {
#          /*
#           * Break when maxNumberOfRecords has been reached.
#           * Continue to read after reschedule.
#           */
#          pStatus->dataState.dataPending = TRUE;
	.d2line		9030
	diab.li		r0,1		# extDataNumberLoop=r0
	stb		r0,15(r30)		# pStatus=r30 extDataNumberLoop=r0
#          pStatus->dataState.current_data_record_number = extDataNumberLoop;
	.d2line		9031
	stb		r28,17(r30)		# pStatus=r30 extDataNumberLoop=r28
	b		.L2061
.L2049:
#       }
#    }
#    else
#    {
#       /*
#        * Requested for One specific extended data record.
#        */
#       getSizeRetVal = Dem_DcmGetSizeOfExtendedDataRecordByDTC(pStatus->current_dtc_id,
	.d2line		9039
.Llo821:
	lbz		r5,16(r30)		# pStatus=r30
.Llo827:
	lwz		r3,0(r30)		# getSizeRetVal=r3 pStatus=r30
	rlwinm		r4,r31,0,24,31		# DtcOrigin=r31
	diab.addi		r6,r1,8
	bl		Dem_DcmGetSizeOfExtendedDataRecordByDTC
.Llo850:
	mr		r3,r3		# getSizeRetVal=r3 getSizeRetVal=r3
#                                                            DtcOrigin,
#                                                            pStatus->dataState.request_data_record_number,
#                                                            &dataRecordSize);
#       if (DEM_GETSIZEBYDTC_OK == getSizeRetVal)
	.d2line		9043
	rlwinm		r0,r3,0,24,31		# extDataNumberLoop=r0 getSizeRetVal=r3
.Llo862:
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2062	# ne
#       {
#          /*
#           * Store the extended data record size, the identifier is included in dataRecordSize if found. [SWS_Dem_00076]
#           */
#          pStatus->total_size += dataRecordSize;
	.d2line		9048
.Llo822:
	lhz		r0,10(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo863:
	lhz		r3,8(r1)		# getSizeRetVal=r3
.Llo851:
	se_add		r0,r3		# extDataNumberLoop=r0 extDataNumberLoop=r0 getSizeRetVal=r3
	sth		r0,10(r30)		# pStatus=r30 extDataNumberLoop=r0
#          pStatus->dataState.dataRecordFoundWithSize = (dataRecordSize != 0) ? TRUE : pStatus->dataState.dataRecordFoundWithSize;
	.d2line		9049
	lhz		r0,8(r1)		# extDataNumberLoop=r0
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		1,2,.L2072	# eq
.Llo828:
	diab.li		r0,1		# extDataNumberLoop=r0
.Llo864:
	b		.L2073
.L2072:
.Llo865:
	lbz		r0,18(r30)		# extDataNumberLoop=r0 pStatus=r30
.L2073:
.Llo866:
	stb		r0,18(r30)		# pStatus=r30 extDataNumberLoop=r0
#          pStatus->dataState.dataRecordFound = TRUE;
	.d2line		9050
	diab.li		r0,1		# extDataNumberLoop=r0
	stb		r0,19(r30)		# pStatus=r30 extDataNumberLoop=r0
#          pStatus->maxNumberRecordsCounter++;
	.d2line		9051
	lhz		r3,12(r30)		# getSizeRetVal=r3 pStatus=r30
.Llo852:
	se_addi		r3,1		# getSizeRetVal=r3 getSizeRetVal=r3
	sth		r3,12(r30)		# pStatus=r30 getSizeRetVal=r3
	b		.L2061
.L2062:
#       }
#       else if ((DEM_GETSIZEBYDTC_WRONG_RECNUM == getSizeRetVal) && (DTC_GROUP_ALL_DTCS == pStatus->dtc_id))
	.d2line		9053
.Llo829:
	rlwinm		r3,r3,0,24,31		# getSizeRetVal=r3 getSizeRetVal=r3
	se_cmpi		r3,3		# getSizeRetVal=r3
	bc		0,2,.L2064	# ne
.Llo853:
	lwz		r0,4(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo867:
	diab.li		r3,16777215		# getSizeRetVal=r3
.Llo854:
	se_cmpl		r0,r3		# extDataNumberLoop=r0 getSizeRetVal=r3
	bc		1,2,.L2061	# eq
.L2064:
#       {
#          /*
#           * No record found, don't increase the total size
#           * but no error since caller looping through all DTC's.
#           */
#       }
#       else
#       {
#          /*
#           * Dem_DcmGetSizeOfExtendedDataRecordByDTC returned one of the following:
#           *  DEM_GETSIZEBYDTC_WRONG_DTC
#           *  DEM_GETSIZEBYDTC_WRONG_DTCORIGIN
#           *  DEM_GET_SIZEOFEDRBYDTC_W_DTCKIND
#           *  DEM_GETSIZEBYDTC_PENDING
#           *
#           * or DEM_GETSIZEBYDTC_WRONG_RECNUM when asking for a single DTC
#           * Abort, failure will be handled below
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		9072
.Llo855:
	diab.li		r0,49		# extDataNumberLoop=r0
.Llo868:
	stb		r0,0(r29)		# pErrorCode=r29 extDataNumberLoop=r0
.L2061:
#       }
#    }
# 
#    /*
#     * Add the DTC, status and status indicator to the extended record size (if any)
#     */
#    if ((FALSE != pStatus->dataState.dataRecordFoundWithSize) && (FALSE == pStatus->dataState.dataPending))
	.d2line		9079
.Llo869:
	lbz		r0,18(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo870:
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		1,2,.L2048	# eq
.Llo830:
	lbz		r0,15(r30)		# extDataNumberLoop=r0 pStatus=r30
.Llo831:
	se_cmpi		r0,0		# extDataNumberLoop=r0
	bc		0,2,.L2048	# ne
#    {
#       pStatus->total_size += DCM_RGI_RGED_HEADERSIZE;
	.d2line		9081
.Llo871:
	lhz		r3,10(r30)		# getSizeRetVal=r3 pStatus=r30
.Llo856:
	se_addi		r3,5		# getSizeRetVal=r3 getSizeRetVal=r3
	sth		r3,10(r30)		# pStatus=r30 getSizeRetVal=r3
#       pStatus->dataState.dataRecordFoundWithSize = FALSE;
	.d2line		9082
	diab.li		r0,0		# extDataNumberLoop=r0
.Llo872:
	stb		r0,18(r30)		# pStatus=r30 extDataNumberLoop=r0
.L2048:
#    }
# }
	.d2line		9084
	.d2epilogue_begin
.Llo823:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
.Llo824:
	lwz		r0,36(r1)		# extDataNumberLoop=r0
	mtspr		lr,r0		# extDataNumberLoop=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo825:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3869:
	.type		GetTotalSizeOfExtendedDataRecordByDtc,@function
	.size		GetTotalSizeOfExtendedDataRecordByDtc,.-GetTotalSizeOfExtendedDataRecordByDtc
# Number of nodes = 279

# Allocations for GetTotalSizeOfExtendedDataRecordByDtc
#	?a4		DtcOrigin
#	?a5		pStatus
#	?a6		pErrorCode
#	?a7		$$56
#	?a8		$$55
#	?a9		$$54
#	SP,8		dataRecordSize
#	?a10		getSizeRetVal
#	?a11		extDataNumberLoop
#	?a12		recordNumber
# static FUNC(void, DCM_CODE) ReportDTCExtendedDataRecordByDTCNumber(CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         8336,29
#$$ld
.L3887:

#$$bf	ReportDTCExtendedDataRecordByDTCNumber,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCExtendedDataRecordByDTCNumber:
.Llo876:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r27,r4		# pErrorCode=r27 pErrorCode=r4
	.d2prologue_end
#                                                                    CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)   responseBuffer;
# 
#    /*
#     * Storage for DTC/data records status information in case of paging
#     */
#    CONSTP2VAR(ReportAllDtcDataRecordByDTCNumberStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.dtc_data_records_status;
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		8346
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo877:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1921	# ne
	.section	.text_vle
.L3893:
#    {
#       /*
#        * Fetch data from request and store in service state
#        */
#       CONST(uint8, AUTOMATIC) ExtendedDataNumber   = pMsgContext->reqData[4];
	.d2line		8351
.Llo878:
	lwz		r3,0(r31)		# pMsgContext=r3 pMsgContext=r31
.Llo926:
	lbz		r5,4(r3)		# ExtendedDataNumber=r5 pMsgContext=r3
.Llo930:
	mr		r4,r5		# ExtendedDataNumber=r4 ExtendedDataNumber=r5
	.d2line		8344
	lbz		r6,1(r3)		# pMsgContext=r3
	rlwinm		r6,r6,16,8,15
	lbz		r0,2(r3)		# pMsgContext=r3
	se_slwi		r0,8
	or		r6,r6,r0
	lbz		r3,3(r3)		# pMsgContext=r3 pMsgContext=r3
	or		r0,r6,r3		# pMsgContext=r3
	rlwinm		r0,r0,0,8,31
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+156)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+152)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+152)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+168)@ha		# pMsgContext=r3
	stb		r5,(Dcm_DspInstance+168)@l(r3)		# pMsgContext=r3 ExtendedDataNumber=r5
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+166)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+166)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+167)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+167)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+162)@ha		# pMsgContext=r3
	sth		r0,(Dcm_DspInstance+162)@l(r3)		# pMsgContext=r3
	lbz		r3,26(r31)		# pMsgContext=r3 pMsgContext=r31
	lis		r5,(Dcm_DspInstance+161)@ha		# ExtendedDataNumber=r5
.Llo931:
	stb		r3,(Dcm_DspInstance+161)@l(r5)		# ExtendedDataNumber=r5 pMsgContext=r3
.Llo932:
	lis		r3,(Dcm_DspInstance+170)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+170)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+171)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+171)@l(r3)		# pMsgContext=r3
	lis		r3,(Dcm_DspInstance+172)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+172)@l(r3)		# pMsgContext=r3
	lbz		r3,(Dcm_DspInstance+161)@l(r5)		# pMsgContext=r3 ExtendedDataNumber=r5
	mr		r4,r4		# ExtendedDataNumber=r4 ExtendedDataNumber=r4
.Llo933:
	bl		GetStartIndexOfEDR
	lis		r4,(Dcm_DspInstance+169)@ha		# ExtendedDataNumber=r4
.Llo934:
	stb		r3,(Dcm_DspInstance+169)@l(r4)		# ExtendedDataNumber=r4 pMsgContext=r3
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetDTCOriginReadDTCInformation
	lis		r4,(Dcm_DspInstance+173)@ha		# ExtendedDataNumber=r4
	stb		r3,(Dcm_DspInstance+173)@l(r4)		# ExtendedDataNumber=r4 pMsgContext=r3
# 
#       pStatus->dtc_id                               = CONVERT_BE_TO_U32(&pMsgContext->reqData[1]);
#       pStatus->current_dtc_id                       = pStatus->dtc_id;
#       pStatus->dataState.request_data_record_number = ExtendedDataNumber;
#       pStatus->dataState.sendPositiveResponse       = FALSE;
#       pStatus->dataState.dataPending                = FALSE;
#       pStatus->total_size                           = (Dcm_MsgLenType)0U;
#       pStatus->sub_service_id                       = pMsgContext->subServiceId;
#       pStatus->dataState.dataRecordFoundWithSize    = FALSE;
#       pStatus->dataState.dataRecordFound            = FALSE;
#       pStatus->dataState.dtcFound                   = FALSE;
#       pStatus->dataState.current_data_record_number = GetStartIndexOfEDR(pStatus->sub_service_id, ExtendedDataNumber);
#       pStatus->dtc_origin                           = GetDTCOriginReadDTCInformation(pMsgContext);
# 
#       /*
#        * Avoid updates during reading.
#        */
#       if (DEM_DISABLE_DTCRECUP_OK != Dem_DcmDisableDTCRecordUpdate(pStatus->dtc_id, pStatus->dtc_origin))
	.d2line		8369
	rlwinm		r4,r3,0,24,31		# ExtendedDataNumber=r4 pMsgContext=r3
.Llo935:
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# pMsgContext=r3 pMsgContext=r3
	bl		Dem_DcmDisableDTCRecordUpdate
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1922	# eq
#       {
#          /*
#           * DEM_DISABLE_DTCRECUP_WRONG_DTC
#           * DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8375
	diab.li		r0,49
	stb		r0,0(r27)		# pErrorCode=r27
	b		.L1921
.L1922:
#       }
#       /*
#        * Get DTC statusbits
#        */
#       else if (DEM_STATUS_OK != Dem_DcmGetStatusOfDTC(pStatus->dtc_id,
	.d2line		8380
	lis		r3,(Dcm_DspInstance+173)@ha		# pMsgContext=r3
	lbz		r4,(Dcm_DspInstance+173)@l(r3)		# ExtendedDataNumber=r4 pMsgContext=r3
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# pMsgContext=r3 pMsgContext=r3
	lis		r5,(Dcm_DspInstance+160)@ha		# ExtendedDataNumber=r5
.Llo936:
	e_add16i		r5,r5,(Dcm_DspInstance+160)@l		# ExtendedDataNumber=r5 ExtendedDataNumber=r5
.Llo937:
	bl		Dem_DcmGetStatusOfDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1924	# eq
#                                                    pStatus->dtc_origin,
#                                                    &pStatus->dtc_status))
#       {
#          /* Error reading DTC status bits */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8385
	diab.li		r0,49
	stb		r0,0(r27)		# pErrorCode=r27
	b		.L1921
.L1924:
#       }
#       else
#       {
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_SIZE_PENDING;
	.d2line		8389
	diab.li		r0,10
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3
	.section	.text_vle
.L3894:
.L1921:
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_SIZE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		8393
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
.Llo959:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3
	se_cmpi		r0,10
	bc		0,2,.L1926	# ne
	.section	.text_vle
.L3899:
#    {
#       CONST(boolean, AUTOMATIC) includeMemorySelection = (boolean)(DCM_S19_SF19_USERDEFMEMORYDTCEXTDATARECORDBYDTCNUMBER == pMsgContext->subServiceId);
	.d2line		8395
	lbz		r0,26(r31)		# additionalHeaderSize=r0 pMsgContext=r31
	xori		r0,r0,25		# additionalHeaderSize=r0 additionalHeaderSize=r0
	cntlzw		r30,r0		# includeMemorySelection=r30 additionalHeaderSize=r0
.Llo956:
	se_srwi		r30,5		# includeMemorySelection=r30 includeMemorySelection=r30
	mr		r30,r30		# includeMemorySelection=r30 includeMemorySelection=r30
#       CONST(Dcm_MsgLenType, AUTOMATIC) additionalHeaderSize = (Dcm_MsgLenType)(includeMemorySelection ? 1U : 0U);  /* Add on extra byte to header for the MEMYS if available. */
	.d2line		8396
	rlwinm		r0,r30,0,24,31		# additionalHeaderSize=r0 includeMemorySelection=r30
	se_cmpi		r0,0		# additionalHeaderSize=r0
	diab.li		r0,1		# additionalHeaderSize=r0
	isel		r0,r3,r0,2		# additionalHeaderSize=r0 additionalHeaderSize=r3 additionalHeaderSize=r0
.L1960:
.Llo960:
	isel		r29,0,r0,2		# additionalHeaderSize=r29 additionalHeaderSize=r0
.L1961:
#       CONST(uint8, AUTOMATIC) memorySelection = (uint8)pMsgContext->reqData[5]; /* Assume MEMYS is available, it will not be used if not correct SF */
	.d2line		8397
.Llo961:
	lwz		r3,0(r31)		# additionalHeaderSize=r3 pMsgContext=r31
	lbz		r28,5(r3)		# additionalHeaderSize=r3
.Llo994:
	mr		r28,r28		# memorySelection=r28 memorySelection=r28
	.d2line		8344
	diab.li		r0,0		# additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+164)@ha		# additionalHeaderSize=r3
	sth		r0,(Dcm_DspInstance+164)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r0
# 
#       pStatus->maxNumberRecordsCounter = 0;
#       GetTotalSizeOfExtendedDataRecordByDtc(pStatus->dtc_origin, pStatus, pErrorCode);
	.d2line		8400
	lis		r3,(Dcm_DspInstance+173)@ha		# additionalHeaderSize=r3
	lbz		r3,(Dcm_DspInstance+173)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r3
	lis		r4,(Dcm_DspInstance+152)@ha		# ExtendedDataNumber=r4
.Llo938:
	e_add16i		r4,r4,(Dcm_DspInstance+152)@l		# ExtendedDataNumber=r4 ExtendedDataNumber=r4
.Llo939:
	mr		r5,r27		# pErrorCode=r5 pErrorCode=r27
	bl		GetTotalSizeOfExtendedDataRecordByDtc
# 
#       if (DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode)
	.d2line		8402
	lbz		r0,0(r27)		# additionalHeaderSize=r0 pErrorCode=r27
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1926	# ne
	.d2line		8344
	lis		r3,(Dcm_DspInstance+167)@ha		# additionalHeaderSize=r3
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# additionalHeaderSize=r0 additionalHeaderSize=r3
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		1,2,.L1929	# eq
#       {
#          /*
#           * Abort, failure will be handled below
#           */
#       }
#       else if (pStatus->dataState.dataPending)
#       {
#          /* Continue to get the size of records later. */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8411
	diab.li		r0,162		# additionalHeaderSize=r0
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	b		.L1926
.L1929:
#       }
#       else if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(pStatus->total_size + additionalHeaderSize))
	.d2line		8413
	lis		r3,(Dcm_DspInstance+162)@ha		# additionalHeaderSize=r3
	lhz		r3,(Dcm_DspInstance+162)@l(r3)		# additionalHeaderSize=r3 additionalHeaderSize=r3
	se_add		r3,r29		# additionalHeaderSize=r3 additionalHeaderSize=r3 additionalHeaderSize=r29
	rlwinm		r3,r3,0,16,31		# additionalHeaderSize=r3 additionalHeaderSize=r3
	bl		Dcm_DsdStartResponse
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	cmpi		0,0,r3,200		# pMsgContext=r3
	bc		0,2,.L1931	# ne
#       {
#          *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		8415
	diab.li		r0,20		# additionalHeaderSize=r0
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	b		.L1926
.L1931:
#       }
#       else if (E_OK != Dcm_DsdRequestResponseBuffer(DCM_REPORTDTCEXTENDEDDATARECORDBYDTC_ANSWERSIZE + additionalHeaderSize, &responseBuffer))
	.d2line		8417
	diab.addi		r3,r29,5		# pMsgContext=r3 additionalHeaderSize=r29
	rlwinm		r3,r3,0,16,31		# pMsgContext=r3 pMsgContext=r3
	diab.addi		r4,r1,8		# ExtendedDataNumber=r4
	bl		Dcm_DsdRequestResponseBuffer
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L1933	# eq
#       {
#          /*
#           * This shall not happen since SCG guarantee the response buffer is at least 8 bytes.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8422
.Llo962:
	diab.li		r0,49		# additionalHeaderSize=r0
.Llo963:
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	b		.L1926
.L1933:
#       }
#       else if (FALSE == pStatus->dataState.dataRecordFound)
	.d2line		8424
.Llo964:
	lis		r3,(Dcm_DspInstance+171)@ha		# pMsgContext=r3
	lbz		r0,(Dcm_DspInstance+171)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo965:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1935	# ne
#       {
#          /*
#           * No valid data record was found
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		8429
.Llo966:
	diab.li		r0,49		# additionalHeaderSize=r0
.Llo967:
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	b		.L1926
.L1935:
#       }
#       else
#       {
#          /*
#           * Fill in mandatory response data
#           */
#          responseBuffer[0] = pMsgContext->subServiceId;
	.d2line		8436
.Llo957:
	lbz		r0,26(r31)		# additionalHeaderSize=r0 pMsgContext=r31
.Llo968:
	lwz		r3,8(r1)		# pMsgContext=r3
	stb		r0,0(r3)		# pMsgContext=r3 additionalHeaderSize=r0
# 
#          /*
#           * Add an echo of the memory selection in case of SF 0x19 [SWS_Dcm_00297] [SWS_Dcm_00474] [SWS_Dcm_00386]
#           */
#          if (includeMemorySelection)
	.d2line		8441
.Llo958:
	rlwinm		r30,r30,0,24,31		# includeMemorySelection=r30 includeMemorySelection=r30
	se_cmpi		r30,0		# includeMemorySelection=r30
	bc		1,2,.L1937	# eq
#          {
#             responseBuffer[1] = memorySelection;
	.d2line		8443
.Llo879:
	lwz		r3,8(r1)		# pMsgContext=r3
.Llo880:
	stb		r28,1(r3)		# pMsgContext=r3 memorySelection=r28
#             SET_RESPONSE_DTC(&responseBuffer[2], pStatus->dtc_id);
	.d2line		8444
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
	lhz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo969:
	lwz		r4,8(r1)		# ExtendedDataNumber=r4
.Llo940:
	stb		r0,2(r4)		# ExtendedDataNumber=r4 additionalHeaderSize=r0
	lwz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	rlwinm		r0,r0,24,24,31		# additionalHeaderSize=r0 additionalHeaderSize=r0
	lwz		r4,8(r1)		# ExtendedDataNumber=r4
	stb		r0,3(r4)		# ExtendedDataNumber=r4 additionalHeaderSize=r0
	lwz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	lwz		r3,8(r1)		# pMsgContext=r3
	stb		r0,4(r3)		# pMsgContext=r3 additionalHeaderSize=r0
#             responseBuffer[5] = pStatus->dtc_status;
	.d2line		8445
	lis		r3,(Dcm_DspInstance+160)@ha		# pMsgContext=r3
	lbz		r0,(Dcm_DspInstance+160)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	lwz		r3,8(r1)		# pMsgContext=r3
	stb		r0,5(r3)		# pMsgContext=r3 additionalHeaderSize=r0
	b		.L1939
.L1937:
#          }
#          else
#          {
#             SET_RESPONSE_DTC(&responseBuffer[1], pStatus->dtc_id);
	.d2line		8449
.Llo881:
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
.Llo882:
	lhz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo970:
	lwz		r4,8(r1)		# ExtendedDataNumber=r4
.Llo941:
	stb		r0,1(r4)		# ExtendedDataNumber=r4 additionalHeaderSize=r0
	lwz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	rlwinm		r0,r0,24,24,31		# additionalHeaderSize=r0 additionalHeaderSize=r0
	lwz		r4,8(r1)		# ExtendedDataNumber=r4
	stb		r0,2(r4)		# ExtendedDataNumber=r4 additionalHeaderSize=r0
	lwz		r0,(Dcm_DspInstance+156)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	lwz		r3,8(r1)		# pMsgContext=r3
	stb		r0,3(r3)		# pMsgContext=r3 additionalHeaderSize=r0
#             responseBuffer[4] = pStatus->dtc_status;
	.d2line		8450
	lis		r3,(Dcm_DspInstance+160)@ha		# pMsgContext=r3
	lbz		r0,(Dcm_DspInstance+160)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	lwz		r3,8(r1)		# pMsgContext=r3
	stb		r0,4(r3)		# pMsgContext=r3 additionalHeaderSize=r0
.L1939:
#          }
# 
#          if (0 == pStatus->total_size)
	.d2line		8453
.Llo883:
	lis		r3,(Dcm_DspInstance+162)@ha		# pMsgContext=r3
.Llo884:
	lhz		r0,(Dcm_DspInstance+162)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo971:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		1,2,.L1926	# eq
	.d2line		8344
.Llo885:
	lis		r3,(Dcm_DspInstance+161)@ha		# pMsgContext=r3
.Llo886:
	lbz		r3,(Dcm_DspInstance+161)@l(r3)		# pMsgContext=r3 pMsgContext=r3
.Llo887:
	lis		r4,(Dcm_DspInstance+168)@ha		# ExtendedDataNumber=r4
.Llo942:
	lbz		r4,(Dcm_DspInstance+168)@l(r4)		# ExtendedDataNumber=r4 ExtendedDataNumber=r4
.Llo943:
	bl		GetStartIndexOfEDR
.Llo888:
	lis		r4,(Dcm_DspInstance+169)@ha		# ExtendedDataNumber=r4
.Llo944:
	stb		r3,(Dcm_DspInstance+169)@l(r4)		# ExtendedDataNumber=r4 pMsgContext=r3
#          {
#             /* An empty positive response will be sent. */
#          }
#          else
#          {
#             pStatus->dataState.current_data_record_number = GetStartIndexOfEDR(pStatus->sub_service_id, pStatus->dataState.request_data_record_number);
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		8460
	diab.li		r0,1		# additionalHeaderSize=r0
.Llo972:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3 additionalHeaderSize=r0
	.section	.text_vle
.L3900:
.L1926:
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		8465
.Llo889:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
.Llo890:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	se_cmpi		r0,1		# additionalHeaderSize=r0
	bc		0,2,.L1943	# ne
	.d2line		8344
.Llo891:
	diab.li		r0,0		# additionalHeaderSize=r0
.Llo973:
	lis		r3,(Dcm_DspInstance+164)@ha		# pMsgContext=r3
.Llo892:
	sth		r0,(Dcm_DspInstance+164)@l(r3)		# pMsgContext=r3 additionalHeaderSize=r0
	lis		r3,(Dcm_DspInstance+167)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+167)@l(r3)		# pMsgContext=r3 additionalHeaderSize=r0
#    {
#       pStatus->maxNumberRecordsCounter = 0;
#       /*
#        * Reset dataPending before starting to read data.
#        */
#       pStatus->dataState.dataPending = FALSE;
# 
#       if ((DCM_ALL_DATA_RECORD_REQ == pStatus->dataState.request_data_record_number)
	.d2line		8473
	lis		r3,(Dcm_DspInstance+168)@ha		# pMsgContext=r3
	lbz		r0,(Dcm_DspInstance+168)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
	cmpi		0,0,r0,255		# additionalHeaderSize=r0
	bc		1,2,.L1962	# eq
.Llo893:
	lis		r3,(Dcm_DspInstance+168)@ha		# pMsgContext=r3
.Llo894:
	lbz		r0,(Dcm_DspInstance+168)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo974:
	cmpi		0,0,r0,254		# additionalHeaderSize=r0
	bc		0,2,.L1944	# ne
.L1962:
	.section	.text_vle
.L3909:
#          || (DCM_ALL_OBD_DATA_RECORD_REQ == pStatus->dataState.request_data_record_number))
#       {
#          uint8 extDataNumberLoop;
#          for (extDataNumberLoop = pStatus->dataState.current_data_record_number;
	.d2line		8477
.Llo895:
	lis		r3,(Dcm_DspInstance+169)@ha		# pMsgContext=r3
.Llo896:
	lbz		r31,(Dcm_DspInstance+169)@l(r3)		# pMsgContext=r31 pMsgContext=r3
.Llo995:
	mr		r31,r31		# extDataNumberLoop=r31 extDataNumberLoop=r31
.L1945:
.Llo897:
	rlwinm		r5,r31,0,24,31		# ExtendedDataNumber=r5 extDataNumberLoop=r31
.Llo945:
	lis		r3,(Dcm_LCfg+136)@ha		# pMsgContext=r3
.Llo898:
	lbz		r0,(Dcm_LCfg+136)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo975:
	se_cmp		r5,r0		# ExtendedDataNumber=r5 additionalHeaderSize=r0
	bc		0,0,.L1947	# ge
.Llo899:
	lbz		r0,0(r27)		# additionalHeaderSize=r0 pErrorCode=r27
.Llo976:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1947	# ne
.Llo977:
	lis		r3,(Dcm_DspInstance+166)@ha		# pMsgContext=r3
.Llo900:
	lbz		r0,(Dcm_DspInstance+166)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo978:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1947	# ne
.Llo901:
	lis		r3,(Dcm_DspInstance+167)@ha		# pMsgContext=r3
.Llo902:
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo979:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1947	# ne
	.d2line		8344
.Llo903:
	lis		r3,(Dcm_DspInstance+164)@ha		# pMsgContext=r3
.Llo904:
	lhz		r0,(Dcm_DspInstance+164)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo980:
	lis		r3,Dcm_LCfg@ha		# pMsgContext=r3
	lhz		r3,Dcm_LCfg@l(r3)		# pMsgContext=r3 pMsgContext=r3
	se_cmp		r0,r3		# additionalHeaderSize=r0 pMsgContext=r3
	bc		0,0,.L1947	# ge
	.section	.text_vle
.L3915:
#              (extDataNumberLoop < Dcm_LCfg.num_extendeddata_records) && /* If more data to read. */
#              (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode) && /* If error did not happen. */
#              (FALSE == pStatus->dataState.sendPositiveResponse) && /* if response buffer is not full. */
#              (FALSE == pStatus->dataState.dataPending) && /* If data reading is not pending. */
#              (pStatus->maxNumberRecordsCounter < Dcm_LCfg.maxNumberOfRecords); /* If maximum number of records during one schedule has reached? */
#              extDataNumberLoop++)
#          {
#             /*
#              * Start to read all data.
#              * Typecasting below is safe as record number shall not be greater than FF.
#              */
#             CONST(uint8, AUTOMATIC) recordNumber = (uint8) ((DCM_ALL_EXT_DATA_RECORD == Dcm_LCfg.num_extendeddata_records) ? extDataNumberLoop : Dcm_LCfg.p_extendeddata_records[extDataNumberLoop]);
	.d2line		8489
.Llo905:
	lis		r3,(Dcm_LCfg+136)@ha		# pMsgContext=r3
.Llo906:
	lbz		r0,(Dcm_LCfg+136)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo981:
	cmpi		0,0,r0,240		# additionalHeaderSize=r0
	bc		0,2,.L1963	# ne
.Llo907:
	mr		r5,r31		# recordNumber=r5 recordNumber=r31
	b		.L1964
.L1963:
	lis		r3,(Dcm_LCfg+140)@ha		# pMsgContext=r3
.Llo908:
	lwz		r3,(Dcm_LCfg+140)@l(r3)		# pMsgContext=r3 pMsgContext=r3
	rlwinm		r5,r31,0,24,31		# ExtendedDataNumber=r5 extDataNumberLoop=r31
.Llo946:
	lbzx		r5,r3,r5		# ExtendedDataNumber=r5 pMsgContext=r3
.Llo947:
	mr		r5,r5		# recordNumber=r5 recordNumber=r5
.L1964:
# 
#             *pErrorCode = GetOneExtendedDataRecordByDtc(pStatus->dtc_id,
	.d2line		8491
.Llo909:
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
.Llo910:
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# pMsgContext=r3 pMsgContext=r3
.Llo911:
	lis		r4,(Dcm_DspInstance+173)@ha		# ExtendedDataNumber=r4
.Llo948:
	lbz		r4,(Dcm_DspInstance+173)@l(r4)		# ExtendedDataNumber=r4 ExtendedDataNumber=r4
.Llo949:
	lis		r6,(Dcm_DspInstance+166)@ha
	e_add16i		r6,r6,(Dcm_DspInstance+166)@l
	mr		r5,r5		# recordNumber=r5 recordNumber=r5
	bl		GetOneExtendedDataRecordByDtc
.Llo912:
	stb		r3,0(r27)		# pErrorCode=r27 pMsgContext=r3
	.d2line		8344
	lis		r4,(Dcm_DspInstance+164)@ha		# ExtendedDataNumber=r4
.Llo950:
	lhz		r3,(Dcm_DspInstance+164)@l(r4)		# pMsgContext=r3 ExtendedDataNumber=r4
	se_addi		r3,1		# pMsgContext=r3 pMsgContext=r3
	sth		r3,(Dcm_DspInstance+164)@l(r4)		# ExtendedDataNumber=r4 pMsgContext=r3
	.section	.text_vle
.L3916:
#                                                              pStatus->dtc_origin,
#                                                              recordNumber,
#                                                              &pStatus->dataState);
#             pStatus->maxNumberRecordsCounter++;
#          }
	.d2line		8496
.Llo913:
	diab.addi		r5,r31,1		# extDataNumberLoop=r5 extDataNumberLoop=r31
	se_addi		r31,1		# extDataNumberLoop=r31 extDataNumberLoop=r31
	b		.L1945
.L1947:
# 
#          if (DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode)
	.d2line		8498
	lbz		r0,0(r27)		# additionalHeaderSize=r0 pErrorCode=r27
.Llo982:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1943	# ne
#          {
#             /* A negative response will be sent later. */
#          }
#          else if (FALSE != pStatus->dataState.dataPending)
	.d2line		8502
.Llo983:
	lis		r3,(Dcm_DspInstance+167)@ha		# pMsgContext=r3
.Llo914:
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo984:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		1,2,.L1950	# eq
#          {
#             /* Continue to read later. */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8505
.Llo915:
	diab.li		r0,162		# additionalHeaderSize=r0
.Llo985:
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	b		.L1943
.L1950:
#          }
#          else if (FALSE != pStatus->dataState.sendPositiveResponse)
	.d2line		8507
.Llo986:
	lis		r3,(Dcm_DspInstance+166)@ha		# pMsgContext=r3
.Llo916:
	lbz		r0,(Dcm_DspInstance+166)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo987:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		0,2,.L1943	# ne
#          {
#             /* A positive response will be sent later. */
#          }
#          else if (extDataNumberLoop >= Dcm_LCfg.num_extendeddata_records)
	.d2line		8511
.Llo917:
	rlwinm		r5,r31,0,24,31		# ExtendedDataNumber=r5 extDataNumberLoop=r31
.Llo951:
	lis		r3,(Dcm_LCfg+136)@ha		# pMsgContext=r3
.Llo918:
	lbz		r0,(Dcm_LCfg+136)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo988:
	se_cmp		r5,r0		# ExtendedDataNumber=r5 additionalHeaderSize=r0
	bc		0,0,.L1943	# ge
	.d2line		8344
.Llo919:
	lis		r3,(Dcm_DspInstance+169)@ha		# pMsgContext=r3
.Llo920:
	stb		r31,(Dcm_DspInstance+169)@l(r3)		# pMsgContext=r3 extDataNumberLoop=r31
#          {
#             /* All records processed with no fatal errors, send positive response */
#          }
#          else
#          {
#             /*
#              * Break when maxNumberOfRecords has been reached.
#              */
#             pStatus->dataState.current_data_record_number = extDataNumberLoop;
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8521
	diab.li		r0,162		# additionalHeaderSize=r0
.Llo989:
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
	.section	.text_vle
.L3910:
.Llo921:
	b		.L1943
.L1944:
#          }
#       }
#       else
#       {
#          *pErrorCode = GetOneExtendedDataRecordByDtc(pStatus->dtc_id,
	.d2line		8526
	lis		r3,(Dcm_DspInstance+156)@ha		# pMsgContext=r3
.Llo922:
	lwz		r3,(Dcm_DspInstance+156)@l(r3)		# pMsgContext=r3 pMsgContext=r3
.Llo923:
	lis		r4,(Dcm_DspInstance+173)@ha		# ExtendedDataNumber=r4
.Llo952:
	lbz		r4,(Dcm_DspInstance+173)@l(r4)		# ExtendedDataNumber=r4 ExtendedDataNumber=r4
.Llo953:
	lis		r5,(Dcm_DspInstance+168)@ha		# ExtendedDataNumber=r5
.Llo954:
	lbz		r5,(Dcm_DspInstance+168)@l(r5)		# ExtendedDataNumber=r5 ExtendedDataNumber=r5
.Llo955:
	lis		r6,(Dcm_DspInstance+166)@ha
	e_add16i		r6,r6,(Dcm_DspInstance+166)@l
	bl		GetOneExtendedDataRecordByDtc
.Llo924:
	stb		r3,0(r27)		# pErrorCode=r27 pMsgContext=r3
	.d2line		8344
	lis		r3,(Dcm_DspInstance+167)@ha		# pMsgContext=r3
	lbz		r0,(Dcm_DspInstance+167)@l(r3)		# additionalHeaderSize=r0 pMsgContext=r3
.Llo990:
	se_cmpi		r0,0		# additionalHeaderSize=r0
	bc		1,2,.L1943	# eq
#                                                           pStatus->dtc_origin,
#                                                           pStatus->dataState.request_data_record_number, /* dataRecordNumber*/
#                                                           &pStatus->dataState);
# 
#          if (pStatus->dataState.dataPending)
#          {
#             /* Still data to fetch. */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		8534
.Llo925:
	diab.li		r0,162		# additionalHeaderSize=r0
.Llo991:
	stb		r0,0(r27)		# pErrorCode=r27 additionalHeaderSize=r0
.L1943:
#          }
#       }
#    }
# 
#    /*
#     * Generic handling for all cases when execution shall terminate.
#     * Enable dtc record updates and send response.
#     */
#    if (DCM_INT_NRC_API_RETURNED_PENDING != *pErrorCode)
	.d2line		8543
.Llo992:
	lbz		r0,0(r27)		# additionalHeaderSize=r0 pErrorCode=r27
.Llo993:
	cmpi		0,0,r0,162		# additionalHeaderSize=r0
	bc		1,2,.L1920	# eq
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Service completed, enable the DTC record update again, too late to send an NRC.
#        */
#       (void)Dem_DcmEnableDTCRecordUpdate();
	.d2line		8550
.Llo927:
	bl		Dem_DcmEnableDTCRecordUpdate
.L1920:
#    }
#    else
#    {
#       /* No termination requested, service will execute again next schedule */
#    }
# }
	.d2line		8556
	.d2epilogue_begin
.Llo928:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,52(r1)		# additionalHeaderSize=r0
	mtspr		lr,r0		# additionalHeaderSize=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo929:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3888:
	.type		ReportDTCExtendedDataRecordByDTCNumber,@function
	.size		ReportDTCExtendedDataRecordByDTCNumber,.-ReportDTCExtendedDataRecordByDTCNumber
# Number of nodes = 748

# Allocations for ReportDTCExtendedDataRecordByDTCNumber
#	?a4		pMsgContext
#	?a5		pErrorCode
#	SP,8		responseBuffer
#	not allocated	pStatus
#	?a6		ExtendedDataNumber
#	?a7		includeMemorySelection
#	?a8		additionalHeaderSize
#	?a9		memorySelection
#	?a10		extDataNumberLoop
#	?a11		recordNumber
# static FUNC(void, DCM_CODE) HelpFncReportDTCBySeverityMaskRecord(CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		1
	.section	.text_vle
        .d2line         10110,29
#$$ld
.L3923:

#$$bf	HelpFncReportDTCBySeverityMaskRecord,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
HelpFncReportDTCBySeverityMaskRecord:
.Llo996:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r29,36(r1)		# offset r1+36  0x24
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pErrorCode=r31 pErrorCode=r3
	.d2prologue_end
# {
#    boolean                           GetNextDtc = TRUE;
	.d2line		10112
	diab.li		r30,1		# GetNextDtc=r30
#    Std_ReturnType           getBufferRes = E_OK;
	.d2line		10113
.Llo1002:
	diab.li		r29,0		# getBufferRes=r29
.L2092:
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)     resBuffer;
# 
#    while ((TRUE == GetNextDtc) && (E_OK == getBufferRes))
	.d2line		10116
.Llo997:
	rlwinm		r0,r30,0,24,31		# GetNextDtc=r30
.Llo998:
	se_cmpi		r0,1
	bc		0,2,.L2091	# ne
	rlwinm		r29,r29,0,24,31		# getBufferRes=r29 getBufferRes=r29
	se_cmpi		r29,0		# getBufferRes=r29
	bc		0,2,.L2091	# ne
#    {
#       getBufferRes =  Dcm_DsdRequestResponseBuffer(DCM_REPORTDTCBYSEVERITYMASKRECORD_ANSWERSIZE, &resBuffer);
	.d2line		10118
.Llo1007:
	diab.addi		r4,r1,12
	diab.li		r3,6		# getBufferRes=r3
	bl		Dcm_DsdRequestResponseBuffer
.Llo1008:
	mr		r29,r3		# getBufferRes=r29 getBufferRes=r3
# 
#       if (E_OK == getBufferRes)
	.d2line		10120
	rlwinm		r3,r3,0,24,31		# getBufferRes=r3 getBufferRes=r3
	se_cmpi		r3,0		# getBufferRes=r3
	bc		0,2,.L2094	# ne
	.section	.text_vle
.L3932:
#       {
#          uint32 Dtc;
#          Dem_UdsStatusByteType DtcStatus;
#          Dem_DTCSeverityType DtcSeverity;
#          uint8 DtcFunctionalUnit;
#          CONST(Dem_ReturnGetNextFilteredElementType, AUTOMATIC) Status = Dem_DcmGetNextFilteredDTCAndSeverity(&Dtc, &DtcStatus, &DtcSeverity, &DtcFunctionalUnit);
	.d2line		10126
.Llo1009:
	diab.addi		r3,r1,16		# getBufferRes=r3
.Llo1010:
	diab.addi		r4,r1,8
	diab.addi		r5,r1,9
	diab.addi		r6,r1,10		# Status=r6
	bl		Dem_DcmGetNextFilteredDTCAndSeverity
.Llo1011:
	mr		r6,r3		# Status=r6 Status=r3
# 
#          switch (Status)
	.d2line		10128
	rlwinm		r6,r6,0,24,31		# Status=r6 Status=r6
	se_cmpi		r6,0		# Status=r6
	bc		1,2,.L2097	# eq
.Llo1012:
	se_cmpi		r6,1		# Status=r6
.Llo1013:
	bc		1,2,.L2095	# eq
.Llo1003:
	b		.L2099
.L2095:
#          {
#             case DEM_FILTERED_NO_MATCHING_ELEMENT:
#             {
#                /*
#                 * All matching dtcs were successfully received.
#                 *
#                 * Release the requested buffer if no data is available.
#                 * DSD will handle the freed buffer.
#                 */
#                GetNextDtc = FALSE;
	.d2line		10138
	diab.li		r30,0		# GetNextDtc=r30
#                Dcm_DsdReleaseResponseBuffer(DCM_REPORTDTCBYSEVERITYMASKRECORD_ANSWERSIZE);
	.d2line		10139
.Llo1004:
	diab.li		r3,6		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
	b		.L2092
.L2097:
#                break;
#             }
# 
#             case DEM_FILTERED_OK:
#             {
#                resBuffer[0] = DtcSeverity;
	.d2line		10145
.Llo1014:
	lbz		r0,9(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,0(r3)		# getBufferRes=r3
#                resBuffer[1] = DtcFunctionalUnit;
	.d2line		10146
	lbz		r0,10(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,1(r3)		# getBufferRes=r3
#                SET_RESPONSE_DTC(&resBuffer[2], Dtc);
	.d2line		10147
	lwz		r0,16(r1)
	rlwinm		r0,r0,16,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,2(r3)		# getBufferRes=r3
	lhz		r0,18(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,3(r3)		# getBufferRes=r3
	lbz		r0,19(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,4(r3)		# getBufferRes=r3
#                resBuffer[5] = (uint8)DtcStatus;
	.d2line		10148
	lbz		r0,8(r1)
	lwz		r3,12(r1)		# getBufferRes=r3
	stb		r0,5(r3)		# getBufferRes=r3
	b		.L2092
.L2099:
#                break;
#             }
# 
#             default:
#             {
#                /*
#                 * All other type of faults will end up here.
#                 *
#                 * Release the requested buffer if no data is available.
#                 * DsD will handle the freed buffer.
#                 */
#                Dcm_DsdReleaseResponseBuffer(DCM_REPORTDTCBYSEVERITYMASKRECORD_ANSWERSIZE);
	.d2line		10160
.Llo1005:
	diab.li		r3,6		# getBufferRes=r3
	bl		Dcm_DsdReleaseResponseBuffer
#                *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10161
	diab.li		r0,49
	stb		r0,0(r31)		# pErrorCode=r31
#                GetNextDtc = FALSE;
	.d2line		10162
	diab.li		r30,0		# GetNextDtc=r30
.Llo1006:
	b		.L2092
	.section	.text_vle
.L3933:
.L2094:
#                break;
#             }
#          }
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == getBufferRes)
#       {
#          /*
#           * Do nothing, it will continue to read data later.
#           */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#       }
#       else if (DCM_INT_E_RESPONSE_FULL == getBufferRes)
#       {
#          /*
#           * The whole length of the originally calculated response length has been filled.
#           */
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned one of:
#           *  E_NOT_OK
#           *
#           * Abort, as neither of these make sense to retrieve the data.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10190
	diab.li		r0,49
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L2092
.L2091:
#       }
#    }
# }
	.d2line		10193
	.d2epilogue_begin
.Llo999:
	lmw		r29,36(r1)		# offset r1+36  0x24
	.d2_cfa_restore_list	3,10
.Llo1000:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1001:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3924:
	.type		HelpFncReportDTCBySeverityMaskRecord,@function
	.size		HelpFncReportDTCBySeverityMaskRecord,.-HelpFncReportDTCBySeverityMaskRecord
# Number of nodes = 129

# Allocations for HelpFncReportDTCBySeverityMaskRecord
#	?a4		pErrorCode
#	?a5		GetNextDtc
#	?a6		getBufferRes
#	SP,12		resBuffer
#	SP,16		Dtc
#	SP,8		DtcStatus
#	SP,9		DtcSeverity
#	SP,10		DtcFunctionalUnit
#	?a7		Status
# static FUNC(void, DCM_CODE) ReportDTCBySeverityMaskRecord(CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         10199,29
#$$ld
.L3944:

#$$bf	ReportDTCBySeverityMaskRecord,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDTCBySeverityMaskRecord:
.Llo1015:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pMsgContext=r31 pMsgContext=r3
	mr		r30,r4		# pErrorCode=r30 pErrorCode=r4
	.d2prologue_end
#                                                           CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Dem_UdsStatusByteType                  dtcStatusMask;
#    Dem_UdsStatusByteType                  statusAvailabilityMask;
#    uint16                                 numOfDtc;
#    Dcm_MsgLenType                         totalAnswerSize;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) resBuffer;
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		10208
	lis		r3,(Dcm_DspInstance+8)@ha
.Llo1016:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L2108	# ne
#    {
#       if (E_OK != Dem_DcmGetDTCStatusAvailabilityMask(&statusAvailabilityMask))
	.d2line		10210
.Llo1017:
	diab.addi		r3,r1,8
.Llo1025:
	bl		Dem_DcmGetDTCStatusAvailabilityMask
	e_andi.		r3,r3,255
	bc		1,2,.L2109	# eq
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10212
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L2108
.L2109:
#       }
#       else
#       {
#          /*
#             * The requested DTC severity mask is in byte 1.
#             * The requested DTC status mask is in byte 2.
#             */
#          dtcStatusMask = (Dem_UdsStatusByteType)(pMsgContext->reqData[2] & (Dcm_MsgItemType)statusAvailabilityMask);
	.d2line		10220
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r0,2(r3)
	lbz		r4,8(r1)		# dtcStatusMask=r4
.Llo1029:
	and		r0,r0,r4		# dtcStatusMask=r4
	mr		r4,r0		# dtcStatusMask=r4 dtcStatusMask=r0
# 
#          /*
#             * [SWS_Dcm_00700]: If the DtcStatusMask is 0x00, the DCM shall respond
#             * with an empty positive response except if the sub service was 0x0A and 0x15
#             */
#          if (0x00 == dtcStatusMask)
	.d2line		10226
.Llo1030:
	rlwinm		r3,r4,0,24,31		# dtcStatusMask=r4
.Llo1031:
	se_cmpi		r3,0
	bc		0,2,.L2111	# ne
#          {
#             /*
#              * Dcm_DsdStartResponse and Dcm_DsdRequestResponseBuffer will never return anything else than E_OK
#              *
#              * MISRA-C:2004 RULE 16.10 VIOLATION:
#              * If a function returns error information, then that error information shall be tested.
#              * Since the request is always two bytes and that will fit into the minimum
#              * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#              */
#             (void)Dcm_DsdStartResponse((Dcm_MsgLenType)2U);
	.d2line		10236
.Llo1032:
	diab.li		r3,2
	bl		Dcm_DsdStartResponse
#             (void)Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)2U, &resBuffer);
	.d2line		10237
	diab.addi		r4,r1,12		# dtcStatusMask=r4
	diab.li		r3,2
	bl		Dcm_DsdRequestResponseBuffer
# 
#             /*
#                * Fill in mandatory response data
#                */
#             resBuffer[0] = pMsgContext->subServiceId;
	.d2line		10242
	lbz		r0,26(r31)		# pMsgContext=r31
	lwz		r3,12(r1)
	stb		r0,0(r3)
#             resBuffer[1] = (Dcm_MsgItemType)statusAvailabilityMask;
	.d2line		10243
	lbz		r0,8(r1)
	lwz		r3,12(r1)
	stb		r0,1(r3)
	b		.L2112
.L2111:
#          }
#          else if (DEM_FILTER_ACCEPTED != Dem_DcmSetDTCFilter(dtcStatusMask,
	.d2line		10245
.Llo1033:
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
	bl		GetSeverityType
	mr		r0,r3		# pMsgContext=r0
	rlwinm		r3,r4,0,24,31		# pMsgContext=r3 dtcStatusMask=r4
	rlwinm		r8,r0,0,24,31		# pMsgContext=r0
	diab.li		r4,1		# dtcStatusMask=r4
.Llo1034:
	diab.li		r5,11
	diab.li		r6,1
	diab.li		r7,1
	diab.li		r9,0
	bl		Dem_DcmSetDTCFilter
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,0		# pMsgContext=r3
	bc		1,2,.L2113	# eq
#                                                       DEM_DTC_KIND_ALL_DTCS,
#                                                       DEM_DTC_FORMAT_UDS,
#                                                       DEM_DTC_ORIGIN_PRIMARY_MEMORY,
#                                                       TRUE,
#                                                       GetSeverityType(pMsgContext),
#                                                       FALSE))
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10253
	diab.li		r0,49		# pMsgContext=r0
	stb		r0,0(r30)		# pErrorCode=r30 pMsgContext=r0
	b		.L2112
.L2113:
#          }
#          /*
#             * The DTC filter is already set, so now just fetch
#             * the number of DTC that matched the filter
#             */
#          else if (DEM_NUMBER_FAILED == Dem_DcmGetNumberOfFilteredDTC(&numOfDtc))
	.d2line		10259
	diab.addi		r3,r1,10		# pMsgContext=r3
	bl		Dem_DcmGetNumberOfFilteredDTC
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	se_cmpi		r3,1		# pMsgContext=r3
	bc		0,2,.L2115	# ne
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10261
	diab.li		r0,49		# pMsgContext=r0
	stb		r0,0(r30)		# pErrorCode=r30 pMsgContext=r0
	b		.L2112
.L2115:
#          }
#          else
#          {
#             /*
#                * Do not worry about pending since Dem currently does not handle pending.
#                */
# 
#             /* 6 bytes per Dtc + 1 byte reportDTCBySeverityMaskRecord + 1 byte DTCStatusAvailabilityMask */
#             totalAnswerSize = (Dcm_MsgLenType)((numOfDtc * 6U) + 2U);
	.d2line		10270
	lhz		r3,10(r1)		# pMsgContext=r3
	e_mulli		r3,r3,6		# pMsgContext=r3 pMsgContext=r3
	se_addi		r3,2		# pMsgContext=r3 pMsgContext=r3
	.d2line		10275
.Llo1035:
	rlwinm		r3,r3,0,16,31		# totalAnswerSize=r3 totalAnswerSize=r3
# 
#             /*
#                * Start response
#                */
#             if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(totalAnswerSize))
.Llo1036:
	bl		Dcm_DsdStartResponse
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
	cmpi		0,0,r3,200		# pMsgContext=r3
	bc		0,2,.L2117	# ne
#             {
#                *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		10277
	diab.li		r0,20		# pMsgContext=r0
	stb		r0,0(r30)		# pErrorCode=r30 pMsgContext=r0
	b		.L2112
.L2117:
#             }
#             else
#             {
#                /*
#                 * Dcm_DsdRequestResponseBuffer will never return anything else than E_OK
#                 *
#                 * MISRA-C:2004 RULE 16.10 VIOLATION:
#                 * If a function returns error information, then that error information shall be tested.
#                 * Since the request is always two bytes and that will fit into the minimum
#                 * Tx buffer since the SCG guarantees that it's at least 8 bytes.
#                 */
#                (void)Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)2U, &resBuffer);
	.d2line		10289
	diab.addi		r4,r1,12		# dtcStatusMask=r4
	diab.li		r3,2		# pMsgContext=r3
	bl		Dcm_DsdRequestResponseBuffer
# 
#                /*
#                   * Fill in mandatory response data
#                   */
#                resBuffer[0] = pMsgContext->subServiceId;
	.d2line		10294
	lbz		r0,26(r31)		# pMsgContext=r0 pMsgContext=r31
	lwz		r3,12(r1)		# pMsgContext=r3
	stb		r0,0(r3)		# pMsgContext=r3 pMsgContext=r0
#                resBuffer[1] = (Dcm_MsgItemType)statusAvailabilityMask;
	.d2line		10295
	lbz		r0,8(r1)		# pMsgContext=r0
	lwz		r3,12(r1)		# pMsgContext=r3
	stb		r0,1(r3)		# pMsgContext=r3 pMsgContext=r0
# 
#                /*
#                 * Start adding data
#                 */
#                HelpFncReportDTCBySeverityMaskRecord(pErrorCode);
	.d2line		10300
	mr		r3,r30		# pErrorCode=r3 pErrorCode=r30
	bl		HelpFncReportDTCBySeverityMaskRecord
.L2112:
#             }
#          }
# 
#          if (DCM_INT_NRC_API_RETURNED_PENDING == *pErrorCode)
	.d2line		10304
.Llo1018:
	lbz		r0,0(r30)		# pMsgContext=r0 pErrorCode=r30
.Llo1019:
	cmpi		0,0,r0,162		# pMsgContext=r0
	bc		0,2,.L2108	# ne
#          {
#             /* All data can not be sent this time, paging*/
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		10307
.Llo1020:
	diab.li		r0,1		# pMsgContext=r0
.Llo1021:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r3 pMsgContext=r0
.L2108:
#          }
#          else
#          {
#             /*
#              * Do nothing, a response will be sent at end.
#              */
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		10318
.Llo1022:
	lis		r3,(Dcm_DspInstance+8)@ha		# pMsgContext=r3
.Llo1023:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# pMsgContext=r0 pMsgContext=r3
	se_cmpi		r0,1		# pMsgContext=r0
	bc		0,2,.L2107	# ne
#    {
#       HelpFncReportDTCBySeverityMaskRecord(pErrorCode);
	.d2line		10320
.Llo1024:
	mr		r3,r30		# pErrorCode=r3 pErrorCode=r30
	bl		HelpFncReportDTCBySeverityMaskRecord
.L2107:
#    }
# }
	.d2line		10322
	.d2epilogue_begin
.Llo1026:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
.Llo1027:
	lwz		r0,36(r1)		# pMsgContext=r0
	mtspr		lr,r0		# pMsgContext=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1028:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3945:
	.type		ReportDTCBySeverityMaskRecord,@function
	.size		ReportDTCBySeverityMaskRecord,.-ReportDTCBySeverityMaskRecord
# Number of nodes = 170

# Allocations for ReportDTCBySeverityMaskRecord
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$57
#	?a7		dtcStatusMask
#	SP,8		statusAvailabilityMask
#	SP,10		numOfDtc
#	?a8		totalAnswerSize
#	SP,12		resBuffer
# static FUNC(void, DCM_CODE) ReportDtcInformationByOccurrence(
	.align		1
	.section	.text_vle
        .d2line         10328,29
#$$ld
.L3958:

#$$bf	ReportDtcInformationByOccurrence,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReportDtcInformationByOccurrence:
.Llo1037:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r29,r3		# pMsgContext=r29 pMsgContext=r3
	mr		r31,r4		# DtcRequest=r31 DtcRequest=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
#                                        CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                        Dem_DTCRequestType           DtcRequest,
#                                        CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint32                 Dtc;
#    uint8                  DtcStatus;
#    Dem_UdsStatusByteType  StatusAvailabilityMask;
# 
#    if (E_OK != Dem_DcmGetDTCStatusAvailabilityMask(&StatusAvailabilityMask))
	.d2line		10337
	diab.addi		r3,r1,8
.Llo1038:
	bl		Dem_DcmGetDTCStatusAvailabilityMask
.Llo1041:
	e_andi.		r3,r3,255
	bc		1,2,.L2131	# eq
#    {
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10339
.Llo1039:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L2130
.L2131:
#    }
#    else if (DEM_OCCURR_OK != Dem_DcmGetDTCByOccurrenceTime(DtcRequest, &Dtc))
	.d2line		10341
	rlwinm		r3,r31,0,24,31		# DtcRequest=r31
	diab.addi		r4,r1,12
	bl		Dem_DcmGetDTCByOccurrenceTime
	e_andi.		r3,r3,255
	bc		1,2,.L2133	# eq
#    {
#       /*
#        * [SWS_Dcm_00766] No dtc matched the request.
#        * Prepare empty positive response, i.e. only the availability mask.
#        */
#       pMsgContext->resData[0] = pMsgContext->reqData[0];
	.d2line		10347
.Llo1042:
	lwz		r3,0(r29)		# pMsgContext=r29
	lbz		r0,0(r3)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,0(r3)
#       pMsgContext->resData[1] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		10348
	lbz		r0,8(r1)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,1(r3)
#       pMsgContext->resDataLen = 2;
	.d2line		10349
	diab.li		r0,2
	sth		r0,12(r29)		# pMsgContext=r29
	b		.L2130
.L2133:
#    }
#    else if (DEM_STATUS_OK == Dem_DcmGetStatusOfDTC(Dtc, DEM_DTC_ORIGIN_PRIMARY_MEMORY, &DtcStatus))
	.d2line		10351
	lwz		r3,12(r1)
	diab.addi		r5,r1,9
	diab.li		r4,1
	bl		Dem_DcmGetStatusOfDTC
	e_andi.		r3,r3,255
	bc		0,2,.L2135	# ne
#    {
#       /*
#        * Prepare positive response
#        */
#       pMsgContext->resData[0] = pMsgContext->reqData[0];
	.d2line		10356
	lwz		r3,0(r29)		# pMsgContext=r29
	lbz		r0,0(r3)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,0(r3)
#       pMsgContext->resData[1] = (Dcm_MsgItemType)StatusAvailabilityMask;
	.d2line		10357
	lbz		r0,8(r1)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,1(r3)
#       SET_RESPONSE_DTC(&pMsgContext->resData[2], Dtc);
	.d2line		10358
	lwz		r0,12(r1)
	rlwinm		r0,r0,16,24,31
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,2(r3)
	lhz		r0,14(r1)
	rlwinm		r0,r0,24,24,31
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,3(r3)
	lbz		r0,15(r1)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,4(r3)
#       pMsgContext->resData[5] = DtcStatus;
	.d2line		10359
	lbz		r0,9(r1)
	lwz		r3,8(r29)		# pMsgContext=r29
	stb		r0,5(r3)
#       pMsgContext->resDataLen = 6;
	.d2line		10360
	diab.li		r0,6
	sth		r0,12(r29)		# pMsgContext=r29
	b		.L2130
.L2135:
#    }
#    else
#    {
#       /*
#        * One of the following was returned:
#        *     DEM_STATUS_WRONG_TRANSLATION,
#        *     DEM_STATUS_WRONG_DTC,
#        *     DEM_STATUS_FAILED
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		10370
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
.L2130:
#    }
# }
	.d2line		10372
	.d2epilogue_begin
.Llo1040:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3959:
	.type		ReportDtcInformationByOccurrence,@function
	.size		ReportDtcInformationByOccurrence,.-ReportDtcInformationByOccurrence
# Number of nodes = 149

# Allocations for ReportDtcInformationByOccurrence
#	?a4		pMsgContext
#	?a5		DtcRequest
#	?a6		pErrorCode
#	SP,12		Dtc
#	SP,9		DtcStatus
#	SP,8		StatusAvailabilityMask
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ReadDTCInformation(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         3253,32
#$$ld
.L3971:

#$$bf	Dcm_ReadDTCInformation,interprocedural,rasave,nostackparams
	.globl		Dcm_ReadDTCInformation
	.d2_cfa_start __cie
Dcm_ReadDTCInformation:
.Llo1043:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)		# OpStatus=r0
	.d2_cfa_offset    108,-1
	mr		r0,r3		# OpStatus=r0 OpStatus=r3
	mr		r3,r4		# pMsgContext=r3 pMsgContext=r4
.Llo1044:
	mr		r31,r5		# pErrorCode=r31 pErrorCode=r5
	.d2prologue_end
# {
#    if (DCM_CANCEL == OpStatus)
	.d2line		3255
.Llo1045:
	rlwinm		r0,r0,0,24,31		# OpStatus=r0 OpStatus=r0
	se_cmpi		r0,2		# OpStatus=r0
	bc		1,2,.L828	# eq
#    {
#       /*
#        * It's currently not possible to cancel Dem operations.
#        * Thus immediately return OK.
#        */
#    }
#    else
#    {
#       /*
#        * The SCG of the DCM will not accept any other subfunctions than 0x01 up to 0x19.
#        * All other configured subfunctions will be rejected by the SCG. Consequently, the DSD
#        * will reject any attempt to request a non configured subfunction. Therefore, there's no
#        * need to check if the subfunction is valid or not (it will always be 0x01 up to 0x19).
#        */
#       if (readDtcReqLengths[pMsgContext->subServiceId] != pMsgContext->reqDataLen)
	.d2line		3270
.Llo1046:
	lis		r4,readDtcReqLengths@ha
.Llo1051:
	e_add16i		r4,r4,readDtcReqLengths@l
	lbz		r0,26(r3)		# OpStatus=r0 pMsgContext=r3
.Llo1047:
	rlwinm		r0,r0,1,23,30		# OpStatus=r0 OpStatus=r0
	lhzx		r0,r4,r0		# OpStatus=r0
	lhz		r4,4(r3)		# pMsgContext=r3
	se_cmp		r0,r4		# OpStatus=r0
	bc		1,2,.L829	# eq
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		3272
.Llo1048:
	diab.li		r0,19		# OpStatus=r0
.Llo1049:
	stb		r0,0(r31)		# pErrorCode=r31 OpStatus=r0
	b		.L828
.L829:
#       }
#       else
#       {
#          switch (pMsgContext->subServiceId)
	.d2line		3276
.Llo1050:
	lbz		r6,26(r3)		# pMsgContext=r3
	se_cmpli	r6,25
	se_slwi		r6,2
	e_add2is		r6,.L3977@ha
	bc		1,1,.L856	# gt
	lwz		r7,.L3977@l(r6)
	mtspr		ctr,r7
	bcctr		20,0
.L3977:
#$$sl
	.long		.L856
	.long		.L833
	.long		.L839
	.long		.L840
	.long		.L842
	.long		.L843
	.long		.L846
	.long		.L833
	.long		.L847
	.long		.L848
	.long		.L839
	.long		.L849
	.long		.L850
	.long		.L851
	.long		.L852
	.long		.L839
	.long		.L846
	.long		.L833
	.long		.L853
	.long		.L854
	.long		.L855
	.long		.L839
	.long		.L856
	.long		.L839
	.long		.L842
	.long		.L846
#$$se
.L833:
#          {
#             case DCM_S19_SF01_NUMBEROFDTCBYSTATUSMASK:             /* Intentional fall through */
#             case DCM_S19_SF07_NUMBEROFDTCBYSEVERITYMASKRECORD:     /* Intentional fall through */
#             case DCM_S19_SF11_NUMBEROFMIRRORMEMORYDTCBYSTATUSMASK:
#             {
#                /* Report both emission and non-emission */
#                ReportNumberOfDTCsByStatusMask(pMsgContext, DEM_DTC_KIND_ALL_DTCS, pErrorCode);
	.d2line		3283
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1052:
	diab.li		r4,1
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportNumberOfDTCsByStatusMask
	b		.L828
.L839:
#                break;
#             }
# 
# 
#             case DCM_S19_SF02_DTCBYSTATUSMASK:              /* Intentional fall through */
#             case DCM_S19_SF0A_SUPPORTEDDTCS:                /* Intentional fall through */
#             case DCM_S19_SF0F_MIRRORMEMORYDTCBYSTATUSMASK:  /* Intentional fall through */
#             case DCM_S19_SF15_DTCWITHPERMANENTSTATUS:       /* Intentional fall through */
#             case DCM_S19_SF17_USERDEFMEMORYDTCBYSTATUSMASK:
#             {
#                /* Report both emission and non-emission */
#                ReportDTCsByStatusMask(pMsgContext, DEM_DTC_KIND_ALL_DTCS, pErrorCode);
	.d2line		3295
.Llo1053:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1054:
	diab.li		r4,1
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDTCsByStatusMask
	b		.L828
.L840:
#                break;
#             }
# 
#             case DCM_S19_SF03_DTCSNAPSHOTIDENTIFICATION:
#             {
#                ReportDTCSnapshotIdentification(pMsgContext, pErrorCode);
	.d2line		3301
.Llo1055:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1056:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportDTCSnapshotIdentification
	b		.L828
.L842:
#                break;
#             }
# 
#             case DCM_S19_SF04_DTCSNAPSHOTRECORDBYDTCNUMBER:              /* intentional fall through */
#             case DCM_S19_SF18_USERDEFMEMORYDTCSNAPSHOTRECORDBYDTCNUMBER:
#             {
#                ReportDTCSnapshotRecordByDTCNumber(pMsgContext, pErrorCode);
	.d2line		3308
.Llo1057:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1058:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportDTCSnapshotRecordByDTCNumber
	b		.L828
.L843:
#                break;
#             }
# 
#             case DCM_S19_SF05_DTCSNAPSHOTRECORDBYRECORDNUMBER:
#             {
#                ReportDTCSnapshotRecordByRecordNumber(pMsgContext, pErrorCode);
	.d2line		3314
.Llo1059:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1060:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportDTCSnapshotRecordByRecordNumber
	b		.L828
.L846:
#                break;
#             }
# 
#             case DCM_S19_SF06_DTCEXTENDEDDATARECORDBYDTCNUMBER:             /* Intentional fall through */
#             case DCM_S19_SF10_MIRRORMEMORYDTCEXTENDEDDATARECORDBYDTCNUMBER: /* Intentional fall through */
#             case DCM_S19_SF19_USERDEFMEMORYDTCEXTDATARECORDBYDTCNUMBER:
#             {
#                ReportDTCExtendedDataRecordByDTCNumber(pMsgContext, pErrorCode);
	.d2line		3322
.Llo1061:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1062:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportDTCExtendedDataRecordByDTCNumber
	b		.L828
.L847:
#                break;
#             }
# 
#             case DCM_S19_SF08_DTCBYSEVERITYMASKRECORD:
#             {
#                ReportDTCBySeverityMaskRecord(pMsgContext, pErrorCode);
	.d2line		3328
.Llo1063:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1064:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportDTCBySeverityMaskRecord
	b		.L828
.L848:
#                break;
#             }
# 
#             case DCM_S19_SF09_SEVERITYINFORMATIONOFDTC:
#             {
#                ReportSeverityInformationOfDTC(pMsgContext, pErrorCode);
	.d2line		3334
.Llo1065:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1066:
	mr		r4,r31		# pErrorCode=r4 pErrorCode=r31
	bl		ReportSeverityInformationOfDTC
	b		.L828
.L849:
#                break;
#             }
# 
#             case DCM_S19_SF0B_FIRSTTESTFAILEDDTC:
#             {
#                /* Report first failed DTC */
#                ReportDtcInformationByOccurrence(pMsgContext, DEM_FIRST_FAILED_DTC, pErrorCode);
	.d2line		3341
.Llo1067:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1068:
	diab.li		r4,1
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDtcInformationByOccurrence
	b		.L828
.L850:
#                break;
#             }
# 
#             case DCM_S19_SF0C_FIRSTCONFIRMEDDTC:
#             {
#                /* Report first confirmed DTC */
#                ReportDtcInformationByOccurrence(pMsgContext, DEM_FIRST_DET_CONFIRMED_DTC, pErrorCode);
	.d2line		3348
.Llo1069:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1070:
	diab.li		r4,3
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDtcInformationByOccurrence
	b		.L828
.L851:
#                break;
#             }
# 
#             case DCM_S19_SF0D_MOSTRECENTTESTFAILEDDTC:
#             {
#                /* Report most recent failed DTC */
#                ReportDtcInformationByOccurrence(pMsgContext, DEM_MOST_RECENT_FAILED_DTC, pErrorCode);
	.d2line		3355
.Llo1071:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1072:
	diab.li		r4,2
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDtcInformationByOccurrence
	b		.L828
.L852:
#                break;
#             }
# 
#             /* reportMostRecentConfirmedDTC */
#             case DCM_S19_SF0E_MOSTRECENTCONFIRMEDDTC:
#             {
#                /* Read most recent confirmed DTC */
#                ReportDtcInformationByOccurrence(pMsgContext, DEM_MOST_REC_DET_CONFIRMED_DTC, pErrorCode);
	.d2line		3363
.Llo1073:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1074:
	diab.li		r4,4
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDtcInformationByOccurrence
	b		.L828
.L853:
#                break;
#             }
# 
#             case DCM_S19_SF12_NUMBEROFEMISSIONSRELATEDOBDDTCBYSTATUSMASK:
#             {
#                /* Report only emission related */
#                ReportNumberOfDTCsByStatusMask(pMsgContext, DEM_DTC_KIND_EMISSION_REL_DTCS, pErrorCode);
	.d2line		3370
.Llo1075:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1076:
	diab.li		r4,2
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportNumberOfDTCsByStatusMask
	b		.L828
.L854:
#                break;
#             }
# 
#             /* reportEmissionsRelatedOBDDTCByStatusMask */
#             case DCM_S19_SF13_EMISSIONSRELATEDOBDDTCBYSTATUSMASK:
#             {
#                /* Report both emission and non-emission */
#                ReportDTCsByStatusMask(pMsgContext, DEM_DTC_KIND_EMISSION_REL_DTCS, pErrorCode);
	.d2line		3378
.Llo1077:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1078:
	diab.li		r4,2
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDTCsByStatusMask
	b		.L828
.L855:
#                break;
#             }
# 
#             case DCM_S19_SF14_DTCFAULTDETECTIONCOUNTER:
#             {
#                /* Report both emission and non-emission */
#                ReportDTCFaultDetectionCounter(pMsgContext, DEM_DTC_KIND_ALL_DTCS, pErrorCode);
	.d2line		3385
.Llo1079:
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
.Llo1080:
	diab.li		r4,1
	mr		r5,r31		# pErrorCode=r5 pErrorCode=r31
	bl		ReportDTCFaultDetectionCounter
	b		.L828
.L856:
#                break;
#             }
# 
#             default:
#             {
#                /*
#                 * Unsupported sub function.
#                 * Shall never happen since cannot be configured by SCG and thus stopped by DSD 
#                 */
#                DCM_ASSERT_PARAM(SID_READDTCINFORMATION, FALSE);
	.d2line		3395
	diab.li		r3,53		# pMsgContext=r3
	diab.li		r4,0
	diab.li		r5,131
	diab.li		r6,6
	bl		Det_ReportError
.L828:
#                break;
#             }
#          }
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		3402
.Llo1081:
	lbz		r3,0(r31)		# pMsgContext=r3 pErrorCode=r31
.Llo1083:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo1082:
	rlwinm		r3,r3,0,24,31		# pMsgContext=r3 pMsgContext=r3
# }
	.d2line		3403
	.d2epilogue_begin
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# OpStatus=r0
	mtspr		lr,r0		# OpStatus=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3972:
	.type		Dcm_ReadDTCInformation,@function
	.size		Dcm_ReadDTCInformation,.-Dcm_ReadDTCInformation
# Number of nodes = 173

# Allocations for Dcm_ReadDTCInformation
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
# static FUNC(void, DCM_CODE) WriteSignalToBuf_uint8N(P2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) pSrcData,
	.align		1
	.section	.text_vle
        .d2line         3908,29
#$$ld
.L3980:

#$$bf	WriteSignalToBuf_uint8N,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
WriteSignalToBuf_uint8N:
.Llo1084:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r0,r3		# pSrcData=r0 pSrcData=r3
	mr		r4,r4		# pDestination=r4 pDestination=r4
	mr		r5,r5		# bitPos=r5 bitPos=r5
	mr		r6,r6		# byteCount=r6 byteCount=r6
	.d2prologue_end
#                                                     P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pDestination,
#                                                     uint16 bitPos,
#                                                     uint16 byteCount)
# {
#    uint8  byteOffset;
#    uint16 i;
# 
#    uint16 srcValue;
#    uint8  lsbValue;
#    uint8  msbValue;
#    uint8  byte;
# 
#    uint16 mask;
#    uint8  lsbMask;
#    uint8  msbMask;
# 
#    byteOffset   = (uint8)(bitPos / 8U);
	.d2line		3925
	rlwinm		r3,r5,29,19,31		# bitPos=r5
.Llo1085:
	mr		r3,r3		# byteOffset=r3 byteOffset=r3
# 
#    if ((uint16)0U == (uint16)(bitPos % 8U))
	.d2line		3927
	rlwinm		r28,r5,0,29,31		# bitPos=r5
	e_and2i.		r28,65535
	bc		0,2,.L877	# ne
#    {
#       /* Placed on a byte border. Use the easy way... */
#       Dcm_Memcpy(&pDestination[byteOffset], pSrcData, (Dcm_MsgLenType)byteCount);
	.d2line		3930
.Llo1086:
	rlwinm		r3,r3,0,24,31		# byteOffset=r3 byteOffset=r3
	se_add		r3,r4		# byteOffset=r3 byteOffset=r3 pDestination=r4
.Llo1091:
	rlwinm		r5,r6,0,16,31		# bitPos=r5 byteCount=r6
	mr		r4,r0		# pSrcData=r4 pSrcData=r0
.Llo1090:
	bl		Dcm_Memcpy
.Llo1087:
	b		.L876
.L877:
#    }
#    else
#    {
#       /* Not placed on a byte border. Use the difficult way... */
# 
#       for (i = 0; i < byteCount; i++)
	.d2line		3936
.Llo1088:
	diab.li		r7,0		# i=r7
.L879:
.Llo1092:
	rlwinm		r31,r7,0,16,31		# i=r7
	rlwinm		r30,r6,0,16,31		# byte=r30 byteCount=r6
.Llo1102:
	se_cmp		r31,r30		# byte=r30
	bc		0,0,.L876	# ge
#       {
#          /*
#           * Create the bit mask for the current signal size and bitPos
#           * Always using 8 bits per byte since it is a Uint8[n]
#           */
#          mask    = (uint16)((uint16)0xFFU << (bitPos % 8U));
	.d2line		3942
.Llo1103:
	diab.li		r31,255
	rlwinm		r28,r5,0,29,31		# byte=r28 bitPos=r5
.Llo1104:
	slw		r30,r31,r28		# byte=r30 byte=r28
.Llo1108:
	mr		r30,r30		# mask=r30 mask=r30
#          msbMask = (uint8)~(uint8)(mask >> 8U);
	.d2line		3943
	rlwinm		r26,r30,24,24,31		# msbValue=r26 mask=r30
.Llo1098:
	nor		r26,r26,r26		# msbValue=r26 msbValue=r26 msbValue=r26
.Llo1099:
	mr		r26,r26		# msbMask=r26 msbMask=r26
#          lsbMask = (uint8)~(uint8)(mask & 0x00FFU);
	.d2line		3944
	nand		r29,r30,r31		# lsbValue=r29 mask=r30
.Llo1110:
	mr		r29,r29		# lsbMask=r29 lsbMask=r29
# 
#          /*
#           * shift the signal to the correct position
#           */
#          srcValue = (uint16)((uint16)pSrcData[i] << (bitPos % 8U)) & mask;
	.d2line		3949
	rlwinm		r31,r7,0,16,31		# i=r7
	lbzux		r27,r31,r0		# mask=r27
	slw		r27,r27,r28		# mask=r27 mask=r27 byte=r28
	and		r30,r30,r27		# mask=r30 mask=r30 mask=r27
.Llo1093:
	mr		r30,r30		# srcValue=r30 srcValue=r30
#          lsbValue = (uint8)(srcValue & 0x00FFU);
	.d2line		3950
.Llo1109:
	rlwinm		r28,r30,0,24,31		# byte=r28 srcValue=r30
.Llo1095:
	mr		r28,r28		# lsbValue=r28 lsbValue=r28
# 
#          /*
#           * Store bits in the first byte
#           */
#          byte  = pDestination[byteOffset];
	.d2line		3955
.Llo1096:
	rlwinm		r31,r3,0,24,31		# byteOffset=r3
	lbzux		r8,r31,r4		# byte=r8
	mr		r8,r8		# byte=r8 byte=r8
#          byte &= lsbMask;
	.d2line		3956
	and		r29,r8,r29		# byte=r29 byte=r8 lsbMask=r29
.Llo1111:
	mr		r29,r29		# byte=r29 byte=r29
#          byte |= lsbValue;
	.d2line		3957
.Llo1097:
	or		r28,r28,r29		# byte=r28 byte=r28 lsbValue=r29
	mr		r8,r28		# byte=r8 byte=r28
#          pDestination[byteOffset] = byte;
	.d2line		3958
	rlwinm		r31,r3,0,24,31		# byteOffset=r3
	stbux		r28,r31,r4		# byte=r28
# 
#          /*
#           * Store rest of the bits (if any) in next byte
#           */
#          byteOffset++;
	.d2line		3963
	diab.addi		r31,r3,1		# byteOffset=r3
	se_addi		r3,1		# byteOffset=r3 byteOffset=r3
# 
#          msbValue = (uint8)(srcValue >> 8U);
	.d2line		3965
	rlwinm		r30,r30,24,24,31		# srcValue=r30 srcValue=r30
.Llo1094:
	mr		r30,r30		# msbValue=r30 msbValue=r30
#          byte  = pDestination[byteOffset];
	.d2line		3966
.Llo1100:
	rlwinm		r31,r3,0,24,31		# byteOffset=r3
	lbzux		r8,r31,r4		# byte=r8
	mr		r8,r8		# byte=r8 byte=r8
#          byte &= msbMask;
	.d2line		3967
	and		r26,r8,r26		# byte=r26 byte=r8 msbMask=r26
.Llo1105:
	mr		r26,r26		# byte=r26 byte=r26
#          byte |= msbValue;
	.d2line		3968
.Llo1101:
	or		r30,r30,r26		# byte=r30 byte=r30 msbValue=r26
.Llo1106:
	mr		r8,r30		# byte=r8 byte=r30
#          pDestination[byteOffset] = byte;
	.d2line		3969
.Llo1107:
	rlwinm		r31,r3,0,24,31		# byteOffset=r3
	stbux		r30,r31,r4		# byte=r30
#       }
	.d2line		3970
	diab.addi		r31,r7,1		# i=r7
	se_addi		r7,1		# i=r7 i=r7
	b		.L879
.L876:
#    }
# }
	.d2line		3972
	.d2epilogue_begin
.Llo1089:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L3981:
	.type		WriteSignalToBuf_uint8N,@function
	.size		WriteSignalToBuf_uint8N,.-WriteSignalToBuf_uint8N
# Number of nodes = 134

# Allocations for WriteSignalToBuf_uint8N
#	?a4		pSrcData
#	?a5		pDestination
#	?a6		bitPos
#	?a7		byteCount
#	?a8		byteOffset
#	?a9		i
#	?a10		srcValue
#	?a11		lsbValue
#	?a12		msbValue
#	?a13		byte
#	?a14		mask
#	?a15		lsbMask
#	?a16		msbMask
# static FUNC(void, DCM_CODE) WriteSignalToBuf_08(uint8 srcData,
	.align		1
	.section	.text_vle
        .d2line         3977,29
#$$ld
.L4008:

#$$bf	WriteSignalToBuf_08,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r8,r31,cr0,lr
	.d2_cfa_start __cie
WriteSignalToBuf_08:
.Llo1112:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
.Llo1121:
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)		# srcValue=r0
	.d2_cfa_offset    108,-1
	mr		r0,r3		# srcData=r0 srcData=r3
.Llo1122:
	mr		r4,r4		# pDestination=r4 pDestination=r4
	mr		r5,r5		# bitPos=r5 bitPos=r5
	mr		r6,r6		# bitSize=r6 bitSize=r6
	.d2prologue_end
#                                                 P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pDestination,
#                                                 uint16 bitPos,
#                                                 uint8 bitSize)
# {
#    uint16 srcValue;
#    uint8  lsbValue;
#    uint8  msbValue;
#    uint8  byte;
# 
#    uint16 mask;
#    uint8 lsbMask;
#    uint8 msbMask;
# 
#    uint8  byteOffset = (uint8)(bitPos / 8U);
	.d2line		3991
	rlwinm		r3,r5,29,19,31		# bitPos=r5
.Llo1113:
	mr		r3,r3		# byteOffset=r3 byteOffset=r3
# 
#    /*
#     * Get signal value to store. use 16 bit, since it could be
#     * be stored in two consecutive IPdu buffer bytes
#     */
#    srcValue = srcData;
	.d2line		3997
.Llo1114:
	rlwinm		r0,r0,0,24,31		# srcData=r0 srcData=r0
.Llo1115:
	mr		r0,r0		# srcValue=r0 srcValue=r0
# 
#    /*
#     * Create the bit mask for the current signal size and bitPos
#     */
#    mask    = (uint16) masks08[bitSize];
	.d2line		4002
	lis		r7,masks08@ha		# lsbMask=r7
.Llo1136:
	e_add16i		r7,r7,masks08@l		# lsbMask=r7 lsbMask=r7
	rlwinm		r6,r6,0,24,31		# bitSize=r6 bitSize=r6
	lbzx		r6,r7,r6		# bitSize=r6 lsbMask=r7
.Llo1120:
	mr		r6,r6		# mask=r6 mask=r6
#    mask    = (uint16)(mask << (bitPos % 8U));
	.d2line		4003
	rlwinm		r5,r5,0,29,31		# bitPos=r5 bitPos=r5
	slw		r6,r6,r5		# mask=r6 mask=r6 bitPos=r5
	mr		r6,r6		# mask=r6 mask=r6
# 
#    /* Mark the bits of destination bytes shall be maintained.*/
#    msbMask = (uint8)~(uint8)(mask >> 8U);
	.d2line		4006
	rlwinm		r31,r6,24,24,31		# mask=r6
	nor		r31,r31,r31
.Llo1141:
	mr		r31,r31		# msbMask=r31 msbMask=r31
#    lsbMask = (uint8)~(uint8)(mask & 0x00FFU);
	.d2line		4007
	diab.li		r7,255		# lsbMask=r7
.Llo1137:
	nand		r7,r7,r6		# mask=r7 mask=r7 mask=r6
.Llo1138:
	mr		r7,r7		# lsbMask=r7 lsbMask=r7
# 
#    /*
#     * shift the signal to the correct position
#     */
#    srcValue = (uint16)(srcValue << (bitPos % 8U)) & mask;
	.d2line		4012
.Llo1133:
	slw		r0,r0,r5		# srcValue=r0 srcValue=r0 bitPos=r5
	and		r0,r0,r6		# srcValue=r0 srcValue=r0 mask=r6
	mr		r0,r0		# srcValue=r0 srcValue=r0
#    msbValue = (uint8)(srcValue >> 8U);
	.d2line		4013
	rlwinm		r6,r0,24,24,31		# mask=r6 srcValue=r0
.Llo1129:
	mr		r6,r6		# msbValue=r6 msbValue=r6
#    lsbValue = (uint8)(srcValue & 0x00FFU);
	.d2line		4014
.Llo1130:
	rlwinm		r0,r0,0,24,31		# srcValue=r0 srcValue=r0
.Llo1123:
	mr		r0,r0		# lsbValue=r0 lsbValue=r0
# 
#    /*
#     * Store bits in the first byte
#     */
#    if (lsbMask != 0xFFU)
	.d2line		4019
.Llo1126:
	rlwinm		r5,r7,0,24,31		# bitPos=r5 lsbMask=r7
	cmpi		0,0,r5,255		# bitPos=r5
	bc		1,2,.L886	# eq
#    {
#       byte  = pDestination[byteOffset];
	.d2line		4021
.Llo1117:
	rlwinm		r5,r3,0,24,31		# bitPos=r5 byteOffset=r3
.Llo1118:
	lbzux		r8,r5,r4		# byte=r8 bitPos=r5
	mr		r8,r8		# byte=r8 byte=r8
#       byte &= lsbMask;
	.d2line		4022
.Llo1139:
	and		r7,r8,r7		# byte=r7 byte=r8 lsbMask=r7
.Llo1140:
	mr		r7,r7		# byte=r7 byte=r7
#       byte |= lsbValue;
	.d2line		4023
.Llo1127:
	or		r0,r0,r7		# byte=r0 byte=r0 lsbValue=r7
	mr		r5,r0		# byte=r5 byte=r0
#       pDestination[byteOffset] = byte;
	.d2line		4024
.Llo1119:
	rlwinm		r5,r3,0,24,31		# byte=r5 byteOffset=r3
	stbux		r0,r5,r4		# byte=r5 byte=r0
.L886:
#    }
# 
#    /*
#     * Store rest of the bits (if any) in next byte
#     */
#    if (msbMask != 0xFFU)
	.d2line		4030
.Llo1128:
	rlwinm		r0,r31,0,24,31		# srcValue=r0 msbMask=r31
.Llo1124:
	cmpi		0,0,r0,255		# srcValue=r0
	bc		1,2,.L885	# eq
#    {
#       byteOffset++;
	.d2line		4032
.Llo1125:
	se_addi		r3,1		# byteOffset=r3 byteOffset=r3
	mr		r5,r3		# byteOffset=r5 byteOffset=r3
# 
#       byte  = pDestination[byteOffset];
	.d2line		4034
	rlwinm		r3,r3,0,24,31		# byteOffset=r3 byteOffset=r3
	lbzux		r0,r3,r4		# srcValue=r0 byteOffset=r3
.Llo1134:
	mr		r0,r0		# byte=r0 byte=r0
#       byte &= msbMask;
	.d2line		4035
	and		r0,r0,r31		# byte=r0 byte=r0 msbMask=r31
	mr		r0,r0		# byte=r0 byte=r0
#       byte |= msbValue;
	.d2line		4036
.Llo1131:
	or		r6,r6,r0		# byte=r6 byte=r6 msbValue=r0
.Llo1135:
	mr		r0,r6		# byte=r0 byte=r6
#       pDestination[byteOffset] = byte;
	.d2line		4037
.Llo1132:
	rlwinm		r5,r5,0,24,31		# byteOffset=r5 byteOffset=r5
	stbx		r6,r5,r4		# byteOffset=r5 pDestination=r4 byte=r6
.L885:
#    }
# }
	.d2line		4039
	.d2epilogue_begin
.Llo1116:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# srcValue=r0
	mtspr		lr,r0		# srcValue=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4009:
	.type		WriteSignalToBuf_08,@function
	.size		WriteSignalToBuf_08,.-WriteSignalToBuf_08
# Number of nodes = 118

# Allocations for WriteSignalToBuf_08
#	?a4		srcData
#	?a5		pDestination
#	?a6		bitPos
#	?a7		bitSize
#	?a8		srcValue
#	?a9		lsbValue
#	?a10		msbValue
#	?a11		byte
#	?a12		mask
#	?a13		lsbMask
#	?a14		msbMask
#	?a15		byteOffset
# static FUNC(boolean, DCM_CODE) IsIdentifierSupported(P2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) pSupport, uint8 id)
	.align		1
	.section	.text_vle
        .d2line         12155,32
#$$ld
.L4033:

#$$bf	IsIdentifierSupported,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,cr0,lr
	.d2_cfa_start __cie
IsIdentifierSupported:
.Llo1142:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
.Llo1145:
	stw		r0,20(r1)		# supported=r0
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pSupport=r3 pSupport=r3
	mr		r4,r4		# id=r4 id=r4
	.d2prologue_end
# {
#    boolean supported = FALSE;
	.d2line		12157
	diab.li		r0,0		# supported=r0
#    const uint8 bytePos = (id - 1U) / 0x08U;
	.d2line		12158
.Llo1146:
	rlwinm		r4,r4,0,24,31		# id=r4 id=r4
	diab.addi		r0,r4,-1		# supported=r0 id=r4
.Llo1147:
	rlwinm		r4,r0,29,3,31		# id=r4 supported=r0
.Llo1144:
	mr		r4,r4		# bytePos=r4 bytePos=r4
#    if ((uint8)0U != (uint8)(pSupport[bytePos] & (uint8)(0x80U >> ((id - 1U) % 0x08U))))
	.d2line		12159
	rlwinm		r4,r4,0,24,31		# bytePos=r4 bytePos=r4
	lbzx		r3,r4,r3		# supported=r3 bytePos=r4 pSupport=r3
.Llo1143:
	diab.li		r4,128		# bytePos=r4
	rlwinm		r0,r0,0,29,31		# supported=r0 supported=r0
	srw		r4,r4,r0		# bytePos=r4 bytePos=r4 supported=r0
	and		r3,r3,r4		# supported=r3 supported=r3 bytePos=r4
	e_andi.		r0,r3,255		# supported=r0 supported=r3
#    {
#       supported = TRUE;
	.d2line		12161
.Llo1148:
	diab.li		r0,1		# supported=r0
.Llo1149:
	isel		r3,0,r0,2		# supported=r3 supported=r0
.L2504:
#    }
#    else
#    {
#       /* do nothing. supported is default FALSE. */
#    }
# 
#    return supported;
	.d2line		12168
.Llo1150:
	rlwinm		r3,r3,0,24,31		# supported=r3 supported=r3
# }
	.d2line		12169
	.d2epilogue_begin
	lwz		r0,20(r1)		# supported=r0
	mtspr		lr,r0		# supported=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4034:
	.type		IsIdentifierSupported,@function
	.size		IsIdentifierSupported,.-IsIdentifierSupported
# Number of nodes = 35

# Allocations for IsIdentifierSupported
#	?a4		pSupport
#	?a5		id
#	?a6		supported
#	?a7		bytePos
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) GetVehInfoLength(uint16 idLength,
	.align		1
	.section	.text_vle
        .d2line         6435,53
#$$ld
.L4044:

#$$bf	GetVehInfoLength,interprocedural,rasave,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r8,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetVehInfoLength:
.Llo1151:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r7,r3		# idLength=r7 idLength=r3
	mr		r4,r4		# infoType=r4 infoType=r4
	mr		r5,r5		# sid=r5 sid=r5
	mr		r6,r6		# pInfoTypeLen=r6 pInfoTypeLen=r6
	.d2prologue_end
#                                                                      uint8 infoType,
#                                                                      uint8 sid,
#                                                                      CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pInfoTypeLen)
# {
#    uint8 i;
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6441
	diab.li		r31,0		# ErrorCode=r31
#    P2CONST(Dcm_Cfg_VehicleInfoType, AUTOMATIC, DCM_APPL_DATA) pVehInfo = NULL_PTR;
	.d2line		6442
.Llo1167:
	diab.li		r30,0
# 
#    if ((uint8)0U == (uint8)(infoType % 0x20U))
	.d2line		6444
.Llo1169:
	rlwinm		r0,r4,0,27,31		# infoType=r4
	e_andi.		r0,r0,255
	bc		0,2,.L1456	# ne
#    {
#       *pInfoTypeLen = OBD_SUPPORT_DATA_LENGTH;
	.d2line		6446
.Llo1152:
	diab.li		r0,4
.Llo1153:
	sth		r0,0(r6)		# pInfoTypeLen=r6
	b		.L1457
.L1456:
#    }
#    else
#    {
#       /*
#        * Find the pointer to the requested ID
#        */
#       for (i = 0; (i < Dcm_LCfg.num_vehicle_info) && (NULL_PTR == pVehInfo); i++)
	.d2line		6453
	diab.li		r3,0		# i=r3
.L1458:
.Llo1161:
	rlwinm		r0,r3,0,24,31		# i=r3
	lis		r8,(Dcm_LCfg+112)@ha
	lbz		r29,(Dcm_LCfg+112)@l(r8)
	se_cmp		r0,r29
	bc		0,0,.L1460	# ge
	se_cmpi		r30,0		# pVehInfo=r30
	bc		0,2,.L1460	# ne
#       {
#          if (Dcm_LCfg.p_vehicle_info[i].identifier == infoType)
	.d2line		6455
	lis		r8,(Dcm_LCfg+116)@ha
	lwz		r8,(Dcm_LCfg+116)@l(r8)
	rlwinm		r0,r3,3,21,28		# i=r3
	lbzx		r0,r8,r0
	rlwinm		r29,r4,0,24,31		# infoType=r4
	se_cmp		r0,r29
	bc		0,2,.L1461	# ne
#          {
#             pVehInfo = &(Dcm_LCfg.p_vehicle_info)[i];
	.d2line		6457
	lis		r8,(Dcm_LCfg+116)@ha
	lwz		r30,(Dcm_LCfg+116)@l(r8)		# pVehInfo=r30
	rlwinm		r0,r3,3,21,28		# i=r3
	se_add		r0,r30		# pVehInfo=r30
	mr		r30,r0		# pVehInfo=r30 pVehInfo=r0
.L1461:
#          }
#       }
	.d2line		6459
	diab.addi		r0,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L1458
.L1460:
# 
#       if (NULL_PTR == pVehInfo)
	.d2line		6461
	se_cmpi		r30,0		# pVehInfo=r30
	bc		0,2,.L1462	# ne
#       {
#          /* VehInfo ID is not configured */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6464
.Llo1162:
	diab.li		r31,160		# ErrorCode=r31
	b		.L1463
.L1462:
#       }
#       else if (FALSE == IsIdentifierSupported(Dcm_pPbCfg->p_vehicle_info_type_support, infoType))
	.d2line		6466
.Llo1157:
	lis		r3,Dcm_pPbCfg@ha		# i=r3
.Llo1163:
	lwz		r3,Dcm_pPbCfg@l(r3)		# i=r3 i=r3
	lwz		r3,36(r3)		# i=r3 i=r3
.Llo1158:
	mr		r4,r4		# infoType=r4 infoType=r4
.Llo1159:
	bl		IsIdentifierSupported
.Llo1164:
	e_andi.		r3,r3,255		# i=r3 i=r3
.Llo1165:
	bc		0,2,.L1464	# ne
#       {
#          /* VehInfo ID is disabled */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6469
	diab.li		r31,160		# ErrorCode=r31
	b		.L1463
.L1464:
#       }
#       else
#       {
#           /*
#           * 1 byte idLength, if OBD service 0x09 is the caller.
#           *
#           * 2 bytes idLength, if UDS service 0x22 requests the vechInfo.
#           * According to ISO 14229 Table C.1, OBDInfoTypeDataIdentifier has two bytes
#           * identifier.
#           */
#          *pInfoTypeLen = (uint16)pVehInfo->size + idLength;
	.d2line		6480
	lbz		r0,1(r30)		# pVehInfo=r30
	se_add		r0,r7		# idLength=r7
	sth		r0,0(r6)		# pInfoTypeLen=r6
.L1463:
#       }
# 
#       if ((SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER == sid) && (DCM_INT_NRC_ID_NOT_SUPPORTED == ErrorCode))
	.d2line		6483
.Llo1154:
	rlwinm		r5,r5,0,24,31		# sid=r5 sid=r5
	cmpi		0,0,r5,44		# sid=r5
	bc		0,2,.L1457	# ne
.Llo1160:
	rlwinm		r3,r31,0,24,31		# i=r3 ErrorCode=r31
.Llo1166:
	cmpi		0,0,r3,160		# i=r3
#       {
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		6485
	diab.li		r3,49		# i=r3
	isel		r31,r3,r31,2		# ErrorCode=r31 i=r3 ErrorCode=r31
.L1457:
#       }
#    }
# 
#    return ErrorCode;
	.d2line		6489
.Llo1155:
	rlwinm		r3,r31,0,24,31		# i=r3 ErrorCode=r31
# }
	.d2line		6490
	.d2epilogue_begin
.Llo1156:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
.Llo1168:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4045:
	.type		GetVehInfoLength,@function
	.size		GetVehInfoLength,.-GetVehInfoLength
# Number of nodes = 111

# Allocations for GetVehInfoLength
#	?a4		idLength
#	?a5		infoType
#	?a6		sid
#	?a7		pInfoTypeLen
#	?a8		i
#	?a9		ErrorCode
#	?a10		pVehInfo
# static FUNC(boolean, DCM_CODE) IsObdRangeSupported(CONST(uint8, DCM_CONST) supportPos,
	.align		1
	.section	.text_vle
        .d2line         12417,32
#$$ld
.L4063:

#$$bf	IsObdRangeSupported,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,cr0,lr
	.d2_cfa_start __cie
IsObdRangeSupported:
.Llo1170:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)		# pSupport=r0
	.d2_cfa_offset    108,-1
	mr		r0,r3		# supportPos=r0 supportPos=r3
	mr		r5,r4		# pSupport=r5 pSupport=r4
	.d2prologue_end
#                                                    CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) pSupport)
# {
#    CONST(uint8, DCM_CONST) offset = supportPos * 4U;
	.d2line		12420
	se_slwi		r0,2		# supportPos=r0 supportPos=r0
.Llo1177:
	mr		r0,r0		# offset=r0 offset=r0
# 
#    return (((pSupport[offset + 0U] + pSupport[offset + 1U] + pSupport[offset + 2U] + pSupport[offset + 3U]) == 0) ? FALSE : TRUE);
	.d2line		12422
	rlwinm		r3,r0,0,24,31		# offset=r0
.Llo1171:
	lbzux		r4,r3,r5
.Llo1172:
	rlwinm		r0,r0,0,24,31		# offset=r0 offset=r0
.Llo1173:
	se_add		r5,r0		# pSupport=r0
	lbz		r0,1(r5)		# pSupport=r0
	se_add		r4,r0		# pSupport=r0
	lbz		r0,2(r5)		# pSupport=r0
	se_add		r0,r4		# pSupport=r0 pSupport=r0
	lbz		r3,3(r5)
	add.		r0,r0,r3		# pSupport=r0 pSupport=r0
	isel		r3,0,r0,2		# pSupport=r0
.L2507:
.Llo1174:
	diab.li		r0,1		# pSupport=r0
.Llo1175:
	isel		r3,r3,r0,2		# pSupport=r0
.L2508:
.Llo1176:
	rlwinm		r3,r3,0,24,31
# }
	.d2line		12423
	.d2epilogue_begin
	lwz		r0,20(r1)		# pSupport=r0
	mtspr		lr,r0		# pSupport=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4064:
	.type		IsObdRangeSupported,@function
	.size		IsObdRangeSupported,.-IsObdRangeSupported
# Number of nodes = 49

# Allocations for IsObdRangeSupported
#	?a4		supportPos
#	?a5		pSupport
#	?a6		$$62
#	?a7		offset
# static FUNC(uint16, DCM_CODE) GetObdVehInfoDidLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6622,31
#$$ld
.L4073:

#$$bf	GetObdVehInfoDidLength,interprocedural,rasave,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r8,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetObdVehInfoDidLength:
.Llo1178:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
.Llo1179:
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
.Llo1180:
	mr		r29,r7		# pErrorCode=r29 pErrorCode=r7
	.d2prologue_end
#                                                    CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                                    Dcm_SesCtrlType activeSession,
#                                                    Dcm_SecLevelType activeSecurityLevel,
#                                                    CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(uint8, DCM_CONST) reqIDType = DcmLoByte(didIdentifier);
#    CONST(uint8, DCM_CONST) bufPos = reqIDType / 0x20U;
#    uint16 didLength = (uint16)0U;
	.d2line		6630
	diab.li		r0,0
	sth		r0,8(r1)
	.d2line		6628
	rlwinm		r4,r31,0,24,31		# reqIDType=r4 didIdentifier=r31
.Llo1182:
	mr		r4,r4		# reqIDType=r4 reqIDType=r4
	.d2line		6629
	rlwinm		r3,r4,27,29,31		# reqIDType=r4
.Llo1196:
	mr		r3,r3		# bufPos=r3 bufPos=r3
# 
#    *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6632
	stb		r0,0(r29)		# pErrorCode=r29
# 
#    if (VEHINFO_HIGH_BYTE != DcmHiByte(didIdentifier))
	.d2line		6634
	rlwinm		r0,r31,24,24,31		# didIdentifier=r31
	cmpi		0,0,r0,248
	bc		1,2,.L1508	# eq
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6636
.Llo1183:
	diab.li		r0,160
.Llo1184:
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1509
.L1508:
#    }
#    else if ((uint8)0U != (uint8)(reqIDType % 0x20U))
	.d2line		6638
	rlwinm		r0,r4,0,27,31		# reqIDType=r4
	e_andi.		r0,r0,255
	bc		1,2,.L1510	# eq
#    {
#       /*
#        * The length of the identifier is two byte long for UDS 0x22. But the 'NofDataItems'(1 byte), part
#        * of the configured size and added by application, shall be ignored later as UDS 0x22 is used.
#        * Therefore only using 1 as input (instead of 2) to compensate for the 'NofDataItems' that shall
#        * be removed.
#        */
#       *pErrorCode = GetVehInfoLength(1U, reqIDType, SID_READ_DATA_BY_IDENTIFIER, &didLength);
	.d2line		6646
.Llo1188:
	diab.addi		r6,r1,8
	diab.li		r3,1
.Llo1189:
	mr		r4,r4		# reqIDType=r4 reqIDType=r4
.Llo1190:
	diab.li		r5,34
	bl		GetVehInfoLength
	stb		r3,0(r29)		# pErrorCode=r29
	b		.L1509
.L1510:
#    }
#    else if ((NULL_PTR != Dcm_pPbCfg->p_vehicle_info_type_support) && (FALSE != IsObdRangeSupported(bufPos, Dcm_pPbCfg->p_vehicle_info_type_support)))
	.d2line		6648
.Llo1197:
	lis		r4,Dcm_pPbCfg@ha		# reqIDType=r4
.Llo1191:
	lwz		r4,Dcm_pPbCfg@l(r4)		# reqIDType=r4 reqIDType=r4
	lwz		r0,36(r4)		# reqIDType=r4
	se_cmpi		r0,0
	bc		1,2,.L1512	# eq
.Llo1192:
	lis		r4,Dcm_pPbCfg@ha		# reqIDType=r4
.Llo1193:
	lwz		r4,Dcm_pPbCfg@l(r4)		# reqIDType=r4 reqIDType=r4
	lwz		r4,36(r4)		# reqIDType=r4 reqIDType=r4
.Llo1194:
	mr		r3,r3		# bufPos=r3 bufPos=r3
.Llo1198:
	bl		IsObdRangeSupported
	e_andi.		r3,r3,255
	bc		1,2,.L1512	# eq
#    {
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6650
	diab.li		r0,0
	stb		r0,0(r29)		# pErrorCode=r29
#       didLength = (uint16)6U;
	.d2line		6651
	diab.li		r0,6
	sth		r0,8(r1)
	b		.L1509
.L1512:
#    }
#    else
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6655
.Llo1199:
	diab.li		r0,160
	stb		r0,0(r29)		# pErrorCode=r29
.L1509:
#    }
# 
#    /*
#    * Only add those DIDs that are accessible for future use when fetching the actual data.
#    */
#    if (*pErrorCode == DCM_INT_NRC_POSITIVERESPONSE)
	.d2line		6661
.Llo1200:
	lbz		r0,0(r29)		# pErrorCode=r29
	se_cmpi		r0,0
	bc		0,2,.L1514	# ne
#    {
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].identifier = didIdentifier;
	.d2line		6663
.Llo1185:
	lis		r3,(Dcm_LCfg+60)@ha
.Llo1186:
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# reqIDType=r4
.Llo1195:
	lhz		r0,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r0,r0,3,13,28
	sthx		r31,r4,r0		# reqIDType=r4 didIdentifier=r31
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].did_type = DID_ENUM_OBD_INFOTYPE;
	.d2line		6664
	diab.li		r0,2
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# reqIDType=r4
	lhz		r3,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r3,r3,3,13,28
	se_add		r3,r4		# reqIDType=r4
	stw		r0,4(r3)
#       (*pCurrentValidDidIndex)++;
	.d2line		6665
	lhz		r3,0(r30)		# pCurrentValidDidIndex=r30
	se_addi		r3,1
	sth		r3,0(r30)		# pCurrentValidDidIndex=r30
.L1514:
#    }
# 
#    return didLength;
	.d2line		6668
.Llo1181:
	lhz		r3,8(r1)
# }
	.d2line		6669
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1187:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4074:
	.type		GetObdVehInfoDidLength,@function
	.size		GetObdVehInfoDidLength,.-GetObdVehInfoDidLength
# Number of nodes = 130

# Allocations for GetObdVehInfoDidLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	not allocated	activeSession
#	not allocated	activeSecurityLevel
#	?a6		pErrorCode
#	?a7		reqIDType
#	?a8		bufPos
#	SP,8		didLength
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) GetPowertrainPidLength(uint16 idLength,
	.align		1
	.section	.text_vle
        .d2line         6495,53
#$$ld
.L4086:

#$$bf	GetPowertrainPidLength,interprocedural,rasave,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r8,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetPowertrainPidLength:
.Llo1201:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r7,r3		# idLength=r7 idLength=r3
	mr		r4,r4		# pidIdentifier=r4 pidIdentifier=r4
	mr		r5,r5		# sid=r5 sid=r5
	mr		r6,r6		# pPidLen=r6 pPidLen=r6
	.d2prologue_end
#                                                                            uint8 pidIdentifier,
#                                                                            uint8 sid,
#                                                                            CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pPidLen)
# {
#    uint8 i;
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6501
	diab.li		r31,0		# ErrorCode=r31
#    P2CONST(Dcm_Cfg_PidType, AUTOMATIC, DCM_APPL_DATA)  pPid = NULL_PTR;
	.d2line		6502
.Llo1215:
	diab.li		r30,0
# 
#    /* Reset the length of Pid. */
#    *pPidLen = 0;
	.d2line		6505
.Llo1217:
	diab.li		r0,0
	sth		r0,0(r6)		# pPidLen=r6
# 
#    if ((uint8)0U == (uint8)(pidIdentifier % 0x20U))
	.d2line		6507
	rlwinm		r0,r4,0,27,31		# pidIdentifier=r4
	e_andi.		r0,r0,255
	bc		0,2,.L1476	# ne
#    {
#       *pPidLen = OBD_SUPPORT_DATA_LENGTH;
	.d2line		6509
.Llo1202:
	diab.li		r0,4
.Llo1203:
	sth		r0,0(r6)		# pPidLen=r6
	b		.L1477
.L1476:
#    }
#    else
#    {
#       /*
#        * Find the pointer to the requested ID
#        */
#       for (i = 0; (i < Dcm_LCfg.num_pids) && (NULL_PTR == pPid); i++)
	.d2line		6516
	diab.li		r3,0		# i=r3
.L1478:
.Llo1209:
	rlwinm		r0,r3,0,24,31		# i=r3
	lis		r8,(Dcm_LCfg+92)@ha
	lbz		r29,(Dcm_LCfg+92)@l(r8)
	se_cmp		r0,r29
	bc		0,0,.L1480	# ge
	se_cmpi		r30,0		# pPid=r30
	bc		0,2,.L1480	# ne
#       {
#          if (Dcm_LCfg.p_pids[i].identifier == pidIdentifier)
	.d2line		6518
	rlwinm		r0,r3,0,24,31		# i=r3
	lis		r8,(Dcm_LCfg+96)@ha
	lwz		r8,(Dcm_LCfg+96)@l(r8)
	rlwinm		r29,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r29
	lbzx		r0,r8,r0
	rlwinm		r29,r4,0,24,31		# pidIdentifier=r4
	se_cmp		r0,r29
	bc		0,2,.L1481	# ne
#          {
#             pPid = &(Dcm_LCfg.p_pids)[i];
	.d2line		6520
	rlwinm		r0,r3,0,24,31		# i=r3
	lis		r8,(Dcm_LCfg+96)@ha
	lwz		r29,(Dcm_LCfg+96)@l(r8)
	rlwinm		r30,r0,5,0,26		# pPid=r30
	se_slwi		r0,3
	subf		r0,r0,r30		# pPid=r30
	se_add		r0,r29
	mr		r30,r0		# pPid=r30 pPid=r0
.L1481:
#          }
#       }
	.d2line		6522
	diab.addi		r0,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L1478
.L1480:
# 
#       if (NULL_PTR == pPid)
	.d2line		6524
	se_cmpi		r30,0		# pPid=r30
	bc		0,2,.L1482	# ne
#       {
#          /* Pid is not configured. */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6527
.Llo1207:
	diab.li		r31,160		# ErrorCode=r31
	b		.L1483
.L1482:
#       }
#       else if ((DCM_SERVICE_01 != pPid->service_type) && (DCM_SERVICE_01_02 != pPid->service_type))
	.d2line		6529
	lwz		r0,4(r30)		# pPid=r30
	se_cmpi		r0,0
	bc		1,2,.L1484	# eq
	lwz		r0,4(r30)		# pPid=r30
	se_cmpi		r0,1
	bc		1,2,.L1484	# eq
#       {
#          /*
#           * Pid is not for OBD Service 0x01, therefore this Pid will not be marked in the support info.
#           * It is treated as unconfigured.
#           */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6535
	diab.li		r31,160		# ErrorCode=r31
	b		.L1483
.L1484:
#       }
#       else if (FALSE == IsIdentifierSupported(Dcm_pPbCfg->p_pids_support_01, pPid->identifier))
	.d2line		6537
	lis		r3,Dcm_pPbCfg@ha		# i=r3
.Llo1210:
	lwz		r3,Dcm_pPbCfg@l(r3)		# i=r3 i=r3
	lwz		r3,24(r3)		# i=r3 i=r3
.Llo1211:
	lbz		r4,0(r30)		# pidIdentifier=r4 pPid=r30
	bl		IsIdentifierSupported
.Llo1212:
	e_andi.		r3,r3,255		# i=r3 i=r3
.Llo1213:
	bc		0,2,.L1486	# ne
#       {
#          /* Pid is disabled. */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6540
	diab.li		r31,160		# ErrorCode=r31
	b		.L1483
.L1486:
#       }
#       else
#       {
#          /*
#           * 1 byte idLength, if OBD service 0x01 is the caller.
#           *
#           * 2 bytes idLength, if UDS service 0x22 requests the vehcInfo.
#           * According to ISO 14229 Table C.1, OBDInfoTypeDataIdentifier has two bytes
#           * identifier.
#           */
#          *pPidLen = (uint16)pPid->size + idLength;
	.d2line		6551
	lbz		r0,1(r30)		# pPid=r30
	se_add		r0,r7		# idLength=r7
	sth		r0,0(r6)		# pPidLen=r6
.L1483:
#       }
# 
#       if ((SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER == sid) && (DCM_INT_NRC_ID_NOT_SUPPORTED == ErrorCode))
	.d2line		6554
.Llo1204:
	rlwinm		r5,r5,0,24,31		# sid=r5 sid=r5
	cmpi		0,0,r5,44		# sid=r5
	bc		0,2,.L1477	# ne
.Llo1208:
	rlwinm		r3,r31,0,24,31		# i=r3 ErrorCode=r31
.Llo1214:
	cmpi		0,0,r3,160		# i=r3
#       {
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		6556
	diab.li		r3,49		# i=r3
	isel		r31,r3,r31,2		# ErrorCode=r31 i=r3 ErrorCode=r31
.L1477:
#       }
#    }
# 
#    return ErrorCode;
	.d2line		6560
.Llo1205:
	rlwinm		r3,r31,0,24,31		# i=r3 ErrorCode=r31
# }
	.d2line		6561
	.d2epilogue_begin
.Llo1206:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
.Llo1216:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4087:
	.type		GetPowertrainPidLength,@function
	.size		GetPowertrainPidLength,.-GetPowertrainPidLength
# Number of nodes = 132

# Allocations for GetPowertrainPidLength
#	?a4		idLength
#	?a5		pidIdentifier
#	?a6		sid
#	?a7		pPidLen
#	?a8		$$83
#	?a9		$$82
#	?a10		i
#	?a11		ErrorCode
#	?a12		pPid
# static FUNC(uint16, DCM_CODE) GetObdPidDidLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6675,31
#$$ld
.L4105:

#$$bf	GetObdPidDidLength,interprocedural,rasave,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r8,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetObdPidDidLength:
.Llo1218:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
.Llo1219:
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
.Llo1220:
	mr		r29,r7		# pErrorCode=r29 pErrorCode=r7
	.d2prologue_end
#                                                  CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                                  Dcm_SesCtrlType activeSession,
#                                                  Dcm_SecLevelType activeSecurityLevel,
#                                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    CONST(uint8, DCM_CONST) reqIDType = DcmLoByte(didIdentifier);
#    CONST(uint8, DCM_CONST) bufPos = reqIDType / 0x20U;
#    uint16 didLength = (uint16)0U;
	.d2line		6683
	diab.li		r0,0
	sth		r0,8(r1)
	.d2line		6681
	rlwinm		r4,r31,0,24,31		# reqIDType=r4 didIdentifier=r31
.Llo1222:
	mr		r4,r4		# reqIDType=r4 reqIDType=r4
	.d2line		6682
	rlwinm		r3,r4,27,29,31		# reqIDType=r4
.Llo1236:
	mr		r3,r3		# bufPos=r3 bufPos=r3
#    
#    *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6685
	stb		r0,0(r29)		# pErrorCode=r29
# 
#    if (OBDDID_HIGH_BYTE != DcmHiByte(didIdentifier))
	.d2line		6687
	rlwinm		r0,r31,24,24,31		# didIdentifier=r31
	cmpi		0,0,r0,244
	bc		1,2,.L1521	# eq
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6689
.Llo1223:
	diab.li		r0,160
.Llo1224:
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1522
.L1521:
#    }
#    else if ((uint8)0U != (uint8)(reqIDType % 0x20U))
	.d2line		6691
	rlwinm		r0,r4,0,27,31		# reqIDType=r4
	e_andi.		r0,r0,255
	bc		1,2,.L1523	# eq
#    {
#       *pErrorCode = GetPowertrainPidLength(2U, reqIDType, SID_READ_DATA_BY_IDENTIFIER, &didLength);
	.d2line		6693
.Llo1228:
	diab.addi		r6,r1,8
	diab.li		r3,2
.Llo1229:
	mr		r4,r4		# reqIDType=r4 reqIDType=r4
.Llo1230:
	diab.li		r5,34
	bl		GetPowertrainPidLength
	stb		r3,0(r29)		# pErrorCode=r29
	b		.L1522
.L1523:
#    }
#    else if ((NULL_PTR != Dcm_pPbCfg->p_pids_support_01) && (FALSE != IsObdRangeSupported(bufPos, Dcm_pPbCfg->p_pids_support_01)))
	.d2line		6695
.Llo1237:
	lis		r4,Dcm_pPbCfg@ha		# reqIDType=r4
.Llo1231:
	lwz		r4,Dcm_pPbCfg@l(r4)		# reqIDType=r4 reqIDType=r4
	lwz		r0,24(r4)		# reqIDType=r4
	se_cmpi		r0,0
	bc		1,2,.L1525	# eq
.Llo1232:
	lis		r4,Dcm_pPbCfg@ha		# reqIDType=r4
.Llo1233:
	lwz		r4,Dcm_pPbCfg@l(r4)		# reqIDType=r4 reqIDType=r4
	lwz		r4,24(r4)		# reqIDType=r4 reqIDType=r4
.Llo1234:
	mr		r3,r3		# bufPos=r3 bufPos=r3
.Llo1238:
	bl		IsObdRangeSupported
	e_andi.		r3,r3,255
	bc		1,2,.L1525	# eq
#    {
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6697
	diab.li		r0,0
	stb		r0,0(r29)		# pErrorCode=r29
#       didLength = (uint16)6U;
	.d2line		6698
	diab.li		r0,6
	sth		r0,8(r1)
	b		.L1522
.L1525:
#    }
#    else
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6702
.Llo1239:
	diab.li		r0,160
	stb		r0,0(r29)		# pErrorCode=r29
.L1522:
#    }
# 
#    /*
#    * Only add those DIDs that are accessible for future use when fetching the actual data.
#    */
#    if (*pErrorCode == DCM_INT_NRC_POSITIVERESPONSE)
	.d2line		6708
.Llo1240:
	lbz		r0,0(r29)		# pErrorCode=r29
	se_cmpi		r0,0
	bc		0,2,.L1527	# ne
#    {
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].identifier = didIdentifier;
	.d2line		6710
.Llo1225:
	lis		r3,(Dcm_LCfg+60)@ha
.Llo1226:
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# reqIDType=r4
.Llo1235:
	lhz		r0,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r0,r0,3,13,28
	sthx		r31,r4,r0		# reqIDType=r4 didIdentifier=r31
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].did_type = DID_ENUM_OBD_PID;
	.d2line		6711
	diab.li		r0,3
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# reqIDType=r4
	lhz		r3,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r3,r3,3,13,28
	se_add		r3,r4		# reqIDType=r4
	stw		r0,4(r3)
#       (*pCurrentValidDidIndex)++;
	.d2line		6712
	lhz		r3,0(r30)		# pCurrentValidDidIndex=r30
	se_addi		r3,1
	sth		r3,0(r30)		# pCurrentValidDidIndex=r30
.L1527:
#    }
# 
#    return didLength;
	.d2line		6715
.Llo1221:
	lhz		r3,8(r1)
# }
	.d2line		6716
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1227:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4106:
	.type		GetObdPidDidLength,@function
	.size		GetObdPidDidLength,.-GetObdPidDidLength
# Number of nodes = 130

# Allocations for GetObdPidDidLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	not allocated	activeSession
#	not allocated	activeSecurityLevel
#	?a6		pErrorCode
#	?a7		reqIDType
#	?a8		bufPos
#	SP,8		didLength
# static FUNC(uint16, DCM_CODE) GetDddidSourcesLength(CONSTP2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDDDid)
	.align		1
	.section	.text_vle
        .d2line         6411,31
#$$ld
.L4118:

#$$bf	GetDddidSourcesLength,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,cr0,lr
	.d2_cfa_start __cie
GetDddidSourcesLength:
.Llo1241:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pDDDid=r3 pDDDid=r3
	.d2prologue_end
# {
#    uint8 j;
#    uint16 dddidLength = (uint16)2U; /* Include the two byte identifier */
	.d2line		6414
	diab.li		r5,2		# dddidLength=r5
# 
#    for (j = (uint8)0U; j < *pDDDid->pNumberOfDefinedSources; j++)
	.d2line		6416
.Llo1244:
	diab.li		r4,0		# j=r4
.L1450:
.Llo1243:
	rlwinm		r0,r4,0,24,31		# j=r4
	lwz		r6,16(r3)		# pDDDid=r3
	lbz		r6,0(r6)
	se_cmp		r0,r6
	bc		0,0,.L1452	# ge
#    {
#       /*
#        * Per definition is the size of the DDDID set when defined using UDS 0x2C
#        * since the number of valid bytes of each source is part of the request.
#        *
#        * pSource->size is uint32 since it's also used for memory sizes.
#        * However, it safe to type case since the SCG guarentees that pSource->size
#        * will never be greater than uint16 if the source is a DID.
#        */
#       dddidLength += (uint16)pDDDid->pDataSourcesRead[j].size;
	.d2line		6426
	lwz		r6,8(r3)		# pDDDid=r3
	rlwinm		r0,r4,0,24,31		# j=r4
	e_mulli		r0,r0,20
	se_add		r6,r0
	lwz		r0,12(r6)
	se_add		r0,r5		# dddidLength=r5
	mr		r5,r0		# dddidLength=r5 dddidLength=r0
#    }
	.d2line		6427
	diab.addi		r0,r4,1		# j=r4
	se_addi		r4,1		# j=r4 j=r4
	b		.L1450
.L1452:
# 
#    return dddidLength;
	.d2line		6429
.Llo1242:
	rlwinm		r3,r5,0,16,31		# pDDDid=r3 dddidLength=r5
# }
	.d2line		6430
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1245:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4119:
	.type		GetDddidSourcesLength,@function
	.size		GetDddidSourcesLength,.-GetDddidSourcesLength
# Number of nodes = 35

# Allocations for GetDddidSourcesLength
#	?a4		pDDDid
#	?a5		j
#	?a6		dddidLength
# static FUNC(uint16, DCM_CODE) GetDddidLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6722,31
#$$ld
.L4129:

#$$bf	GetDddidLength,interprocedural,rasave,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
GetDddidLength:
.Llo1246:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
	mr		r7,r7		# pErrorCode=r7 pErrorCode=r7
	.d2prologue_end
#                                              CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                              Dcm_SesCtrlType activeSession,
#                                              Dcm_SecLevelType activeSecurityLevel,
#                                              CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint16 i;
#    uint16 didLength = (uint16)0U;
	.d2line		6729
	diab.li		r4,0		# didLength=r4
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDDDid = NULL_PTR;
	.d2line		6730
.Llo1250:
	diab.li		r5,0
# 
#    *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6732
.Llo1261:
	diab.li		r3,0
.Llo1247:
	stb		r3,0(r7)		# pErrorCode=r7
# 
#    for (i = (uint16)0U; (i < Dcm_LCfg.num_periodic_dynamic_dids) && (NULL_PTR == pDDDid); i++)
.L1534:
	.d2line		6734
.Llo1248:
	rlwinm		r0,r3,0,16,31		# i=r3
	lis		r6,(Dcm_LCfg+72)@ha
	lhz		r6,(Dcm_LCfg+72)@l(r6)
	se_cmp		r0,r6
	bc		0,0,.L1536	# ge
	se_cmpi		r5,0		# pDDDid=r5
	bc		0,2,.L1536	# ne
#    {
#       if (Dcm_LCfg.periodicDynamicDids[i].identifier == didIdentifier)
	.d2line		6736
	rlwinm		r0,r3,0,16,31		# i=r3
	lis		r6,(Dcm_LCfg+76)@ha
	lwz		r6,(Dcm_LCfg+76)@l(r6)
	rlwinm		r29,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r29
	lhzx		r6,r6,r0
	rlwinm		r0,r31,0,16,31		# didIdentifier=r31
	se_cmp		r6,r0
	bc		0,2,.L1537	# ne
#       {
#          pDDDid = &Dcm_LCfg.periodicDynamicDids[i];
	.d2line		6738
	rlwinm		r0,r3,0,16,31		# i=r3
	lis		r5,(Dcm_LCfg+76)@ha		# pDDDid=r5
	lwz		r5,(Dcm_LCfg+76)@l(r5)		# pDDDid=r5 pDDDid=r5
	rlwinm		r6,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r6
	se_add		r0,r5		# pDDDid=r5
	mr		r5,r0		# pDDDid=r5 pDDDid=r0
.L1537:
#       }
#    }
	.d2line		6740
	diab.addi		r0,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L1534
.L1536:
# 
#    /*
#    * 1. Was the DID found amongst the configured ones?
#    */
#    if (NULL_PTR == pDDDid)
	.d2line		6745
	se_cmpi		r5,0		# pDDDid=r5
	bc		0,2,.L1538	# ne
#    {
#       /*
#        * [SWS_Dcm_00651]
#        * The SCG will guarantee that only DIDs within the range of 0xF200 to 0xF3FF is dynamically defined.
#        * The requested DID was not found. Report an error and break.
#        * NRC 0x31 will be returned if all DIDs in the request are not supported.
#        */
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6753
.Llo1252:
	diab.li		r0,160
	stb		r0,0(r7)		# pErrorCode=r7
	b		.L1539
.L1538:
#    }
#    /*
#    * 2. Is the DID defined?
#    */
#    else if ((uint8)0U == *(pDDDid->pNumberOfDefinedSources))
	.d2line		6758
	lwz		r3,16(r5)		# i=r3 pDDDid=r5
.Llo1253:
	lbz		r0,0(r3)		# i=r3
	se_cmpi		r0,0
	bc		0,2,.L1540	# ne
#    {
#       /*
#        * [SWS_Dcm_00651]
#        * No defined data source, report an error and break.
#        * NRC 0x31 will be returned if all DIDs in the request are not supported.
#        */
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6765
.Llo1254:
	diab.li		r0,160
	stb		r0,0(r7)		# pErrorCode=r7
	b		.L1539
.L1540:
#    }
#    else if (NULL_PTR != pDDDid->pDataSourcesDefine)
	.d2line		6767
	lwz		r0,12(r5)		# pDDDid=r5
	se_cmpi		r0,0
	bc		1,2,.L1542	# eq
#    {
#       /*
#       * Fetch the total length of all defined sources.
#       */
#       didLength = GetDddidSourcesLength(pDDDid);
	.d2line		6772
.Llo1256:
	mr		r3,r5		# pDDDid=r3 pDDDid=r5
	bl		GetDddidSourcesLength
.Llo1257:
	mr		r4,r3		# didLength=r4 didLength=r3
	b		.L1539
.L1542:
#    }
#    else
#    {
#       /*
#       * Static defined periodic / composite DID and thus is the size calculated by the SCG.
#       */
#       didLength = pDDDid->size + (uint16)2U;
	.d2line		6779
.Llo1258:
	lhz		r4,2(r5)		# didLength=r4 pDDDid=r5
.Llo1259:
	se_addi		r4,2		# didLength=r4 didLength=r4
	mr		r4,r4		# didLength=r4 didLength=r4
.L1539:
#    }
# 
#    /*
#    * Only add those DIDs that are accessible for future use when fetching the actual data.
#    */
#    if (*pErrorCode == DCM_INT_NRC_POSITIVERESPONSE)
	.d2line		6785
.Llo1262:
	lbz		r0,0(r7)		# pErrorCode=r7
	se_cmpi		r0,0
	bc		0,2,.L1544	# ne
#    {
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].identifier = didIdentifier;
	.d2line		6787
.Llo1251:
	lis		r3,(Dcm_LCfg+60)@ha		# i=r3
.Llo1255:
	lwz		r5,(Dcm_LCfg+60)@l(r3)		# pDDDid=r5 i=r3
.Llo1263:
	lhz		r0,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r0,r0,3,13,28
	sthx		r31,r5,r0		# pDDDid=r5 didIdentifier=r31
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].did_type = DID_ENUM_DDDID;
	.d2line		6788
	diab.li		r0,1
	lwz		r5,(Dcm_LCfg+60)@l(r3)		# pDDDid=r5 i=r3
	lhz		r3,0(r30)		# i=r3 pCurrentValidDidIndex=r30
	rlwinm		r3,r3,3,13,28		# i=r3 i=r3
	se_add		r3,r5		# i=r3 i=r3 pDDDid=r5
	stw		r0,4(r3)		# i=r3
#       (*pCurrentValidDidIndex)++;
	.d2line		6789
	lhz		r3,0(r30)		# i=r3 pCurrentValidDidIndex=r30
	se_addi		r3,1		# i=r3 i=r3
	sth		r3,0(r30)		# pCurrentValidDidIndex=r30 i=r3
.L1544:
#    }
# 
#    return didLength;
	.d2line		6792
.Llo1249:
	rlwinm		r3,r4,0,16,31		# i=r3 didLength=r4
# }
	.d2line		6793
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1260:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4130:
	.type		GetDddidLength,@function
	.size		GetDddidLength,.-GetDddidLength
# Number of nodes = 137

# Allocations for GetDddidLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	not allocated	activeSession
#	not allocated	activeSecurityLevel
#	?a6		pErrorCode
#	?a7		$$85
#	?a8		$$84
#	?a9		i
#	?a10		didLength
#	?a11		pDDDid
# static FUNC(void, DCM_CODE) HandleStdRetVal(CONST(Std_ReturnType, AUTOMATIC) stdRetVal,
	.align		1
	.section	.text_vle
        .d2line         14460,29
#$$ld
.L4143:

#$$bf	HandleStdRetVal,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
HandleStdRetVal:
.Llo1264:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# stdRetVal=r3 stdRetVal=r3
	mr		r4,r4		# syncApi=r4 syncApi=r4
	mr		r5,r5		# forceRcrrpSupport=r5 forceRcrrpSupport=r5
	mr		r31,r6		# pErrorCode=r31 pErrorCode=r6
	.d2prologue_end
#                                              CONST(Std_ReturnType, AUTOMATIC) syncApi,
#                                              CONST(boolean, AUTOMATIC) forceRcrrpSupport,
#                                              CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    switch (stdRetVal)
	.d2line		14465
	rlwinm		r6,r3,0,24,31		# stdRetVal=r3
.Llo1271:
	se_cmpi		r6,0
	bc		1,2,.L3056	# eq
.Llo1265:
	se_cmpi		r6,1
	bc		1,2,.L3062	# eq
	se_cmpi		r6,10
	bc		1,2,.L3058	# eq
	se_cmpi		r6,12
	bc		1,2,.L3063	# eq
.Llo1266:
	b		.L3067
.L3056:
#    {
#       case E_OK:
#       {
#          *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		14469
.Llo1267:
	diab.li		r0,0
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3055
.L3058:
#          break;
#       }
# 
#       case DCM_E_PENDING:
#       {
#          if (DCM_E_PENDING == syncApi)
	.d2line		14475
	rlwinm		r4,r4,0,24,31		# syncApi=r4 syncApi=r4
	se_cmpi		r4,10		# syncApi=r4
	bc		0,2,.L3059	# ne
#          {
#             /* Pending is allowed. */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		14478
.Llo1268:
	diab.li		r0,162
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3055
.L3059:
#          }
#          else
#          {
#             /*
#              * This is synchronous API call.
#              * Pending is not allowed.
#              *
#              * [VSTAR_Dcm_00041]
#              * Call DET in case of PENDING when SYNC is configured.
#              *
#              * [VSTAR_Dcm_00042]
#              * Return NRC 0x22 in case of PENDING when SYNC is configured.
#              */
#             DCM_ASSERT_INTERFACE_RETURN_VALUE(SID_MAINFUNCTION, FALSE);
	.d2line		14492
	diab.li		r3,53		# stdRetVal=r3
	diab.li		r4,0		# syncApi=r4
	diab.li		r5,37
	diab.li		r6,2
	bl		Det_ReportError
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		14493
	diab.li		r0,34
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3055
.L3062:
#          }
#          break;
#       }
# 
#       case E_NOT_OK:
#       {
#          /*
#          * A wrapper handling several signals, e.g. ReadData and ConditionCheckRead, will convert
#          * a returned DCM_E_PENDING for a synchronous signal to E_NOT_OK. The error code will still
#          * be 0x00 (ErrorCode is not present in the ReadData signature) and thus will the call
#          * below also solve [VSTAR_Dcm_00041] and [VSTAR_Dcm_00042].
#          */
#          Dcm_CheckAndPossiblyConvertErrorCode(pErrorCode);
	.d2line		14506
	mr		r3,r31		# pErrorCode=r3 pErrorCode=r31
	bl		Dcm_CheckAndPossiblyConvertErrorCode
	b		.L3055
.L3063:
#          break;
#       }
# 
#       case DCM_E_FORCE_RCRRP:
#       {
#          if (forceRcrrpSupport)
	.d2line		14512
.Llo1269:
	rlwinm		r5,r5,0,24,31		# forceRcrrpSupport=r5 forceRcrrpSupport=r5
	se_cmpi		r5,0		# forceRcrrpSupport=r5
	bc		1,2,.L3064	# eq
#          {
#             /*
#             * The function has returned forced response pending and it shall support it.
#             * Force a NRC 0x78 (requestCorrectlyReceived-ResponsePending) and wait for the confirm
#             */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_FORCE_RCRRP;
	.d2line		14518
.Llo1270:
	diab.li		r0,163
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3055
.L3064:
#          }
#          else
#          {
#             /*
#              * It's an asynchronous API, but forced response pending is not allowed.
#              */
# 
#             /*
#              * [VSTAR_Dcm_00041]
#              * Call DET in case of invalid error
#              */
#             DCM_ASSERT_INTERFACE_RETURN_VALUE(SID_MAINFUNCTION, FALSE);
	.d2line		14530
	diab.li		r3,53		# stdRetVal=r3
	diab.li		r4,0
	diab.li		r5,37		# forceRcrrpSupport=r5
	diab.li		r6,2
	bl		Det_ReportError
# 
#             /*
#              * [VSTAR_Dcm_00042]
#              */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		14535
	diab.li		r0,34
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3055
.L3067:
#          }
#          break;
#       }
# 
#       default: /* Impossible, all valid return values covered. Therefore consider the return value as an error. */
#       {
#          /*
#           * [VSTAR_Dcm_00041]
#           * Call DET in case of invalid error
#           */
#          DCM_ASSERT_INTERFACE_RETURN_VALUE(SID_MAINFUNCTION, FALSE);
	.d2line		14546
	diab.li		r3,53		# stdRetVal=r3
	diab.li		r4,0
	diab.li		r5,37
	diab.li		r6,2
	bl		Det_ReportError
# 
#          /*
#           * [VSTAR_Dcm_00042]
#           */
#          *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		14551
	diab.li		r0,34
	stb		r0,0(r31)		# pErrorCode=r31
.L3055:
#          break;
#       }
#    }
# }
	.d2line		14555
	.d2epilogue_begin
.Llo1272:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4144:
	.type		HandleStdRetVal,@function
	.size		HandleStdRetVal,.-HandleStdRetVal
# Number of nodes = 76

# Allocations for HandleStdRetVal
#	?a4		stdRetVal
#	?a5		syncApi
#	?a6		forceRcrrpSupport
#	?a7		pErrorCode
# static FUNC(uint16, DCM_CODE) GetStandardDidLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6799,31
#$$ld
.L4152:

#$$bf	GetStandardDidLength,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetStandardDidLength:
.Llo1273:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	25,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
	mr		r3,r5		# activeSession=r3 activeSession=r5
.Llo1274:
	mr		r29,r6		# activeSecurityLevel=r29 activeSecurityLevel=r6
	mr		r28,r7		# pErrorCode=r28 pErrorCode=r7
	mr		r27,r8		# opStatus=r27 opStatus=r8
	.d2prologue_end
#                                                  CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                                  Dcm_SesCtrlType activeSession,
#                                                  Dcm_SecLevelType activeSecurityLevel,
#                                                  CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode,
#                                                  Dcm_OpStatusType opStatus)
# {
#    uint16 i;
#    uint16 didLength = (uint16)0U;
	.d2line		6807
	diab.li		r26,0		# didLength=r26
# 
#    P2CONST(Dcm_Cfg_DidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
	.d2line		6809
.Llo1308:
	diab.li		r25,0
# 
#    *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6811
.Llo1310:
	diab.li		r4,0
.Llo1277:
	stb		r4,0(r28)		# pErrorCode=r28
# 
#    for (i = (uint16)0U; (i < Dcm_LCfg.num_dids) && (NULL_PTR == pDid); i++)
.L1554:
	.d2line		6813
.Llo1275:
	rlwinm		r0,r4,0,16,31		# i=r4
.Llo1278:
	lis		r5,(Dcm_LCfg+64)@ha
	lhz		r5,(Dcm_LCfg+64)@l(r5)
	se_cmp		r0,r5
	bc		0,0,.L1556	# ge
	se_cmpi		r25,0		# pDid=r25
	bc		0,2,.L1556	# ne
#    {
#       if ((Dcm_LCfg.dids[i].identifier == didIdentifier) && (NULL_PTR != Dcm_LCfg.dids[i].pDidRead))
	.d2line		6815
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r6,r0,5,0,26
	se_slwi		r0,2
	subf		r0,r0,r6
	lhzx		r5,r5,r0
	rlwinm		r0,r31,0,16,31		# didIdentifier=r31
	se_cmp		r5,r0
	bc		0,2,.L1557	# ne
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r6,r0,5,0,26
	se_slwi		r0,2
	subf		r0,r0,r6
	se_add		r5,r0
	lwz		r0,12(r5)
	se_cmpi		r0,0
	bc		1,2,.L1557	# eq
#       {
#          pDid = &Dcm_LCfg.dids[i];
	.d2line		6817
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r25,(Dcm_LCfg+68)@l(r5)		# pDid=r25
	rlwinm		r5,r0,5,0,26
	se_slwi		r0,2
	subf		r0,r0,r5
	se_add		r0,r25		# pDid=r25
	mr		r25,r0		# pDid=r25 pDid=r0
.L1557:
#       }
#    }
	.d2line		6819
	diab.addi		r0,r4,1		# i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L1554
.L1556:
# 
#    /*
#     * 1. Was the DID found amongst the configured ones?
#     */
#    if (NULL_PTR == pDid)
	.d2line		6824
	se_cmpi		r25,0		# pDid=r25
	bc		0,2,.L1558	# ne
#    {
#       /*
#        * The requested DID was not found. Report an error and break.
#        */
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6829
.Llo1305:
	diab.li		r0,160
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1559
.L1558:
#    }
#    /*
#     * 2. Can the DID be read in the current session?
#     */
#    else if (FALSE == Dcm_IsLevelSupported(activeSession, pDid->pDidRead->p_session_levels))
	.d2line		6834
.Llo1279:
	lwz		r4,12(r25)		# i=r4 pDid=r25
.Llo1306:
	lwz		r4,16(r4)		# i=r4 i=r4
.Llo1280:
	rlwinm		r3,r3,0,24,31		# activeSession=r3 activeSession=r3
.Llo1281:
	bl		Dcm_IsLevelSupported
.Llo1282:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1283:
	bc		0,2,.L1560	# ne
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED_IN_SESSION;
	.d2line		6836
	diab.li		r0,161
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1559
.L1560:
#    }
#    /*
#     * 3. Can the DID be read in the current security level?
#     */
#    else if (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, pDid->pDidRead->p_security_levels))
	.d2line		6841
	lwz		r3,12(r25)		# activeSession=r3 pDid=r25
.Llo1284:
	lwz		r4,12(r3)		# i=r4 activeSession=r3
	rlwinm		r3,r29,0,24,31		# activeSession=r3 activeSecurityLevel=r29
.Llo1285:
	bl		Dcm_IsLevelSupported
.Llo1286:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1287:
	bc		0,2,.L1562	# ne
#    {
#       *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		6843
.Llo1301:
	diab.li		r0,51
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1559
.L1562:
#    }
#    else
#    {
#       if (NULL_PTR == pDid->pDidRead->ReadDataLengthFunc)
	.d2line		6847
	lwz		r3,12(r25)		# activeSession=r3 pDid=r25
.Llo1288:
	lwz		r0,4(r3)		# activeSession=r3
	se_cmpi		r0,0
	bc		0,2,.L1564	# ne
#       {
#          didLength = (uint16)(pDid->size + 2); /* the length of data + 2 bytes Did */
	.d2line		6849
.Llo1289:
	lhz		r26,2(r25)		# didLength=r26 pDid=r25
	se_addi		r26,2		# didLength=r26 didLength=r26
	mr		r26,r26		# didLength=r26 didLength=r26
	b		.L1559
.L1564:
	.section	.text_vle
.L4171:
#       }
#       else
#       {
#          uint16 tempDidLength;
#          Std_ReturnType stdReturnVal = pDid->pDidRead->ReadDataLengthFunc(opStatus, &tempDidLength);
	.d2line		6854
	lwz		r3,12(r25)		# activeSession=r3 pDid=r25
.Llo1290:
	lwz		r0,4(r3)		# activeSession=r3
	mtspr		ctr,r0
	rlwinm		r3,r27,0,24,31		# activeSession=r3 opStatus=r27
.Llo1291:
	diab.addi		r4,r1,8		# i=r4
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#          /*
#           * [VSTAR_Dcm_00043]
#           * Assume error was returned and thus assign the ErrorCode since it's not part of the API.
#           * The ErrorCode will be changed to a proper value depending on stdReturnVal in the call to HandleStdRetVal
#           */
#          *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		6861
.Llo1304:
	diab.li		r0,34		# activeSession=r0
.Llo1292:
	stb		r0,0(r28)		# pErrorCode=r28 activeSession=r0
# 
#          HandleStdRetVal(stdReturnVal, pDid->RetStatus, FALSE, pErrorCode);
	.d2line		6863
	lbz		r4,24(r25)		# i=r4 pDid=r25
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
.Llo1293:
	diab.li		r5,0
	mr		r6,r28		# pErrorCode=r6 pErrorCode=r28
	bl		HandleStdRetVal
# 
#          if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		6865
.Llo1311:
	lbz		r0,0(r28)		# activeSession=r0 pErrorCode=r28
.Llo1294:
	se_cmpi		r0,0		# activeSession=r0
	bc		0,2,.L1559	# ne
#          {
#             didLength = (uint16)2 + tempDidLength; /* 2 bytes Did + the length of data */
	.d2line		6867
.Llo1295:
	lhz		r26,8(r1)		# didLength=r26
	se_addi		r26,2		# didLength=r26 didLength=r26
	mr		r26,r26		# didLength=r26 didLength=r26
	.section	.text_vle
.L4172:
.L1559:
#          }
#          else
#          {
#             /*
#              * The DID length could not be read or pending was returned.
#              */
#          }
#       }
#    }
# 
#    /*
#    * Only add those DIDs that are accessible for future use when fetching the actual data.
#    */
#    if (*pErrorCode == DCM_INT_NRC_POSITIVERESPONSE)
	.d2line		6881
.Llo1302:
	lbz		r0,0(r28)		# activeSession=r0 pErrorCode=r28
.Llo1296:
	se_cmpi		r0,0		# activeSession=r0
	bc		0,2,.L1568	# ne
#    {
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].identifier = didIdentifier;
	.d2line		6883
.Llo1297:
	lis		r3,(Dcm_LCfg+60)@ha		# activeSession=r3
.Llo1298:
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# i=r4 activeSession=r3
.Llo1307:
	lhz		r0,0(r30)		# activeSession=r0 pCurrentValidDidIndex=r30
	rlwinm		r0,r0,3,13,28		# activeSession=r0 activeSession=r0
	sthx		r31,r4,r0		# i=r4 didIdentifier=r31
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].did_type = DID_ENUM_DID;
	.d2line		6884
	diab.li		r0,0		# activeSession=r0
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# i=r4 activeSession=r3
	lhz		r3,0(r30)		# activeSession=r3 pCurrentValidDidIndex=r30
.Llo1299:
	rlwinm		r3,r3,3,13,28		# activeSession=r3 activeSession=r3
.Llo1300:
	se_add		r3,r4		# activeSession=r3 activeSession=r3 i=r4
	stw		r0,4(r3)		# activeSession=r3 activeSession=r0
#       (*pCurrentValidDidIndex)++;
	.d2line		6885
	lhz		r3,0(r30)		# activeSession=r3 pCurrentValidDidIndex=r30
	se_addi		r3,1		# activeSession=r3 activeSession=r3
	sth		r3,0(r30)		# pCurrentValidDidIndex=r30 activeSession=r3
.L1568:
#    }
# 
#    return didLength;
	.d2line		6888
.Llo1276:
	rlwinm		r3,r26,0,16,31		# activeSession=r3 didLength=r26
# }
	.d2line		6889
	.d2epilogue_begin
	lmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	2,10
.Llo1309:
	lwz		r0,52(r1)		# activeSession=r0
	mtspr		lr,r0		# activeSession=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1303:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4153:
	.type		GetStandardDidLength,@function
	.size		GetStandardDidLength,.-GetStandardDidLength
# Number of nodes = 224

# Allocations for GetStandardDidLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	?a6		activeSession
#	?a7		activeSecurityLevel
#	?a8		pErrorCode
#	?a9		opStatus
#	?a10		$$88
#	?a11		$$87
#	?a12		$$86
#	?a13		i
#	?a14		didLength
#	?a15		pDid
#	SP,8		tempDidLength
#	?a16		stdReturnVal
# static FUNC(boolean, DCM_CODE) IsDidAvailableWithinRange(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6895,32
#$$ld
.L4180:

#$$bf	IsDidAvailableWithinRange,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
IsDidAvailableWithinRange:
.Llo1312:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# didIdentifier=r3 didIdentifier=r3
	mr		r4,r4		# pDidRange=r4 pDidRange=r4
	mr		r31,r5		# pErrorCode=r31 pErrorCode=r5
	mr		r6,r6		# opStatus=r6 opStatus=r6
	.d2prologue_end
#                                                         P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_CONST) pDidRange,
#                                                         CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode,
#                                                         Dcm_OpStatusType opStatus)
# {
# 
#    if (NULL_PTR != pDidRange->IsDidAvailableFunc)
	.d2line		6901
	lwz		r0,8(r4)		# pDidRange=r4
	se_cmpi		r0,0
	bc		1,2,.L1582	# eq
	.section	.text_vle
.L4191:
#    {
#       Dcm_DidSupportedType supported = DCM_DID_SUPPORTED;
	.d2line		6903
.Llo1313:
	diab.li		r0,0
.Llo1317:
	stb		r0,8(r1)
#       Std_ReturnType stdReturnVal;
# 
#       /*
#        * Consider all other responses than E_OK to be a failure and not supported.
#        * Note that DCM_E_PENDING should be supported, but it's currently a TODO (BZ #22739).
#        */
#       stdReturnVal = pDidRange->IsDidAvailableFunc(didIdentifier, opStatus, &supported);
	.d2line		6910
	lwz		r0,8(r4)		# pDidRange=r4
	mtspr		ctr,r0
.Llo1314:
	rlwinm		r3,r3,0,16,31		# didIdentifier=r3 didIdentifier=r3
.Llo1315:
	rlwinm		r4,r6,0,24,31		# pDidRange=r4 opStatus=r6
.Llo1316:
	diab.addi		r5,r1,8
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo1321:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
#       if ((E_OK == stdReturnVal) && (DCM_DID_SUPPORTED == supported))
	.d2line		6911
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1580	# ne
.Llo1322:
	lbz		r0,8(r1)
	se_cmpi		r0,0
	bc		1,2,.L1582	# eq
.L1580:
#       {
#          /*
#           * DID is supported
#           */
#       }
#       else
#       {
#          /*
#           * The available function returned something else than OK and thus is supported unreliable, or
#           * The function returned OK and the requested DID was not supported.
#           */
#          *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		6923
	diab.li		r0,160
	stb		r0,0(r31)		# pErrorCode=r31
	.section	.text_vle
.L4192:
.L1582:
#       }
#    }
#    else
#    {
#       /*
#        * No gaps according to configuration so consider the DID as supported
#        */
#    }
# 
#    return (boolean)(DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode);
	.d2line		6933
.Llo1318:
	lbz		r3,0(r31)		# stdReturnVal=r3 pErrorCode=r31
.Llo1319:
	cntlzw		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
	diab.srwi		r3,5		# stdReturnVal=r3
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
# }
	.d2line		6934
	.d2epilogue_begin
.Llo1323:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1320:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4181:
	.type		IsDidAvailableWithinRange,@function
	.size		IsDidAvailableWithinRange,.-IsDidAvailableWithinRange
# Number of nodes = 44

# Allocations for IsDidAvailableWithinRange
#	?a4		didIdentifier
#	?a5		pDidRange
#	?a6		pErrorCode
#	?a7		opStatus
#	SP,8		supported
#	?a8		stdReturnVal
# static FUNC(uint16, DCM_CODE) CallReadDidDataLengthFunc(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6940,31
#$$ld
.L4201:

#$$bf	CallReadDidDataLengthFunc,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
CallReadDidDataLengthFunc:
.Llo1324:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pDidRange=r31 pDidRange=r4
.Llo1326:
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
.Llo1327:
	mr		r4,r6		# opStatus=r4 opStatus=r6
	.d2prologue_end
#                                                         P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_CONST) pDidRange,
#                                                         CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode,
#                                                         Dcm_OpStatusType opStatus)
# {
#    uint16 didLength = (uint16)0U;
	.d2line		6945
	diab.li		r0,0
	sth		r0,8(r1)
#    CONST(Std_ReturnType, AUTOMATIC) stdReturnVal = pDidRange->p_did_range_read->ReadDidDataLengthFunc(didIdentifier, opStatus, &didLength);
	.d2line		6946
	lwz		r5,12(r31)		# pDidRange=r31
.Llo1329:
	lwz		r0,4(r5)
	mtspr		ctr,r0
	rlwinm		r3,r3,0,16,31		# didIdentifier=r3 didIdentifier=r3
.Llo1325:
	rlwinm		r4,r4,0,24,31		# opStatus=r4 opStatus=r4
	diab.addi		r5,r1,8
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo1330:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
# 
#    if (E_OK != stdReturnVal)
	.d2line		6948
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		1,2,.L1586	# eq
#    {
#       /*
#       * Note that DCM_E_PENDING should be supported, but it's currently a TODO (BZ #22739).
#       * The DID length could not be read. Return an error.
#       */
#       *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		6954
.Llo1332:
	diab.li		r0,34
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1587
.L1586:
#    }
#    else if (didLength > pDidRange->max_data_length)
	.d2line		6956
	lhz		r0,8(r1)
	lhz		r3,4(r31)		# stdReturnVal=r3 pDidRange=r31
.Llo1333:
	se_cmp		r0,r3		# stdReturnVal=r3
	bc		0,1,.L1587	# le
#    {
#       /*
#       * [VSTAR_Dcm_00029] Too long length according to configuration
#       */
#       *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		6961
.Llo1328:
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
.L1587:
#    }
#    else
#    {
#       /*
#        * The length was successfully fetched
#        */
#    }
# 
#    return didLength;
	.d2line		6970
.Llo1331:
	lhz		r3,8(r1)		# stdReturnVal=r3
# }
	.d2line		6971
	.d2epilogue_begin
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4202:
	.type		CallReadDidDataLengthFunc,@function
	.size		CallReadDidDataLengthFunc,.-CallReadDidDataLengthFunc
# Number of nodes = 46

# Allocations for CallReadDidDataLengthFunc
#	?a4		didIdentifier
#	?a5		pDidRange
#	?a6		pErrorCode
#	?a7		opStatus
#	SP,8		didLength
#	?a8		stdReturnVal
# static FUNC(uint16, DCM_CODE) GetDidRangeLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6977,31
#$$ld
.L4213:

#$$bf	GetDidRangeLength,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetDidRangeLength:
.Llo1334:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	25,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
	mr		r3,r5		# activeSession=r3 activeSession=r5
.Llo1335:
	mr		r29,r6		# activeSecurityLevel=r29 activeSecurityLevel=r6
	mr		r28,r7		# pErrorCode=r28 pErrorCode=r7
	mr		r27,r8		# opStatus=r27 opStatus=r8
	.d2prologue_end
#                                                 CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                                 Dcm_SesCtrlType activeSession,
#                                                 Dcm_SecLevelType activeSecurityLevel,
#                                                 CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode,
#                                                 Dcm_OpStatusType opStatus)
# {
#    uint16 i;
#    uint16 didLength = (uint16)0U;
	.d2line		6985
	diab.li		r26,0		# didLength=r26
# 
#    P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_CONST) pDidRange = NULL_PTR;
	.d2line		6987
.Llo1365:
	diab.li		r25,0
# 
#    *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6989
.Llo1367:
	diab.li		r4,0
.Llo1338:
	stb		r4,0(r28)		# pErrorCode=r28
# 
#    for (i = (uint16)0U; (i < Dcm_LCfg.num_did_ranges) && (NULL_PTR == pDidRange); i++)
.L1593:
	.d2line		6991
.Llo1336:
	rlwinm		r6,r4,0,16,31		# i=r4
.Llo1339:
	lis		r5,(Dcm_LCfg+86)@ha
	lhz		r0,(Dcm_LCfg+86)@l(r5)
	se_cmp		r6,r0
	bc		0,0,.L1595	# ge
	se_cmpi		r25,0		# pDidRange=r25
	bc		0,2,.L1595	# ne
#    {
#       if ((didIdentifier >= Dcm_LCfg.p_did_ranges[i].lower_limit) &&
	.d2line		6993
	rlwinm		r0,r31,0,16,31		# didIdentifier=r31
	lis		r5,(Dcm_LCfg+88)@ha
	lwz		r5,(Dcm_LCfg+88)@l(r5)
	rlwinm		r6,r4,0,16,31		# i=r4
	e_mulli		r6,r6,20
	lhzx		r5,r5,r6
	se_cmp		r0,r5
	bc		1,0,.L1596	# lt
	rlwinm		r0,r31,0,16,31		# didIdentifier=r31
	lis		r5,(Dcm_LCfg+88)@ha
	lwz		r6,(Dcm_LCfg+88)@l(r5)
	rlwinm		r5,r4,0,16,31		# i=r4
	e_mulli		r5,r5,20
	se_add		r5,r6
	lhz		r5,2(r5)
	se_cmp		r0,r5
	bc		1,1,.L1596	# gt
	lis		r5,(Dcm_LCfg+88)@ha
	lwz		r0,(Dcm_LCfg+88)@l(r5)
	rlwinm		r5,r4,0,16,31		# i=r4
	e_mulli		r5,r5,20
	se_add		r5,r0
	lwz		r0,12(r5)
	se_cmpi		r0,0
	bc		1,2,.L1596	# eq
#          (didIdentifier <= Dcm_LCfg.p_did_ranges[i].upper_limit) &&
#          (NULL_PTR != Dcm_LCfg.p_did_ranges[i].p_did_range_read))
#       {
#          pDidRange = &Dcm_LCfg.p_did_ranges[i];
	.d2line		6997
	lis		r5,(Dcm_LCfg+88)@ha
	lwz		r25,(Dcm_LCfg+88)@l(r5)		# pDidRange=r25
	rlwinm		r5,r4,0,16,31		# i=r4
	e_mulli		r5,r5,20
	se_add		r5,r25		# pDidRange=r25
	mr		r25,r5		# pDidRange=r25 pDidRange=r5
.L1596:
#       }
#    }
	.d2line		6999
	diab.addi		r5,r4,1		# i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L1593
.L1595:
# 
#    /*
#     * 1. Was the DID found amongst the configured ones?
#     */
#    if (NULL_PTR == pDidRange)
	.d2line		7004
	se_cmpi		r25,0		# pDidRange=r25
	bc		0,2,.L1597	# ne
#    {
#       /*
#        * The requested DID was not found. Report an error and break.
#        */
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		7009
.Llo1362:
	diab.li		r0,160
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1598
.L1597:
#    }
#    /*
#     * 2. Can the DID be read in the current session?
#     */
#    else if (!Dcm_IsLevelSupported(activeSession, pDidRange->p_did_range_read->p_session_levels))
	.d2line		7014
.Llo1340:
	lwz		r4,12(r25)		# i=r4 pDidRange=r25
.Llo1363:
	lwz		r4,12(r4)		# i=r4 i=r4
.Llo1341:
	rlwinm		r3,r3,0,24,31		# activeSession=r3 activeSession=r3
.Llo1342:
	bl		Dcm_IsLevelSupported
.Llo1343:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1344:
	bc		0,2,.L1599	# ne
#    {
#       *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED_IN_SESSION;
	.d2line		7016
	diab.li		r0,161
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1598
.L1599:
#    }
#    /*
#     * 3. Can the DID be read in the current security level?
#     */
#    else if (!Dcm_IsLevelSupported(activeSecurityLevel, pDidRange->p_did_range_read->p_security_levels))
	.d2line		7021
	lwz		r3,12(r25)		# activeSession=r3 pDidRange=r25
.Llo1345:
	lwz		r4,8(r3)		# i=r4 activeSession=r3
	rlwinm		r3,r29,0,24,31		# activeSession=r3 activeSecurityLevel=r29
.Llo1346:
	bl		Dcm_IsLevelSupported
.Llo1347:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1348:
	bc		0,2,.L1601	# ne
#    {
#       *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		7023
.Llo1356:
	diab.li		r0,51
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1598
.L1601:
#    }
#    /*
#     * 4. Can the DID be read in the current security level?
#     */
#    else if (!Dcm_IsCurrentModesAllowed(pDidRange->p_did_range_read->modeRuleFunc, pErrorCode))
	.d2line		7028
	lwz		r3,12(r25)		# activeSession=r3 pDidRange=r25
.Llo1349:
	lwz		r3,16(r3)		# activeSession=r3 activeSession=r3
.Llo1350:
	mr		r4,r28		# pErrorCode=r4 pErrorCode=r28
	bl		Dcm_IsCurrentModesAllowed
.Llo1351:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1352:
	bc		0,2,.L1603	# ne
#    {
#       /*
#        * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#        */
#       HandleNrcResponsePending(*pErrorCode);
	.d2line		7033
	lbz		r0,0(r28)		# pErrorCode=r28
	cmpi		0,0,r0,120
	bc		0,2,.L1608	# ne
.Llo1360:
	diab.li		r0,162
	b		.L1609
.L1608:
	lbz		r0,0(r28)		# pErrorCode=r28
.L1609:
	stb		r0,0(r28)		# pErrorCode=r28
	b		.L1598
.L1603:
#    }
#    /*
#     * 5. Is the requested DID in the range in case of existing gaps?
#     */
#    else if (!IsDidAvailableWithinRange(didIdentifier, pDidRange, pErrorCode, opStatus))
	.d2line		7038
.Llo1361:
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r25		# pDidRange=r4 pDidRange=r25
	mr		r5,r28		# pErrorCode=r5 pErrorCode=r28
	mr		r6,r27		# opStatus=r6 opStatus=r27
	bl		IsDidAvailableWithinRange
.Llo1353:
	e_andi.		r3,r3,255		# activeSession=r3 activeSession=r3
.Llo1354:
	bc		1,2,.L1598	# eq
#    {
#       /*
#        * The NRC was set during the call to IsDidAvailableWithinRange
#        */
#    }
#    /*
#     * 6. Finally time to fetch the length
#     */
#    else
#    {
#       didLength = CallReadDidDataLengthFunc(didIdentifier, pDidRange, pErrorCode, opStatus);
	.d2line		7049
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r25		# pDidRange=r4 pDidRange=r25
	mr		r5,r28		# pErrorCode=r5 pErrorCode=r28
	mr		r6,r27		# opStatus=r6 opStatus=r27
	bl		CallReadDidDataLengthFunc
	mr		r26,r3		# didLength=r26 didLength=r3
.L1598:
#    }
# 
#    /*
#     * Only add those DIDs that are accessible for future use when fetching the actual data.
#     */
#    if (*pErrorCode == DCM_INT_NRC_POSITIVERESPONSE)
	.d2line		7055
	lbz		r0,0(r28)		# pErrorCode=r28
	se_cmpi		r0,0
	bc		0,2,.L1607	# ne
#    {
#       /*
#        * The length of data + 2 bytes identifier
#        */
#       didLength += (uint16)2U;
	.d2line		7060
.Llo1357:
	diab.addi		r3,r26,2		# activeSession=r3 didLength=r26
.Llo1358:
	se_addi		r26,2		# didLength=r26 didLength=r26
# 
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].identifier = didIdentifier;
	.d2line		7062
	lis		r3,(Dcm_LCfg+60)@ha		# activeSession=r3
.Llo1355:
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# i=r4 activeSession=r3
.Llo1364:
	lhz		r0,0(r30)		# pCurrentValidDidIndex=r30
	rlwinm		r0,r0,3,13,28
	sthx		r31,r4,r0		# i=r4 didIdentifier=r31
#       Dcm_LCfg.p_requested_dids[*pCurrentValidDidIndex].did_type = DID_ENUM_DID_RANGE;
	.d2line		7063
	diab.li		r0,5
	lwz		r4,(Dcm_LCfg+60)@l(r3)		# i=r4 activeSession=r3
	lhz		r3,0(r30)		# activeSession=r3 pCurrentValidDidIndex=r30
	rlwinm		r3,r3,3,13,28		# activeSession=r3 activeSession=r3
	se_add		r3,r4		# activeSession=r3 activeSession=r3 i=r4
	stw		r0,4(r3)		# activeSession=r3
#       (*pCurrentValidDidIndex)++;
	.d2line		7064
	lhz		r3,0(r30)		# activeSession=r3 pCurrentValidDidIndex=r30
	se_addi		r3,1		# activeSession=r3 activeSession=r3
	sth		r3,0(r30)		# pCurrentValidDidIndex=r30 activeSession=r3
.L1607:
#    }
# 
#    return didLength;
	.d2line		7067
.Llo1337:
	rlwinm		r3,r26,0,16,31		# activeSession=r3 didLength=r26
# }
	.d2line		7068
	.d2epilogue_begin
	lmw		r25,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	2,10
.Llo1366:
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1359:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4214:
	.type		GetDidRangeLength,@function
	.size		GetDidRangeLength,.-GetDidRangeLength
# Number of nodes = 242

# Allocations for GetDidRangeLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	?a6		activeSession
#	?a7		activeSecurityLevel
#	?a8		pErrorCode
#	?a9		opStatus
#	?a10		$$43
#	?a11		i
#	?a12		didLength
#	?a13		pDidRange
# static FUNC(uint16, DCM_CODE) GetCommonDidLength(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         6567,31
#$$ld
.L4230:

#$$bf	GetCommonDidLength,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetCommonDidLength:
.Llo1368:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
.Llo1378:
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)		# didLength=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r4		# pCurrentValidDidIndex=r30 pCurrentValidDidIndex=r4
	mr		r29,r5		# activeSession=r29 activeSession=r5
	mr		r28,r6		# activeSecurityLevel=r28 activeSecurityLevel=r6
	mr		r27,r7		# pErrorCode=r27 pErrorCode=r7
.Llo1375:
	mr		r26,r8		# opStatus=r26 opStatus=r8
	.d2prologue_end
#                                            CONSTP2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) pCurrentValidDidIndex,
#                                            Dcm_SesCtrlType activeSession,
#                                            Dcm_SecLevelType activeSecurityLevel,
#                                            CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode,
#                                            Dcm_OpStatusType opStatus)
# {
#    uint16 didLength = (uint16)0U;
	.d2line		6574
.Llo1376:
	diab.li		r0,0		# didLength=r0
# 
#    /*
#    * Always check for normal configured DIDs first since they are most common
#    */
#    didLength = GetStandardDidLength(didIdentifier, pCurrentValidDidIndex, activeSession, activeSecurityLevel, pErrorCode, opStatus);
	.d2line		6579
.Llo1379:
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
.Llo1369:
	mr		r4,r30		# pCurrentValidDidIndex=r4 pCurrentValidDidIndex=r30
.Llo1372:
	mr		r5,r29		# activeSession=r5 activeSession=r29
.Llo1373:
	mr		r6,r28		# activeSecurityLevel=r6 activeSecurityLevel=r28
.Llo1374:
	mr		r7,r27		# pErrorCode=r7 pErrorCode=r27
	mr		r8,r26		# opStatus=r8 opStatus=r26
.Llo1377:
	bl		GetStandardDidLength
.Llo1380:
	mr		r3,r3		# didLength=r3 didLength=r3
# 
#    /*
#     * [SWS_Dcm_00483]
#     * Check for OBD Vehicle info types, i.e. DIDs in the range of 0xF8nn
#     */
#    if (DCM_INT_NRC_ID_NOT_SUPPORTED == *pErrorCode)
	.d2line		6585
	lbz		r0,0(r27)		# didLength=r0 pErrorCode=r27
	cmpi		0,0,r0,160		# didLength=r0
	bc		0,2,.L1499	# ne
#    {
#       didLength = GetObdVehInfoDidLength(didIdentifier, pCurrentValidDidIndex, activeSession, activeSecurityLevel, pErrorCode);
	.d2line		6587
.Llo1370:
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pCurrentValidDidIndex=r4 pCurrentValidDidIndex=r30
	mr		r5,r29		# activeSession=r5 activeSession=r29
	mr		r6,r28		# activeSecurityLevel=r6 activeSecurityLevel=r28
	mr		r7,r27		# pErrorCode=r7 pErrorCode=r27
	bl		GetObdVehInfoDidLength
	mr		r3,r3		# didLength=r3 didLength=r3
.L1499:
#    }
# 
#    /*
#     * [SWS_Dcm_00481]
#     * Check for OBD PIDs, i.e. DIDs in the range of 0xF4nn
#     */
#    if (DCM_INT_NRC_ID_NOT_SUPPORTED == *pErrorCode)
	.d2line		6594
	lbz		r0,0(r27)		# didLength=r0 pErrorCode=r27
	cmpi		0,0,r0,160		# didLength=r0
	bc		0,2,.L1500	# ne
#    {
#       didLength = GetObdPidDidLength(didIdentifier, pCurrentValidDidIndex, activeSession, activeSecurityLevel, pErrorCode);
	.d2line		6596
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pCurrentValidDidIndex=r4 pCurrentValidDidIndex=r30
	mr		r5,r29		# activeSession=r5 activeSession=r29
	mr		r6,r28		# activeSecurityLevel=r6 activeSecurityLevel=r28
	mr		r7,r27		# pErrorCode=r7 pErrorCode=r27
	bl		GetObdPidDidLength
	mr		r3,r3		# didLength=r3 didLength=r3
.L1500:
#    }
# 
#    /*
#     * Check for periodic, dynamically and composite DIDs since they are using the same structure.
#     */
#    if (DCM_INT_NRC_ID_NOT_SUPPORTED == *pErrorCode)
	.d2line		6602
	lbz		r0,0(r27)		# didLength=r0 pErrorCode=r27
	cmpi		0,0,r0,160		# didLength=r0
	bc		0,2,.L1501	# ne
#    {
#       didLength = GetDddidLength(didIdentifier, pCurrentValidDidIndex, activeSession, activeSecurityLevel, pErrorCode);
	.d2line		6604
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pCurrentValidDidIndex=r4 pCurrentValidDidIndex=r30
	mr		r5,r29		# activeSession=r5 activeSession=r29
	mr		r6,r28		# activeSecurityLevel=r6 activeSecurityLevel=r28
	mr		r7,r27		# pErrorCode=r7 pErrorCode=r27
	bl		GetDddidLength
	mr		r3,r3		# didLength=r3 didLength=r3
.L1501:
#    }
# 
#    /*
#     * Range DIDs
#     */
#    if (DCM_INT_NRC_ID_NOT_SUPPORTED == *pErrorCode)
	.d2line		6610
	lbz		r0,0(r27)		# didLength=r0 pErrorCode=r27
	cmpi		0,0,r0,160		# didLength=r0
	bc		0,2,.L1502	# ne
#    {
#       didLength = GetDidRangeLength(didIdentifier, pCurrentValidDidIndex, activeSession, activeSecurityLevel, pErrorCode, opStatus);
	.d2line		6612
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pCurrentValidDidIndex=r4 pCurrentValidDidIndex=r30
	mr		r5,r29		# activeSession=r5 activeSession=r29
	mr		r6,r28		# activeSecurityLevel=r6 activeSecurityLevel=r28
	mr		r7,r27		# pErrorCode=r7 pErrorCode=r27
	mr		r8,r26		# opStatus=r8 opStatus=r26
	bl		GetDidRangeLength
	mr		r3,r3		# didLength=r3 didLength=r3
.L1502:
#    }
# 
#    return didLength;
	.d2line		6615
.Llo1371:
	rlwinm		r3,r3,0,16,31		# didLength=r3 didLength=r3
# }
	.d2line		6616
	.d2epilogue_begin
.Llo1381:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)		# didLength=r0
	mtspr		lr,r0		# didLength=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4231:
	.type		GetCommonDidLength,@function
	.size		GetCommonDidLength,.-GetCommonDidLength
# Number of nodes = 116

# Allocations for GetCommonDidLength
#	?a4		didIdentifier
#	?a5		pCurrentValidDidIndex
#	?a6		activeSession
#	?a7		activeSecurityLevel
#	?a8		pErrorCode
#	?a9		opStatus
#	?a10		didLength
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDid(uint16 didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         10808,53
#$$ld
.L4243:

#$$bf	ReadConfiguredDid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDid:
.Llo1382:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
.Llo1415:
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)		# pDid=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r29,r6		# pStatus=r29 pStatus=r6
	.d2prologue_end
#                                                                       Dcm_SesCtrlType activeSession,
#                                                                       Dcm_SecLevelType activeSecurityLevel,
#                                                                       CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    uint16 confDidCounter;
#    P2CONST(Dcm_Cfg_DidType, AUTOMATIC, DCM_APPL_DATA) pDid  = NULL_PTR;
	.d2line		10814
	diab.li		r0,0		# pDid=r0
# 
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		10816
	stb		r0,8(r1)		# pDid=r0
# 
#    if (READ_DID_INIT == pStatus->read_did_info.current_operation)
	.d2line		10818
	lwz		r0,24(r29)		# pDid=r0 pStatus=r29
	se_cmpi		r0,0		# pDid=r0
	bc		0,2,.L2204	# ne
#    {
#       /*
#        * Try to find a matching DID in the configuration
#        */
#       pDid = NULL_PTR;
	.d2line		10823
.Llo1383:
	diab.li		r4,0		# pDid=r4
#       for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_dids) && (NULL_PTR == pDid); confDidCounter++)
	.d2line		10824
.Llo1384:
	diab.li		r3,0
.L2205:
.Llo1394:
	rlwinm		r0,r3,0,16,31		# pDid=r0 confDidCounter=r3
	lis		r5,(Dcm_LCfg+64)@ha
	lhz		r5,(Dcm_LCfg+64)@l(r5)
	se_cmp		r0,r5		# pDid=r0
	bc		0,0,.L2207	# ge
	se_cmpi		r4,0		# pDid=r4
	bc		0,2,.L2207	# ne
#       {
#          if ((Dcm_LCfg.dids[confDidCounter].identifier == didIdentifier) && (NULL_PTR != Dcm_LCfg.dids[confDidCounter].pDidRead))
	.d2line		10826
	rlwinm		r0,r3,0,16,31		# pDid=r0 confDidCounter=r3
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r6,r0,5,0,26		# pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r6		# pDid=r0 pDid=r0
	lhzx		r5,r5,r0
	rlwinm		r0,r31,0,16,31		# pDid=r0 didIdentifier=r31
	se_cmp		r5,r0		# pDid=r0
	bc		0,2,.L2208	# ne
	rlwinm		r0,r3,0,16,31		# pDid=r0 confDidCounter=r3
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r6,r0,5,0,26		# pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r6		# pDid=r0 pDid=r0
	se_add		r5,r0		# pDid=r0
	lwz		r0,12(r5)		# pDid=r0
	se_cmpi		r0,0		# pDid=r0
	bc		1,2,.L2208	# eq
#          {
#             pDid = &Dcm_LCfg.dids[confDidCounter];
	.d2line		10828
	rlwinm		r0,r3,0,16,31		# pDid=r0 confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha		# pDid=r4
	lwz		r4,(Dcm_LCfg+68)@l(r4)		# pDid=r4 pDid=r4
	rlwinm		r5,r0,5,0,26		# pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r5		# pDid=r0 pDid=r0
	se_add		r0,r4		# pDid=r0 pDid=r0 pDid=r4
	mr		r4,r0		# pDid=r4 pDid=r0
#             pStatus->currentDidIndex = confDidCounter;
	.d2line		10829
	sth		r3,16(r29)		# pStatus=r29 confDidCounter=r3
.L2208:
#          }
#       }
	.d2line		10831
	diab.addi		r0,r3,1		# pDid=r0 confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L2205
.L2207:
# 
#       /*
#        * 1. Was the DID found amongst the configured ones?
#        * It shall always be found since only valid identifiers will be used.
#        * But to be sure, and avoid SCA warnings, do a check that never will be possible to test.
#        */
#       if (NULL_PTR == pDid)
	.d2line		10838
	se_cmpi		r4,0		# pDid=r4
	bc		0,2,.L2209	# ne
#       {
#          /*
#           * The requested DID was not found.
#           */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		10843
.Llo1395:
	diab.li		r0,160		# pDid=r0
	stb		r0,8(r1)		# pDid=r0
	b		.L2204
.L2209:
#       }
#       /*
#        * 2. Can the DID be read in the current session?
#        *    No need since it was checked during GetStandardDidLength.
#        *    The only reason it will change is due to protocol pre-emption. And in that case will not data be read anyway.
#        * 3. Can the DID be read in the current security level?
#        *    No need since it was checked during GetStandardDidLength.
#        *    The only reason it will change is due to protocol pre-emption. And in that case will not data be read anyway.
#        * 4. [SWS_Dcm_00819]: Can the DID be read in the current mode conditions?
#        *    Mode can be changed by SW-C without any possibility for the DCM to know.
#        *    Therefore is a check still needed even already checked during GetStandardDidLength.
#        */
#       else if (!Dcm_IsCurrentModesAllowed(pDid->pDidRead->modeRuleFunc, &ErrorCode))
	.d2line		10856
	lwz		r3,12(r4)		# confDidCounter=r3 pDid=r4
.Llo1396:
	lwz		r3,20(r3)		# confDidCounter=r3 confDidCounter=r3
.Llo1397:
	diab.addi		r4,r1,8		# pDid=r4
.Llo1416:
	bl		Dcm_IsCurrentModesAllowed
.Llo1398:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo1399:
	bc		0,2,.L2211	# ne
#       {
#          /*
#           * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#           */
#          HandleNrcResponsePending(ErrorCode);
	.d2line		10861
	lbz		r0,8(r1)		# pDid=r0
.Llo1417:
	cmpi		0,0,r0,120		# pDid=r0
	bc		0,2,.L2238	# ne
.Llo1418:
	diab.li		r0,162		# pDid=r0
.Llo1419:
	b		.L2239
.L2238:
.Llo1420:
	lbz		r0,8(r1)		# pDid=r0
.L2239:
.Llo1421:
	stb		r0,8(r1)		# pDid=r0
	b		.L2204
.L2211:
#       }
#       else
#       {
#          pStatus->read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		10865
.Llo1422:
	diab.li		r0,0		# pDid=r0
.Llo1423:
	stb		r0,22(r29)		# pStatus=r29 pDid=r0
#          pStatus->read_did_info.current_res_buffer = NULL_PTR;
	.d2line		10866
	stw		r0,28(r29)		# pStatus=r29 pDid=r0
#          pStatus->read_did_info.current_operation = READ_DID_CONDITION_CHECK;
	.d2line		10867
	diab.li		r0,1		# pDid=r0
	stw		r0,24(r29)		# pStatus=r29 pDid=r0
.L2204:
#       }
#    }
# 
#    if (READ_DID_CONDITION_CHECK == pStatus->read_did_info.current_operation)
	.d2line		10871
.Llo1424:
	lwz		r0,24(r29)		# pDid=r0 pStatus=r29
.Llo1425:
	se_cmpi		r0,1		# pDid=r0
	bc		0,2,.L2213	# ne
#    {
#       pDid = &Dcm_LCfg.dids[pStatus->currentDidIndex];
	.d2line		10873
.Llo1426:
	lhz		r0,16(r29)		# pDid=r0 pStatus=r29
.Llo1427:
	lis		r3,(Dcm_LCfg+68)@ha		# confDidCounter=r3
.Llo1400:
	lwz		r30,(Dcm_LCfg+68)@l(r3)		# pDid=r30 confDidCounter=r3
	rlwinm		r3,r0,5,0,26		# confDidCounter=r3 pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r3		# pDid=r0 pDid=r0 confDidCounter=r3
	se_add		r0,r30		# pDid=r0 pDid=r0 pDid=r30
	mr		r30,r0		# pDid=r30 pDid=r0
# 
#       /*
#        * 5. Does the application allow the DID to be read?
#        */
#       if (NULL_PTR == pDid->pDidRead->ConditionCheckReadFunc)
	.d2line		10878
	lwz		r3,12(r30)		# confDidCounter=r3 pDid=r30
	lwz		r0,0(r3)		# pDid=r0 confDidCounter=r3
	se_cmpi		r0,0		# pDid=r0
	bc		1,2,.L2215	# eq
	.section	.text_vle
.L4257:
#       {
#          /*
#           * Ecu Signal, NvM API is used or DcmDspDataConditionCheckReadFncUsed is false, no conditionCheckReadFunc is needed.
#           */
#       }
#       else
#       {
#          Std_ReturnType stdReturnVal = pDid->pDidRead->ConditionCheckReadFunc(pStatus->read_did_info.current_opstatus, &ErrorCode);
	.d2line		10886
.Llo1401:
	lwz		r3,12(r30)		# confDidCounter=r3 pDid=r30
.Llo1402:
	lwz		r0,0(r3)		# pDid=r0 confDidCounter=r3
	mtspr		ctr,r0		# pDid=ctr
	lbz		r3,22(r29)		# confDidCounter=r3 pStatus=r29
.Llo1403:
	diab.addi		r4,r1,8		# pDid=r4
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#          /*
#           * Use HandleStdRetVal to possibly set the ErrorCode for different cases.
#           */
#          HandleStdRetVal(stdReturnVal, pDid->RetStatus, FALSE, &ErrorCode);
	.d2line		10891
.Llo1458:
	lbz		r4,24(r30)		# pDid=r4 pDid=r30
	diab.addi		r6,r1,8
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	diab.li		r5,0
	bl		HandleStdRetVal
	.section	.text_vle
.L4258:
.L2215:
#       }
# 
#       if (DCM_INT_NRC_API_RETURNED_PENDING == ErrorCode)
	.d2line		10894
.Llo1459:
	lbz		r0,8(r1)		# pDid=r0
	cmpi		0,0,r0,162		# pDid=r0
	bc		0,2,.L2216	# ne
#       {
#          pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		10896
.Llo1428:
	diab.li		r0,1		# pDid=r0
.Llo1429:
	stb		r0,22(r29)		# pStatus=r29 pDid=r0
	b		.L2213
.L2216:
#       }
#       else if (DCM_INT_NRC_POSITIVERESPONSE != ErrorCode)
	.d2line		10898
.Llo1430:
	lbz		r0,8(r1)		# pDid=r0
.Llo1431:
	se_cmpi		r0,0		# pDid=r0
	bc		0,2,.L2213	# ne
#       {
#          /*
#           * [SWS_Dcm_00797], [SWS_Dcm_00439]
#           * The DCM module shall send a negative response with NRC set to value from the
#           * parameter "ErrorCode" of DcmDspDataConditionCheckReadFnc function or ConditionCheckRead operation.
#           */
#       }
#       else
#       {
#          /*
#           * Read condition check is successfully executed.
#           */
#          pStatus->read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		10911
.Llo1432:
	diab.li		r0,0		# pDid=r0
.Llo1433:
	stb		r0,22(r29)		# pStatus=r29 pDid=r0
#          pStatus->read_did_info.current_operation = READ_DID_LENGTH;
	.d2line		10912
	diab.li		r0,2		# pDid=r0
	stw		r0,24(r29)		# pStatus=r29 pDid=r0
.L2213:
#       }
#    }
# 
#    if (READ_DID_LENGTH == pStatus->read_did_info.current_operation)
	.d2line		10916
.Llo1434:
	lwz		r0,24(r29)		# pDid=r0 pStatus=r29
.Llo1435:
	se_cmpi		r0,2		# pDid=r0
	bc		0,2,.L2220	# ne
#    {
#       pDid = &Dcm_LCfg.dids[pStatus->currentDidIndex];
	.d2line		10918
.Llo1436:
	lhz		r0,16(r29)		# pDid=r0 pStatus=r29
.Llo1437:
	lis		r3,(Dcm_LCfg+68)@ha		# confDidCounter=r3
.Llo1404:
	lwz		r30,(Dcm_LCfg+68)@l(r3)		# pDid=r30 confDidCounter=r3
	rlwinm		r3,r0,5,0,26		# confDidCounter=r3 pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r3		# pDid=r0 pDid=r0 confDidCounter=r3
	se_add		r0,r30		# pDid=r0 pDid=r0 pDid=r30
	mr		r30,r0		# pDid=r30 pDid=r0
# 
#       if (NULL_PTR == pDid->pDidRead->ReadDataLengthFunc)
	.d2line		10920
	lwz		r3,12(r30)		# confDidCounter=r3 pDid=r30
	lwz		r0,4(r3)		# pDid=r0 confDidCounter=r3
	se_cmpi		r0,0		# pDid=r0
	bc		0,2,.L2221	# ne
#       {
#          pStatus->read_did_info.current_size = pDid->size;
	.d2line		10922
.Llo1405:
	lhz		r0,2(r30)		# pDid=r0 pDid=r30
.Llo1438:
	sth		r0,20(r29)		# pStatus=r29 pDid=r0
#          pStatus->read_did_info.current_operation = READ_DID_BUFFER;
	.d2line		10923
	diab.li		r0,3		# pDid=r0
	stw		r0,24(r29)		# pStatus=r29 pDid=r0
	b		.L2222
.L2221:
	.section	.text_vle
.L4263:
#       }
#       else
#       {
#          Std_ReturnType stdReturnVal = pDid->pDidRead->ReadDataLengthFunc(pStatus->read_did_info.current_opstatus, &pStatus->read_did_info.current_size);
	.d2line		10927
	lwz		r3,12(r30)		# confDidCounter=r3 pDid=r30
.Llo1406:
	lwz		r0,4(r3)		# pDid=r0 confDidCounter=r3
	mtspr		ctr,r0		# pDid=ctr
	lbz		r3,22(r29)		# confDidCounter=r3 pStatus=r29
.Llo1407:
	diab.addi		r4,r29,20		# pDid=r4 pStatus=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#          /*
#           * [VSTAR_Dcm_00043]
#           * Assume error was returned and thus assign the ErrorCode since it's not part of the API.
#           * The ErrorCode will be changed to a proper value depending on stdReturnVal in the call to HandleStdRetVal
#           */
#          ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		10934
.Llo1460:
	diab.li		r0,34		# pDid=r0
	stb		r0,8(r1)		# pDid=r0
# 
#          /*
#          * Use HandleStdRetVal to possibly set the ErrorCode for different cases.
#          */
#          HandleStdRetVal(stdReturnVal, pDid->RetStatus, FALSE, &ErrorCode);
	.d2line		10939
	lbz		r4,24(r30)		# pDid=r4 pDid=r30
	diab.addi		r6,r1,8
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	diab.li		r5,0
	bl		HandleStdRetVal
	.section	.text_vle
.L4264:
.L2222:
#       }
# 
#       if (DCM_INT_NRC_API_RETURNED_PENDING == ErrorCode)
	.d2line		10942
.Llo1439:
	lbz		r0,8(r1)		# pDid=r0
.Llo1440:
	cmpi		0,0,r0,162		# pDid=r0
	bc		0,2,.L2223	# ne
#       {
#          pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		10944
.Llo1441:
	diab.li		r0,1		# pDid=r0
.Llo1442:
	stb		r0,22(r29)		# pStatus=r29 pDid=r0
	b		.L2220
.L2223:
#       }
#       else if (DCM_INT_NRC_POSITIVERESPONSE != ErrorCode)
	.d2line		10946
.Llo1443:
	lbz		r0,8(r1)		# pDid=r0
.Llo1444:
	se_cmpi		r0,0		# pDid=r0
	bc		0,2,.L2220	# ne
#       {
#          /*
#           * [VSTAR_Dcm_00043]
#           * The DCM module shall send a negative response with NRC 0x22
#           */
#       }
#       else
#       {
#          /*
#          * Read data length is successfully executed. Continue with next step.
#          */
#          pStatus->read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		10958
.Llo1445:
	diab.li		r0,0		# pDid=r0
.Llo1446:
	stb		r0,22(r29)		# pStatus=r29 pDid=r0
#          pStatus->read_did_info.current_operation = READ_DID_BUFFER;
	.d2line		10959
	diab.li		r0,3		# pDid=r0
	stw		r0,24(r29)		# pStatus=r29 pDid=r0
.L2220:
#       }
#    }
# 
#    /*
#     * Finally try to get the response buffer
#     */
#    if (READ_DID_BUFFER == pStatus->read_did_info.current_operation)
	.d2line		10966
.Llo1447:
	lwz		r0,24(r29)		# pDid=r0 pStatus=r29
.Llo1448:
	se_cmpi		r0,3		# pDid=r0
	bc		0,2,.L2227	# ne
	.section	.text_vle
.L4269:
#    {
#       /*
#        * When paged buffer is disabled shall the static code reserve the buffer for ID plus DATA
#        * When paged buffer is enabled shall the generated wrapper (in case of several signals reserve the buffer for DATA.
#        */
#       Std_ReturnType stdReturnVal;
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       pDid = &Dcm_LCfg.dids[pStatus->currentDidIndex];
# 
#       if (pDid->pDidRead->multiple_signals)
#       {
#          stdReturnVal =  Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)2U, &pStatus->read_did_info.current_res_buffer);
#       }
#       else
# #endif
#       {
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)(pStatus->read_did_info.current_size + 2U), &pStatus->read_did_info.current_res_buffer);
	.d2line		10983
.Llo1449:
	lhz		r3,20(r29)		# confDidCounter=r3 pStatus=r29
.Llo1408:
	se_addi		r3,2		# confDidCounter=r3 confDidCounter=r3
	rlwinm		r3,r3,0,16,31		# confDidCounter=r3 confDidCounter=r3
.Llo1409:
	diab.addi		r4,r29,28		# pDid=r4 pStatus=r29
	bl		Dcm_DsdRequestResponseBuffer
.Llo1461:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		10986
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L2228	# ne
#       {
#          /*
#           * Set the identifier and switch operation to start fetching data
#           */
#          SET_2BYTE_ID(&pStatus->read_did_info.current_res_buffer[0], didIdentifier);
	.d2line		10991
.Llo1462:
	rlwinm		r0,r31,24,24,31		# pDid=r0 didIdentifier=r31
.Llo1450:
	lwz		r3,28(r29)		# stdReturnVal=r3 pStatus=r29
.Llo1463:
	stb		r0,0(r3)		# stdReturnVal=r3 pDid=r0
	rlwinm		r0,r31,0,24,31		# pDid=r0 didIdentifier=r31
.Llo1451:
	lwz		r3,28(r29)		# stdReturnVal=r3 pStatus=r29
	stb		r31,1(r3)		# stdReturnVal=r3 didIdentifier=r31
#          pStatus->read_did_info.current_operation = READ_DID_DATA;
	.d2line		10992
	diab.li		r0,4		# pDid=r0
.Llo1452:
	stw		r0,24(r29)		# pStatus=r29 pDid=r0
	b		.L2227
.L2228:
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#       {
#          /*
#           * Do nothing, it will continue to read data later.
#           */
#          ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#       }
#       else if (DCM_INT_E_RESPONSE_FULL == stdReturnVal)
#       {
#          /*
#           * The whole length of the originally calculated response length has been filled.
#           */
#          pStatus->sendPositiveResponse = TRUE;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned
#           *  DCM_INT_E_RESPONSE_TOO_LONG
#           *
#           * Abort, requested size can't possible fit in buffer.
#           */
#          ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11018
.Llo1453:
	diab.li		r0,20		# pDid=r0
.Llo1454:
	stb		r0,8(r1)		# pDid=r0
	.section	.text_vle
.L4270:
.L2227:
# 
#          /*
#           * Dcm_DsdRequestResponseBuffer returning
#           *  E_NOT_OK
#           * will never happen per design.
#           */
#       }
#    }
# 
#    if (READ_DID_DATA == pStatus->read_did_info.current_operation)
	.d2line		11028
.Llo1455:
	lwz		r0,24(r29)		# pDid=r0 pStatus=r29
.Llo1456:
	se_cmpi		r0,4		# pDid=r0
	bc		0,2,.L2231	# ne
#    {
#       pDid = &Dcm_LCfg.dids[pStatus->currentDidIndex];
	.d2line		11030
.Llo1385:
	lhz		r0,16(r29)		# pDid=r0 pStatus=r29
.Llo1386:
	lis		r3,(Dcm_LCfg+68)@ha		# confDidCounter=r3
.Llo1387:
	lwz		r31,(Dcm_LCfg+68)@l(r3)		# didIdentifier=r31 confDidCounter=r3
.Llo1388:
	rlwinm		r3,r0,5,0,26		# confDidCounter=r3 pDid=r0
	se_slwi		r0,2		# pDid=r0 pDid=r0
	subf		r0,r0,r3		# pDid=r0 pDid=r0 confDidCounter=r3
	se_add		r0,r31		# pDid=r0 pDid=r0 didIdentifier=r31
	mr		r31,r0		# pDid=r31 pDid=r0
# 
#       if (NULL_PTR != pStatus->read_did_info.current_res_buffer)
	.d2line		11032
.Llo1389:
	lwz		r0,28(r29)		# pDid=r0 pStatus=r29
	se_cmpi		r0,0		# pDid=r0
	bc		1,2,.L2231	# eq
	.section	.text_vle
.L4275:
#       {
#          /*
#           * Read the actual data.
#           */
# /*
#  * When paged buffer is disabled shall the static code reserve the buffer for ID plus DATA
#  * - Therefore is the allocated buffer sent to ReadDataFunc
#  * When paged buffer is disabled shall the generated wrapper reserve the buffer for DATA.
#  * - Therefore is NULL_PTR sent to ReadDataFunc
#  */
#          Std_ReturnType stdReturnVal;
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          if (pDid->pDidRead->multiple_signals)
#          {
#             stdReturnVal = pDid->pDidRead->ReadDataFunc(pStatus->read_did_info.current_opstatus, NULL_PTR);
#          }
#          else
# #endif
#          {
#             stdReturnVal = pDid->pDidRead->ReadDataFunc(pStatus->read_did_info.current_opstatus, &pStatus->read_did_info.current_res_buffer[2]);
	.d2line		11052
.Llo1410:
	lwz		r3,12(r31)		# confDidCounter=r3 pDid=r31
.Llo1411:
	lwz		r0,8(r3)		# pDid=r0 confDidCounter=r3
	mtspr		ctr,r0		# pDid=ctr
	lbz		r3,22(r29)		# confDidCounter=r3 pStatus=r29
.Llo1412:
	lwz		r4,28(r29)		# pDid=r4 pStatus=r29
	se_addi		r4,2		# pDid=r4 pDid=r4
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo1464:
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
#          }
# 
# 
#          if ((DCM_E_PENDING == stdReturnVal) && (DCM_E_PENDING == pDid->RetStatus))
	.d2line		11056
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo1465:
	se_cmpi		r3,10		# stdReturnVal=r3
.Llo1466:
	bc		0,2,.L2233	# ne
	lbz		r3,24(r31)		# stdReturnVal=r3 pDid=r31
	se_cmpi		r3,10		# stdReturnVal=r3
	bc		0,2,.L2233	# ne
#          {
#             /*
#              * Read request returned pending and it's a ASYNC function.
#              */
#             ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		11061
.Llo1457:
	diab.li		r0,162		# confDidCounter=r0
.Llo1413:
	stb		r0,8(r1)		# confDidCounter=r0
#             pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		11062
	diab.li		r0,1		# confDidCounter=r0
	stb		r0,22(r29)		# pStatus=r29 confDidCounter=r0
	b		.L2231
.L2233:
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_FULL == stdReturnVal)
#          {
#             /*
#              * The whole length of the originally calculated response length has been filled.
#              */
#             pStatus->sendPositiveResponse = TRUE;
#          }
#          else if (DCM_INT_E_RESPONSE_TOO_LONG == stdReturnVal)
#          {
#             /*
#              *
#              * Abort, requested size can't possible fit in buffer.
#              */
#             ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
#          }
#          else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#          {
#             /*
#              * Buffer request returned pending, just wait and try again.
#              */
#             ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#             pStatus->read_did_info.current_opstatus = DCM_PENDING;
#          }
# #endif
#          else if (E_OK != stdReturnVal)
	.d2line		11089
.Llo1414:
	rlwinm		r3,r0,0,24,31		# stdReturnVal=r3 stdReturnVal=r0
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		1,2,.L2231	# eq
#          {
#             /*
#              * The application did not accept the read request. Return an error.
#              *
#              * [VSTAR_Dcm_00041]
#              * Call DET in case of PENDING when SYNC is configured.
#              *
#              * [VSTAR_Dcm_00042]
#              * Return NRC 0x22 in case of PENDING when SYNC is configured.
#              *
#              * [VSTAR_Dcm_00044]
#              * Return NRC 0x22 in case of value not equal to E_OK (PENDING when ASYNC is allowed)
#              */
#             DCM_ASSERT_INTERFACE_RETURN_VALUE(SID_MAINFUNCTION, DCM_E_PENDING != stdReturnVal);
	.d2line		11103
.Llo1392:
	rlwinm		r0,r0,0,24,31		# stdReturnVal=r0 stdReturnVal=r0
	se_cmpi		r0,10		# stdReturnVal=r0
	bc		0,2,.L2236	# ne
.Llo1467:
	diab.li		r3,53		# stdReturnVal=r3
	diab.li		r4,0		# pDid=r4
	diab.li		r5,37
	diab.li		r6,2
	bl		Det_ReportError
.L2236:
#             ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		11104
	diab.li		r0,34		# stdReturnVal=r0
.Llo1468:
	stb		r0,8(r1)		# stdReturnVal=r0
	.section	.text_vle
.L4276:
.L2231:
#          }
#          else
#          {
#             /* The DID was read */
#          }
#       }
#    }
# 
#    return ErrorCode;
	.d2line		11113
.Llo1390:
	lbz		r3,8(r1)		# confDidCounter=r3
# }
	.d2line		11114
	.d2epilogue_begin
.Llo1391:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# pDid=r0
	mtspr		lr,r0		# pDid=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1393:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4244:
	.type		ReadConfiguredDid,@function
	.size		ReadConfiguredDid,.-ReadConfiguredDid
# Number of nodes = 495

# Allocations for ReadConfiguredDid
#	?a4		didIdentifier
#	not allocated	activeSession
#	not allocated	activeSecurityLevel
#	?a5		pStatus
#	?a6		$$94
#	?a7		$$93
#	?a8		$$92
#	?a9		$$91
#	?a10		$$90
#	?a11		$$89
#	?a12		$$60
#	?a13		confDidCounter
#	?a14		pDid
#	SP,8		ErrorCode
#	?a15		stdReturnVal
#	?a16		stdReturnVal
#	?a17		stdReturnVal
#	?a18		stdReturnVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDidRange_Init(CONST(uint16, AUTOMATIC) didIdentifier, 
	.align		1
	.section	.text_vle
        .d2line         11156,53
#$$ld
.L4283:

#$$bf	ReadConfiguredDidRange_Init,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDidRange_Init:
.Llo1469:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# didIdentifier=r3 didIdentifier=r3
	mr		r31,r4		# pStatus=r31 pStatus=r4
	.d2prologue_end
#                                                         CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
#    uint16 confDidCounter;
#    P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_DATA) pDidRange = NULL_PTR;
	.d2line		11161
	diab.li		r5,0		# pDidRange=r5
# 
#    /*
#    * Try to find a matching DID in the configuration
#    * Since only valid DIDs will be stored while fetching the length will it not be possible to test
#    * all conditions.
#    */
#    for (confDidCounter = (uint16)0U; (confDidCounter < Dcm_LCfg.num_did_ranges) && (NULL_PTR == pDidRange); confDidCounter++)
	.d2line		11168
.Llo1481:
	diab.li		r4,0
.L2270:
.Llo1477:
	rlwinm		r7,r4,0,16,31		# confDidCounter=r4
.Llo1478:
	lis		r6,(Dcm_LCfg+86)@ha
	lhz		r0,(Dcm_LCfg+86)@l(r6)
	se_cmp		r7,r0
	bc		0,0,.L2272	# ge
	se_cmpi		r5,0		# pDidRange=r5
	bc		0,2,.L2272	# ne
#    {
#       if ((didIdentifier >= Dcm_LCfg.p_did_ranges[confDidCounter].lower_limit) &&
	.d2line		11170
	rlwinm		r0,r3,0,16,31		# didIdentifier=r3
	lis		r6,(Dcm_LCfg+88)@ha
	lwz		r6,(Dcm_LCfg+88)@l(r6)
	rlwinm		r7,r4,0,16,31		# confDidCounter=r4
	e_mulli		r7,r7,20
	lhzx		r6,r6,r7
	se_cmp		r0,r6
	bc		1,0,.L2273	# lt
	rlwinm		r0,r3,0,16,31		# didIdentifier=r3
	lis		r6,(Dcm_LCfg+88)@ha
	lwz		r7,(Dcm_LCfg+88)@l(r6)
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	e_mulli		r6,r6,20
	se_add		r6,r7
	lhz		r6,2(r6)
	se_cmp		r0,r6
	bc		1,1,.L2273	# gt
	lis		r6,(Dcm_LCfg+88)@ha
	lwz		r0,(Dcm_LCfg+88)@l(r6)
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	e_mulli		r6,r6,20
	se_add		r6,r0
	lwz		r0,12(r6)
	se_cmpi		r0,0
	bc		1,2,.L2273	# eq
#          (didIdentifier <= Dcm_LCfg.p_did_ranges[confDidCounter].upper_limit) &&
#          (NULL_PTR != Dcm_LCfg.p_did_ranges[confDidCounter].p_did_range_read))
#       {
#          pDidRange = &Dcm_LCfg.p_did_ranges[confDidCounter];
	.d2line		11174
	lis		r5,(Dcm_LCfg+88)@ha		# pDidRange=r5
	lwz		r0,(Dcm_LCfg+88)@l(r5)		# pDidRange=r5
	rlwinm		r5,r4,0,16,31		# pDidRange=r5 confDidCounter=r4
	e_mulli		r5,r5,20		# pDidRange=r5 pDidRange=r5
	se_add		r0,r5		# pDidRange=r5
	mr		r5,r0		# pDidRange=r5 pDidRange=r0
#          pStatus->currentDidIndex = confDidCounter;
	.d2line		11175
	sth		r4,16(r31)		# pStatus=r31 confDidCounter=r4
.L2273:
#       }
#    }
	.d2line		11177
	diab.addi		r6,r4,1		# confDidCounter=r4
	se_addi		r4,1		# confDidCounter=r4 confDidCounter=r4
	b		.L2270
.L2272:
# 
#    /*
#    * 1. Was the DID found amongst the configured ones?
#    * It shall always be found since only valid identifiers will be used.
#    * But to be sure, and avoid SCA warnings, do a check that never will be possible to test.
#    */
#    if (NULL_PTR == pDidRange)
	.d2line		11184
	se_cmpi		r5,0		# pDidRange=r5
	bc		0,2,.L2274	# ne
#    {
#       /*
#       * The requested DID was not found.
#       */
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11189
.Llo1470:
	diab.li		r0,160
	stb		r0,8(r1)
	b		.L2275
.L2274:
#    }
#    /*
#    * 2. Can the DID be read in the current session?
#    *    No need since it was checked during GetDidRangeLength.
#    *    The only reason it will change is due to protocol pre-emption. And in that case will not data be read anyway.
#    * 3. Can the DID be read in the current security level?
#    *    No need since it was checked during GetDidRangeLength.
#    *    The only reason it will change is due to protocol pre-emption. And in that case will not data be read anyway.
#    * 4. [SWS_Dcm_00819]: Can the DID be read in the current mode conditions?
#    *    Mode can be changed by SW-C without any possibility for the DCM to know.
#    *    Therefore is a check still needed even already checked during GetDidRangeLength.
#    * 5. Does the DID range has any gaps?
#    *    No need since it was checked during GetDidRangeLength and assuming it won't change during readout.
#    *    If so will ReadData return error anyway.
#    */
#    else if (!Dcm_IsCurrentModesAllowed(pDidRange->p_did_range_read->modeRuleFunc, &ErrorCode))
	.d2line		11205
	lwz		r3,12(r5)		# didIdentifier=r3 pDidRange=r5
.Llo1471:
	lwz		r3,16(r3)		# didIdentifier=r3 didIdentifier=r3
.Llo1472:
	diab.addi		r4,r1,8		# confDidCounter=r4
	bl		Dcm_IsCurrentModesAllowed
.Llo1473:
	e_andi.		r3,r3,255		# didIdentifier=r3 didIdentifier=r3
.Llo1474:
	bc		0,2,.L2276	# ne
#    {
#       /*
#       * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#       */
#       HandleNrcResponsePending(ErrorCode);
	.d2line		11210
	lbz		r0,8(r1)
	cmpi		0,0,r0,120
	bc		0,2,.L2278	# ne
.Llo1479:
	diab.li		r0,162
	b		.L2279
.L2278:
	lbz		r0,8(r1)
.L2279:
	stb		r0,8(r1)
	b		.L2275
.L2276:
#    }
#    else
#    {
#       /*
#       * Fetch the length
#       */
#       pStatus->read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		11217
.Llo1480:
	diab.li		r3,0		# didIdentifier=r3
.Llo1475:
	stb		r3,22(r31)		# pStatus=r31 didIdentifier=r3
#       pStatus->read_did_info.current_res_buffer = NULL_PTR;
	.d2line		11218
	stw		r3,28(r31)		# pStatus=r31 didIdentifier=r3
#       pStatus->read_did_info.current_operation = READ_DID_LENGTH;
	.d2line		11219
	diab.li		r0,2
	stw		r0,24(r31)		# pStatus=r31
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11220
	stb		r3,8(r1)		# didIdentifier=r3
.L2275:
#    }
# 
#    return ErrorCode;
	.d2line		11223
.Llo1476:
	lbz		r3,8(r1)		# didIdentifier=r3
# }
	.d2line		11224
	.d2epilogue_begin
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4284:
	.type		ReadConfiguredDidRange_Init,@function
	.size		ReadConfiguredDidRange_Init,.-ReadConfiguredDidRange_Init
# Number of nodes = 147

# Allocations for ReadConfiguredDidRange_Init
#	?a4		didIdentifier
#	?a5		pStatus
#	?a6		$$61
#	SP,8		ErrorCode
#	?a7		confDidCounter
#	?a8		pDidRange
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDidRange_Length(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         11229,53
#$$ld
.L4295:

#$$bf	ReadConfiguredDidRange_Length,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDidRange_Length:
.Llo1482:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pStatus=r31 pStatus=r4
	.d2prologue_end
#                                                           CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
#    CONSTP2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_DATA) pDidRange = &Dcm_LCfg.p_did_ranges[pStatus->currentDidIndex];
	.d2line		11233
.Llo1484:
	lis		r4,(Dcm_LCfg+88)@ha
.Llo1485:
	lwz		r30,(Dcm_LCfg+88)@l(r4)		# pDidRange=r30
	lhz		r0,16(r31)		# pStatus=r31
	e_mulli		r0,r0,20
	se_add		r0,r30		# pDidRange=r30
	mr		r30,r0		# pDidRange=r30 pDidRange=r0
# 
#    Std_ReturnType stdReturnVal = pDidRange->p_did_range_read->ReadDidDataLengthFunc(didIdentifier, pStatus->read_did_info.current_opstatus, &pStatus->read_did_info.current_size);
	.d2line		11235
.Llo1495:
	lwz		r4,12(r30)		# pDidRange=r30
.Llo1496:
	lwz		r0,4(r4)
.Llo1497:
	mtspr		ctr,r0
	lbz		r4,22(r31)		# pStatus=r31
	rlwinm		r3,r3,0,16,31		# didIdentifier=r3 didIdentifier=r3
.Llo1483:
	diab.addi		r5,r31,20		# pStatus=r31
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo1498:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
# 
#    if (DCM_E_PENDING == stdReturnVal)
	.d2line		11237
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r3
	se_cmpi		r0,10
	bc		0,2,.L2289	# ne
#    {
#       ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		11239
.Llo1500:
	diab.li		r3,162		# ErrorCode=r3
#       pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		11240
.Llo1487:
	diab.li		r0,1
	stb		r0,22(r31)		# pStatus=r31
	b		.L2290
.L2289:
#    }
#    else if (E_OK != stdReturnVal)
	.d2line		11242
.Llo1488:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		1,2,.L2291	# eq
#    {
#       /*
#       * The DID length could not be read. Return an error.
#       * No given value according to specification.
#       */
#       ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		11248
.Llo1501:
	diab.li		r3,34		# ErrorCode=r3
.Llo1489:
	b		.L2290
.L2291:
#    }
#    else if (pStatus->read_did_info.current_size > pDidRange->max_data_length)
	.d2line		11250
.Llo1490:
	lhz		r0,20(r31)		# pStatus=r31
	lhz		r3,4(r30)		# stdReturnVal=r3 pDidRange=r30
.Llo1502:
	se_cmp		r0,r3		# stdReturnVal=r3
	bc		0,1,.L2293	# le
#    {
#       ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11252
.Llo1499:
	diab.li		r3,20		# ErrorCode=r3
.Llo1491:
	b		.L2290
.L2293:
#    }
#    else
#    {
#       /*
#       * Move to next step.
#       * Changing to DCM_INITIAL just in case previous operation returned pending
#       */
#       pStatus->read_did_info.current_opstatus = DCM_INITIAL;
	.d2line		11260
.Llo1492:
	diab.li		r3,0		# stdReturnVal=r3
.Llo1493:
	stb		r3,22(r31)		# pStatus=r31 stdReturnVal=r3
#       pStatus->read_did_info.current_operation = READ_DID_BUFFER;
	.d2line		11261
	diab.li		r0,3
	stw		r0,24(r31)		# pStatus=r31
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
.L2290:
#    }
# 
#    return ErrorCode;
	.d2line		11265
.Llo1486:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		11266
	.d2epilogue_begin
.Llo1494:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4296:
	.type		ReadConfiguredDidRange_Length,@function
	.size		ReadConfiguredDidRange_Length,.-ReadConfiguredDidRange_Length
# Number of nodes = 93

# Allocations for ReadConfiguredDidRange_Length
#	?a4		didIdentifier
#	?a5		pStatus
#	?a6		ErrorCode
#	?a7		pDidRange
#	?a8		stdReturnVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDidRange_Buffer(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         11271,53
#$$ld
.L4309:

#$$bf	ReadConfiguredDidRange_Buffer,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDidRange_Buffer:
.Llo1503:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r4		# pStatus=r30 pStatus=r4
	.d2prologue_end
#                                                           CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
#    Std_ReturnType stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)(pStatus->read_did_info.current_size + 2U), &pStatus->read_did_info.current_res_buffer);
	.d2line		11275
	lhz		r3,20(r30)		# stdReturnVal=r3 pStatus=r30
.Llo1504:
	se_addi		r3,2		# stdReturnVal=r3 stdReturnVal=r3
	rlwinm		r3,r3,0,16,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo1511:
	se_addi		r4,28		# pStatus=r4 pStatus=r4
.Llo1507:
	bl		Dcm_DsdRequestResponseBuffer
.Llo1512:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
# 
#    if (E_OK == stdReturnVal)
	.d2line		11277
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L2300	# ne
#    {
#       /*
#       * Set the identifier and switch operation to start fetching data
#       */
#       SET_2BYTE_ID(&pStatus->read_did_info.current_res_buffer[0], didIdentifier);
	.d2line		11282
.Llo1505:
	rlwinm		r0,r31,24,24,31		# didIdentifier=r31
	lwz		r3,28(r30)		# stdReturnVal=r3 pStatus=r30
.Llo1513:
	stb		r0,0(r3)		# stdReturnVal=r3
	rlwinm		r0,r31,0,24,31		# didIdentifier=r31
	lwz		r3,28(r30)		# stdReturnVal=r3 pStatus=r30
	stb		r31,1(r3)		# stdReturnVal=r3 didIdentifier=r31
#       pStatus->read_did_info.current_operation = READ_DID_DATA;
	.d2line		11283
	diab.li		r0,4
	stw		r0,24(r30)		# pStatus=r30
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11284
	diab.li		r3,0		# ErrorCode=r3
.Llo1508:
	b		.L2302
.L2300:
#    }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#    else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#    {
#       /*
#       * Do nothing, it will continue to read data later.
#       */
#       ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#    }
#    else if (DCM_INT_E_RESPONSE_FULL == stdReturnVal)
#    {
#       /*
#       * The whole length of the originally calculated response length has been filled.
#       */
#       pStatus->sendPositiveResponse = TRUE;
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
#    }
# #endif
#    else
#    {
#       /*
#       * Dcm_DsdRequestResponseBuffer returned
#       *  DCM_INT_E_RESPONSE_TOO_LONG
#       *
#       * Abort, requested size can't possible fit in buffer.
#       */
#       ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11311
.Llo1509:
	diab.li		r3,20		# ErrorCode=r3
.L2302:
# 
#       /*
#       * Dcm_DsdRequestResponseBuffer returning
#       *  E_NOT_OK
#       * will never happen per design.
#       */
#    }
# 
#    return ErrorCode;
	.d2line		11320
.Llo1506:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		11321
	.d2epilogue_begin
.Llo1510:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4310:
	.type		ReadConfiguredDidRange_Buffer,@function
	.size		ReadConfiguredDidRange_Buffer,.-ReadConfiguredDidRange_Buffer
# Number of nodes = 60

# Allocations for ReadConfiguredDidRange_Buffer
#	?a4		didIdentifier
#	?a5		pStatus
#	?a6		ErrorCode
#	?a7		stdReturnVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDidRange_Data(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         11326,53
#$$ld
.L4320:

#$$bf	ReadConfiguredDidRange_Data,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDidRange_Data:
.Llo1514:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pStatus=r31 pStatus=r4
	.d2prologue_end
#                                                         CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
#    P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_DATA) pDidRange = &Dcm_LCfg.p_did_ranges[pStatus->currentDidIndex];
	.d2line		11330
.Llo1520:
	lis		r4,(Dcm_LCfg+88)@ha		# pDidRange=r4
.Llo1521:
	lwz		r4,(Dcm_LCfg+88)@l(r4)		# pDidRange=r4 pDidRange=r4
	lhz		r0,16(r31)		# pStatus=r31
	e_mulli		r0,r0,20
	se_add		r0,r4		# pDidRange=r4
	mr		r4,r0		# pDidRange=r4 pDidRange=r0
# 
#    /*
#    * Read the actual data.
#    */
#    Std_ReturnType stdReturnVal = pDidRange->p_did_range_read->ReadDidDataFunc(didIdentifier, &pStatus->read_did_info.current_res_buffer[2], pStatus->read_did_info.current_opstatus, &pStatus->read_did_info.current_size, &ErrorCode);
	.d2line		11335
.Llo1522:
	lwz		r4,12(r4)		# pDidRange=r4 pDidRange=r4
.Llo1523:
	lwz		r0,0(r4)		# pDidRange=r4
.Llo1524:
	mtspr		ctr,r0
	lwz		r4,28(r31)		# pDidRange=r4 pStatus=r31
.Llo1525:
	se_addi		r4,2		# pDidRange=r4 pDidRange=r4
.Llo1526:
	lbz		r5,22(r31)		# pStatus=r31
	rlwinm		r3,r3,0,16,31		# didIdentifier=r3 didIdentifier=r3
.Llo1515:
	diab.addi		r6,r31,20		# pStatus=r31
	diab.addi		r7,r1,8
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#    /*
#     * The Range APIs are always asynchronous, thus using DCM_E_PENDING.
#     */
#    HandleStdRetVal(stdReturnVal, DCM_E_PENDING, FALSE, &ErrorCode);
	.d2line		11340
.Llo1527:
	diab.addi		r6,r1,8
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	diab.li		r4,10		# pDidRange=r4
	diab.li		r5,0
	bl		HandleStdRetVal
# 
#    if (DCM_INT_NRC_API_RETURNED_PENDING == ErrorCode)
	.d2line		11342
.Llo1528:
	lbz		r0,8(r1)		# didIdentifier=r0
.Llo1516:
	cmpi		0,0,r0,162		# didIdentifier=r0
	bc		0,2,.L2306	# ne
#    {
#       /*
#        * Call the API with pending next time
#        */
#       pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		11347
.Llo1517:
	diab.li		r0,1		# didIdentifier=r0
.Llo1518:
	stb		r0,22(r31)		# pStatus=r31 didIdentifier=r0
.L2306:
#    }
# 
#    return ErrorCode;
	.d2line		11350
.Llo1519:
	lbz		r3,8(r1)		# didIdentifier=r3
# }
	.d2line		11351
	.d2epilogue_begin
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# didIdentifier=r0
	mtspr		lr,r0		# didIdentifier=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4321:
	.type		ReadConfiguredDidRange_Data,@function
	.size		ReadConfiguredDidRange_Data,.-ReadConfiguredDidRange_Data
# Number of nodes = 71

# Allocations for ReadConfiguredDidRange_Data
#	?a4		didIdentifier
#	?a5		pStatus
#	SP,8		ErrorCode
#	?a6		pDidRange
#	?a7		stdReturnVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadConfiguredDidRange(CONST(uint16, AUTOMATIC) didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         11120,53
#$$ld
.L4332:

#$$bf	ReadConfiguredDidRange,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadConfiguredDidRange:
.Llo1529:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# didIdentifier=r31 didIdentifier=r3
	mr		r30,r6		# pStatus=r30 pStatus=r6
	.d2prologue_end
#                                                                            Dcm_SesCtrlType activeSession,
#                                                                            Dcm_SecLevelType activeSecurityLevel,
#                                                                            CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11125
	diab.li		r3,0		# ErrorCode=r3
# 
#    if (READ_DID_INIT == pStatus->read_did_info.current_operation)
	.d2line		11127
.Llo1530:
	lwz		r0,24(r30)		# pStatus=r30
	se_cmpi		r0,0
	bc		0,2,.L2261	# ne
#    {
#       ErrorCode = ReadConfiguredDidRange_Init(didIdentifier, pStatus);
	.d2line		11129
.Llo1531:
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
.Llo1533:
	mr		r4,r30		# pStatus=r4 pStatus=r30
	bl		ReadConfiguredDidRange_Init
	mr		r3,r3		# ErrorCode=r3 ErrorCode=r3
.L2261:
#    }
# 
#    if (READ_DID_LENGTH == pStatus->read_did_info.current_operation)
	.d2line		11132
	lwz		r0,24(r30)		# pStatus=r30
	se_cmpi		r0,2
	bc		0,2,.L2262	# ne
#    {
#       ErrorCode = ReadConfiguredDidRange_Length(didIdentifier, pStatus);
	.d2line		11134
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pStatus=r4 pStatus=r30
	bl		ReadConfiguredDidRange_Length
	mr		r3,r3		# ErrorCode=r3 ErrorCode=r3
.L2262:
#    }
# 
#    /*
#    * Finally try to get the response buffer
#    */
#    if (READ_DID_BUFFER == pStatus->read_did_info.current_operation)
	.d2line		11140
	lwz		r0,24(r30)		# pStatus=r30
	se_cmpi		r0,3
	bc		0,2,.L2263	# ne
#    {
#       ErrorCode = ReadConfiguredDidRange_Buffer(didIdentifier, pStatus);
	.d2line		11142
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pStatus=r4 pStatus=r30
	bl		ReadConfiguredDidRange_Buffer
	mr		r3,r3		# ErrorCode=r3 ErrorCode=r3
.L2263:
#    }
# 
#    if (READ_DID_DATA == pStatus->read_did_info.current_operation)
	.d2line		11145
	lwz		r0,24(r30)		# pStatus=r30
	se_cmpi		r0,4
	bc		0,2,.L2264	# ne
#    {
#       ErrorCode = ReadConfiguredDidRange_Data(didIdentifier, pStatus);
	.d2line		11147
	mr		r3,r31		# didIdentifier=r3 didIdentifier=r31
	mr		r4,r30		# pStatus=r4 pStatus=r30
	bl		ReadConfiguredDidRange_Data
	mr		r3,r3		# ErrorCode=r3 ErrorCode=r3
.L2264:
#    }
# 
#    return ErrorCode;
	.d2line		11150
.Llo1532:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		11151
	.d2epilogue_begin
.Llo1534:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1535:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4333:
	.type		ReadConfiguredDidRange,@function
	.size		ReadConfiguredDidRange,.-ReadConfiguredDidRange
# Number of nodes = 65

# Allocations for ReadConfiguredDidRange
#	?a4		didIdentifier
#	not allocated	activeSession
#	not allocated	activeSecurityLevel
#	?a5		pStatus
#	?a6		ErrorCode
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadOBDDataAndInfoType(CONST(uint8, AUTOMATIC) sid,
	.align		1
	.section	.text_vle
        .d2line         11811,53
#$$ld
.L4341:

#$$bf	ReadOBDDataAndInfoType,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadOBDDataAndInfoType:
.Llo1536:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# sid=r31 sid=r3
	mr		r30,r4		# didIdentifier=r30 didIdentifier=r4
	mr		r0,r5		# readObdFunc=r0 readObdFunc=r5
	mr		r29,r6		# idSupport=r29 idSupport=r6
	mr		r5,r7		# pStatus=r5 pStatus=r7
.Llo1548:
	mr		r28,r8		# position=r28 position=r8
	mr		r7,r9		# sizeOfMemory=r7 sizeOfMemory=r9
	.d2prologue_end
#                                                                            CONST(uint16, AUTOMATIC) didIdentifier,
#                                                                            ReadObdFuncType readObdFunc,
#                                                                            CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_CONST) idSupport,
#                                                                            CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus,
#                                                                            uint8 position,
#                                                                            uint8 sizeOfMemory)
# {
#    CONST(uint8, DCM_CONST) obdId = DcmLoByte(didIdentifier);
	.d2line		11819
.Llo1551:
	rlwinm		r4,r4,0,24,31		# didIdentifier=r4 didIdentifier=r4
.Llo1546:
	mr		r4,r4		# obdId=r4 obdId=r4
#    CONST(uint8, DCM_CONST) bufPos = obdId / 0x20U;
	.d2line		11820
	rlwinm		r27,r4,27,29,31		# obdId=r4
.Llo1567:
	mr		r27,r27		# bufPos=r27 bufPos=r27
#    uint8 i;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  resBuffer;
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    /*
#     * UDS 0x22 does always request all (i.e. 6 ) supported info bytes.
#     * It's only when using 0x2C when it's possible to request a portion of the supported info
#     */
#    CONST(Dcm_MsgLenType, DCM_CONST) sizeOfSupportedInfo = (Dcm_MsgLenType)((SID_READ_DATA_BY_IDENTIFIER == sid) ? 6U : sizeOfMemory);
	.d2line		11829
	rlwinm		r3,r3,0,24,31		# sid=r3 sid=r3
	cmpi		0,0,r3,34		# sid=r3
	bc		0,2,.L2430	# ne
.Llo1537:
	diab.li		r26,6		# sizeOfSupportedInfo=r26
.Llo1538:
	b		.L2431
.L2430:
.Llo1569:
	rlwinm		r26,r7,0,24,31		# sizeOfMemory=r7
.Llo1570:
	mr		r26,r26		# sizeOfSupportedInfo=r26 sizeOfSupportedInfo=r26
.L2431:
# 
#    if ((uint8)0U != (uint8)(obdId % 0x20U))
	.d2line		11831
	rlwinm		r3,r4,0,27,31		# sid=r3 obdId=r4
	e_andi.		r3,r3,255		# sid=r3 sid=r3
	bc		1,2,.L2419	# eq
#    {
#       ErrorCode = readObdFunc(sid, obdId, pStatus, position, sizeOfMemory);
	.d2line		11833
.Llo1552:
	mtspr		ctr,r0		# readObdFunc=ctr readObdFunc=r0
.Llo1555:
	rlwinm		r3,r31,0,24,31		# sid=r3 sid=r31
.Llo1559:
	rlwinm		r4,r4,0,24,31		# obdId=r4 obdId=r4
.Llo1560:
	rlwinm		r6,r28,0,24,31		# position=r28
	rlwinm		r7,r7,0,24,31		# sizeOfMemory=r7 sizeOfMemory=r7
.Llo1553:
	mr		r5,r5		# pStatus=r5 pStatus=r5
.Llo1554:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo1539:
	mr		r3,r3		# ErrorCode=r3 ErrorCode=r3
	b		.L2420
.L2419:
#    }
#    else if (FALSE != IsObdRangeSupported(bufPos, idSupport))
	.d2line		11835
.Llo1540:
	mr		r3,r27		# bufPos=r3 bufPos=r27
	mr		r4,r29		# idSupport=r4 idSupport=r29
	bl		IsObdRangeSupported
	e_andi.		r3,r3,255		# sid=r3 sid=r3
	bc		1,2,.L2421	# eq
	.section	.text_vle
.L4366:
#    {
#       /*
#        * Try to get the response buffer.
#        */
#       Std_ReturnType stdReturnVal = Dcm_DsdRequestResponseBuffer(sizeOfSupportedInfo, &resBuffer);
	.d2line		11840
.Llo1556:
	rlwinm		r3,r26,0,16,31		# sid=r3 sizeOfSupportedInfo=r26
.Llo1557:
	diab.addi		r4,r1,8		# obdId=r4
	bl		Dcm_DsdRequestResponseBuffer
.Llo1558:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
# 
#       if (E_OK == stdReturnVal)
	.d2line		11842
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L2422	# ne
#       {
#          if (SID_READ_DATA_BY_IDENTIFIER == sid)
	.d2line		11844
.Llo1571:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	cmpi		0,0,r31,34		# sid=r31
	bc		0,2,.L2423	# ne
#          {
#             /*
#              * The DID shall only be set in case of service 0x22
#              */
#             SET_2BYTE_ID(&resBuffer[0], didIdentifier);
	.d2line		11849
.Llo1541:
	rlwinm		r4,r30,24,24,31		# obdId=r4 didIdentifier=r30
.Llo1561:
	lwz		r3,8(r1)		# stdReturnVal=r3
.Llo1572:
	stb		r4,0(r3)		# stdReturnVal=r3 obdId=r4
	rlwinm		r4,r30,0,24,31		# obdId=r4 didIdentifier=r30
.Llo1562:
	lwz		r3,8(r1)		# stdReturnVal=r3
	stb		r30,1(r3)		# stdReturnVal=r3 didIdentifier=r30
# 
#             /*
#              * Adjust for the DID identifier
#              */
#             resBuffer += 2;
	.d2line		11854
	lwz		r3,8(r1)		# stdReturnVal=r3
	se_addi		r3,2		# stdReturnVal=r3 stdReturnVal=r3
	stw		r3,8(r1)		# stdReturnVal=r3
.L2423:
#          }
# 
#          /*
#           * Copy the supported information
#           */
#          for (i = 0; i < sizeOfSupportedInfo; i++)
	.d2line		11860
.Llo1573:
	diab.li		r3,0		# i=r3
.L2425:
.Llo1547:
	rlwinm		r0,r3,0,24,31		# i=r3
	rlwinm		r4,r26,0,16,31		# obdId=r4 sizeOfSupportedInfo=r26
.Llo1563:
	se_cmp		r0,r4		# obdId=r4
	bc		0,0,.L2427	# ge
#          {
#             resBuffer[i] = idSupport[(bufPos * 4U) + position + i];
	.d2line		11862
.Llo1564:
	rlwinm		r6,r27,2,22,29		# bufPos=r27
	se_add		r6,r29		# idSupport=r29
	rlwinm		r4,r28,0,24,31		# obdId=r4 position=r28
.Llo1565:
	se_add		r4,r6		# obdId=r4 obdId=r4
	rlwinm		r0,r3,0,24,31		# i=r3
	lbzux		r5,r4,r0		# obdId=r4
	lwz		r4,8(r1)		# obdId=r4
	stbx		r5,r4,r0		# obdId=r4
#          }
	.d2line		11863
	diab.addi		r0,r3,1		# i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L2425
.L2427:
# 
#          ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11865
.Llo1566:
	diab.li		r3,0		# ErrorCode=r3
.Llo1568:
	b		.L2420
.L2422:
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#       {
#          /*
#           * Do nothing, it will continue to read data later.
#           */
#          ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#       }
#       else if ((DCM_INT_E_RESPONSE_FULL == stdReturnVal) ||
#                (E_NOT_OK == stdReturnVal))
#       {
#          /*
#           * DCM_INT_E_RESPONSE_FULL shall never happen since InfoTypes always have a fixed length.
#           * Therefore will the requested size in the beginning never be exceeded.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned:
#           *  DCM_INT_E_RESPONSE_TOO_LONG
#           *
#           * Abort, requested size can't possible fit in buffer.
#           */
#          ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11893
.Llo1542:
	diab.li		r3,20		# ErrorCode=r3
	.section	.text_vle
.L4367:
.Llo1543:
	b		.L2420
.L2421:
#       }
#    }
#    else
#    {
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11898
.Llo1544:
	diab.li		r3,160		# ErrorCode=r3
.L2420:
#    }
# 
#    return ErrorCode;
	.d2line		11901
.Llo1545:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		11902
	.d2epilogue_begin
.Llo1549:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1550:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4342:
	.type		ReadOBDDataAndInfoType,@function
	.size		ReadOBDDataAndInfoType,.-ReadOBDDataAndInfoType
# Number of nodes = 146

# Allocations for ReadOBDDataAndInfoType
#	?a4		sid
#	?a5		didIdentifier
#	?a6		readObdFunc
#	?a7		idSupport
#	?a8		pStatus
#	?a9		position
#	?a10		sizeOfMemory
#	?a11		obdId
#	?a12		bufPos
#	?a13		i
#	SP,8		resBuffer
#	?a14		ErrorCode
#	?a15		sizeOfSupportedInfo
#	?a16		stdReturnVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadDynamicallyDefinedDid(uint16 didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         11356,53
#$$ld
.L4374:

#$$bf	ReadDynamicallyDefinedDid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadDynamicallyDefinedDid:
.Llo1574:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
	stmw		r26,40(r1)		# offset r1+40  0x28
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,68(r1)
	.d2_cfa_offset    108,-1
	mr		r28,r3		# didIdentifier=r28 didIdentifier=r3
	mr		r31,r4		# activeSession=r31 activeSession=r4
	mr		r30,r5		# activeSecurityLevel=r30 activeSecurityLevel=r5
	mr		r29,r6		# pStatus=r29 pStatus=r6
	.d2prologue_end
#                                                       Dcm_SesCtrlType activeSession,
#                                                       Dcm_SecLevelType activeSecurityLevel,
#                                                       CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    uint16         confDidCounter;
#    uint8          i;
#    Std_ReturnType stdReturnVal = E_OK;
	.d2line		11363
	diab.li		r26,0		# stdReturnVal=r26
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
	.d2line		11364
	diab.li		r3,0
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pBuf;
#    uint16 didSize;
# 
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11368
.Llo1575:
	stb		r3,12(r1)
# 
#    if (READ_DID_INIT == pStatus->currentDDDidOperation)
	.d2line		11370
	lwz		r0,12(r29)		# pStatus=r29
	se_cmpi		r0,0
	bc		0,2,.L2309	# ne
#    {
#       /*
#        * Try to find a matching DDDID in the configuration
#        */
#       pDid = NULL_PTR;
	.d2line		11375
.Llo1576:
	diab.li		r5,0		# pDid=r5
#       for (confDidCounter = 0; confDidCounter < Dcm_LCfg.num_periodic_dynamic_dids; confDidCounter++)
	.d2line		11376
.Llo1578:
	diab.li		r3,0
.L2310:
.Llo1584:
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+72)@ha
	lhz		r4,(Dcm_LCfg+72)@l(r4)
	se_cmp		r0,r4
	bc		0,0,.L2314	# ge
#       {
#          if (Dcm_LCfg.periodicDynamicDids[confDidCounter].identifier == didIdentifier)
	.d2line		11378
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+76)@ha
	lwz		r4,(Dcm_LCfg+76)@l(r4)
	rlwinm		r6,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r6
	lhzx		r0,r4,r0
	rlwinm		r4,r28,0,16,31		# didIdentifier=r28
	se_cmp		r0,r4
	bc		0,2,.L2313	# ne
#          {
#             pDid = &Dcm_LCfg.periodicDynamicDids[confDidCounter];
	.d2line		11380
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+76)@ha
	lwz		r5,(Dcm_LCfg+76)@l(r4)		# pDid=r5
	rlwinm		r4,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r4
	se_add		r0,r5		# pDid=r5
	mr		r5,r0		# pDid=r5 pDid=r0
#             pStatus->currentDidIndex = confDidCounter;
	.d2line		11381
	sth		r3,16(r29)		# pStatus=r29 confDidCounter=r3
	b		.L2314
.L2313:
#             break;
#          }
#       }
	.d2line		11384
	diab.addi		r0,r3,1		# confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L2310
.L2314:
# 
#       /*
#        * 1. Was the DDDID found amongst the configured ones?
#        * It shall always be found since only valid identifiers will be used.
#        * But to be sure, and avoid SCA warnings, do a check that never will be possible to test.
#        */
#       if (NULL_PTR == pDid)
	.d2line		11391
	se_cmpi		r5,0		# pDid=r5
	bc		0,2,.L2315	# ne
#       {
#          /*
#           * The requested DID was not found. Report an error and break.
#           */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11396
.Llo1585:
	diab.li		r0,160
	stb		r0,12(r1)
	b		.L2309
.L2315:
#       }
#       /*
#        * 2. Is the DDDID defined?
#        * GetDddidLength has already validated so the DDDID has source(s).
#        */
#       else
#       {
#          /*
#           * Move to next step.
#           */
#          pStatus->currentDDDidOperation = READ_DID_BUFFER;
	.d2line		11407
	diab.li		r0,3
	stw		r0,12(r29)		# pStatus=r29
.L2309:
#       }
#    }
# 
#    if (READ_DID_BUFFER == pStatus->currentDDDidOperation)
	.d2line		11411
	lwz		r0,12(r29)		# pStatus=r29
	se_cmpi		r0,3
	bc		0,2,.L2317	# ne
#    {
#       /*
#        * Finally try to get the response buffer
#        */
#       stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)2U, &pBuf);
	.d2line		11416
	diab.addi		r4,r1,16
	diab.li		r3,2		# confDidCounter=r3
	bl		Dcm_DsdRequestResponseBuffer
	mr		r26,r3		# stdReturnVal=r26 stdReturnVal=r3
#       if (E_OK == stdReturnVal)
	.d2line		11417
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L2318	# ne
#       {
#          /*
#           * Fill the two bytes Did identifier in the response buffer.
#           */
#          SET_2BYTE_ID(pBuf, didIdentifier);
	.d2line		11422
	rlwinm		r4,r28,24,24,31		# didIdentifier=r28
	lwz		r3,16(r1)		# stdReturnVal=r3
	stb		r4,0(r3)		# stdReturnVal=r3
	rlwinm		r3,r28,0,24,31		# stdReturnVal=r3 didIdentifier=r28
	lwz		r3,16(r1)		# stdReturnVal=r3
	stb		r28,1(r3)		# stdReturnVal=r3 didIdentifier=r28
# 
#          /*
#           * Buffer allocated; move to next step
#           */
#          pStatus->currentDDDidOperation = READ_DID_DATA;
	.d2line		11427
	diab.li		r0,4
	stw		r0,12(r29)		# pStatus=r29
	b		.L2317
.L2318:
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#       {
#          /*
#           * Do nothing, it will continue to read data later.
#           */
#          ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#       }
#       else if (DCM_INT_E_RESPONSE_FULL == stdReturnVal)
#       {
#          /*
#           * The whole length of the originally calculated response length has been filled.
#           */
#          pStatus->sendPositiveResponse = TRUE;
#       }
#       else if (E_NOT_OK == stdReturnVal)
#       {
#          /*
#           * Abort, make sense to retrieve the data.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned
#           *  DCM_INT_E_RESPONSE_TOO_LONG
#           *
#           * Abort, requested size can't possible fit in buffer.
#           */
#          ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11460
	diab.li		r0,20
	stb		r0,12(r1)
.L2317:
#       }
#    }
# 
#    if (READ_DID_DATA == pStatus->currentDDDidOperation)
	.d2line		11464
	lwz		r0,12(r29)		# pStatus=r29
	se_cmpi		r0,4
	bc		0,2,.L2321	# ne
#    {
#       pDid = &Dcm_LCfg.periodicDynamicDids[pStatus->currentDidIndex];
	.d2line		11466
.Llo1577:
	lhz		r0,16(r29)		# pStatus=r29
	lis		r3,(Dcm_LCfg+76)@ha		# confDidCounter=r3
.Llo1586:
	lwz		r27,(Dcm_LCfg+76)@l(r3)		# confDidCounter=r3
	rlwinm		r3,r0,5,0,26		# confDidCounter=r3
	se_slwi		r0,3
	subf		r0,r0,r3		# confDidCounter=r3
	se_add		r0,r27
.Llo1619:
	mr		r27,r0		# pDid=r27 pDid=r0
# 
#       /*
#        * Loop all data sources of the dynamically defined DiD.
#        */
#       for (i = pStatus->current_source_did_index; (i < *pDid->pNumberOfDefinedSources) && (E_OK == stdReturnVal); i++)
	.d2line		11471
	lbz		r28,8(r29)		# didIdentifier=r28 pStatus=r29
.Llo1618:
	mr		r28,r28		# i=r28 i=r28
.L2322:
.Llo1587:
	rlwinm		r0,r28,0,24,31		# i=r28
.Llo1620:
	lwz		r3,16(r27)		# confDidCounter=r3 pDid=r27
.Llo1588:
	lbz		r3,0(r3)		# confDidCounter=r3 confDidCounter=r3
	se_cmp		r0,r3		# confDidCounter=r3
	bc		0,0,.L2324	# ge
.Llo1589:
	rlwinm		r3,r26,0,24,31		# confDidCounter=r3 stdReturnVal=r26
.Llo1590:
	se_cmpi		r3,0		# confDidCounter=r3
	bc		0,2,.L2324	# ne
#       {
#          /*
#           * Different data types have different read function
#           */
#          if ((DCM_DD_DID == pDid->pDataSourcesRead[i].record_type) || (DCM_COMP_DID == pDid->pDataSourcesRead[i].record_type))
	.d2line		11476
.Llo1591:
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1592:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	lwzx		r0,r3,r0		# confDidCounter=r3
	se_cmpi		r0,0
	bc		1,2,.L2340	# eq
.Llo1593:
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1594:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	lwzx		r0,r3,r0		# confDidCounter=r3
	se_cmpi		r0,4
	bc		0,2,.L2325	# ne
.L2340:
#          {
#             /*
#              * If stdReturnVal is not OK, the loop will break; sample buffer will be marked as not ready.
#              * pErrorCode will not be checked. However it will be used in UDS service 0x22 to read a dynamically defined Did.
#              */
#             stdReturnVal = ReadOneDDDidByDid(&pDid->pDataSourcesRead[i],
	.d2line		11482
.Llo1595:
	diab.addi		r0,r1,12
	stw		r0,8(r1)
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1596:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	lwzux		r7,r3,r0		# pStatus=r7 confDidCounter=r3
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
	se_add		r3,r0		# confDidCounter=r3 confDidCounter=r3
.Llo1597:
	diab.addi		r8,r29,20		# pStatus=r29
	diab.addi		r10,r1,14
	mr		r6,r30		# activeSecurityLevel=r6 activeSecurityLevel=r30
	mr		r5,r31		# activeSession=r5 activeSession=r31
	diab.li		r4,65535
	diab.li		r9,0
	bl		ReadOneDDDidByDid
	mr		r26,r3		# stdReturnVal=r26 stdReturnVal=r3
	b		.L2326
.L2325:
#                                              0xFFFFU,
#                                              activeSession,
#                                              activeSecurityLevel,
#                                              pDid->pDataSourcesRead[i].record_type,
#                                              &pStatus->read_did_info,
#                                              FALSE, /* The buffer will be allocated by the function itself */
#                                              &didSize,
#                                              &ErrorCode);
#          }
#          else if (DCM_DD_MEMORY == pDid->pDataSourcesRead[i].record_type)
	.d2line		11492
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1598:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	lwzx		r0,r3,r0		# confDidCounter=r3
	se_cmpi		r0,3
	bc		0,2,.L2327	# ne
#          {
#             /*
#              * If stdReturnVal is not OK, the loop will break; sample buffer will be marked as not ready.
#              * pErrorCode will not be checked. However it will be used in UDS service 0x22 to read a dynamically defined Did.
#              */
#             stdReturnVal = ReadOneDDDidByMemory(&pDid->pDataSourcesRead[i], NULL_PTR, &ErrorCode);
	.d2line		11498
.Llo1599:
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1600:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	se_add		r3,r0		# confDidCounter=r3 confDidCounter=r3
.Llo1601:
	diab.addi		r5,r1,12		# pDid=r5
	diab.li		r4,0
	bl		ReadOneDDDidByMemory
	mr		r26,r3		# stdReturnVal=r26 stdReturnVal=r3
	b		.L2326
.L2327:
#          }
#          else if (DCM_DD_PID == pDid->pDataSourcesRead[i].record_type)
	.d2line		11500
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1602:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	lwzx		r0,r3,r0		# confDidCounter=r3
	se_cmpi		r0,1
	bc		0,2,.L2329	# ne
#          {
#             /* recordType is enumeration type. Currently we don't support dynamically define Did by Pid yet.
#              * recordType: DCM_DD_PID will be supported later.
#              */
#             ErrorCode = ReadOBDDataAndInfoType(SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER,
	.d2line		11505
.Llo1603:
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1604:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	se_add		r3,r0		# confDidCounter=r3 confDidCounter=r3
	lhz		r4,8(r3)		# confDidCounter=r3
	lwz		r8,8(r3)		# confDidCounter=r3
	lwz		r9,12(r3)		# confDidCounter=r3
	lis		r3,Dcm_pPbCfg@ha		# confDidCounter=r3
	lwz		r3,Dcm_pPbCfg@l(r3)		# confDidCounter=r3 confDidCounter=r3
	lwz		r6,24(r3)		# confDidCounter=r3
	lis		r5,ReadCommonPid@ha		# pDid=r5
	e_add16i		r5,r5,ReadCommonPid@l		# pDid=r5 pDid=r5
	diab.li		r3,44		# confDidCounter=r3
.Llo1605:
	mr		r7,r29		# pStatus=r7 pStatus=r29
	bl		ReadOBDDataAndInfoType
.Llo1606:
	stb		r3,12(r1)		# confDidCounter=r3
	b		.L2326
.L2329:
#                                                DcmHiWord(pDid->pDataSourcesRead[i].address),
#                                                &ReadCommonPid,
#                                                Dcm_pPbCfg->p_pids_support_01,
#                                                pStatus,
#                                                (uint8) pDid->pDataSourcesRead[i].address,
#                                                (uint8) pDid->pDataSourcesRead[i].size);
#          }
#          else
#          {
#             /* DCM_DD_VEH_INFO */
#             ErrorCode = ReadOBDDataAndInfoType(SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER,
	.d2line		11516
.Llo1607:
	lwz		r3,8(r27)		# confDidCounter=r3 pDid=r27
.Llo1608:
	rlwinm		r0,r28,0,24,31		# i=r28
	e_mulli		r0,r0,20
	se_add		r3,r0		# confDidCounter=r3 confDidCounter=r3
	lhz		r4,8(r3)		# confDidCounter=r3
	lwz		r8,8(r3)		# confDidCounter=r3
	lwz		r9,12(r3)		# confDidCounter=r3
	lis		r3,Dcm_pPbCfg@ha		# confDidCounter=r3
	lwz		r3,Dcm_pPbCfg@l(r3)		# confDidCounter=r3 confDidCounter=r3
	lwz		r6,36(r3)		# confDidCounter=r3
	lis		r5,ReadCommonOBDInfoTypeIdentifier@ha		# pDid=r5
	e_add16i		r5,r5,ReadCommonOBDInfoTypeIdentifier@l		# pDid=r5 pDid=r5
	diab.li		r3,44		# confDidCounter=r3
.Llo1609:
	mr		r7,r29		# pStatus=r7 pStatus=r29
	bl		ReadOBDDataAndInfoType
.Llo1610:
	stb		r3,12(r1)		# confDidCounter=r3
.L2326:
#                                                DcmHiWord(pDid->pDataSourcesRead[i].address),
#                                                &ReadCommonOBDInfoTypeIdentifier,
#                                                Dcm_pPbCfg->p_vehicle_info_type_support,
#                                                pStatus,
#                                                (uint8) pDid->pDataSourcesRead[i].address,
#                                                (uint8) pDid->pDataSourcesRead[i].size);
#          }
# 
#          if (DCM_INT_E_RESPONSE_TOO_LONG == stdReturnVal)
	.d2line		11525
.Llo1611:
	rlwinm		r3,r26,0,24,31		# confDidCounter=r3 stdReturnVal=r26
.Llo1612:
	cmpi		0,0,r3,200		# confDidCounter=r3
	bc		0,2,.L2331	# ne
#          {
#             /*
#              * Abort, requested size can't possible fit in buffer.
#              */
#             ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		11530
.Llo1613:
	diab.li		r0,20
	stb		r0,12(r1)
	b		.L2332
.L2331:
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#          {
#             /*
#              * Do nothing, it will continue to read data later.
#              */
#             pStatus->current_source_did_index = i;
#             ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#          }
#          else if (DCM_INT_E_RESPONSE_FULL == stdReturnVal)
#          {
#             /*
#              * The whole length of the originally calculated response length has been filled.
#              */
#             pStatus->sendPositiveResponse = TRUE;
#          }
# #endif
#          else if (E_OK == stdReturnVal)
	.d2line		11549
	rlwinm		r3,r26,0,24,31		# confDidCounter=r3 stdReturnVal=r26
.Llo1614:
	se_cmpi		r3,0		# confDidCounter=r3
	bc		1,2,.L2332	# eq
#          {
#             /*
#              * DID successfully read
#              */
#          }
#          else if (DCM_E_PENDING == stdReturnVal)
	.d2line		11555
.Llo1615:
	rlwinm		r3,r26,0,24,31		# confDidCounter=r3 stdReturnVal=r26
.Llo1616:
	se_cmpi		r3,10		# confDidCounter=r3
	bc		0,2,.L2335	# ne
#          {
#             /*
#              * Do nothing, it will continue to read data later.
#              */
#             pStatus->current_source_did_index = i;
	.d2line		11560
.Llo1617:
	stb		r28,8(r29)		# pStatus=r29 i=r28
#             ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		11561
	diab.li		r0,162
	stb		r0,12(r1)
	b		.L2332
.L2335:
#          }
#          else if (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode)
	.d2line		11563
	lbz		r0,12(r1)
	se_cmpi		r0,0
	bc		0,2,.L2332	# ne
#          {
#             /*
#              * The application did not accept the read request but did not set an error.
#              */
#             ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		11568
	diab.li		r0,34
	stb		r0,12(r1)
.L2332:
#          }
#          else
#          {
#             /*
#              * The application did not accept the read request. Return an error.
#              * pErrorCode is already set by the application.
#              */
#          }
#       }
	.d2line		11577
	diab.addi		r0,r28,1		# i=r28
	se_addi		r28,1		# i=r28 i=r28
	b		.L2322
.L2324:
# 
#       if (DCM_INT_NRC_API_RETURNED_PENDING != ErrorCode)
	.d2line		11579
	lbz		r0,12(r1)
	cmpi		0,0,r0,162
	bc		1,2,.L2321	# eq
#       {
#          /*
#           * Read of dynamically defined DID has finished. Reset operation state for next dynamically defined DID.
#           */
#          pStatus->currentDDDidOperation = READ_DID_INIT;
	.d2line		11584
.Llo1579:
	diab.li		r0,0
.Llo1580:
	stw		r0,12(r29)		# pStatus=r29
.L2321:
#       }
#    }
# 
#    return ErrorCode;
	.d2line		11588
.Llo1582:
	lbz		r3,12(r1)		# confDidCounter=r3
# }
	.d2line		11589
	.d2epilogue_begin
.Llo1583:
	lmw		r26,40(r1)		# offset r1+40  0x28
	.d2_cfa_restore_list	2,10
	lwz		r0,68(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1581:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4375:
	.type		ReadDynamicallyDefinedDid,@function
	.size		ReadDynamicallyDefinedDid,.-ReadDynamicallyDefinedDid
# Number of nodes = 461

# Allocations for ReadDynamicallyDefinedDid
#	?a4		didIdentifier
#	?a5		activeSession
#	?a6		activeSecurityLevel
#	?a7		pStatus
#	?a8		$$97
#	?a9		$$96
#	?a10		$$95
#	?a11		confDidCounter
#	?a12		i
#	?a13		stdReturnVal
#	?a14		pDid
#	SP,16		pBuf
#	SP,14		didSize
#	SP,12		ErrorCode
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ReadDataByIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         4057,32
#$$ld
.L4394:

#$$bf	Dcm_ReadDataByIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_ReadDataByIdentifier
	.d2_cfa_start __cie
Dcm_ReadDataByIdentifier:
.Llo1621:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
# 
#    /*
#     * Storage for Did/data sources status information in case of paging
#     */
#    CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.read_did_status;
# 
#    /*
#     * Do some initiation:
#     * - Get the current session
#     * - Get the current security level
#     */
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * [SWS_Dcm_00339] : E_OK shall always be returned.
#     * [SWS_Dcm_00338] : E_OK shall always be returned.
#     */
#    (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		4079
	diab.addi		r3,r1,8
	bl		Dcm_GetSesCtrlType
#    (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		4080
.Llo1622:
	diab.addi		r3,r1,9
	bl		Dcm_GetSecurityLevel
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		4082
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L891	# ne
	.d2line		4065
.Llo1623:
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+176)@ha
	stb		r0,(Dcm_DspInstance+176)@l(r3)
	lis		r3,(Dcm_DspInstance+182)@ha
	sth		r0,(Dcm_DspInstance+182)@l(r3)
	lis		r3,(Dcm_DspInstance+178)@ha
	sth		r0,(Dcm_DspInstance+178)@l(r3)
	lis		r3,(Dcm_DspInstance+198)@ha
	stb		r0,(Dcm_DspInstance+198)@l(r3)
	lis		r3,(Dcm_DspInstance+200)@ha
	stw		r0,(Dcm_DspInstance+200)@l(r3)
	lis		r3,(Dcm_DspInstance+188)@ha
	stw		r0,(Dcm_DspInstance+188)@l(r3)
	lis		r3,(Dcm_DspInstance+184)@ha
	stb		r0,(Dcm_DspInstance+184)@l(r3)
	lhz		r4,4(r31)		# pMsgContext=r31
	rlwinm		r4,r4,31,17,31
	lis		r3,(Dcm_DspInstance+180)@ha
	sth		r4,(Dcm_DspInstance+180)@l(r3)
	lis		r3,(Dcm_DspInstance+186)@ha
	sth		r0,(Dcm_DspInstance+186)@l(r3)
#    {
#       pStatus->sendPositiveResponse = FALSE;
#       pStatus->current_did_index = (uint16)0U;
#       pStatus->num_valid_requested_dids = (uint16)0U;
#       pStatus->read_did_info.current_opstatus = DCM_INITIAL;
#       pStatus->read_did_info.current_operation = READ_DID_INIT;
#       pStatus->currentDDDidOperation = READ_DID_INIT;
#       pStatus->current_source_did_index = (uint8)0U;
#       pStatus->num_requested_dids = (uint16)(pMsgContext->reqDataLen / (Dcm_MsgLenType)2U); /* Each DID is two bytes, might be incorrect but handled below */
#       pStatus->total_answer_size = (Dcm_MsgLenType)0U;
# 
#       if ((0U == pMsgContext->reqDataLen) || (0U != (pMsgContext->reqDataLen % 2U)))
	.d2line		4094
	lhz		r0,4(r31)		# pMsgContext=r31
	e_cmphl16i	r0,0
	bc		1,2,.L927	# eq
	lhz		r0,4(r31)		# pMsgContext=r31
	se_btsti		r0,31
	bc		1,2,.L892	# eq
.L927:
#       {
#          /*
#           * Reject request since invalid length (missing DIDs) or format (not even number of bytes)
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4099
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L891
.L892:
	.d2line		4065
	lis		r3,(Dcm_DspInstance+180)@ha
	lhz		r0,(Dcm_DspInstance+180)@l(r3)
	lis		r3,(Dcm_LCfg+56)@ha
	lhz		r3,(Dcm_LCfg+56)@l(r3)
	se_cmp		r0,r3
	bc		0,1,.L894	# le
#       }
#       else if (pStatus->num_requested_dids > Dcm_LCfg.max_did_to_read)
#       {
#          /*
#           * [ECUC_Dcm_00638]
#           * Reject request since more received DIDs than configured or none received DIDs.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4107
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L891
.L894:
#       }
#       else
#       {
#          /*
#           * Time to fetch the complete positive response size
#           */
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_SIZE_PENDING;
	.d2line		4114
	diab.li		r0,10
	lis		r3,(Dcm_DspInstance+8)@ha
	stw		r0,(Dcm_DspInstance+8)@l(r3)
.L891:
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_SIZE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		4118
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,10
	bc		0,2,.L896	# ne
.L897:
	.d2line		4065
	lis		r3,(Dcm_DspInstance+182)@ha
	lhz		r0,(Dcm_DspInstance+182)@l(r3)
	lis		r3,(Dcm_DspInstance+180)@ha
	lhz		r3,(Dcm_DspInstance+180)@l(r3)
	se_cmp		r0,r3
	bc		0,0,.L899	# ge
#    {
#       /*
#        * Count the total length of response
#        */
#       for (; (pStatus->current_did_index < pStatus->num_requested_dids)
	.d2line		4123
	lbz		r0,0(r30)		# pErrorCode=r30
	se_cmpi		r0,0
	bc		1,2,.L928	# eq
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,160
	bc		1,2,.L928	# eq
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,161
	bc		0,2,.L899	# ne
.L928:
	.section	.text_vle
.L4401:
#                               && ((DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode) ||
#                               (DCM_INT_NRC_ID_NOT_SUPPORTED == *pErrorCode) ||
#                               (DCM_INT_NRC_ID_NOT_SUPPORTED_IN_SESSION == *pErrorCode));
#                               pStatus->current_did_index++)
#       {
#          CONST(uint16, AUTOMATIC) didIdentifier = GET_2BYTE_ID(&pMsgContext->reqData[2U * pStatus->current_did_index]);
	.d2line		4129
	lwz		r3,0(r31)		# pMsgContext=r31
	lis		r4,(Dcm_DspInstance+182)@ha
	lhz		r4,(Dcm_DspInstance+182)@l(r4)
	rlwinm		r4,r4,1,15,30
	lbzux		r0,r3,r4
	se_slwi		r0,8
	lwz		r3,0(r31)		# pMsgContext=r31
	se_add		r4,r3
	lbz		r3,1(r4)
	or		r0,r0,r3
.Llo1628:
	mr		r3,r0		# didIdentifier=r3 didIdentifier=r0
	.d2line		4065
	lis		r4,(Dcm_DspInstance+198)@ha
	lbz		r8,(Dcm_DspInstance+198)@l(r4)
	lis		r4,(Dcm_DspInstance+178)@ha
	e_add16i		r4,r4,(Dcm_DspInstance+178)@l
	lbz		r5,8(r1)
	lbz		r6,9(r1)
	mr		r3,r3		# didIdentifier=r3 didIdentifier=r3
	mr		r7,r30		# pErrorCode=r7 pErrorCode=r30
	bl		GetCommonDidLength
.Llo1629:
	lis		r4,(Dcm_DspInstance+186)@ha
	lhz		r0,(Dcm_DspInstance+186)@l(r4)
	se_add		r3,r0
	sth		r3,(Dcm_DspInstance+186)@l(r4)
# 
#          /* 
#           * GetCommonDidLength will return zero in case of error or pending.
#           */
#          pStatus->total_answer_size += GetCommonDidLength(didIdentifier, &(pStatus->num_valid_requested_dids), activeSession, activeSecurityLevel, pErrorCode, pStatus->read_did_info.current_opstatus);
# 
#          if (DCM_INT_NRC_API_RETURNED_PENDING != *pErrorCode)
	.d2line		4136
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,162
	bc		1,2,.L900	# eq
	.d2line		4065
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+198)@ha
	stb		r0,(Dcm_DspInstance+198)@l(r3)
.L900:
	.section	.text_vle
.L4402:
	lis		r4,(Dcm_DspInstance+182)@ha
	lhz		r3,(Dcm_DspInstance+182)@l(r4)
	se_addi		r3,1
	sth		r3,(Dcm_DspInstance+182)@l(r4)
	b		.L897
.L899:
#          {
#             /*
#              * Re-initialise the current opStatus in case of OK or error.
#              * It might have been DCM_PENDING in previous call.
#              */
#             pStatus->read_did_info.current_opstatus = DCM_INITIAL;
#          }
#       }
# 
#       if (DCM_INT_NRC_API_RETURNED_PENDING == *pErrorCode)
	.d2line		4146
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,162
	bc		0,2,.L901	# ne
	.d2line		4065
.Llo1624:
	lis		r3,(Dcm_DspInstance+182)@ha
	lhz		r0,(Dcm_DspInstance+182)@l(r3)
	diab.li		r4,65535
	se_add		r0,r4
	sth		r0,(Dcm_DspInstance+182)@l(r3)
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+198)@ha
	stb		r0,(Dcm_DspInstance+198)@l(r3)
	b		.L896
.L901:
#       {
#          /* 
#           * Since some API call returned pending,
#           * calls will continue later. Store the current DID.
#           *
#           * The next API call shall be used with PENDING.
#           */
#          pStatus->current_did_index--;
#          pStatus->read_did_info.current_opstatus = DCM_PENDING;
#       }
#       else if ((DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode) &&
	.d2line		4157
	lbz		r0,0(r30)		# pErrorCode=r30
	se_cmpi		r0,0
	bc		1,2,.L903	# eq
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,160
	bc		1,2,.L903	# eq
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,161
	bc		0,2,.L896	# ne
.L903:
#          (DCM_INT_NRC_ID_NOT_SUPPORTED != *pErrorCode) &&
#          (DCM_INT_NRC_ID_NOT_SUPPORTED_IN_SESSION != *pErrorCode))
#       {
#          /*
#           * Abort, failure will be handled below
#           * A negative response shall be sent.
#           */
#       }
#       else if (0 == pStatus->total_answer_size)
	.d2line		4166
	lis		r3,(Dcm_DspInstance+186)@ha
	lhz		r0,(Dcm_DspInstance+186)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L905	# ne
#       {
#          /*
#           * [SWS_Dcm_00438], [SWS_Dcm_00651], [SWS_Dcm_00561], [SWS_Dcm_00433] and [SWS_Dcm_00434]
#           * If a Did is not valid because it is not configured, not supported, not having read access or not in
#           * the right session or not defined (in case of dynamic DID), DCM_E_REQUESTOUTOFRANGE will be returned.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4173
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L896
.L905:
#       }
#       else if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse(pStatus->total_answer_size))
	.d2line		4175
	lis		r3,(Dcm_DspInstance+186)@ha
	lhz		r3,(Dcm_DspInstance+186)@l(r3)
	bl		Dcm_DsdStartResponse
	rlwinm		r3,r3,0,24,31
	cmpi		0,0,r3,200
	bc		0,2,.L907	# ne
#       {
#          *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		4177
	diab.li		r0,20
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L896
.L907:
	.d2line		4065
	diab.li		r4,0
	lis		r3,(Dcm_DspInstance+182)@ha
	sth		r4,(Dcm_DspInstance+182)@l(r3)
#       }
#       else
#       {
#          pStatus->current_did_index = (uint16)0U; /* The DID loop shall restart when fetching data. */
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		4182
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+8)@ha
	stw		r0,(Dcm_DspInstance+8)@l(r3)
#          *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		4183
	stb		r4,0(r30)		# pErrorCode=r30
.L896:
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		4187
.Llo1625:
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,1
	bc		0,2,.L909	# ne
.L910:
	.d2line		4065
.Llo1626:
	lis		r3,(Dcm_DspInstance+182)@ha		# pDidInfo=r3
.Llo1630:
	lhz		r0,(Dcm_DspInstance+182)@l(r3)		# pDidInfo=r3
	lis		r3,(Dcm_DspInstance+178)@ha		# pDidInfo=r3
	lhz		r3,(Dcm_DspInstance+178)@l(r3)		# pDidInfo=r3 pDidInfo=r3
	se_cmp		r0,r3		# pDidInfo=r3
	bc		0,0,.L912	# ge
#    {
#       /*
#        * Only process the service if it was possible to copy the DID identifiers.
#        * An error will be handled in the end.
#        * Loop through all requested DIDs.
#        */
#       for (; (pStatus->current_did_index < pStatus->num_valid_requested_dids)  /* Are all requested Dids read? */
	.d2line		4194
.Llo1631:
	lbz		r0,0(r30)		# pErrorCode=r30
	se_cmpi		r0,0
	bc		0,2,.L912	# ne
	lis		r3,(Dcm_DspInstance+176)@ha		# pDidInfo=r3
.Llo1632:
	lbz		r0,(Dcm_DspInstance+176)@l(r3)		# pDidInfo=r3
	se_cmpi		r0,0
	bc		0,2,.L912	# ne
	.section	.text_vle
.L4407:
#                               && (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
#                               && (FALSE == pStatus->sendPositiveResponse);  /* Is the response buffer full? */
#                               pStatus->current_did_index++)
#       {
#          /*
#           * [SWS_Dcm_00438], [SWS_Dcm_00651], [SWS_Dcm_00561] and [SWS_Dcm_00434]
#           * If a Did is not valid because it is not configured, or not supported, or not in
#           * the right session or not defined, DCM_E_REQUESTOUTOFRANGE will be returned and just skip it.
#           * Try to read other valid Dids.
#           */
#          CONSTP2CONST(Dcm_Cfg_RequestedDidInfoType, TYPEDEF, DCM_APPL_DATA) pDidInfo = &Dcm_LCfg.p_requested_dids[pStatus->current_did_index];
	.d2line		4205
.Llo1633:
	lis		r3,(Dcm_LCfg+60)@ha		# pDidInfo=r3
.Llo1634:
	lwz		r0,(Dcm_LCfg+60)@l(r3)		# pDidInfo=r3
	lis		r3,(Dcm_DspInstance+182)@ha		# pDidInfo=r3
	lhz		r3,(Dcm_DspInstance+182)@l(r3)		# pDidInfo=r3 pDidInfo=r3
	rlwinm		r3,r3,3,13,28		# pDidInfo=r3 pDidInfo=r3
	se_add		r0,r3		# pDidInfo=r3
	mr		r3,r0		# pDidInfo=r3 pDidInfo=r0
# 
#          if (DID_ENUM_OBD_PID == pDidInfo->did_type)
	.d2line		4207
.Llo1635:
	lwz		r0,4(r3)		# pDidInfo=r3
	se_cmpi		r0,3
	bc		0,2,.L913	# ne
#          {
#             /*
#              * OBDDataIdentifier
#              */
#             *pErrorCode = ReadOBDDataAndInfoType(SID_READ_DATA_BY_IDENTIFIER, pDidInfo->identifier, &ReadCommonPid, Dcm_pPbCfg->p_pids_support_01, NULL_PTR, 0, 0);
	.d2line		4212
.Llo1636:
	lis		r4,Dcm_pPbCfg@ha
	lwz		r4,Dcm_pPbCfg@l(r4)
	lwz		r6,24(r4)
	lhz		r4,0(r3)		# pDidInfo=r3
	lis		r5,ReadCommonPid@ha
	e_add16i		r5,r5,ReadCommonPid@l
	diab.li		r3,34		# pDidInfo=r3
.Llo1637:
	diab.li		r7,0		# pErrorCode=r7
	mr		r8,r7		# pErrorCode=r8
	mr		r9,r7		# pErrorCode=r9
	bl		ReadOBDDataAndInfoType
.Llo1638:
	stb		r3,0(r30)		# pErrorCode=r30 pDidInfo=r3
	b		.L914
.L913:
#          }
#          else if (DID_ENUM_OBD_INFOTYPE == pDidInfo->did_type)
	.d2line		4214
	lwz		r0,4(r3)		# pDidInfo=r3
	se_cmpi		r0,2
	bc		0,2,.L915	# ne
#          {
#             /* 
#              * OBDInfoTypeDataIdentifier 
#              */
#             *pErrorCode = ReadOBDDataAndInfoType(SID_READ_DATA_BY_IDENTIFIER, pDidInfo->identifier, &ReadCommonOBDInfoTypeIdentifier, Dcm_pPbCfg->p_vehicle_info_type_support,
	.d2line		4219
	lis		r4,Dcm_pPbCfg@ha
	lwz		r4,Dcm_pPbCfg@l(r4)
	lwz		r6,36(r4)
	lis		r7,(Dcm_DspInstance+176)@ha		# pErrorCode=r7
	e_add16i		r7,r7,(Dcm_DspInstance+176)@l		# pErrorCode=r7 pErrorCode=r7
	lhz		r4,0(r3)		# pDidInfo=r3
	lis		r5,ReadCommonOBDInfoTypeIdentifier@ha
	e_add16i		r5,r5,ReadCommonOBDInfoTypeIdentifier@l
	diab.li		r3,34		# pDidInfo=r3
.Llo1639:
	diab.li		r8,0		# pErrorCode=r8
	mr		r9,r8		# pErrorCode=r9
	bl		ReadOBDDataAndInfoType
.Llo1640:
	stb		r3,0(r30)		# pErrorCode=r30 pDidInfo=r3
	b		.L914
.L915:
#                                                    pStatus, 0, 0);
#          }
#          else if (DID_ENUM_OBD_MID == pDidInfo->did_type)
	.d2line		4222
	lwz		r0,4(r3)		# pDidInfo=r3
	se_cmpi		r0,4
	bc		0,2,.L917	# ne
#          {
#             /*
#              * OBDMonitorDataIdentifier, currently not supported
#              */
#             *pErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		4227
	diab.li		r0,160
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L914
.L917:
#          }
#          else if (DID_ENUM_DDDID == pDidInfo->did_type)
	.d2line		4229
	lwz		r0,4(r3)		# pDidInfo=r3
	se_cmpi		r0,1
	bc		0,2,.L919	# ne
#          {
#             /*
#              * DIDs using the DDDID structure included DDDIDs, PRDIDs (static and dynamically) and composite DIDs.
#              */
#             *pErrorCode = ReadDynamicallyDefinedDid(pDidInfo->identifier, activeSession, activeSecurityLevel, pStatus);
	.d2line		4234
.Llo1641:
	lbz		r4,8(r1)
	lbz		r5,9(r1)
	lis		r6,(Dcm_DspInstance+176)@ha
	e_add16i		r6,r6,(Dcm_DspInstance+176)@l
.Llo1642:
	lhz		r3,0(r3)		# pDidInfo=r3 pDidInfo=r3
.Llo1643:
	bl		ReadDynamicallyDefinedDid
.Llo1644:
	stb		r3,0(r30)		# pErrorCode=r30 pDidInfo=r3
	b		.L914
.L919:
#          }
#          else if (DID_ENUM_DID == pDidInfo->did_type)
	.d2line		4236
	lwz		r0,4(r3)		# pDidInfo=r3
	se_cmpi		r0,0
	bc		0,2,.L921	# ne
#          {
#             /*
#              * Standard DID
#              */
#             *pErrorCode = ReadConfiguredDid(pDidInfo->identifier, activeSession, activeSecurityLevel, pStatus);
	.d2line		4241
.Llo1645:
	lbz		r4,8(r1)
	lbz		r5,9(r1)
	lis		r6,(Dcm_DspInstance+176)@ha
	e_add16i		r6,r6,(Dcm_DspInstance+176)@l
.Llo1646:
	lhz		r3,0(r3)		# pDidInfo=r3 pDidInfo=r3
.Llo1647:
	bl		ReadConfiguredDid
.Llo1648:
	stb		r3,0(r30)		# pErrorCode=r30 pDidInfo=r3
	b		.L914
.L921:
#          }
#          else
#          {
#             /*
#              * The only choice left, a DID defined using ranges
#              */
#             *pErrorCode = ReadConfiguredDidRange(pDidInfo->identifier, activeSession, activeSecurityLevel, pStatus);
	.d2line		4248
.Llo1649:
	lbz		r4,8(r1)
	lbz		r5,9(r1)
	lis		r6,(Dcm_DspInstance+176)@ha
	e_add16i		r6,r6,(Dcm_DspInstance+176)@l
.Llo1650:
	lhz		r3,0(r3)		# pDidInfo=r3 pDidInfo=r3
.Llo1651:
	bl		ReadConfiguredDidRange
.Llo1652:
	stb		r3,0(r30)		# pErrorCode=r30 pDidInfo=r3
.L914:
#          }
# 
#          if (DCM_INT_NRC_API_RETURNED_PENDING != *pErrorCode)
	.d2line		4251
.Llo1653:
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,162
	bc		1,2,.L924	# eq
	.d2line		4065
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+200)@ha		# pDidInfo=r3
.Llo1654:
	stw		r0,(Dcm_DspInstance+200)@l(r3)		# pDidInfo=r3
	lis		r3,(Dcm_DspInstance+198)@ha		# pDidInfo=r3
	stb		r0,(Dcm_DspInstance+198)@l(r3)		# pDidInfo=r3
.L924:
	.section	.text_vle
.L4408:
.Llo1655:
	lis		r4,(Dcm_DspInstance+182)@ha
	lhz		r3,(Dcm_DspInstance+182)@l(r4)		# pDidInfo=r3
.Llo1656:
	se_addi		r3,1		# pDidInfo=r3 pDidInfo=r3
	sth		r3,(Dcm_DspInstance+182)@l(r4)		# pDidInfo=r3
	b		.L910
.L912:
#          {
#             /*
#             * Re-initialise the current opStatus in case of OK or error.
#             * It might have been DCM_PENDING in previous call.
#             */
#             pStatus->read_did_info.current_operation = READ_DID_INIT;
#             pStatus->read_did_info.current_opstatus = DCM_INITIAL;
#          }
#          else
#          {
#             /*
#              * Keep the current values for the next cycle
#              */
#          }
#       } /* for */
# 
#       if (DCM_INT_NRC_API_RETURNED_PENDING == *pErrorCode)
	.d2line		4268
.Llo1657:
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,162
	bc		0,2,.L909	# ne
	.d2line		4065
	lis		r3,(Dcm_DspInstance+182)@ha		# pDidInfo=r3
.Llo1658:
	lhz		r0,(Dcm_DspInstance+182)@l(r3)		# pDidInfo=r3
	diab.li		r4,65535
	se_add		r0,r4
	sth		r0,(Dcm_DspInstance+182)@l(r3)		# pDidInfo=r3
.L909:
#       {
#          /* 
#           * Since response buffer is not available or some call returned pending,
#           * reading will continue later. Store the current DID.
#           */
#          pStatus->current_did_index--;
#       }
#       else
#       {
#          /* 
#           * OK or error, already cleaned up within the loop itself.
#           */
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		4284
.Llo1659:
	lbz		r3,0(r30)		# pDidInfo=r3 pErrorCode=r30
	bl		Dcm_ErrorCodeToStdReturnType
.Llo1660:
	rlwinm		r3,r3,0,24,31		# pDidInfo=r3 pDidInfo=r3
# }
	.d2line		4285
	.d2epilogue_begin
.Llo1661:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
.Llo1627:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4395:
	.type		Dcm_ReadDataByIdentifier,@function
	.size		Dcm_ReadDataByIdentifier,.-Dcm_ReadDataByIdentifier
# Number of nodes = 578

# Allocations for Dcm_ReadDataByIdentifier
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	not allocated	pStatus
#	?a6		didIdentifier
#	?a7		pDidInfo
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ReadScalingByIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         4290,32
#$$ld
.L4420:

#$$bf	Dcm_ReadScalingByIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_ReadScalingByIdentifier
	.d2_cfa_start __cie
Dcm_ReadScalingByIdentifier:
.Llo1662:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# OpStatus=r31 OpStatus=r3
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
# {
#    /* Each DID is two bytes */
#    uint16 didIdentifier;
#    uint16 confDidCounter;
#    P2CONST(Dcm_Cfg_DidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
	.d2line		4295
	diab.li		r28,0		# pDid=r28
#    CONSTP2VAR(ReadScalingByIdentifierOperationStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.readScalingByIdentifier_status;
# 
#    /*
#     * - DCM_ASYNCH_STATE_PENDING should be checked first to avoid multiple call of the function in the same scheduler
#     */
#    if (DCM_PENDING == OpStatus)
	.d2line		4301
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
	se_cmpi		r3,1		# OpStatus=r3
	bc		0,2,.L953	# ne
	.section	.text_vle
.L4432:
#    {
#       CONST(Std_ReturnType, CONST) stdRetVal = pStatus->pCurrentDid->GetScalingInformationFunc(DCM_PENDING, pStatus->pRequestData, pErrorCode);
	.d2line		4303
.Llo1663:
	lis		r3,(Dcm_DspInstance+120)@ha		# OpStatus=r3
.Llo1664:
	lwz		r3,(Dcm_DspInstance+120)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,20(r3)		# OpStatus=r3
	mtspr		ctr,r0
	lis		r3,(Dcm_DspInstance+124)@ha		# OpStatus=r3
	lwz		r4,(Dcm_DspInstance+124)@l(r3)		# OpStatus=r3
	diab.li		r3,1		# OpStatus=r3
	mr		r5,r29		# pErrorCode=r5 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#       HandleStdRetVal(stdRetVal, pStatus->pCurrentDid->RetStatus, FALSE, pErrorCode);
	.d2line		4305
.Llo1687:
	lis		r4,(Dcm_DspInstance+120)@ha
	lwz		r4,(Dcm_DspInstance+120)@l(r4)
	lbz		r4,24(r4)
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,0
	bl		HandleStdRetVal
	.section	.text_vle
.L4433:
.L953:
#    }
# 
#    if (DCM_INITIAL == OpStatus)
	.d2line		4308
.Llo1688:
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
	se_cmpi		r3,0		# OpStatus=r3
	bc		0,2,.L954	# ne
#    {
#       /*
#        * Do some initiation:
#        * - Clear the response length
#        */
#       pMsgContext->resDataLen = 0;
	.d2line		4314
	diab.li		r0,0		# OpStatus=r0
	sth		r0,12(r30)		# pMsgContext=r30 OpStatus=r0
# 
#       /* The request shall only contain the DID */
#       if (2 != pMsgContext->reqDataLen)
	.d2line		4317
	lhz		r0,4(r30)		# OpStatus=r0 pMsgContext=r30
	se_cmpi		r0,2		# OpStatus=r0
	bc		1,2,.L955	# eq
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4319
	diab.li		r0,19		# OpStatus=r0
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
	b		.L956
.L955:
#       }
#       else
#       {
#          /*
#           * Before calling the application to get the scaling data several checks have to be done:
#           * 1. Was the DID found which has read scaling data information amongst the configured ones?
#           * 2. Does the scaling info data length fit into the response buffer?
#           */
# 
#          didIdentifier = GET_2BYTE_ID(&pMsgContext->reqData[0]);
	.d2line		4329
	lwz		r3,0(r30)		# OpStatus=r3 pMsgContext=r30
	lbz		r0,0(r3)		# OpStatus=r0 OpStatus=r3
	se_slwi		r0,8		# OpStatus=r0
	lbz		r5,1(r3)		# OpStatus=r5 OpStatus=r3
	or		r0,r0,r5		# OpStatus=r0 OpStatus=r0 OpStatus=r5
.Llo1679:
	mr		r5,r0		# didIdentifier=r5 didIdentifier=r0
# 
#          /*
#           * Try to find a matching DID in the configuration
#           */
#          for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_dids) && (NULL_PTR == pDid); confDidCounter++)
	.d2line		4334
	diab.li		r3,0		# confDidCounter=r3
.L957:
.Llo1680:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 confDidCounter=r3
.Llo1681:
	lis		r4,(Dcm_LCfg+64)@ha
	lhz		r4,(Dcm_LCfg+64)@l(r4)
	se_cmp		r0,r4		# OpStatus=r0
	bc		0,0,.L959	# ge
	se_cmpi		r28,0		# pDid=r28
	bc		0,2,.L959	# ne
#          {
#             if ((Dcm_LCfg.dids[confDidCounter].identifier == didIdentifier) && (NULL_PTR != Dcm_LCfg.dids[confDidCounter].GetScalingInformationFunc))
	.d2line		4336
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r6,r0,5,0,26		# OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r6		# OpStatus=r0 OpStatus=r0
	lhzx		r4,r4,r0
	rlwinm		r0,r5,0,16,31		# OpStatus=r0 didIdentifier=r5
	se_cmp		r4,r0		# OpStatus=r0
	bc		0,2,.L960	# ne
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r6,r0,5,0,26		# OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r6		# OpStatus=r0 OpStatus=r0
	se_add		r4,r0		# OpStatus=r0
	lwz		r0,20(r4)		# OpStatus=r0
	se_cmpi		r0,0		# OpStatus=r0
	bc		1,2,.L960	# eq
#             {
#                pStatus->pCurrentDid = &Dcm_LCfg.dids[confDidCounter];
	.d2line		4338
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 confDidCounter=r3
	.d2line		4296
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r28,(Dcm_LCfg+68)@l(r4)		# pDid=r28
	rlwinm		r4,r0,5,0,26		# OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r4		# OpStatus=r0 OpStatus=r0
	se_add		r28,r0		# pDid=r28 pDid=r28 OpStatus=r0
	lis		r4,(Dcm_DspInstance+120)@ha
	stw		r28,(Dcm_DspInstance+120)@l(r4)		# pDid=r28
#                pDid = pStatus->pCurrentDid;
	.d2line		4339
	mr		r28,r28		# pDid=r28 pDid=r28
.L960:
#             }
#          }
	.d2line		4341
	diab.addi		r0,r3,1		# OpStatus=r0 confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L957
.L959:
# 
#          /*
#           * 1. Was the DID found which has read scaling data information amongst the configured ones?
#           */
#          if (NULL_PTR == pDid)
	.d2line		4346
	se_cmpi		r28,0		# pDid=r28
	bc		0,2,.L961	# ne
#          {
#             /*
#              * The requested DID was not found and which has no get scaling data. Report an error and break.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4351
.Llo1682:
	diab.li		r0,49		# OpStatus=r0
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
	b		.L956
.L961:
	.d2line		4296
	lis		r3,(Dcm_DspInstance+120)@ha		# confDidCounter=r3
.Llo1683:
	lwz		r3,(Dcm_DspInstance+120)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	lhz		r3,4(r3)		# confDidCounter=r3 confDidCounter=r3
	se_addi		r3,2		# confDidCounter=r3 confDidCounter=r3
	lhz		r0,20(r30)		# OpStatus=r0 pMsgContext=r30
	se_cmpl		r3,r0		# confDidCounter=r3 OpStatus=r0
	bc		0,1,.L956	# le
#          }
# 
#          /*
#           * 2. Does the scaling info data length fit into the response buffer?
#           *    Shall be done in SCG, but take it here until further notice
#           */
#          else if ((pStatus->pCurrentDid->scalingInfoSize + 2U /* DID */) > pMsgContext->resMaxDataLen)
#          {
#             /*
#              * The result will not fit, report error and break
#              */
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		4363
.Llo1684:
	diab.li		r0,20		# OpStatus=r0
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
.L956:
#          }
#          else
#          {
#             /*
#              * Continue with get the scaling info data
#              */
#          }
#       }
# 
#       /*
#        * Only get the scaling info data if all checks are OK
#        * It is not necessary to check the pDid since it is checked above, but it will remove a SCA warning.
#        */
#       if ((DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode) && (NULL_PTR != pDid))
	.d2line		4377
	lbz		r0,0(r29)		# OpStatus=r0 pErrorCode=r29
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L954	# ne
	se_cmpi		r28,0		# pDid=r28
	bc		1,2,.L954	# eq
	.section	.text_vle
.L4438:
	.d2line		4296
	lwz		r4,8(r30)		# pMsgContext=r30
	se_addi		r4,2
	lis		r3,(Dcm_DspInstance+124)@ha		# OpStatus=r3
	stw		r4,(Dcm_DspInstance+124)@l(r3)		# OpStatus=r3
#       {
#          /*
#           * Store the request data
#           */
#          pStatus->pRequestData = &pMsgContext->resData[2];
# 
#          /*
#           * The call returned an error. Send a negative response, the error to be sent has been stored in ErrorCode
#           */
#          CONST(Std_ReturnType, AUTOMATIC) stdRetVal = pDid->GetScalingInformationFunc(DCM_INITIAL, pStatus->pRequestData, pErrorCode);
	.d2line		4387
	lwz		r0,20(r28)		# OpStatus=r0 pDid=r28
	mtspr		ctr,r0		# OpStatus=ctr
	diab.li		r3,0		# OpStatus=r3
	mr		r5,r29		# pErrorCode=r5 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
# 
#          HandleStdRetVal(stdRetVal, pStatus->pCurrentDid->RetStatus, FALSE, pErrorCode);
	.d2line		4389
.Llo1685:
	lis		r4,(Dcm_DspInstance+120)@ha
	lwz		r4,(Dcm_DspInstance+120)@l(r4)
	lbz		r4,24(r4)
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,0		# pErrorCode=r5
	bl		HandleStdRetVal
	.section	.text_vle
.L4439:
.L954:
#       }
#       else
#       {
#          /*
#           * Report if any error
#           */
#       }
#    }
# 
#    if (DCM_CANCEL == OpStatus)
	.d2line		4399
.Llo1686:
	rlwinm		r31,r31,0,24,31		# OpStatus=r31 OpStatus=r31
	se_cmpi		r31,2		# OpStatus=r31
	bc		0,2,.L967	# ne
	.d2line		4296
.Llo1665:
	lis		r3,(Dcm_DspInstance+120)@ha		# OpStatus=r3
.Llo1666:
	lwz		r3,(Dcm_DspInstance+120)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,20(r3)		# OpStatus=r0 OpStatus=r3
	mtspr		ctr,r0		# OpStatus=ctr
	lis		r3,(Dcm_DspInstance+124)@ha		# OpStatus=r3
	lwz		r4,(Dcm_DspInstance+124)@l(r3)		# OpStatus=r3
	diab.li		r3,2		# OpStatus=r3
.Llo1667:
	mr		r5,r29		# pErrorCode=r5 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * The return result is not interesting since we cancel the service
#        */
#       (void)pStatus->pCurrentDid->GetScalingInformationFunc(DCM_CANCEL, pStatus->pRequestData, pErrorCode);
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		4407
	diab.li		r0,0		# OpStatus=r0
.Llo1668:
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
.L967:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		4410
.Llo1669:
	lbz		r0,0(r29)		# OpStatus=r0 pErrorCode=r29
.Llo1670:
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L968	# ne
#    {
#       /*
#        * The positive response only contains the DID identifier.
#        */
#       SET_2BYTE_ID(&pMsgContext->resData[0], pStatus->pCurrentDid->identifier);
	.d2line		4415
.Llo1671:
	lis		r3,(Dcm_DspInstance+120)@ha		# OpStatus=r3
.Llo1672:
	lwz		r4,(Dcm_DspInstance+120)@l(r3)		# OpStatus=r3
	lhz		r0,0(r4)		# OpStatus=r0
	rlwinm		r0,r0,24,24,31		# OpStatus=r0 OpStatus=r0
	lwz		r4,8(r30)		# pMsgContext=r30
	stb		r0,0(r4)		# OpStatus=r0
	lwz		r4,(Dcm_DspInstance+120)@l(r3)		# OpStatus=r3
	lbz		r0,1(r4)		# OpStatus=r0
	lwz		r4,8(r30)		# pMsgContext=r30
	stb		r0,1(r4)		# OpStatus=r0
#       pMsgContext->resDataLen = 2 + pStatus->pCurrentDid->scalingInfoSize;
	.d2line		4416
	lwz		r3,(Dcm_DspInstance+120)@l(r3)		# OpStatus=r3 OpStatus=r3
.Llo1673:
	lhz		r3,4(r3)		# OpStatus=r3 OpStatus=r3
.Llo1674:
	se_addi		r3,2		# OpStatus=r3 OpStatus=r3
	sth		r3,12(r30)		# pMsgContext=r30 OpStatus=r3
.L968:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		4419
.Llo1675:
	lbz		r3,0(r29)		# OpStatus=r3 pErrorCode=r29
.Llo1678:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo1676:
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
# }
	.d2line		4420
	.d2epilogue_begin
.Llo1677:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# OpStatus=r0
	mtspr		lr,r0		# OpStatus=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4421:
	.type		Dcm_ReadScalingByIdentifier,@function
	.size		Dcm_ReadScalingByIdentifier,.-Dcm_ReadScalingByIdentifier
# Number of nodes = 332

# Allocations for Dcm_ReadScalingByIdentifier
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		$$100
#	?a8		$$99
#	?a9		$$98
#	?a10		didIdentifier
#	?a11		confDidCounter
#	?a12		pDid
#	not allocated	pStatus
#	?a13		stdRetVal
#	?a14		stdRetVal
# static FUNC(uint16, DCM_CODE) CountConfiguredPeriodicDids(CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_CONST) pDids,
	.align		1
	.section	.text_vle
        .d2line         4426,31
#$$ld
.L4446:

#$$bf	CountConfiguredPeriodicDids,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r28,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
CountConfiguredPeriodicDids:
.Llo1689:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pDids=r3 pDids=r3
.Llo1690:
	mr		r0,r4		# numDids=r0 numDids=r4
	.d2prologue_end
#                                                           uint16 const numDids )
# {
#    uint16 didIndex;
#    uint16 didCount = 0;
	.d2line		4430
	diab.li		r5,0		# didCount=r5
# 
#    /*
#     * Go through all requested DIDs.
#     */
#    for (didIndex = (uint16)0U; didIndex < numDids; didIndex++)
	.d2line		4435
.Llo1694:
	diab.li		r4,0
.L981:
.Llo1691:
	rlwinm		r6,r4,0,16,31		# periodicDynamicDidIndex=r6 didIndex=r4
.Llo1692:
	rlwinm		r7,r0,0,16,31		# numDids=r0
	se_cmp		r6,r7		# periodicDynamicDidIndex=r6
	bc		0,0,.L983	# ge
	.section	.text_vle
.L4455:
#    {
#       uint16 periodicDynamicDidIndex;
#       uint16 const didIdentifier = GET_PERIODIC_ID(pDids[didIndex]);
	.d2line		4438
.Llo1696:
	rlwinm		r6,r4,0,16,31		# periodicDynamicDidIndex=r6 didIndex=r4
.Llo1697:
	lbzux		r30,r6,r3		# didIdentifier=r30 periodicDynamicDidIndex=r6
.Llo1701:
	e_ori		r30,r30,61952		# didIdentifier=r30 didIdentifier=r30
	mr		r30,r30		# didIdentifier=r30 didIdentifier=r30
# 
#       /*
#        * Go through all configured DIDs.
#        */
#       for (periodicDynamicDidIndex = (uint16)0U; periodicDynamicDidIndex < Dcm_LCfg.num_periodic_dynamic_dids; periodicDynamicDidIndex++)
	.d2line		4443
	diab.li		r6,0		# periodicDynamicDidIndex=r6
.L984:
	rlwinm		r31,r6,0,16,31		# periodicDynamicDidIndex=r6
	lis		r7,(Dcm_LCfg+72)@ha
	lhz		r7,(Dcm_LCfg+72)@l(r7)
	se_cmp		r31,r7
	bc		0,0,.L988	# ge
#       {
#          if (didIdentifier == Dcm_LCfg.periodicDynamicDids[periodicDynamicDidIndex].identifier)
	.d2line		4445
	rlwinm		r31,r6,0,16,31		# periodicDynamicDidIndex=r6
	rlwinm		r29,r30,0,16,31		# didIdentifier=r30
	lis		r7,(Dcm_LCfg+76)@ha
	lwz		r7,(Dcm_LCfg+76)@l(r7)
	rlwinm		r28,r31,5,0,26
	se_slwi		r31,3
	subf		r31,r31,r28
	lhzx		r7,r7,r31
	se_cmp		r29,r7
	bc		0,2,.L987	# ne
#          {
#             didCount++;
	.d2line		4447
.Llo1698:
	diab.addi		r6,r5,1		# periodicDynamicDidIndex=r6 didCount=r5
	se_addi		r5,1		# didCount=r5 didCount=r5
	b		.L988
.L987:
#             break;
#          }
#       }
	.d2line		4450
.Llo1699:
	diab.addi		r31,r6,1		# periodicDynamicDidIndex=r6
	se_addi		r6,1		# periodicDynamicDidIndex=r6 periodicDynamicDidIndex=r6
	b		.L984
.L988:
	.section	.text_vle
.L4456:
#    }
	.d2line		4451
.Llo1700:
	diab.addi		r6,r4,1		# periodicDynamicDidIndex=r6 didIndex=r4
	se_addi		r4,1		# didIndex=r4 didIndex=r4
	b		.L981
.L983:
# 
#    return didCount;
	.d2line		4453
.Llo1693:
	rlwinm		r3,r5,0,16,31		# didCount=r5
# }
	.d2line		4454
	.d2epilogue_begin
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# numDids=r0
	mtspr		lr,r0		# numDids=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1695:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4447:
	.type		CountConfiguredPeriodicDids,@function
	.size		CountConfiguredPeriodicDids,.-CountConfiguredPeriodicDids
# Number of nodes = 59

# Allocations for CountConfiguredPeriodicDids
#	?a4		pDids
#	?a5		numDids
#	?a6		$$101
#	?a7		didIndex
#	?a8		didCount
#	?a9		periodicDynamicDidIndex
#	?a10		didIdentifier
# static FUNC(boolean, DCM_CODE) IsValidPeriodicDid(Dcm_SesCtrlType activeSession,
	.align		1
	.section	.text_vle
        .d2line         12962,32
#$$ld
.L4465:

#$$bf	IsValidPeriodicDid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
IsValidPeriodicDid:
.Llo1702:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# activeSession=r31 activeSession=r3
	mr		r30,r4		# activeSecurityLevel=r30 activeSecurityLevel=r4
	mr		r5,r5		# didId=r5 didId=r5
	mr		r6,r6		# index=r6 index=r6
	mr		r7,r7		# numStored=r7 numStored=r7
	.d2prologue_end
#                                                   Dcm_SecLevelType activeSecurityLevel,
#                                                   uint8 didId, P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) index, uint16 numStored)
# {
#    uint16 i;
#    CONST(uint16, DCM_CONST) didIdentifier = GET_PERIODIC_ID(didId);
#    boolean valid = FALSE;
	.d2line		12968
	diab.li		r3,0		# valid=r3
#    Dcm_Cfg_MemoryRangePointerType pSelectedMemoryRange;
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
	.d2line		12970
.Llo1703:
	diab.li		r28,0
	.d2line		12967
.Llo1741:
	rlwinm		r5,r5,0,24,31		# didId=r5 didId=r5
	e_ori		r5,r5,61952		# didId=r5 didId=r5
.Llo1707:
	mr		r29,r5		# didIdentifier=r29 didIdentifier=r5
# 
#    /*
#     * Check if the requested DID is configured.
#     */
#    for (i = 0; (FALSE == valid) && (i < Dcm_LCfg.num_periodic_dynamic_dids); i++)
	.d2line		12975
	diab.li		r4,0
.L2653:
.Llo1704:
	rlwinm		r0,r3,0,24,31		# valid=r3
.Llo1706:
	se_cmpi		r0,0
	bc		0,2,.L2659	# ne
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+72)@ha		# didId=r5
.Llo1708:
	lhz		r5,(Dcm_LCfg+72)@l(r5)		# didId=r5 didId=r5
	se_cmp		r0,r5		# didId=r5
	bc		0,0,.L2659	# ge
#    {
#       if (Dcm_LCfg.periodicDynamicDids[i].identifier == didIdentifier)
	.d2line		12977
.Llo1709:
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+76)@ha		# didId=r5
.Llo1710:
	lwz		r5,(Dcm_LCfg+76)@l(r5)		# didId=r5 didId=r5
	rlwinm		r27,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r27
	lhzx		r0,r5,r0		# didId=r5
	rlwinm		r5,r29,0,16,31		# didId=r5 didIdentifier=r29
	se_cmp		r0,r5		# didId=r5
	bc		0,2,.L2656	# ne
#       {
#          if (0 != *(Dcm_LCfg.periodicDynamicDids[i].pNumberOfDefinedSources))
	.d2line		12979
.Llo1711:
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r5,(Dcm_LCfg+76)@ha		# didId=r5
.Llo1712:
	lwz		r5,(Dcm_LCfg+76)@l(r5)		# didId=r5 didId=r5
	rlwinm		r27,r0,5,0,26
	se_slwi		r0,3
	subf		r0,r0,r27
	se_add		r5,r0		# didId=r5 didId=r5
	lwz		r5,16(r5)		# didId=r5 didId=r5
	lbz		r0,0(r5)		# didId=r5
	se_cmpi		r0,0
	bc		1,2,.L2659	# eq
#          {
#             *index = i;
	.d2line		12981
.Llo1713:
	sth		r4,0(r6)		# index=r6 i=r4
#             pDid = &Dcm_LCfg.periodicDynamicDids[i];
	.d2line		12982
	rlwinm		r0,r4,0,16,31		# i=r4
	lis		r3,(Dcm_LCfg+76)@ha		# valid=r3
	lwz		r28,(Dcm_LCfg+76)@l(r3)		# valid=r3
	rlwinm		r3,r0,5,0,26		# valid=r3
	se_slwi		r0,3
	subf		r0,r0,r3		# valid=r3
	se_add		r0,r28
	mr		r28,r0		# pDid=r28 pDid=r0
#             valid = TRUE;
	.d2line		12983
	diab.li		r3,1		# valid=r3
.L2656:
#          }
#          else
#          {
#             /*
#              * A undefined or cleared dynamically defined periodic Did.
#              */
#             break;
#          }
#       }
#    }
	.d2line		12993
	diab.addi		r0,r4,1		# i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L2653
.L2659:
# 
#    /*
#     * Check if the requested DID is already stored.
#     */
#    for (i = 0; (TRUE == valid) && (i < numStored); i++)
	.d2line		12998
	diab.li		r5,0		# i=r5
.L2660:
.Llo1717:
	rlwinm		r0,r3,0,24,31		# valid=r3
.Llo1718:
	se_cmpi		r0,1
	bc		0,2,.L2662	# ne
	rlwinm		r0,r5,0,16,31		# i=r5
	rlwinm		r4,r7,0,16,31		# i=r4 numStored=r7
	se_cmp		r0,r4		# i=r4
	bc		0,0,.L2662	# ge
#    {
#       if (Dcm_LCfg.requested_periodicDids[i] == *index)
	.d2line		13000
	lis		r4,(Dcm_LCfg+80)@ha		# i=r4
	lwz		r4,(Dcm_LCfg+80)@l(r4)		# i=r4 i=r4
	rlwinm		r0,r5,1,15,30		# i=r5
	lhzx		r0,r4,r0		# i=r4
	lhz		r4,0(r6)		# i=r4 index=r6
	se_cmp		r0,r4		# i=r4
#       {
#          valid = FALSE;
	.d2line		13002
	isel		r3,0,r3,2		# valid=r3 valid=r3
.L2663:
#       }
#    }
	.d2line		13004
	diab.addi		r0,r5,1		# i=r5
	se_addi		r5,1		# i=r5 i=r5
	b		.L2660
.L2662:
# 
#    /*
#     * pDID check only for SCA. If pDid is NULL_PTR, valid will always by FALSE
#     */
#    if (NULL_PTR != pDid)
	.d2line		13009
	se_cmpi		r28,0		# pDid=r28
	bc		1,2,.L2664	# eq
#    {
#        /**
#         * Go through all data sources of the requested DiD, check it is allowed to read all signals
#         * under the current session level.
#         */
#       for (i = 0; (i < *(pDid->pNumberOfDefinedSources)) && (TRUE == valid); i++)
	.d2line		13015
.Llo1714:
	diab.li		r29,0		# i=r29
.L2665:
.Llo1719:
	rlwinm		r0,r29,0,16,31		# i=r29
	lwz		r4,16(r28)		# i=r4 pDid=r28
	lbz		r4,0(r4)		# i=r4 i=r4
	se_cmp		r0,r4		# i=r4
	bc		0,0,.L2664	# ge
	rlwinm		r0,r3,0,24,31		# valid=r3
	se_cmpi		r0,1
	bc		0,2,.L2664	# ne
#       {
#          if (DCM_DD_DID == pDid->pDataSourcesRead[i].record_type)
	.d2line		13017
	lwz		r4,8(r28)		# i=r4 pDid=r28
	rlwinm		r0,r29,0,16,31		# i=r29
	e_mulli		r0,r0,20
	lwzx		r0,r4,r0		# i=r4
	se_cmpi		r0,0
	bc		0,2,.L2668	# ne
#          {
#             if ((FALSE == Dcm_IsLevelSupported(activeSession, pDid->pDataSourcesRead[i].pDidRead->p_session_levels)) ||
	.d2line		13019
.Llo1720:
	lwz		r3,8(r28)		# valid=r3 pDid=r28
.Llo1721:
	rlwinm		r0,r29,0,16,31		# i=r29
	e_mulli		r0,r0,20
	se_add		r3,r0		# valid=r3 valid=r3
	lwz		r3,16(r3)		# valid=r3 valid=r3
	lwz		r4,16(r3)		# i=r4 valid=r3
	rlwinm		r3,r31,0,24,31		# valid=r3 activeSession=r31
.Llo1722:
	bl		Dcm_IsLevelSupported
.Llo1723:
	e_andi.		r3,r3,255		# valid=r3 valid=r3
.Llo1724:
	bc		1,2,.L2676	# eq
	lwz		r3,8(r28)		# valid=r3 pDid=r28
.Llo1725:
	rlwinm		r0,r29,0,16,31		# i=r29
	e_mulli		r0,r0,20
	se_add		r3,r0		# valid=r3 valid=r3
	lwz		r3,16(r3)		# valid=r3 valid=r3
	lwz		r4,12(r3)		# i=r4 valid=r3
	rlwinm		r3,r30,0,24,31		# valid=r3 activeSecurityLevel=r30
.Llo1726:
	bl		Dcm_IsLevelSupported
.Llo1727:
	e_andi.		r3,r3,255		# valid=r3 valid=r3
.Llo1728:
	bc		0,2,.L2669	# ne
.L2676:
#                (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, pDid->pDataSourcesRead[i].pDidRead->p_security_levels)))
#             {
#                valid = FALSE;
	.d2line		13022
	diab.li		r3,0		# valid=r3
.Llo1729:
	b		.L2671
.L2669:
#             }
#             else
#             {
#                valid = TRUE;
	.d2line		13026
.Llo1730:
	diab.li		r3,1		# valid=r3
.Llo1731:
	b		.L2671
.L2668:
#             }
#          }
#          else if (DCM_DD_MEMORY == pDid->pDataSourcesRead[i].record_type)
	.d2line		13029
	lwz		r4,8(r28)		# i=r4 pDid=r28
	rlwinm		r0,r29,0,16,31		# i=r29
	e_mulli		r0,r0,20
	lwzx		r0,r4,r0		# i=r4
	se_cmpi		r0,3
	bc		0,2,.L2671	# ne
#          {
#             /*
#              * No session level validation is needed for memory address according to AutoSAR DCM4.0.
#              *
#              * The memory_id is used for two purposes, depending on the source.
#              * But when used for memory, the id equal or less than 255. A cast is therefore safe.
#              */
#             pSelectedMemoryRange = GetMemoryRange((uint8)pDid->pDataSourcesRead[i].memory_id,
	.d2line		13037
.Llo1732:
	lwz		r5,8(r28)		# i=r5 pDid=r28
	rlwinm		r0,r29,0,16,31		# i=r29
	e_mulli		r0,r0,20
	se_add		r5,r0		# i=r5 i=r5
	lhz		r3,4(r5)		# valid=r3 i=r5
	lwz		r4,8(r5)		# i=r4 i=r5
	lwz		r5,12(r5)		# i=r5 i=r5
	lis		r6,(Dcm_LCfg+156)@ha		# index=r6
.Llo1715:
	lwz		r6,(Dcm_LCfg+156)@l(r6)		# index=r6 index=r6
.Llo1716:
	bl		GetMemoryRange
	.d2line		13042
.Llo1733:
	mr.		r3,r3		# pSelectedMemoryRange=?a15 pSelectedMemoryRange=r3
#                                                   pDid->pDataSourcesRead[i].address,
#                                                   pDid->pDataSourcesRead[i].size,
#                                                   Dcm_LCfg.p_read_memory);
# 
#             if (NULL_PTR == pSelectedMemoryRange)
.Llo1734:
	bc		0,2,.L2673	# ne
#             {
#                valid = FALSE;
	.d2line		13044
.Llo1739:
	diab.li		r3,0		# valid=r3
.Llo1735:
	b		.L2671
.L2673:
#             }
#             else
#             {
#                valid = Dcm_IsLevelSupported(activeSecurityLevel, pSelectedMemoryRange->p_security_levels);
	.d2line		13048
.Llo1736:
	lwz		r4,12(r3)		# i=r4 pSelectedMemoryRange=r3
	rlwinm		r3,r30,0,24,31		# pSelectedMemoryRange=r3 activeSecurityLevel=r30
.Llo1740:
	bl		Dcm_IsLevelSupported
.Llo1737:
	mr		r3,r3		# valid=r3 valid=r3
.L2671:
#             }
#          }
#          else
#          {
#             /*
#              * DCM_DD_PID is to be supported
#              */
#          }
#       }
	.d2line		13057
	diab.addi		r0,r29,1		# i=r29
	se_addi		r29,1		# i=r29 i=r29
	b		.L2665
.L2664:
#    }
# 
#    return valid;
	.d2line		13060
.Llo1705:
	rlwinm		r3,r3,0,24,31		# valid=r3 valid=r3
# }
	.d2line		13061
	.d2epilogue_begin
.Llo1738:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,52(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4466:
	.type		IsValidPeriodicDid,@function
	.size		IsValidPeriodicDid,.-IsValidPeriodicDid
# Number of nodes = 290

# Allocations for IsValidPeriodicDid
#	?a4		activeSession
#	?a5		activeSecurityLevel
#	?a6		didId
#	?a7		index
#	?a8		numStored
#	?a9		$$104
#	?a10		$$103
#	?a11		$$102
#	?a12		i
#	?a13		didIdentifier
#	?a14		valid
#	?a15		pSelectedMemoryRange
#	?a16		pDid
# static FUNC(uint16, DCM_CODE) StopSomeDIDs(CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_CONST) pRequestedDids,
	.align		1
	.section	.text_vle
        .d2line         13067,31
#$$ld
.L4485:

#$$bf	StopSomeDIDs,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,r28,r29,r30,r31,cr0,lr
	.d2_cfa_start __cie
StopSomeDIDs:
.Llo1742:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pRequestedDids=r3 pRequestedDids=r3
.Llo1743:
	mr		r0,r4		# numRequested=r0 numRequested=r4
	.d2prologue_end
#                                            uint16 const numRequested )
# {
#    uint16 didIndex;
#    uint16 numFound = 0;
	.d2line		13071
	diab.li		r5,0		# numFound=r5
# 
#    /*
#     * Go through all DIDs to be stopped.
#     */
#    for (didIndex = 0; didIndex < numRequested; didIndex++)
	.d2line		13076
.Llo1747:
	diab.li		r4,0
.L2691:
.Llo1744:
	rlwinm		r6,r4,0,16,31		# periodicDidIndex=r6 didIndex=r4
.Llo1745:
	rlwinm		r7,r0,0,16,31		# numRequested=r0
	se_cmp		r6,r7		# periodicDidIndex=r6
	bc		0,0,.L2693	# ge
	.section	.text_vle
.L4494:
#    {
#       uint16 periodicDidIndex;
# 
#       uint16 const didIdentifier = GET_PERIODIC_ID(pRequestedDids[didIndex]);
	.d2line		13080
.Llo1749:
	rlwinm		r6,r4,0,16,31		# periodicDidIndex=r6 didIndex=r4
.Llo1750:
	lbzux		r30,r6,r3		# didIdentifier=r30 periodicDidIndex=r6
.Llo1752:
	e_ori		r30,r30,61952		# didIdentifier=r30 didIdentifier=r30
	mr		r30,r30		# didIdentifier=r30 didIdentifier=r30
# 
#       /*
#        * Go through all current active DIDs.
#        */
#       for (periodicDidIndex = 0; periodicDidIndex < Dcm_DspInstance.periodic_status.num_periodic_id; periodicDidIndex++)
	.d2line		13085
	diab.li		r6,0		# periodicDidIndex=r6
.L2694:
.Llo1759:
	rlwinm		r31,r6,0,16,31		# periodicDidIndex=r6
	lis		r7,(Dcm_DspInstance+214)@ha
	lhz		r7,(Dcm_DspInstance+214)@l(r7)
	se_cmp		r31,r7
	bc		0,0,.L2701	# ge
#       {
#          if (didIdentifier == Dcm_LCfg.periodicDynamicDids[Dcm_LCfg.requested_periodicDids[periodicDidIndex]].identifier)
	.d2line		13087
	lis		r7,(Dcm_LCfg+80)@ha
	lwz		r7,(Dcm_LCfg+80)@l(r7)
	rlwinm		r31,r6,1,15,30		# periodicDidIndex=r6
	lhzx		r31,r7,r31
	rlwinm		r29,r30,0,16,31		# didIdentifier=r30
	lis		r7,(Dcm_LCfg+76)@ha
	lwz		r7,(Dcm_LCfg+76)@l(r7)
	rlwinm		r28,r31,5,0,26
	se_slwi		r31,3
	subf		r31,r31,r28
	lhzx		r7,r7,r31
	se_cmp		r29,r7
	bc		0,2,.L2697	# ne
	.section	.text_vle
.L4502:
#          {
#             uint16 periodicDidMoveIndex;
# 
#             /*
#              * found one DID to be removed
#              */
#             numFound++;
	.d2line		13094
.Llo1753:
	diab.addi		r7,r5,1		# numFound=r5
	se_addi		r5,1		# numFound=r5 numFound=r5
# 
#             /*
#              * eventually need to move the elements after.
#              */
#             for (periodicDidMoveIndex = periodicDidIndex; periodicDidMoveIndex < (uint16)(Dcm_DspInstance.periodic_status.num_periodic_id - 1); periodicDidMoveIndex++)
	.d2line		13099
	mr		r6,r6		# periodicDidMoveIndex=r6 periodicDidMoveIndex=r6
.L2698:
	rlwinm		r30,r6,0,16,31		# didIdentifier=r30 periodicDidMoveIndex=r6
.Llo1754:
	lis		r7,(Dcm_DspInstance+214)@ha
	lhz		r7,(Dcm_DspInstance+214)@l(r7)
	diab.li		r31,65535
	se_add		r31,r7
	rlwinm		r7,r31,0,16,31
	se_cmp		r30,r7		# didIdentifier=r30
	bc		0,0,.L2701	# ge
#             {
#                Dcm_LCfg.requested_periodicDids[periodicDidMoveIndex] = Dcm_LCfg.requested_periodicDids[periodicDidMoveIndex + 1U];
	.d2line		13101
.Llo1755:
	lis		r7,(Dcm_LCfg+80)@ha
	lwz		r31,(Dcm_LCfg+80)@l(r7)
	rlwinm		r30,r6,1,15,30		# didIdentifier=r30 periodicDidMoveIndex=r6
.Llo1756:
	add		r7,r31,r30		# didIdentifier=r30
	lhz		r7,2(r7)
	sthx		r7,r31,r30
#             }
	.d2line		13102
	diab.addi		r30,r6,1		# didIdentifier=r30 periodicDidMoveIndex=r6
.Llo1757:
	se_addi		r6,1		# periodicDidMoveIndex=r6 periodicDidMoveIndex=r6
	b		.L2698
	.section	.text_vle
.L4503:
.L2697:
#             break;
#          }
#       }
	.d2line		13105
.Llo1758:
	diab.addi		r31,r6,1		# periodicDidIndex=r6
	se_addi		r6,1		# periodicDidIndex=r6 periodicDidIndex=r6
	b		.L2694
.L2701:
	.section	.text_vle
.L4495:
#    }
	.d2line		13106
.Llo1751:
	diab.addi		r6,r4,1		# periodicDidIndex=r6 didIndex=r4
	se_addi		r4,1		# didIndex=r4 didIndex=r4
	b		.L2691
.L2693:
# 
#    return numFound;
	.d2line		13108
.Llo1746:
	rlwinm		r3,r5,0,16,31		# numFound=r5
# }
	.d2line		13109
	.d2epilogue_begin
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# numRequested=r0
	mtspr		lr,r0		# numRequested=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1748:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4486:
	.type		StopSomeDIDs,@function
	.size		StopSomeDIDs,.-StopSomeDIDs
# Number of nodes = 110

# Allocations for StopSomeDIDs
#	?a4		pRequestedDids
#	?a5		numRequested
#	?a6		$$105
#	?a7		didIndex
#	?a8		numFound
#	?a9		periodicDidIndex
#	?a10		didIdentifier
#	?a11		periodicDidMoveIndex
# static FUNC(void, DCM_CODE) StartPeriodicTransmission(void)
	.align		1
	.section	.text_vle
        .d2line         13125,29
#$$ld
.L4510:

#$$bf	StartPeriodicTransmission,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
StartPeriodicTransmission:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    ResetPeriodicStatusVariables();
	.d2line		13127
	bl		ResetPeriodicStatusVariables
#    Dcm_DspInstance.periodic_status.state = PERIODIC_ON_PROGRESS;
	.d2line		13128
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+224)@ha
	stw		r0,(Dcm_DspInstance+224)@l(r3)
#    Dcm_DspInstance.periodic_status.timer_expired = FALSE;
	.d2line		13129
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+208)@ha
	stb		r0,(Dcm_DspInstance+208)@l(r3)
#    TimerStart(Dcm_DspInstance.periodic_status.active_timer, Dcm_DspInstance.periodic_status.rate);
	.d2line		13130
	bl		SchM_Enter_Dcm_EaTimers
	lis		r3,(Dcm_DspInstance+210)@ha
	lhz		r0,(Dcm_DspInstance+210)@l(r3)
	lis		r3,(Dcm_DspInstance+212)@ha
	sth		r0,(Dcm_DspInstance+212)@l(r3)
	bl		SchM_Exit_Dcm_EaTimers
# }
	.d2line		13131
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4511:
	.type		StartPeriodicTransmission,@function
	.size		StartPeriodicTransmission,.-StartPeriodicTransmission
# Number of nodes = 31

# Allocations for StartPeriodicTransmission
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ReadDataByPeriodicIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         4460,32
#$$ld
.L4515:

#$$bf	Dcm_ReadDataByPeriodicIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_ReadDataByPeriodicIdentifier
	.d2_cfa_start __cie
Dcm_ReadDataByPeriodicIdentifier:
.Llo1760:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	26,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    /* Each DID is two bytes */
#    Dcm_MsgLenType i;
#    uint16 didIndex;
#    P2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus = &Dcm_DspInstance.periodic_status;
	.d2line		4465
	lis		r28,(Dcm_DspInstance+208)@ha
	e_add16i		r28,r28,(Dcm_DspInstance+208)@l
.Llo1776:
	mr		r28,r28		# pStatus=r28 pStatus=r28
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
# 
#    /*
#     * It is safe to access the first element in the array at this point, since Dcm_ReadDataByPeriodicIdentifier() is
#     * always called with a valid buffer. (Although the value can still be garbage).
#     */
#    uint8 const requestedTransmissionMode = pMsgContext->reqData[0];
	.d2line		4473
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r27,0(r3)
.Llo1779:
	mr		r27,r27		# requestedTransmissionMode=r27 requestedTransmissionMode=r27
# 
#    pMsgContext->resDataLen = 0;
	.d2line		4475
	diab.li		r0,0
	sth		r0,12(r31)		# pMsgContext=r31
# 
#    /*
#     * At least transmission mode has to be requested.
#     * A request shall never exceed 257 bytes: transmission mode plus 256 DIDs (0xF200 -> 0xF2FF)
#     */
#    if ((0 == pMsgContext->reqDataLen) || (pMsgContext->reqDataLen > 257))
	.d2line		4481
	lhz		r0,4(r31)		# pMsgContext=r31
	se_cmpi		r0,0
	bc		1,2,.L1037	# eq
.Llo1761:
	lhz		r0,4(r31)		# pMsgContext=r31
.Llo1762:
	cmpi		0,0,r0,257
	bc		0,1,.L995	# le
.L1037:
#    {
#       /* The request is too short for any request. */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4484
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L995:
#    }
#    /*
#     * At least we have a transmission mode
#     */
#    else if ((0 == requestedTransmissionMode) || (requestedTransmissionMode > (uint8)4U))
	.d2line		4489
	rlwinm		r0,r27,0,24,31		# requestedTransmissionMode=r27
	se_cmpi		r0,0
	bc		1,2,.L1038	# eq
	rlwinm		r0,r27,0,24,31		# requestedTransmissionMode=r27
	se_cmpi		r0,4
	bc		0,1,.L997	# le
.L1038:
#    {
#       /* Invalid transmission mode */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4492
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L997:
#    }
#    else if (1 == pMsgContext->reqDataLen)
	.d2line		4494
	lhz		r0,4(r31)		# pMsgContext=r31
	se_cmpi		r0,1
	bc		0,2,.L999	# ne
#    {
#       if (DCM_PERIODIC_MODE_STOP != requestedTransmissionMode)
	.d2line		4496
	rlwinm		r27,r27,0,24,31		# requestedTransmissionMode=r27 requestedTransmissionMode=r27
	se_cmpi		r27,4		# requestedTransmissionMode=r27
	bc		1,2,.L1000	# eq
#       {
#          /*
#           * The request has a transmission mode which is not stop.
#           * However there is no any DID in the request message.
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4502
.Llo1763:
	diab.li		r0,19
.Llo1764:
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L1000:
#       }
#       else if (!AllSentSamplesConfirmed(pStatus))
	.d2line		4504
	mr		r3,r28		# pStatus=r3 pStatus=r28
	bl		AllSentSamplesConfirmed
.Llo1765:
	e_andi.		r3,r3,255
	bc		0,2,.L1002	# ne
#       {
#          /*
#           * Clear Dsl tx channel after all
#           * confirmations are received.
#           */
#          TimerStop(pStatus->active_timer);
	.d2line		4510
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535
	sth		r0,4(r28)		# pStatus=r28
	bl		SchM_Exit_Dcm_EaTimers
#          pStatus->state = PERIODIC_WAIT_TO_STOP;
	.d2line		4511
	diab.li		r0,2
	stw		r0,16(r28)		# pStatus=r28
	b		.L996
.L1002:
#       }
#       else
#       {
#          Dcm_DspResetPeriodicTransmission();
	.d2line		4515
	bl		Dcm_DspResetPeriodicTransmission
	b		.L996
.L999:
#       }
#    }
#    else if (DCM_PERIODIC_MODE_STOP == requestedTransmissionMode)
	.d2line		4518
.Llo1766:
	rlwinm		r0,r27,0,24,31		# requestedTransmissionMode=r27
	se_cmpi		r0,4
	bc		0,2,.L1006	# ne
	.section	.text_vle
.L4530:
#    {
#        /*
#         * 1 is removed since that requested Transmission Mode is in the first.
#         */
#       uint16 const numStoppedDids = StopSomeDIDs(&pMsgContext->reqData[1], (uint16)(pMsgContext->reqDataLen - 1));
	.d2line		4523
.Llo1780:
	lhz		r0,4(r31)		# numStoppedDids=r0 pMsgContext=r31
.Llo1784:
	diab.li		r4,65535
	se_add		r4,r0		# numStoppedDids=r0
	lwz		r3,0(r31)		# numStoppedDids=r3 pMsgContext=r31
	se_addi		r3,1		# numStoppedDids=r3 numStoppedDids=r3
	bl		StopSomeDIDs
.Llo1785:
	mr		r0,r3		# numStoppedDids=r0 numStoppedDids=r3
# 
#       if (0 == numStoppedDids)
	.d2line		4525
.Llo1786:
	rlwinm		r3,r3,0,16,31		# numStoppedDids=r3 numStoppedDids=r3
.Llo1787:
	se_cmpi		r3,0		# numStoppedDids=r3
.Llo1788:
	bc		0,2,.L1007	# ne
#       {
#          if (0 == CountConfiguredPeriodicDids(&pMsgContext->reqData[1], (uint16)(pMsgContext->reqDataLen - 1)))
	.d2line		4527
.Llo1789:
	lhz		r0,4(r31)		# numStoppedDids=r0 pMsgContext=r31
.Llo1790:
	diab.li		r4,65535
	se_add		r4,r0		# numStoppedDids=r0
	lwz		r3,0(r31)		# numStoppedDids=r3 pMsgContext=r31
	se_addi		r3,1		# numStoppedDids=r3 numStoppedDids=r3
	bl		CountConfiguredPeriodicDids
.Llo1791:
	e_and2i.		r3,65535		# numStoppedDids=r3
.Llo1792:
	bc		0,2,.L996	# ne
#          {
#             /*
#              * SS-ISO 14229-2006:
#              * requestOutOfRange shall be sent if
#              * none of the requested periodicDataIdentifier values are supported by the device,
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4534
.Llo1767:
	diab.li		r0,49		# numStoppedDids=r0
.Llo1793:
	stb		r0,0(r30)		# pErrorCode=r30 numStoppedDids=r0
	b		.L996
.L1007:
#          }
#          else
#          {
#             /*
#              * SS-ISO 14229-2006:
#              * Upon receiving a ReadDataByPeriodicIdentifier request other than stopSending, the server shall check
#              * whether the conditions are correct to execute the service.
#              *
#              * None of the requested Dids is active. Just send a positive response
#              */
#          }
#       }
#       else if (numStoppedDids == pStatus->num_periodic_id)
	.d2line		4547
.Llo1768:
	rlwinm		r3,r0,0,16,31		# numStoppedDids=r3 numStoppedDids=r0
	lhz		r4,6(r28)		# pStatus=r28
	se_cmp		r3,r4		# numStoppedDids=r3
	bc		0,2,.L1011	# ne
#       {
#          pStatus->num_periodic_id = 0;
	.d2line		4549
.Llo1769:
	diab.li		r0,0		# numStoppedDids=r0
.Llo1794:
	sth		r0,6(r28)		# pStatus=r28 numStoppedDids=r0
# 
#          if (!AllSentSamplesConfirmed(pStatus))
	.d2line		4551
	mr		r3,r28		# pStatus=r3 pStatus=r28
	bl		AllSentSamplesConfirmed
.Llo1795:
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
	se_cmpi		r3,0		# pStatus=r3
	bc		0,2,.L1012	# ne
#          {
#             /*
#              * All DIDs removed, stop the periodic transmission when all confirmations are received.
#              */
#             TimerStop(pStatus->active_timer);
	.d2line		4556
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535		# numStoppedDids=r0
.Llo1796:
	sth		r0,4(r28)		# pStatus=r28 numStoppedDids=r0
	bl		SchM_Exit_Dcm_EaTimers
#             pStatus->state = PERIODIC_WAIT_TO_STOP;
	.d2line		4557
.Llo1797:
	diab.li		r0,2		# numStoppedDids=r0
.Llo1798:
	stw		r0,16(r28)		# pStatus=r28 numStoppedDids=r0
	b		.L996
.L1012:
#          }
#          else
#          {
#             /*
#              * All DIDs removed, just clear the periodic transmission.
#              */
#             Dcm_DspResetPeriodicTransmission();
	.d2line		4564
.Llo1799:
	bl		Dcm_DspResetPeriodicTransmission
	b		.L996
.L1011:
#          }
#       }
#       else
#       {
#          pStatus->num_periodic_id -= numStoppedDids;
	.d2line		4569
	lhz		r3,6(r28)		# numStoppedDids=r3 pStatus=r28
.Llo1800:
	subf		r0,r0,r3		# numStoppedDids=r0 numStoppedDids=r0 numStoppedDids=r3
	sth		r0,6(r28)		# pStatus=r28 numStoppedDids=r0
# 
#          if (!AllSentSamplesConfirmed(pStatus))
	.d2line		4571
	mr		r3,r28		# pStatus=r3 pStatus=r28
	bl		AllSentSamplesConfirmed
.Llo1801:
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
	se_cmpi		r3,0		# pStatus=r3
	bc		0,2,.L1016	# ne
#          {
#             /*
#              * Some DIDs to be stopped.
#              * Do not start to collect samples until all confirmations have been received.
#              */
#             TimerStop(pStatus->active_timer);
	.d2line		4577
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535		# numStoppedDids=r0
.Llo1802:
	sth		r0,4(r28)		# pStatus=r28 numStoppedDids=r0
	bl		SchM_Exit_Dcm_EaTimers
#             pStatus->state = PERIODIC_WAIT_TO_RESTART;
	.d2line		4578
.Llo1803:
	diab.li		r0,3		# numStoppedDids=r0
.Llo1804:
	stw		r0,16(r28)		# pStatus=r28 numStoppedDids=r0
	b		.L996
.L1016:
#          }
#          else
#          {
#             /*
#              * Some DIDs to be stopped.
#              * Start the new periodic transmission right away since DSP is not
#              * waiting for any confirmation.
#              */
#             StartPeriodicTransmission();
	.d2line		4587
.Llo1805:
	bl		StartPeriodicTransmission
	.section	.text_vle
.L4531:
.Llo1777:
	b		.L996
.L1006:
	.section	.text_vle
.L4536:
#          }
#       }
#    }
#    else
#    {
#       uint16 numValidId = 0;
	.d2line		4593
.Llo1770:
	diab.li		r26,0		# numValidId=r26
# 
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * [SWS_Dcm_00339] : E_OK shall always be returned.
#        * [SWS_Dcm_00338] : E_OK shall always be returned.
#        */
#       (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		4601
.Llo1806:
	diab.addi		r3,r1,8
	bl		Dcm_GetSesCtrlType
#       (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		4602
	diab.addi		r3,r1,9
	bl		Dcm_GetSecurityLevel
# 
#       /*
#        * There are some periodic DIDs to started
#        * We should only store valid dids.
#        */
#       for (i = 1U; i < pMsgContext->reqDataLen; i++)
	.d2line		4608
	diab.li		r29,1		# i=r29
.L1020:
.Llo1775:
	rlwinm		r0,r29,0,16,31		# i=r29
	lhz		r3,4(r31)		# pMsgContext=r31
	se_cmp		r0,r3
	bc		0,0,.L1022	# ge
#       {
#          if (IsValidPeriodicDid(activeSession, activeSecurityLevel, pMsgContext->reqData[i], &didIndex, numValidId))
	.d2line		4610
	lwz		r3,0(r31)		# pMsgContext=r31
	rlwinm		r0,r29,0,16,31		# i=r29
	lbzx		r5,r3,r0
	lbz		r3,8(r1)
	lbz		r4,9(r1)
	diab.addi		r6,r1,10
	mr		r7,r26		# numValidId=r7 numValidId=r26
	bl		IsValidPeriodicDid
	e_andi.		r3,r3,255
	bc		1,2,.L1023	# eq
#          {
#             /*
#              * If the didIdentifier is valid (configured and not stored already,
#              * store the index of the DID.
#              */
#             Dcm_LCfg.requested_periodicDids[numValidId] = didIndex;
	.d2line		4616
	lhz		r0,10(r1)
	lis		r3,(Dcm_LCfg+80)@ha
	lwz		r3,(Dcm_LCfg+80)@l(r3)
	rlwinm		r7,r26,1,15,30		# numValidId=r7 numValidId=r26
	sthx		r0,r3,r7
#             numValidId++;
	.d2line		4617
	diab.addi		r7,r26,1		# numValidId=r7 numValidId=r26
	se_addi		r26,1		# numValidId=r26 numValidId=r26
.L1023:
#          }
#       }
	.d2line		4619
	diab.addi		r0,r29,1		# i=r29
	se_addi		r29,1		# i=r29 i=r29
	b		.L1020
.L1022:
# 
#       /*
#        * Get the transmission rate in ticks. 
#        * If the transmission rate is supported (!0) or not (0) is checked later.
#        * The periodic transmission rates are always present, but maybe not supported (0).
#        * The requestedTransmissionMode is checked above so it's always a valid number (1 .. 3).
#        */
#       pStatus->rate = Dcm_LCfg.periodic_transmission_rates[requestedTransmissionMode - (uint8)1U];
	.d2line		4627
.Llo1781:
	lis		r3,(Dcm_LCfg+8)@ha
	e_add16i		r3,r3,(Dcm_LCfg+8)@l
.Llo1782:
	rlwinm		r27,r27,1,23,30		# requestedTransmissionMode=r27 requestedTransmissionMode=r27
.Llo1783:
	lhzx		r0,r3,r27
	sth		r0,2(r28)		# pStatus=r28
# 
#       if (0 == numValidId)
	.d2line		4629
	rlwinm		r7,r26,0,16,31		# numValidId=r7 numValidId=r26
	se_cmpi		r7,0		# numValidId=r7
	bc		0,2,.L1024	# ne
#       {
#          /*
#           * No valid periodic id
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4634
.Llo1771:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L1024:
#       }
#       else if (PERIODIC_IDLE == pStatus->state)
	.d2line		4636
	lwz		r0,16(r28)		# pStatus=r28
	se_cmpi		r0,0
	bc		0,2,.L1026	# ne
#       {
#          if (E_OK != Dcm_DslSetPeriodicTxConnection())
	.d2line		4638
	bl		Dcm_DslSetPeriodicTxConnection
	e_andi.		r3,r3,255
	bc		1,2,.L1027	# eq
#          {
#             /*
#              * No active periodic tx available
#              */
#             *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		4643
	diab.li		r0,34
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L1027:
#          }
#          else if ((uint16)0x00U == pStatus->rate)
	.d2line		4645
	lhz		r0,2(r28)		# pStatus=r28
	se_cmpi		r0,0
	bc		0,2,.L1029	# ne
#          {
#             /* Transmission mode is not configured.*/
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4648
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L1029:
#          }
#          else
#          {
#             /*
#              * Success, set some status variables and start the timer before next sample
#              */
#             pStatus->num_periodic_id = numValidId;
	.d2line		4655
	sth		r26,6(r28)		# pStatus=r28 numValidId=r26
# 
#             StartPeriodicTransmission();
	.d2line		4657
	bl		StartPeriodicTransmission
	b		.L996
.L1026:
#          }
#       }
#       /*
#        * There is ongoing periodic transmission.
#        * Check if the new rate is configured.
#        */
#       else if ((uint16)0x00U == pStatus->rate)
	.d2line		4664
	lhz		r0,2(r28)		# pStatus=r28
	se_cmpi		r0,0
	bc		0,2,.L1032	# ne
#       {
#          /* Transmission mode is not configured.*/
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4667
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L996
.L1032:
#       }
#       else if (!AllSentSamplesConfirmed(pStatus))
	.d2line		4669
	mr		r3,r28		# pStatus=r3 pStatus=r28
	bl		AllSentSamplesConfirmed
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
	se_cmpi		r3,0		# pStatus=r3
	bc		0,2,.L1034	# ne
#       {
#          /*
#           * Some out standing DSL confirmation
#           * Just store all information, start until all confirmations have been received.
#           */
#          TimerStop(pStatus->active_timer);
	.d2line		4675
	bl		SchM_Enter_Dcm_EaTimers
	diab.li		r0,65535
	sth		r0,4(r28)		# pStatus=r28
	bl		SchM_Exit_Dcm_EaTimers
#          pStatus->state = PERIODIC_WAIT_TO_RESTART;
	.d2line		4676
	diab.li		r0,3
	stw		r0,16(r28)		# pStatus=r28
# 
#          pStatus->num_periodic_id = numValidId;
	.d2line		4678
	sth		r26,6(r28)		# pStatus=r28 numValidId=r26
#          pStatus->next_did_to_be_sent = 0;
	.d2line		4679
	diab.li		r0,0
	sth		r0,8(r28)		# pStatus=r28
	b		.L996
.L1034:
#       }
#       else
#       {
#          /*
#           * No any unconfirmed datatransmission.
#           * Just start new transmission.
#           */
#          pStatus->num_periodic_id = numValidId;
	.d2line		4687
	sth		r26,6(r28)		# pStatus=r28 numValidId=r26
# 
#          StartPeriodicTransmission();
	.d2line		4689
	bl		StartPeriodicTransmission
	.section	.text_vle
.L4537:
.L996:
#       }
# 
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		4694
.Llo1772:
	lbz		r3,0(r30)		# numStoppedDids=r3 pErrorCode=r30
.Llo1774:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo1773:
	rlwinm		r3,r3,0,24,31		# pStatus=r3 pStatus=r3
# }
	.d2line		4695
	.d2epilogue_begin
.Llo1778:
	lmw		r26,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	2,10
	lwz		r0,52(r1)		# numStoppedDids=r0
	mtspr		lr,r0		# numStoppedDids=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4516:
	.type		Dcm_ReadDataByPeriodicIdentifier,@function
	.size		Dcm_ReadDataByPeriodicIdentifier,.-Dcm_ReadDataByPeriodicIdentifier
# Number of nodes = 405

# Allocations for Dcm_ReadDataByPeriodicIdentifier
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		i
#	SP,10		didIndex
#	?a7		pStatus
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	?a8		requestedTransmissionMode
#	?a9		numStoppedDids
#	?a10		numValidId
# FUNC(void, DCM_CODE) Dcm_DspConfirmPeriodicTxData(void)
	.align		2
	.section	.text_vle
        .d2line         4700,22
#$$ld
.L4544:

#$$bf	Dcm_DspConfirmPeriodicTxData,interprocedural,rasave,nostackparams
	.globl		Dcm_DspConfirmPeriodicTxData
	.d2_cfa_start __cie
Dcm_DspConfirmPeriodicTxData:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	.d2prologue_end
# {
#    P2VAR(DspPeriodicStatusType, AUTOMATIC, DCM_APPL_DATA) pPeriodicStatus;
# 
#    pPeriodicStatus = &Dcm_DspInstance.periodic_status;
	.d2line		4704
	lis		r5,(Dcm_DspInstance+208)@ha
	e_add16i		r5,r5,(Dcm_DspInstance+208)@l
.Llo1807:
	mr		r5,r5		# pPeriodicStatus=r5 pPeriodicStatus=r5
# 
#    if (FALSE == AllSentSamplesConfirmed(pPeriodicStatus))
	.d2line		4706
	mr		r3,r5		# pPeriodicStatus=r3 pPeriodicStatus=r5
	bl		AllSentSamplesConfirmed
	e_andi.		r3,r3,255
	bc		0,2,.L1063	# ne
#    {
#       pPeriodicStatus->num_confirmed_sent_dids++;
	.d2line		4708
	lhz		r3,12(r5)		# pPeriodicStatus=r5
	se_addi		r3,1
	sth		r3,12(r5)		# pPeriodicStatus=r5
.L1063:
#    }
#    else
#    {
#       /*
#        * Wrong confirmation, just ignore.
#        */
#    }
# 
#    if (FALSE == AllSentSamplesConfirmed(pPeriodicStatus))
	.d2line		4717
	mr		r3,r5		# pPeriodicStatus=r3 pPeriodicStatus=r5
	bl		AllSentSamplesConfirmed
	rlwinm		r3,r3,0,24,31		# pPeriodicStatus=r3 pPeriodicStatus=r3
	se_cmpi		r3,0		# pPeriodicStatus=r3
	bc		1,2,.L1061	# eq
#    {
#       /*
#        * Wait for more confirmation.
#        * Reading, sending more DIDs at the next schedule.
#        */
#    }
#    else if (PERIODIC_WAIT_TO_STOP == pPeriodicStatus->state)
	.d2line		4724
	lwz		r0,16(r5)		# pPeriodicStatus=r5
	se_cmpi		r0,2
	bc		0,2,.L1066	# ne
#    {
#       /*
#        * All sent samples have been confirmed.
#        * Now it is Ok to stop.
#        */
#       Dcm_DspResetPeriodicTransmission();
	.d2line		4730
.Llo1808:
	bl		Dcm_DspResetPeriodicTransmission
	b		.L1061
.L1066:
# 
#    }
#    else if (PERIODIC_WAIT_TO_RESTART == pPeriodicStatus->state)
	.d2line		4733
.Llo1809:
	lwz		r0,16(r5)		# pPeriodicStatus=r5
	se_cmpi		r0,3
	bc		0,2,.L1068	# ne
#    {
#       /*
#        * All sent samples have been confirmed.
#        * Retart the peoridic transmission with new parameters.
#        */
#       StartPeriodicTransmission();
	.d2line		4739
.Llo1810:
	bl		StartPeriodicTransmission
	b		.L1061
.L1068:
# 
#    }
#    else if (FALSE != AllPeriodicDIDsSent(pPeriodicStatus))
	.d2line		4742
.Llo1811:
	mr		r3,r5		# pPeriodicStatus=r3 pPeriodicStatus=r5
	bl		AllPeriodicDIDsSent
	rlwinm		r3,r3,0,24,31		# pPeriodicStatus=r3 pPeriodicStatus=r3
	se_cmpi		r3,0		# pPeriodicStatus=r3
	bc		1,2,.L1061	# eq
#    {
#       /*
#        * All DIDs have been sent and confirmed.
#        * Reset the parameters.
#        */
#       ResetPeriodicStatusVariables();
	.d2line		4748
.Llo1812:
	bl		ResetPeriodicStatusVariables
#       Dcm_DspInstance.periodic_status.state = PERIODIC_ON_PROGRESS;
	.d2line		4749
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+224)@ha		# pPeriodicStatus=r3
.Llo1813:
	stw		r0,(Dcm_DspInstance+224)@l(r3)		# pPeriodicStatus=r3
.L1061:
#    }
#    else
#    {
#       /*
#        * Reading, sending the rest DIDs at the next schedule.
#        */
#    }
# }
	.d2line		4757
	.d2epilogue_begin
.Llo1814:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4545:
	.type		Dcm_DspConfirmPeriodicTxData,@function
	.size		Dcm_DspConfirmPeriodicTxData,.-Dcm_DspConfirmPeriodicTxData
# Number of nodes = 63

# Allocations for Dcm_DspConfirmPeriodicTxData
#	?a4		pPeriodicStatus
# static FUNC(Dcm_Cfg_DidPointerType, DCM_CODE) GetSourceDid(uint16 didIdentifier,
	.align		1
	.section	.text_vle
        .d2line         13810,47
#$$ld
.L4551:

#$$bf	GetSourceDid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GetSourceDid:
.Llo1815:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# didIdentifier=r3 didIdentifier=r3
	mr		r0,r4		# activeSession=r0 activeSession=r4
	mr		r31,r5		# activeSecurityLevel=r31 activeSecurityLevel=r5
	mr		r30,r6		# pErrorCode=r30 pErrorCode=r6
	.d2prologue_end
#                                                            Dcm_SesCtrlType activeSession,
#                                                            Dcm_SecLevelType activeSecurityLevel,
#                                                            CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    uint16                        confDidCounter;
#    P2CONST(Dcm_Cfg_DidType, AUTOMATIC, DCM_APPL_DATA) pSrcDid = 0;
	.d2line		13816
	diab.li		r29,0		# pSrcDid=r29
# 
#    /*
#     * Try to find a matching DID in the configuration
#     */
#    for (confDidCounter = 0; (NULL_PTR == pSrcDid) && (confDidCounter < Dcm_LCfg.num_dids); confDidCounter++)
	.d2line		13821
	diab.li		r4,0
.L2866:
.Llo1831:
	se_cmpi		r29,0		# pSrcDid=r29
.Llo1832:
	bc		0,2,.L2868	# ne
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	lis		r5,(Dcm_LCfg+64)@ha
	lhz		r5,(Dcm_LCfg+64)@l(r5)
	se_cmp		r6,r5
	bc		0,0,.L2868	# ge
#    {
#       if ((Dcm_LCfg.dids[confDidCounter].identifier == didIdentifier) && (NULL_PTR != Dcm_LCfg.dids[confDidCounter].pDidRead))
	.d2line		13823
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r7,r6,5,0,26
	se_slwi		r6,2
	subf		r6,r6,r7
	lhzx		r6,r5,r6
	rlwinm		r5,r3,0,16,31		# didIdentifier=r3
	se_cmp		r6,r5
	bc		0,2,.L2869	# ne
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r5,(Dcm_LCfg+68)@l(r5)
	rlwinm		r7,r6,5,0,26
	se_slwi		r6,2
	subf		r6,r6,r7
	se_add		r5,r6
	lwz		r5,12(r5)
	se_cmpi		r5,0
	bc		1,2,.L2869	# eq
#       {
#          pSrcDid = &Dcm_LCfg.dids[confDidCounter];
	.d2line		13825
	rlwinm		r6,r4,0,16,31		# confDidCounter=r4
	lis		r5,(Dcm_LCfg+68)@ha
	lwz		r29,(Dcm_LCfg+68)@l(r5)		# pSrcDid=r29
	rlwinm		r5,r6,5,0,26
	se_slwi		r6,2
	subf		r6,r6,r5
	se_add		r6,r29		# pSrcDid=r29
	mr		r29,r6		# pSrcDid=r29 pSrcDid=r6
.L2869:
#       }
#    }
	.d2line		13827
	diab.addi		r6,r4,1		# confDidCounter=r4
	se_addi		r4,1		# confDidCounter=r4 confDidCounter=r4
	b		.L2866
.L2868:
# 
#    /*
#     * 1. Was the DID found amongst the configured ones?
#     */
#    if (NULL_PTR == pSrcDid)
	.d2line		13832
	se_cmpi		r29,0		# pSrcDid=r29
	bc		0,2,.L2870	# ne
#    {
#       /*
#        * The requested DID was not found. Report an error and break.
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13837
.Llo1816:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L2871
.L2870:
#    }
#    /*
#     * 2. Can the DID be read in the current session?
#     */
#    else if (!Dcm_IsLevelSupported(activeSession, pSrcDid->pDidRead->p_session_levels))
	.d2line		13842
.Llo1833:
	lwz		r3,12(r29)		# didIdentifier=r3 pSrcDid=r29
.Llo1817:
	lwz		r4,16(r3)		# confDidCounter=r4 didIdentifier=r3
	rlwinm		r3,r0,0,24,31		# didIdentifier=r3 activeSession=r0
.Llo1818:
	bl		Dcm_IsLevelSupported
.Llo1819:
	e_andi.		r3,r3,255		# didIdentifier=r3 didIdentifier=r3
.Llo1820:
	bc		0,2,.L2872	# ne
#    {
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13844
	diab.li		r0,49		# activeSession=r0
.Llo1834:
	stb		r0,0(r30)		# pErrorCode=r30 activeSession=r0
	b		.L2871
.L2872:
#    }
#    /*
#     * 3. Can the DID be read in the current security level?
#     */
#    else if (!Dcm_IsLevelSupported(activeSecurityLevel, pSrcDid->pDidRead->p_security_levels))
	.d2line		13849
.Llo1835:
	lwz		r3,12(r29)		# didIdentifier=r3 pSrcDid=r29
.Llo1821:
	lwz		r4,12(r3)		# confDidCounter=r4 didIdentifier=r3
	rlwinm		r3,r31,0,24,31		# didIdentifier=r3 activeSecurityLevel=r31
.Llo1822:
	bl		Dcm_IsLevelSupported
.Llo1823:
	e_andi.		r3,r3,255		# didIdentifier=r3 didIdentifier=r3
.Llo1824:
	bc		0,2,.L2874	# ne
#    {
#       *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		13851
.Llo1847:
	diab.li		r0,51		# activeSession=r0
.Llo1836:
	stb		r0,0(r30)		# pErrorCode=r30 activeSession=r0
	b		.L2871
.L2874:
#    }
#    /*
#     * 4. [SWS_Dcm_00821]: if the requested Source-DID is supported in the current mode condition
#     */
#    else if (!Dcm_IsCurrentModesAllowed(pSrcDid->pDidRead->modeRuleFunc, pErrorCode))
	.d2line		13856
.Llo1837:
	lwz		r3,12(r29)		# didIdentifier=r3 pSrcDid=r29
.Llo1825:
	lwz		r3,20(r3)		# didIdentifier=r3 didIdentifier=r3
.Llo1826:
	mr		r4,r30		# pErrorCode=r4 pErrorCode=r30
	bl		Dcm_IsCurrentModesAllowed
.Llo1827:
	e_andi.		r3,r3,255		# didIdentifier=r3 didIdentifier=r3
.Llo1828:
	bc		0,2,.L2876	# ne
#    {
#       /*
#        * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#        */
#       HandleNrcResponsePending(*pErrorCode);
	.d2line		13861
	lbz		r0,0(r30)		# activeSession=r0 pErrorCode=r30
.Llo1838:
	cmpi		0,0,r0,120		# activeSession=r0
	bc		0,2,.L2880	# ne
.Llo1839:
	diab.li		r0,162		# activeSession=r0
.Llo1840:
	b		.L2881
.L2880:
.Llo1841:
	lbz		r0,0(r30)		# activeSession=r0 pErrorCode=r30
.L2881:
.Llo1842:
	stb		r0,0(r30)		# pErrorCode=r30 activeSession=r0
	b		.L2871
.L2876:
#    }
#    else if (NULL_PTR != pSrcDid->pDidRead->ReadDataLengthFunc)
	.d2line		13863
.Llo1843:
	lwz		r3,12(r29)		# didIdentifier=r3 pSrcDid=r29
.Llo1829:
	lwz		r0,4(r3)		# activeSession=r0 didIdentifier=r3
.Llo1844:
	se_cmpi		r0,0		# activeSession=r0
	bc		1,2,.L2871	# eq
#    {
#       /*
#        * A DID with dynamic length is not allowed.
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13868
.Llo1830:
	diab.li		r0,49		# activeSession=r0
.Llo1845:
	stb		r0,0(r30)		# pErrorCode=r30 activeSession=r0
.L2871:
#    }
#    else
#    {
#       /* Source DID is OK. */
#    }
# 
#    return pSrcDid;
	.d2line		13875
.Llo1846:
	mr		r3,r29		# pSrcDid=r3 pSrcDid=r29
# }
	.d2line		13876
	.d2epilogue_begin
.Llo1849:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
.Llo1850:
	lwz		r0,36(r1)		# activeSession=r0
	mtspr		lr,r0		# activeSession=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1848:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4552:
	.type		GetSourceDid,@function
	.size		GetSourceDid,.-GetSourceDid
# Number of nodes = 161

# Allocations for GetSourceDid
#	?a4		didIdentifier
#	?a5		activeSession
#	?a6		activeSecurityLevel
#	?a7		pErrorCode
#	?a8		$$108
#	?a9		$$107
#	?a10		$$106
#	?a11		$$67
#	?a12		confDidCounter
#	?a13		pSrcDid
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) DefineDDDidByIdentifier(CONSTP2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid,
	.align		1
	.section	.text_vle
        .d2line         13881,53
#$$ld
.L4565:

#$$bf	DefineDDDidByIdentifier,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
DefineDDDidByIdentifier:
.Llo1851:
	stwu		r1,-80(r1)		
	.d2_cfa_def_cfa_offset	80
	mfspr		r0,lr
.Llo1867:
	stmw		r19,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	19,31,1,1
	stw		r0,84(r1)		# lengthSource=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pDid=r31 pDid=r3
.Llo1852:
	mr		r30,r4		# activeSession=r30 activeSession=r4
.Llo1853:
	mr		r29,r5		# activeSecurityLevel=r29 activeSecurityLevel=r5
	mr		r28,r6		# pMsgContext=r28 pMsgContext=r6
	.d2prologue_end
#                                                                             Dcm_SesCtrlType activeSession,
#                                                                             Dcm_SecLevelType activeSecurityLevel,
#                                                                             CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
# {
#    CONST(uint8, DCM_CONST) numRequestedSources = (uint8)((pMsgContext->reqDataLen - 3) / 4); /* Safe cast since the number of requested sources can not be more than 256. */
#    CONST(uint16, DCM_CONST) lengthSource = (uint16)(pMsgContext->reqDataLen - 3); /* Safe cast since the caller has handled the case of less than three. */
#    uint16  i;
#    uint8 numStoredSources;
#    uint8 positionSourceRecord;
#    uint8 sizeOfMemory;
#    uint16 sourceId;
#    uint16 sizeOfSrcDid = 0;
	.d2line		13893
	diab.li		r0,0		# lengthSource=r0
.Llo1946:
	sth		r0,10(r1)		# lengthSource=r0
#    uint32 totalLength = 0;
	.d2line		13894
	mr		r22,r0		# totalLength=r22 totalLength=r0
#    Dcm_Cfg_DidPointerType pSrcDid = NULL_PTR;
	.d2line		13895
.Llo1948:
	mr		r9,r22		# pSrcDid=r9 pSrcDid=r22
#    P2VAR(Dcm_Cfg_DDDDidSourceType, AUTOMATIC, DCM_APPL_DATA) pDataSource;
#    boolean isVehInfo = FALSE;
	.d2line		13897
.Llo1952:
	mr		r21,r9		# isVehInfo=r21 isVehInfo=r9
# 
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		13899
	stb		r0,8(r1)		# lengthSource=r0
	.d2line		13886
	lhz		r3,4(r28)		# pMsgContext=r28
	diab.addi		r0,r3,-3		# lengthSource=r0
.Llo1947:
	srawi		r0,r0,2		# lengthSource=r0 lengthSource=r0
	addze		r27,r0		# lengthSource=r0
.Llo1866:
	mr		r27,r27		# numRequestedSources=r27 numRequestedSources=r27
	.d2line		13887
	diab.li		r0,65533		# lengthSource=r0
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0
	mr		r0,r0		# lengthSource=r0 lengthSource=r0
# 
#    /* Remove sub-function (1 byte), dynamicallyDefinedDataIdentifie (2 bytes) */
#    CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_CONST) pSourceDids = &pMsgContext->reqData[3];
	.d2line		13902
	lwz		r20,0(r28)		# pMsgContext=r28
	diab.addi		r20,r20,3
.Llo1953:
	mr		r20,r20		# pSourceDids=r20 pSourceDids=r20
# 
#    /* fetch the currently stored data sources */
#    numStoredSources = *(pDid->pNumberOfDefinedSources);
	.d2line		13905
	lwz		r3,16(r31)		# pDid=r31
	lbz		r26,0(r3)
.Llo1921:
	mr		r26,r26		# numStoredSources=r26 numStoredSources=r26
# 
#    if ((uint16)0U != (uint16)(lengthSource % 4U))
	.d2line		13907
	rlwinm		r0,r0,0,30,31		# lengthSource=r0 lengthSource=r0
	e_and2i.		r0,65535		# lengthSource=r0
	bc		1,2,.L2893	# eq
#    {
#       ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		13909
.Llo1855:
	diab.li		r0,19		# lengthSource=r0
.Llo1856:
	stb		r0,8(r1)		# lengthSource=r0
	b		.L2894
.L2893:
#    }
#    else if ( numRequestedSources > (pDid->pDDDidInfo->max_no_of_requested_sources - numStoredSources))
	.d2line		13911
.Llo1868:
	rlwinm		r0,r27,0,24,31		# lengthSource=r0 numRequestedSources=r27
.Llo1869:
	lwz		r3,4(r31)		# pDid=r31
	lbz		r3,0(r3)
	rlwinm		r4,r26,0,24,31		# numStoredSources=r26
	subf		r4,r4,r3
	se_cmp		r0,r4		# lengthSource=r0
	bc		0,1,.L2895	# le
#    {
#       /* Too many source DIDs*/
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13914
.Llo1870:
	diab.li		r0,49		# lengthSource=r0
.Llo1871:
	stb		r0,8(r1)		# lengthSource=r0
	b		.L2894
.L2895:
#    }
#    else
#    {
#       for (i = 0; (i < numRequestedSources) && (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode); i++)
	.d2line		13918
.Llo1872:
	diab.li		r19,0		# i=r19
.L2897:
.Llo1920:
	rlwinm		r3,r19,0,16,31		# sourceId=r3 i=r19
.Llo1933:
	rlwinm		r0,r27,0,24,31		# lengthSource=r0 numRequestedSources=r27
.Llo1873:
	se_cmp		r3,r0		# sourceId=r3 lengthSource=r0
	bc		0,0,.L2894	# ge
.Llo1874:
	lbz		r0,8(r1)		# lengthSource=r0
.Llo1875:
	se_cmpi		r0,0		# lengthSource=r0
	bc		0,2,.L2894	# ne
#       {
#          sourceId             = GET_2BYTE_ID(&pSourceDids[i * 4U]);
	.d2line		13920
.Llo1876:
	rlwinm		r3,r19,2,14,29		# sourceId=r3 i=r19
.Llo1934:
	lbzux		r0,r3,r20		# lengthSource=r0 sourceId=r3
.Llo1877:
	se_slwi		r0,8		# lengthSource=r0 lengthSource=r0
	rlwinm		r3,r19,2,14,29		# sourceId=r3 i=r19
	add		r3,r3,r20		# sourceId=r3 sourceId=r3 pSourceDids=r20
	lbz		r23,1(r3)		# sourceId=r23 sourceId=r3
	or		r0,r0,r23		# lengthSource=r0 lengthSource=r0 sourceId=r23
.Llo1878:
	mr		r23,r0		# sourceId=r23 sourceId=r0
#          positionSourceRecord = pSourceDids[(4U * i) + 2U];
	.d2line		13921
	lbz		r25,2(r3)		# positionSourceRecord=r25 sourceId=r3
.Llo1922:
	mr		r25,r25		# positionSourceRecord=r25 positionSourceRecord=r25
#          sizeOfMemory         = pSourceDids[(4U * i) + 3U];
	.d2line		13922
	lbz		r24,3(r3)		# sizeOfMemory=r24 sourceId=r3
.Llo1929:
	mr		r24,r24		# sizeOfMemory=r24 sizeOfMemory=r24
# 
#          if (((GET_OBD_DID(0x00U)) <= sourceId) && ((GET_OBD_DID(0xFFU)) >= sourceId)) /* OBDDataIdentifier  */
	.d2line		13924
	rlwinm		r3,r23,0,16,31		# sourceId=r3 sourceId=r23
	diab.li		r0,-62464		# lengthSource=r0
.Llo1879:
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
	cmpli		0,0,r0,255		# lengthSource=r0
	bc		1,1,.L2900	# gt
#          {
#             ErrorCode = GetPowertrainPidLength(0U, DcmLoByte(sourceId), SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER, &sizeOfSrcDid);
	.d2line		13926
.Llo1880:
	rlwinm		r4,r23,0,24,31		# sourceId=r23
.Llo1935:
	diab.addi		r6,r1,10
	diab.li		r3,0		# sourceId=r3
	diab.li		r5,44
	bl		GetPowertrainPidLength
	stb		r3,8(r1)		# sourceId=r3
	b		.L2901
.L2900:
#          }
#          else if (((GET_VEHINFO_DID(0x00U)) <= sourceId) && ((GET_VEHINFO_DID(0xFFU)) >= sourceId)) /* OBDInfoTypeDataIdentifier */
	.d2line		13928
	rlwinm		r3,r23,0,16,31		# sourceId=r3 sourceId=r23
	diab.li		r0,-63488		# lengthSource=r0
.Llo1881:
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
	cmpli		0,0,r0,255		# lengthSource=r0
	bc		1,1,.L2902	# gt
#          {
#             isVehInfo = TRUE;
	.d2line		13930
.Llo1882:
	diab.li		r21,1		# isVehInfo=r21
#             ErrorCode = GetVehInfoLength(0U, DcmLoByte(sourceId), SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER, &sizeOfSrcDid);
	.d2line		13931
	rlwinm		r4,r23,0,24,31		# sourceId=r23
	diab.addi		r6,r1,10
	diab.li		r3,0		# sourceId=r3
	diab.li		r5,44
	bl		GetVehInfoLength
	stb		r3,8(r1)		# sourceId=r3
	b		.L2901
.L2902:
#          }
#          else
#          {
#             pSrcDid = GetSourceDid(sourceId, activeSession, activeSecurityLevel, &ErrorCode);
	.d2line		13935
	diab.addi		r6,r1,8
	mr		r3,r23		# sourceId=r3 sourceId=r23
	mr		r4,r30		# activeSession=r4 activeSession=r30
	mr		r5,r29		# activeSecurityLevel=r5 activeSecurityLevel=r29
	bl		GetSourceDid
	.d2line		13936
	mr.		r9,r3		# pSrcDid=?a17 pSrcDid=r3
#             if (NULL_PTR != pSrcDid)
	bc		1,2,.L2901	# eq
#             {
#                sizeOfSrcDid = pSrcDid->size;
	.d2line		13938
	lhz		r0,2(r9)		# lengthSource=r0 pSrcDid=r9
.Llo1883:
	sth		r0,10(r1)		# lengthSource=r0
.L2901:
#             }
#             else
#             {
#                /* ErrorCode will be handled later. */
#             }
#          }
# 
#          if (DCM_INT_NRC_POSITIVERESPONSE != ErrorCode)
	.d2line		13946
.Llo1884:
	lbz		r0,8(r1)		# lengthSource=r0
.Llo1885:
	se_cmpi		r0,0		# lengthSource=r0
	bc		0,2,.L2907	# ne
#          {
#             /*
#              * Report error
#              */
#          }
#          else if ((0 == positionSourceRecord) || (0 == sizeOfMemory) || (sizeOfSrcDid < ((uint8)(positionSourceRecord - (uint8)1U) + sizeOfMemory)))
	.d2line		13952
.Llo1886:
	rlwinm		r0,r25,0,24,31		# lengthSource=r0 positionSourceRecord=r25
.Llo1887:
	se_cmpi		r0,0		# lengthSource=r0
	bc		1,2,.L2923	# eq
.Llo1888:
	rlwinm		r3,r24,0,24,31		# sourceId=r3 sizeOfMemory=r24
	se_cmpi		r3,0		# sourceId=r3
	bc		1,2,.L2923	# eq
	lhz		r4,10(r1)
	diab.addi		r0,r25,255		# lengthSource=r0 positionSourceRecord=r25
.Llo1889:
	rlwinm		r0,r0,0,24,31		# lengthSource=r0 lengthSource=r0
	rlwinm		r3,r24,0,24,31		# sourceId=r3 sizeOfMemory=r24
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
	se_cmp		r4,r0		# lengthSource=r0
	bc		0,0,.L2908	# ge
.L2923:
#          {
#             /*
#              * According to ISO 14229:2006 "A position of one (1) shall reference the first byte of the data
#              * record referenced by the sourceDataIdentifier.", therefore the positionInSourceDataRecord shall
#              * not be zero.
#              *
#              * No point of copy zero bytes
#              *
#              * The data to be copied shall fit withing the source DID
#              */
#             ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		13963
.Llo1890:
	diab.li		r0,49		# lengthSource=r0
.Llo1891:
	stb		r0,8(r1)		# lengthSource=r0
	b		.L2907
.L2908:
#          }
#          else if (NULL_PTR != pSrcDid)
	.d2line		13965
.Llo1892:
	cmpi		0,0,r9,0		# pSrcDid=r9
	bc		1,2,.L2910	# eq
#          {
#             pDataSource = &pDid->pDataSourcesDefine[numStoredSources];
	.d2line		13967
.Llo1923:
	lwz		r3,12(r31)		# sourceId=r3 pDid=r31
	rlwinm		r0,r26,0,24,31		# lengthSource=r0 numStoredSources=r26
.Llo1893:
	e_mulli		r0,r0,20		# lengthSource=r0 lengthSource=r0
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
.Llo1894:
	mr		r3,r0		# pDataSource=r3 pDataSource=r0
#             /*
#              * When the type of data source is DID, field memoryId stores the whole size of data.
#              */
#             pDataSource->memory_id   = pSrcDid->size;
	.d2line		13971
.Llo1949:
	lhz		r0,2(r9)		# lengthSource=r0 pSrcDid=r9
.Llo1895:
	sth		r0,4(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->record_type = DCM_DD_DID;
	.d2line		13972
	diab.li		r0,0		# lengthSource=r0
	stw		r0,0(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->pDidRead    = pSrcDid->pDidRead;
	.d2line		13973
	lwz		r0,12(r9)		# lengthSource=r0 pSrcDid=r9
	stw		r0,16(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->address     = (uint8)(positionSourceRecord - 1U); /* positionSourceRecord is one based index */
	.d2line		13974
.Llo1924:
	diab.addi		r25,r25,255		# positionSourceRecord=r25 positionSourceRecord=r25
	rlwinm		r25,r25,0,24,31		# positionSourceRecord=r25 positionSourceRecord=r25
	stw		r25,8(r3)		# pDataSource=r3 positionSourceRecord=r25
#             /*
#              * sizeOfMemory <= pSrcDid->size Maybe only a portion of source DID is needed.
#              */
#             pDataSource->size       = sizeOfMemory;
	.d2line		13978
.Llo1930:
	rlwinm		r24,r24,0,24,31		# sizeOfMemory=r24 sizeOfMemory=r24
	stw		r24,12(r3)		# pDataSource=r3 sizeOfMemory=r24
#             numStoredSources++;
	.d2line		13979
	diab.addi		r0,r26,1		# lengthSource=r0 numStoredSources=r26
.Llo1896:
	se_addi		r26,1		# numStoredSources=r26 numStoredSources=r26
	b		.L2907
.L2910:
#          }
#          else if (FALSE != isVehInfo)
	.d2line		13981
.Llo1950:
	rlwinm		r0,r21,0,24,31		# lengthSource=r0 isVehInfo=r21
.Llo1897:
	se_cmpi		r0,0		# lengthSource=r0
	bc		1,2,.L2912	# eq
#          {
#             pDataSource = &pDid->pDataSourcesDefine[numStoredSources];
	.d2line		13983
.Llo1898:
	lwz		r3,12(r31)		# sourceId=r3 pDid=r31
.Llo1936:
	rlwinm		r0,r26,0,24,31		# lengthSource=r0 numStoredSources=r26
.Llo1899:
	e_mulli		r0,r0,20		# lengthSource=r0 lengthSource=r0
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
.Llo1900:
	mr		r3,r0		# pDataSource=r3 pDataSource=r0
#             /*
#              * When the type of data source is DID, field memoryId stores the whole size of data.
#              */
#             pDataSource->memory_id   = sizeOfSrcDid;
	.d2line		13987
.Llo1937:
	lhz		r0,10(r1)		# lengthSource=r0
.Llo1901:
	sth		r0,4(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->record_type = DCM_DD_VEH_INFO;
	.d2line		13988
	diab.li		r0,2		# lengthSource=r0
	stw		r0,0(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->pDidRead    = NULL_PTR;
	.d2line		13989
	diab.li		r0,0		# lengthSource=r0
	stw		r0,16(r3)		# pDataSource=r3 lengthSource=r0
#              /* positionSourceRecord is one based index and takes the lest significant byte of address. */
#             pDataSource->address     = (uint8)(positionSourceRecord - 1U);
	.d2line		13991
.Llo1925:
	diab.addi		r25,r25,255		# positionSourceRecord=r25 positionSourceRecord=r25
	rlwinm		r25,r25,0,24,31		# positionSourceRecord=r25 positionSourceRecord=r25
#              /* sourceDid 0xF8XX takes the two most significant bytes of address. */
#             pDataSource->address    |= ((uint32) sourceId << 16 ) & 0xFFFFFFFFU;
	.d2line		13993
.Llo1938:
	rlwinm		r23,r23,16,0,15		# sourceId=r23 sourceId=r23
	or		r25,r25,r23		# positionSourceRecord=r25 positionSourceRecord=r25 sourceId=r23
	stw		r25,8(r3)		# pDataSource=r3 positionSourceRecord=r25
#             /*
#              * sizeOfMemory <= pVehInfo->size Maybe only a portion of source PID is needed.
#              */
#             pDataSource->size        = sizeOfMemory;
	.d2line		13997
.Llo1931:
	rlwinm		r24,r24,0,24,31		# sizeOfMemory=r24 sizeOfMemory=r24
	stw		r24,12(r3)		# pDataSource=r3 sizeOfMemory=r24
#             numStoredSources++;
	.d2line		13998
	diab.addi		r0,r26,1		# lengthSource=r0 numStoredSources=r26
.Llo1902:
	se_addi		r26,1		# numStoredSources=r26 numStoredSources=r26
	b		.L2907
.L2912:
#          }
#          else
#          {
#             pDataSource = &pDid->pDataSourcesDefine[numStoredSources];
	.d2line		14002
.Llo1926:
	lwz		r3,12(r31)		# sourceId=r3 pDid=r31
.Llo1939:
	rlwinm		r0,r26,0,24,31		# lengthSource=r0 numStoredSources=r26
.Llo1903:
	e_mulli		r0,r0,20		# lengthSource=r0 lengthSource=r0
	se_add		r0,r3		# lengthSource=r0 lengthSource=r0 sourceId=r3
.Llo1904:
	mr		r3,r0		# pDataSource=r3 pDataSource=r0
#             /*
#              * When the type of data source is DID, field memoryId stores the whole size of data.
#              */
#             pDataSource->memory_id   = sizeOfSrcDid;
	.d2line		14006
.Llo1940:
	lhz		r0,10(r1)		# lengthSource=r0
.Llo1905:
	sth		r0,4(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->record_type = DCM_DD_PID;
	.d2line		14007
	diab.li		r0,1		# lengthSource=r0
	stw		r0,0(r3)		# pDataSource=r3 lengthSource=r0
#             pDataSource->pDidRead    = NULL_PTR;
	.d2line		14008
	diab.li		r0,0		# lengthSource=r0
	stw		r0,16(r3)		# pDataSource=r3 lengthSource=r0
#              /* positionSourceRecord is one based index and takes the lest significant byte. */
#             pDataSource->address     = (uint8)(positionSourceRecord - 1);
	.d2line		14010
.Llo1927:
	diab.addi		r25,r25,255		# positionSourceRecord=r25 positionSourceRecord=r25
	rlwinm		r25,r25,0,24,31		# positionSourceRecord=r25 positionSourceRecord=r25
#              /* sourceDid 0xF4XX takes the two most significant bytes of address. */
#             pDataSource->address    |= ((uint32) sourceId << 16 ) & 0xFFFFFFFFU;
	.d2line		14012
.Llo1941:
	rlwinm		r23,r23,16,0,15		# sourceId=r23 sourceId=r23
	or		r25,r25,r23		# positionSourceRecord=r25 positionSourceRecord=r25 sourceId=r23
	stw		r25,8(r3)		# pDataSource=r3 positionSourceRecord=r25
#             /*
#              * sizeOfMemory <= pSrcDid->size Maybe only a portion of source DID is needed.
#              */
#             pDataSource->size        = sizeOfMemory;
	.d2line		14016
.Llo1932:
	rlwinm		r24,r24,0,24,31		# sizeOfMemory=r24 sizeOfMemory=r24
	stw		r24,12(r3)		# pDataSource=r3 sizeOfMemory=r24
#             numStoredSources++;
	.d2line		14017
	diab.addi		r0,r26,1		# lengthSource=r0 numStoredSources=r26
.Llo1906:
	se_addi		r26,1		# numStoredSources=r26 numStoredSources=r26
.L2907:
#          }
#       }
	.d2line		14019
.Llo1951:
	diab.addi		r3,r19,1		# sourceId=r3 i=r19
	diab.addi		r19,r19,1		# i=r19 i=r19
	b		.L2897
.L2894:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode)
	.d2line		14022
.Llo1928:
	lbz		r0,8(r1)		# lengthSource=r0
.Llo1907:
	se_cmpi		r0,0		# lengthSource=r0
	bc		0,2,.L2914	# ne
#    {
#       /*
#        * Check if the total length of the source DIDs does fit.
#        */
#       for (i = 0; i < numStoredSources; i++)
	.d2line		14027
.Llo1857:
	diab.li		r4,0		# i=r4
.L2915:
.Llo1860:
	rlwinm		r3,r4,0,16,31		# sourceId=r3 i=r4
.Llo1942:
	rlwinm		r0,r26,0,24,31		# lengthSource=r0 numStoredSources=r26
.Llo1908:
	se_cmp		r3,r0		# sourceId=r3 lengthSource=r0
	bc		0,0,.L2917	# ge
#       {
#          totalLength += pDid->pDataSourcesDefine[i].size;
	.d2line		14029
.Llo1909:
	lwz		r0,12(r31)		# lengthSource=r0 pDid=r31
.Llo1910:
	rlwinm		r3,r4,0,16,31		# sourceId=r3 i=r4
.Llo1943:
	e_mulli		r3,r3,20		# sourceId=r3 sourceId=r3
	se_add		r3,r0		# sourceId=r3 sourceId=r3 lengthSource=r0
	lwz		r0,12(r3)		# lengthSource=r0 sourceId=r3
	add		r0,r0,r22		# lengthSource=r0 lengthSource=r0 totalLength=r22
.Llo1911:
	mr		r22,r0		# totalLength=r22 totalLength=r0
#       }
	.d2line		14030
	diab.addi		r3,r4,1		# sourceId=r3 i=r4
.Llo1944:
	se_addi		r4,1		# i=r4 i=r4
	b		.L2915
.L2917:
# 
#       /*
#        * Size doesn't matter when using paged buffer.
#        * Error will be returned when trying to access the sources.
#        */
# #if (DCM_PAGEDBUFFER_ENABLED == STD_OFF)
#       if((totalLength + 2) > pMsgContext->resMaxDataLen)
	.d2line		14037
	diab.addi		r0,r22,2		# lengthSource=r0 totalLength=r22
.Llo1912:
	lhz		r3,20(r28)		# sourceId=r3 pMsgContext=r28
.Llo1945:
	se_cmpl		r0,r3		# lengthSource=r0 sourceId=r3
	bc		0,1,.L2918	# le
#       {
#          /*
#           * For non-periodic DDDiD (0xF300 - 0xF3FF), it is enough to check the length
#           * of DiD against the size of response buffer - 2. (2 bytes DiD identifier)
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14043
.Llo1861:
	diab.li		r0,49		# lengthSource=r0
.Llo1862:
	stb		r0,8(r1)		# lengthSource=r0
	b		.L2914
.L2918:
#       }
#       else
# #endif
#       /* else */ if ((PERIODIC_HIGH_BYTE == DcmHiByte(pDid->identifier)) && (totalLength > pDid->size))
	.d2line		14047
.Llo1913:
	lhz		r0,0(r31)		# lengthSource=r0 pDid=r31
.Llo1914:
	rlwinm		r0,r0,24,24,31		# lengthSource=r0 lengthSource=r0
	cmpi		0,0,r0,242		# lengthSource=r0
	bc		0,2,.L2914	# ne
.Llo1915:
	lhz		r0,2(r31)		# lengthSource=r0 pDid=r31
.Llo1916:
	cmpl		0,0,r0,r22		# lengthSource=r0 totalLength=r22
	bc		0,0,.L2914	# ge
#       {
#          /*
#           * For periodic DDDiD (0xF200 - 0xF2FF), it is necessary to
#           * check the length of DiD against the size of data sample buffer.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14053
.Llo1917:
	diab.li		r0,49		# lengthSource=r0
.Llo1918:
	stb		r0,8(r1)		# lengthSource=r0
.L2914:
#       }
#       else
#       {
#          /* Check is OK.*/
#       }
#    }
# 
#    /* Only if all sources are valid, update the number of current stored sources. */
#    if (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode)
	.d2line		14062
.Llo1858:
	lbz		r0,8(r1)		# lengthSource=r0
.Llo1863:
	se_cmpi		r0,0		# lengthSource=r0
	bc		0,2,.L2922	# ne
#    {
#       *(pDid->pNumberOfDefinedSources) += numRequestedSources;
	.d2line		14064
.Llo1864:
	lwz		r3,16(r31)		# sourceId=r3 pDid=r31
.Llo1865:
	lbz		r0,0(r3)		# lengthSource=r0 sourceId=r3
.Llo1919:
	se_add		r0,r27		# lengthSource=r0 lengthSource=r0 numRequestedSources=r27
	stb		r0,0(r3)		# sourceId=r3 lengthSource=r0
.L2922:
#    }
# 
#    return ErrorCode;
	.d2line		14067
.Llo1854:
	lbz		r3,8(r1)		# sourceId=r3
# }
	.d2line		14068
	.d2epilogue_begin
	lmw		r19,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	2,10
	lwz		r0,84(r1)		# lengthSource=r0
	mtspr		lr,r0		# lengthSource=lr
	diab.addi		r1,r1,80		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1859:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4566:
	.type		DefineDDDidByIdentifier,@function
	.size		DefineDDDidByIdentifier,.-DefineDDDidByIdentifier
# Number of nodes = 490

# Allocations for DefineDDDidByIdentifier
#	?a4		pDid
#	?a5		activeSession
#	?a6		activeSecurityLevel
#	?a7		pMsgContext
#	?a8		$$68
#	?a9		numRequestedSources
#	?a10		lengthSource
#	?a11		i
#	?a12		numStoredSources
#	?a13		positionSourceRecord
#	?a14		sizeOfMemory
#	?a15		sourceId
#	SP,10		sizeOfSrcDid
#	?a16		totalLength
#	?a17		pSrcDid
#	?a18		pDataSource
#	?a19		isVehInfo
#	SP,8		ErrorCode
#	?a20		pSourceDids
# static FUNC(uint32, DCM_CODE) ParseMemoryParameter(P2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) parameterData, uint8 parameterLength)
	.align		1
	.section	.text_vle
        .d2line         12794,31
#$$ld
.L4601:

#$$bf	ParseMemoryParameter,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,r7,cr0,lr
	.d2_cfa_start __cie
ParseMemoryParameter:
.Llo1954:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# parameterData=r3 parameterData=r3
.Llo1955:
	mr		r7,r4		# parameterLength=r7 parameterLength=r4
	.d2prologue_end
# {
#    uint8 i;
#    uint32 parameter = 0;
	.d2line		12797
	diab.li		r5,0		# parameter=r5
#    for (i = 0; i < parameterLength; i++)
	.d2line		12798
.Llo1959:
	diab.li		r4,0
.L2608:
.Llo1956:
	rlwinm		r0,r4,0,24,31		# parameter=r0 i=r4
.Llo1957:
	rlwinm		r6,r7,0,24,31		# parameter=r6 parameterLength=r7
	se_cmp		r0,r6		# parameter=r0 parameter=r6
	bc		0,0,.L2610	# ge
#    {
#       parameter <<= 8U;
	.d2line		12800
	rlwinm		r0,r5,8,0,23		# parameter=r0 parameter=r5
	mr		r0,r0		# parameter=r0 parameter=r0
#       /*
#        * Type cast the parameter so the operands inte the bitwise operation is of equal size.
#        */
#       parameter |= (uint32)parameterData[i];
	.d2line		12804
	rlwinm		r5,r4,0,24,31		# parameter=r5 i=r4
	lbzux		r6,r5,r3		# parameter=r6 parameter=r5
	or		r0,r0,r6		# parameter=r0 parameter=r0 parameter=r6
	mr		r5,r0		# parameter=r5 parameter=r0
#    }
	.d2line		12805
	diab.addi		r0,r4,1		# parameter=r0 i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L2608
.L2610:
#    return parameter;
	.d2line		12806
.Llo1958:
	mr		r3,r5		# parameter=r3 parameter=r5
# }
	.d2line		12807
	.d2epilogue_begin
	lwz		r0,20(r1)		# parameter=r0
	mtspr		lr,r0		# parameter=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo1960:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4602:
	.type		ParseMemoryParameter,@function
	.size		ParseMemoryParameter,.-ParseMemoryParameter
# Number of nodes = 27

# Allocations for ParseMemoryParameter
#	?a4		parameterData
#	?a5		parameterLength
#	?a6		i
#	?a7		parameter
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) DefineDDDidByMemoryAddress(CONSTP2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid,
	.align		1
	.section	.text_vle
        .d2line         14073,53
#$$ld
.L4612:

#$$bf	DefineDDDidByMemoryAddress,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
DefineDDDidByMemoryAddress:
.Llo1961:
	stwu		r1,-80(r1)		
	.d2_cfa_def_cfa_offset	80
	mfspr		r0,lr
	stmw		r23,44(r1)		# offset r1+44  0x2c
	.d2_cfa_offset_list	23,31,1,1
	stw		r0,84(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pDid=r31 pDid=r3
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
	.d2prologue_end
#                                                                                CONSTP2CONST(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
# {
#    MemoryDataStructureType dataStructure;
# 
#    CONST(uint16, DCM_CONST) lengthSource = (uint16)(pMsgContext->reqDataLen - 3); /* Safe to cast since call function check the size of reqDataLen */
#    uint8  i;
#    uint8 numRequestedSources = 0;
	.d2line		14080
	diab.li		r29,0		# numRequestedSources=r29
#    uint8 numStoredSources;
#    uint8 sourceItemLength;
#    uint32 totalLength = 0;
	.d2line		14083
.Llo1975:
	diab.li		r26,0
# 
#    Dcm_Cfg_MemoryRangePointerType pSelectedMemoryRange;
#    P2VAR(Dcm_Cfg_DDDDidSourceType, AUTOMATIC, DCM_APPL_DATA) pDataSource;
# 
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		14088
.Llo1980:
	diab.li		r25,0
	.d2line		14078
.Llo2013:
	lhz		r5,4(r30)		# pMsgContext=r30
	diab.li		r0,65533
	se_add		r0,r5
.Llo1969:
	mr		r5,r0		# lengthSource=r5 lengthSource=r0
# 
#     /* Remove sub-function (1 byte), dynamicallyDefinedDataIdentifie (2 bytes) */
#    CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_CONST) pSourceMemory = &pMsgContext->reqData[3];
	.d2line		14091
	lwz		r23,0(r30)		# pMsgContext=r30
	diab.addi		r23,r23,3
.Llo2015:
	mr		r23,r23		# pSourceMemory=r23 pSourceMemory=r23
# 
#    dataStructure.include_memory_id_byte   = (uint8)((TRUE == Dcm_LCfg.p_read_memory->use_memory_id) ? 1U : 0U);
	.d2line		14093
	lis		r3,(Dcm_LCfg+156)@ha
.Llo1962:
	lwz		r3,(Dcm_LCfg+156)@l(r3)
	lbz		r0,0(r3)
.Llo1970:
	se_cmpi		r0,1
	diab.li		r3,1
	.d2line		14080
	isel		r3,r3,r0,2
.L2970:
	.d2line		14093
.Llo1963:
	diab.li		r0,0
.Llo1965:
	isel		r27,r3,r0,2
.L2971:
	stb		r27,8(r1)
#    dataStructure.memory_address_format   = pSourceMemory[0] & 0x0FU;
	.d2line		14094
	lbz		r0,0(r23)		# pSourceMemory=r23
	rlwinm		r0,r0,0,28,31
	stb		r0,9(r1)
#    dataStructure.memory_address_length   = dataStructure.memory_address_format - dataStructure.include_memory_id_byte;
	.d2line		14095
	rlwinm		r27,r27,0,24,31
	subf		r3,r27,r0
	stb		r3,10(r1)
#    dataStructure.memory_size_length      = pSourceMemory[0] >> 4;
	.d2line		14096
	lbz		r4,0(r23)		# pSourceMemory=r23
	rlwinm		r4,r4,28,28,31
	stb		r4,11(r1)
#    sourceItemLength                    = dataStructure.memory_address_length + dataStructure.memory_size_length + dataStructure.include_memory_id_byte;
	.d2line		14097
	rlwinm		r3,r3,0,24,31
	se_extzb		r4
	se_add		r3,r4
	se_add		r3,r27
.Llo1977:
	mr		r27,r3		# sourceItemLength=r27 sourceItemLength=r3
# 
#    /* fetch the current number of source items */
#    numStoredSources = *(pDid->pNumberOfDefinedSources);
	.d2line		14100
	lwz		r3,16(r31)		# pDid=r31
.Llo1978:
	lbz		r28,0(r3)
.Llo1976:
	mr		r28,r28		# numStoredSources=r28 numStoredSources=r28
# 
#    /* Check acceptable address width.
#     * MemoryAddressFormat (Memory address length + optional memory id byte) minimum 1 bytes (ref. ISO14229)
#     * Memory address length maximum 4 bytes + optional memory id byte (constrained by AUTOSAR Dcm_ReadMemory)
#     */
#    if ((0 == dataStructure.memory_address_format) || (dataStructure.memory_address_length > 4))
	.d2line		14106
	e_andi.		r0,r0,255
	bc		1,2,.L2972	# eq
.Llo1979:
	lbz		r0,10(r1)
	se_cmpi		r0,4
	bc		0,1,.L2942	# le
.L2972:
#    {
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14108
	diab.li		r25,49		# ErrorCode=r25
	b		.L2943
.L2942:
#    }
#    /* Check acceptable data length parameter size.
#     * Minimum 1 bytes (ref. ISO14229)
#     * Maximum 4 bytes (constrained by AUTOSAR Dcm_WriteMemory/Dcm_ReadMemory)
#     */
#    else if ((0 == dataStructure.memory_size_length) || (dataStructure.memory_size_length > 4))
	.d2line		14114
	lbz		r0,11(r1)
	se_cmpi		r0,0
	bc		1,2,.L2973	# eq
	lbz		r0,11(r1)
	se_cmpi		r0,4
	bc		0,1,.L2944	# le
.L2973:
#    {
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14116
	diab.li		r25,49		# ErrorCode=r25
	b		.L2943
.L2944:
#    }
#    /* Check that  memory address and memory size parameters fits in request */
#    else if (lengthSource < ((uint8)1U + dataStructure.include_memory_id_byte + dataStructure.memory_address_length + dataStructure.memory_size_length))
	.d2line		14119
	rlwinm		r0,r5,0,16,31		# lengthSource=r5
	lbz		r3,8(r1)
	lbz		r4,10(r1)
	se_add		r3,r4
	lbz		r4,11(r1)
	se_add		r3,r4
	se_addi		r3,1
	se_cmp		r0,r3
	bc		0,0,.L2946	# ge
#    {
#       ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		14121
	diab.li		r25,19		# ErrorCode=r25
	b		.L2943
.L2946:
#    }
#    else if ( 0 != ((lengthSource - 1) % sourceItemLength))
	.d2line		14123
	rlwinm		r3,r5,0,16,31		# lengthSource=r5
	diab.addi		r3,r3,-1
	rlwinm		r4,r27,0,24,31		# sourceItemLength=r27
	divw		r0,r3,r4
	mullw		r0,r0,r4
	subf.		r0,r0,r3
	bc		1,2,.L2948	# eq
#    {
#       ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		14125
	diab.li		r25,19		# ErrorCode=r25
	b		.L2943
.L2948:
#    }
#    else
#    {
#       /* safe case since the number of requested sources can not be more than 256. */
#       numRequestedSources = (uint8) ((lengthSource - 1) / sourceItemLength);
	.d2line		14130
	rlwinm		r5,r5,0,16,31		# lengthSource=r5 lengthSource=r5
	diab.addi		r5,r5,-1		# lengthSource=r5 lengthSource=r5
	rlwinm		r3,r27,0,24,31		# sourceItemLength=r27
	divw		r29,r5,r3		# numRequestedSources=r29 lengthSource=r5
	mr		r29,r29		# numRequestedSources=r29 numRequestedSources=r29
# 
#       if ( numRequestedSources > (pDid->pDDDidInfo->max_no_of_requested_sources - numStoredSources))
	.d2line		14132
	rlwinm		r0,r29,0,24,31		# numRequestedSources=r29
	lwz		r3,4(r31)		# pDid=r31
	lbz		r3,0(r3)
	rlwinm		r4,r28,0,24,31		# numStoredSources=r28
	subf		r4,r4,r3
	se_cmp		r0,r4
	bc		0,1,.L2950	# le
#       {
#          /* Too many sources*/
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14135
.Llo1971:
	diab.li		r25,49		# ErrorCode=r25
	b		.L2943
.L2950:
#       }
#       else
#       {
#          for (i = 0; (i < numRequestedSources) && (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode); i++)
	.d2line		14139
	diab.li		r24,0		# i=r24
.L2952:
.Llo1972:
	rlwinm		r3,r24,0,24,31		# pSelectedMemoryRange=r3 i=r24
.Llo1981:
	rlwinm		r0,r29,0,24,31		# numRequestedSources=r29
	se_cmp		r3,r0		# pSelectedMemoryRange=r3
	bc		0,0,.L2943	# ge
.Llo1982:
	rlwinm		r3,r25,0,24,31		# pSelectedMemoryRange=r3 ErrorCode=r25
.Llo1983:
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2943	# ne
#          {
#             dataStructure.memory_address_offset = 1 + dataStructure.include_memory_id_byte + (i * sourceItemLength);
	.d2line		14141
.Llo1984:
	lbz		r3,8(r1)		# pSelectedMemoryRange=r3
.Llo1985:
	mullw		r4,r24,r27		# i=r24 sourceItemLength=r27
	se_add		r3,r4		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_addi		r3,1		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	stb		r3,12(r1)		# pSelectedMemoryRange=r3
#             dataStructure.memory_size_offset    = dataStructure.memory_address_offset + dataStructure.memory_address_length;
	.d2line		14142
	se_extzb		r3		# pSelectedMemoryRange=r3
	lbz		r0,10(r1)
	se_add		r0,r3		# pSelectedMemoryRange=r3
	stb		r0,13(r1)
# 
#             /*
#              * Fetch the received memory id if it's used.
#              * If not used, set it to zero which is the default value set by the SCG
#              */
#             if (TRUE == Dcm_LCfg.p_read_memory->use_memory_id)
	.d2line		14148
	lis		r3,(Dcm_LCfg+156)@ha		# pSelectedMemoryRange=r3
	lwz		r3,(Dcm_LCfg+156)@l(r3)		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	lbz		r0,0(r3)		# pSelectedMemoryRange=r3
	se_cmpi		r0,1
	bc		0,2,.L2955	# ne
#             {
#                dataStructure.memory_identifier = pSourceMemory[1 + (i * sourceItemLength)];
	.d2line		14150
.Llo1986:
	rlwinm		r3,r24,0,24,31		# pSelectedMemoryRange=r3 i=r24
.Llo1987:
	rlwinm		r4,r27,0,24,31		# sourceItemLength=r27
	mullw		r3,r3,r4		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	add		r3,r3,r23		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3 pSourceMemory=r23
	lbz		r0,1(r3)		# pSelectedMemoryRange=r3
	stb		r0,15(r1)
	b		.L2956
.L2955:
#             }
#             else
#             {
#                dataStructure.memory_identifier = 0;
	.d2line		14154
.Llo1988:
	diab.li		r0,0
	stb		r0,15(r1)
.L2956:
#             }
# 
#             dataStructure.memory_address = ParseMemoryParameter(&pSourceMemory[dataStructure.memory_address_offset], dataStructure.memory_address_length);
	.d2line		14157
	lbz		r3,12(r1)		# pSelectedMemoryRange=r3
.Llo1989:
	add		r3,r3,r23		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3 pSourceMemory=r23
.Llo1990:
	lbz		r4,10(r1)
	bl		ParseMemoryParameter
.Llo1991:
	stw		r3,16(r1)		# pSelectedMemoryRange=r3
#             dataStructure.memory_size    = ParseMemoryParameter(&pSourceMemory[dataStructure.memory_size_offset], dataStructure.memory_size_length);
	.d2line		14158
	lbz		r3,13(r1)		# pSelectedMemoryRange=r3
	add		r3,r3,r23		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3 pSourceMemory=r23
.Llo1992:
	lbz		r4,11(r1)
	bl		ParseMemoryParameter
.Llo1993:
	stw		r3,20(r1)		# pSelectedMemoryRange=r3
# 
#             pSelectedMemoryRange = GetMemoryRange(dataStructure.memory_identifier, dataStructure.memory_address, dataStructure.memory_size, Dcm_LCfg.p_read_memory);
	.d2line		14160
	lis		r3,(Dcm_LCfg+156)@ha		# pSelectedMemoryRange=r3
	lwz		r6,(Dcm_LCfg+156)@l(r3)		# pSelectedMemoryRange=r3
	lbz		r3,15(r1)		# pSelectedMemoryRange=r3
.Llo1994:
	lwz		r4,16(r1)
	lwz		r5,20(r1)		# lengthSource=r5
	bl		GetMemoryRange
	.d2line		14163
.Llo1995:
	mr.		r3,r3		# pSelectedMemoryRange=?a14 pSelectedMemoryRange=r3
# 
#             /* Check that requested memory range is configured */
#             if (NULL_PTR == pSelectedMemoryRange)
	bc		0,2,.L2957	# ne
#             {
#                ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14165
	diab.li		r25,49		# ErrorCode=r25
	b		.L2958
.L2957:
#             }
#             /* Check that requested memory range is accessible in current security level */
#             else if (FALSE == IsMemoryRangeAcessible(pSelectedMemoryRange))
	.d2line		14168
	mr		r3,r3		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
.Llo1996:
	bl		IsMemoryRangeAcessible
.Llo1997:
	rlwinm		r3,r3,0,24,31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2959	# ne
#             {
#                ErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		14170
.Llo1998:
	diab.li		r25,51		# ErrorCode=r25
	b		.L2958
.L2959:
#             }
#             else
#             {
#                pDataSource = &pDid->pDataSourcesDefine[numStoredSources];
	.d2line		14174
	lwz		r3,12(r31)		# pSelectedMemoryRange=r3 pDid=r31
.Llo1999:
	rlwinm		r0,r28,0,24,31		# numStoredSources=r28
	e_mulli		r0,r0,20
	se_add		r0,r3		# pSelectedMemoryRange=r3
.Llo2010:
	mr		r3,r0		# pDataSource=r3 pDataSource=r0
#                pDataSource->record_type = DCM_DD_MEMORY;
	.d2line		14175
.Llo2000:
	diab.li		r0,3
.Llo2011:
	stw		r0,0(r3)		# pDataSource=r3
#                pDataSource->address     = dataStructure.memory_address;
	.d2line		14176
	lwz		r0,16(r1)
	stw		r0,8(r3)		# pDataSource=r3
#                pDataSource->size        = dataStructure.memory_size;
	.d2line		14177
	lwz		r0,20(r1)
	stw		r0,12(r3)		# pDataSource=r3
#                pDataSource->memory_id   = dataStructure.memory_identifier;
	.d2line		14178
	lbz		r0,15(r1)
	sth		r0,4(r3)		# pDataSource=r3
#                numStoredSources++;
	.d2line		14179
	diab.addi		r0,r28,1		# numStoredSources=r28
	se_addi		r28,1		# numStoredSources=r28 numStoredSources=r28
.L2958:
#             }
#          }
	.d2line		14181
.Llo2012:
	diab.addi		r3,r24,1		# pSelectedMemoryRange=r3 i=r24
	se_addi		r24,1		# i=r24 i=r24
	b		.L2952
.L2943:
#       }
#    }
# 
#    /*
#     * Check that all configured sources fits into the response (0xF3nn)
#     * or snapshot (0xF2nn) buffers
#     */
#    if (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode)
	.d2line		14189
	rlwinm		r3,r25,0,24,31		# pSelectedMemoryRange=r3 ErrorCode=r25
.Llo2001:
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2961	# ne
#    {
#       for (i = 0; i < numStoredSources; i++)
	.d2line		14191
.Llo1973:
	diab.li		r4,0		# i=r4
.L2962:
.Llo1974:
	rlwinm		r3,r4,0,24,31		# pSelectedMemoryRange=r3 i=r4
.Llo2002:
	rlwinm		r0,r28,0,24,31		# numStoredSources=r28
	se_cmp		r3,r0		# pSelectedMemoryRange=r3
	bc		0,0,.L2964	# ge
#       {
#          totalLength += pDid->pDataSourcesDefine[i].size;
	.d2line		14193
.Llo2003:
	lwz		r0,12(r31)		# pDid=r31
	rlwinm		r3,r4,0,24,31		# pSelectedMemoryRange=r3 i=r4
.Llo2004:
	e_mulli		r3,r3,20		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_add		r3,r0		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	lwz		r0,12(r3)		# pSelectedMemoryRange=r3
	se_add		r0,r26		# totalLength=r26
	mr		r26,r0		# totalLength=r26 totalLength=r0
#       }
	.d2line		14194
	diab.addi		r3,r4,1		# pSelectedMemoryRange=r3 i=r4
.Llo2005:
	se_addi		r4,1		# i=r4 i=r4
	b		.L2962
.L2964:
# 
#       if ((totalLength + 2) > pMsgContext->resMaxDataLen)
	.d2line		14196
	diab.addi		r0,r26,2		# totalLength=r26
	lhz		r3,20(r30)		# pSelectedMemoryRange=r3 pMsgContext=r30
.Llo2006:
	se_cmpl		r0,r3		# pSelectedMemoryRange=r3
	bc		0,1,.L2965	# le
#       {
#          /*
#           * For non-periodic DDDID (0xF300 - 0xF3FF), it is enough to check the length
#           * of DID against the size of response buffer - 2. (2 bytes DID identifier)
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14202
.Llo1966:
	diab.li		r25,49		# ErrorCode=r25
	b		.L2961
.L2965:
#       }
#       else if ((PERIODIC_HIGH_BYTE == DcmHiByte(pDid->identifier)) && (totalLength > pDid->size))
	.d2line		14204
	lhz		r0,0(r31)		# pDid=r31
	rlwinm		r0,r0,24,24,31
	cmpi		0,0,r0,242
	bc		0,2,.L2961	# ne
	lhz		r0,2(r31)		# pDid=r31
	se_cmpl		r0,r26		# totalLength=r26
#       {
#          /*
#           * For periodic DDDID (0xF200 - 0xF2FF), it is necessary to
#           * check the length of DID against the size of data sample buffer.
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14210
	diab.li		r3,49		# pSelectedMemoryRange=r3
.Llo2007:
	isel		r25,r3,r25,0		# ErrorCode=r25 pSelectedMemoryRange=r3 ErrorCode=r25
.L2961:
#       }
#       else
#       {
#          /* The size of DDDID does fit.*/
#       }
#    }
# 
#     /* Only if all sources are valid, update the number of current stored sources. */
#    if (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode)
	.d2line		14219
.Llo1967:
	rlwinm		r3,r25,0,24,31		# pSelectedMemoryRange=r3 ErrorCode=r25
.Llo2008:
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2969	# ne
#    {
#       *(pDid->pNumberOfDefinedSources) += numRequestedSources;
	.d2line		14221
.Llo1968:
	lwz		r3,16(r31)		# pSelectedMemoryRange=r3 pDid=r31
.Llo2009:
	lbz		r0,0(r3)		# pSelectedMemoryRange=r3
	se_add		r0,r29		# numRequestedSources=r29
	stb		r0,0(r3)		# pSelectedMemoryRange=r3
.L2969:
#    }
# 
#    return ErrorCode;
	.d2line		14224
.Llo1964:
	rlwinm		r3,r25,0,24,31		# pSelectedMemoryRange=r3 ErrorCode=r25
# }
	.d2line		14225
	.d2epilogue_begin
	lmw		r23,44(r1)		# offset r1+44  0x2c
	.d2_cfa_restore_list	2,10
.Llo2014:
	lwz		r0,84(r1)
	mtspr		lr,r0
	diab.addi		r1,r1,80		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4613:
	.type		DefineDDDidByMemoryAddress,@function
	.size		DefineDDDidByMemoryAddress,.-DefineDDDidByMemoryAddress
# Number of nodes = 510

# Allocations for DefineDDDidByMemoryAddress
#	?a4		pDid
#	?a5		pMsgContext
#	?a6		$$70
#	?a7		$$69
#	SP,8		dataStructure
#	?a8		lengthSource
#	?a9		i
#	?a10		numRequestedSources
#	?a11		numStoredSources
#	?a12		sourceItemLength
#	?a13		totalLength
#	?a14		pSelectedMemoryRange
#	?a15		pDataSource
#	?a16		ErrorCode
#	?a17		pSourceMemory
# FUNC(Std_ReturnType, DCM_CODE) Dcm_DynamicallyDefineDataIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         4762,32
#$$ld
.L4642:

#$$bf	Dcm_DynamicallyDefineDataIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_DynamicallyDefineDataIdentifier
	.d2_cfa_start __cie
Dcm_DynamicallyDefineDataIdentifier:
.Llo2016:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
.Llo2034:
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)		# didIdentifier=r0
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
.Llo2017:
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    /* Each DID is two bytes */
#    uint16 confDidCounter;
#    uint16 didIdentifier = 0;
	.d2line		4766
.Llo2018:
	diab.li		r0,0		# didIdentifier=r0
#    P2CONST(Dcm_Cfg_PeriodicDynamicDidType, AUTOMATIC, DCM_APPL_DATA) pDid = NULL_PTR;
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
# 
#    CONST(uint8, DCM_CONST) subFunc = pMsgContext->reqData[0]; /* Safe since handler will never be called if not subfunction provided. */
	.d2line		4771
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r29,0(r3)		# subFunc=r29
	mr		r27,r29		# subFunc=r27 subFunc=r29
# 
#    /*
#     * Do some initiation:
#     * - Clear the response length
#     * - Get the current session
#     * - Get the current security level
#     */
#    pMsgContext->resDataLen = 0;
	.d2line		4779
	sth		r0,12(r31)		# pMsgContext=r31 didIdentifier=r0
# 
#    /*
#     * MISRA-C:2004 RULE 16.10 VIOLATION:
#     * If a function returns error information, then that error information shall be tested.
#     * [SWS_Dcm_00339] : E_OK shall always be returned.
#     * [SWS_Dcm_00338] : E_OK shall always be returned.
#     */
#    (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		4787
	diab.addi		r3,r1,8
	bl		Dcm_GetSesCtrlType
#    (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		4788
.Llo2020:
	diab.addi		r3,r1,9
	bl		Dcm_GetSecurityLevel
# 
#    /*
#     * Copy the subfunction can always be done. If negative response,
#     * this will not be used anyway.
#     */
#    pMsgContext->resData[0] = subFunc;
	.d2line		4794
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r29,0(r3)		# subFunc=r29
# 
#    if ((7 > pMsgContext->reqDataLen) && (0x01U == subFunc)) /* defineByIdentifier */
	.d2line		4796
	lhz		r0,4(r31)		# didIdentifier=r0 pMsgContext=r31
.Llo2035:
	se_cmpi		r0,7		# didIdentifier=r0
	bc		0,0,.L1077	# ge
.Llo2021:
	rlwinm		r0,r27,0,24,31		# didIdentifier=r0 subFunc=r27
.Llo2036:
	se_cmpi		r0,1		# didIdentifier=r0
	bc		0,2,.L1077	# ne
#    {
#       /*
#        * For defineByIdentifier, the length of request is at least 7.
#        * The mandatory fields are sub-function (1 byte), dynamicallyDefinedDataIdentifier (2 bytes),
#        * sourceDataIdentifier (2 bytes), positionInSourceDataRecord(1 byte), memorySize (1 byte).
#        */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4803
.Llo2037:
	diab.li		r0,19		# didIdentifier=r0
.Llo2038:
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1078
.L1077:
#    }
#    else if ((5 > pMsgContext->reqDataLen) && (0x02U == subFunc)) /* defineByMemoryAddress */
	.d2line		4805
.Llo2039:
	lhz		r0,4(r31)		# didIdentifier=r0 pMsgContext=r31
.Llo2040:
	se_cmpi		r0,5		# didIdentifier=r0
	bc		0,0,.L1079	# ge
.Llo2041:
	rlwinm		r0,r27,0,24,31		# didIdentifier=r0 subFunc=r27
.Llo2042:
	se_cmpi		r0,2		# didIdentifier=r0
	bc		0,2,.L1079	# ne
#    {
#       /*
#        * For defineByMemoryAddress, at least one source memory block.
#        * However the length of source memory block is dependent on the parameter
#        * addressAndLengthFormatIdentifier.
#        * The mandatory fields are sub-function (1 byte), dynamicallyDefinedDataIdentifier(2 bytes),
#        * addressAndLengthFormatIdentifier(1 byte), memoryAddress (first byte)
#        */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4814
.Llo2043:
	diab.li		r0,19		# didIdentifier=r0
.Llo2044:
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1078
.L1079:
#    }
#    else if ((1 == pMsgContext->reqDataLen) && (0x03U == subFunc)) /* clearDynamicallyDefinedDataIdentifier */
	.d2line		4816
.Llo2045:
	lhz		r0,4(r31)		# didIdentifier=r0 pMsgContext=r31
.Llo2046:
	se_cmpi		r0,1		# didIdentifier=r0
	bc		0,2,.L1081	# ne
.Llo2047:
	rlwinm		r0,r27,0,24,31		# didIdentifier=r0 subFunc=r27
.Llo2048:
	se_cmpi		r0,3		# didIdentifier=r0
	bc		0,2,.L1081	# ne
#    {
#       /*
#        * Clear all dynamicallyDefinedDataIdentifier
#        */
#       ResetAllDDDiDsAndPeriodicDids(DDID_CLEAR_ALWAYS, DDPRID_CLEAR_ALWAYS);
	.d2line		4821
.Llo2049:
	diab.li		r3,0
	diab.li		r4,0
	bl		ResetAllDDDiDsAndPeriodicDids
#       pMsgContext->resDataLen = 1;
	.d2line		4822
	diab.li		r0,1		# didIdentifier=r0
.Llo2050:
	sth		r0,12(r31)		# pMsgContext=r31 didIdentifier=r0
	b		.L1078
.L1081:
#    }
#    else if ((3 != pMsgContext->reqDataLen) && (0x03U == subFunc)) /* clearDynamicallyDefinedDataIdentifier */
	.d2line		4824
.Llo2051:
	lhz		r0,4(r31)		# didIdentifier=r0 pMsgContext=r31
.Llo2052:
	se_cmpi		r0,3		# didIdentifier=r0
	bc		1,2,.L1083	# eq
.Llo2053:
	rlwinm		r0,r27,0,24,31		# didIdentifier=r0 subFunc=r27
.Llo2054:
	se_cmpi		r0,3		# didIdentifier=r0
	bc		0,2,.L1083	# ne
#    {
#       /*
#        * Only clear one DID
#        */
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		4829
.Llo2055:
	diab.li		r0,19		# didIdentifier=r0
.Llo2056:
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1078
.L1083:
#    }
#    else
#    {
#       /*
#        * Before defining the DIDs, several checks have to be done:
#        * 1. Is the DID found amongst the configured ones?
#        * 2. Is the DID allowed to be dynamically definedd?
#        * 3. Can the DID be defined in the current session?
#        * 4. Can the DID be defined in the current security level?
#        */
#       didIdentifier = GET_2BYTE_ID(&pMsgContext->reqData[1]);
	.d2line		4840
.Llo2057:
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r4,1(r3)		# didIdentifier=r4
.Llo2058:
	se_slwi		r4,8		# didIdentifier=r4
	lbz		r29,2(r3)		# subFunc=r29
	or		r4,r4,r29		# didIdentifier=r4 didIdentifier=r4 subFunc=r29
	mr		r29,r4		# didIdentifier=r29 didIdentifier=r4
# 
#       /*
#        * Assume succesful checks.
#        * The subfunction has already been assigned in the beginning.
#        */
#       SET_2BYTE_ID(&pMsgContext->resData[1], didIdentifier);
	.d2line		4846
	rlwinm		r0,r29,24,24,31		# didIdentifier=r0 didIdentifier=r29
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,1(r3)		# didIdentifier=r0
	rlwinm		r0,r29,0,24,31		# didIdentifier=r0 didIdentifier=r29
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r4,2(r3)		# didIdentifier=r4
#       pMsgContext->resDataLen = 3;
	.d2line		4847
	diab.li		r0,3		# didIdentifier=r0
	sth		r0,12(r31)		# pMsgContext=r31 didIdentifier=r0
# 
#       /*
#        * Try to find a matching DID in the configuration
#        * Using check against NULL_PTR instead of break to avoid an unnecessary high essential cyclomatic.
#        */
#       pDid = NULL_PTR;
	.d2line		4853
	diab.li		r28,0		# pDid=r28
#       for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_periodic_dynamic_dids) && (NULL_PTR == pDid); confDidCounter++)
	.d2line		4854
.Llo2061:
	diab.li		r3,0
.L1086:
.Llo2023:
	rlwinm		r0,r3,0,16,31		# didIdentifier=r0 confDidCounter=r3
.Llo2059:
	lis		r4,(Dcm_LCfg+72)@ha		# didIdentifier=r4
	lhz		r4,(Dcm_LCfg+72)@l(r4)		# didIdentifier=r4 didIdentifier=r4
	se_cmp		r0,r4		# didIdentifier=r0 didIdentifier=r4
	bc		0,0,.L1088	# ge
	se_cmpi		r28,0		# pDid=r28
	bc		0,2,.L1088	# ne
#       {
#          if (Dcm_LCfg.periodicDynamicDids[confDidCounter].identifier == didIdentifier)
	.d2line		4856
	rlwinm		r0,r3,0,16,31		# didIdentifier=r0 confDidCounter=r3
	lis		r4,(Dcm_LCfg+76)@ha		# didIdentifier=r4
	lwz		r4,(Dcm_LCfg+76)@l(r4)		# didIdentifier=r4 didIdentifier=r4
	rlwinm		r5,r0,5,0,26		# didIdentifier=r0
	se_slwi		r0,3		# didIdentifier=r0 didIdentifier=r0
	subf		r0,r0,r5		# didIdentifier=r0 didIdentifier=r0
	lhzx		r0,r4,r0		# didIdentifier=r0 didIdentifier=r4
	rlwinm		r4,r29,0,16,31		# didIdentifier=r4 didIdentifier=r29
	se_cmp		r0,r4		# didIdentifier=r0 didIdentifier=r4
	bc		0,2,.L1089	# ne
#          {
#             pDid = &Dcm_LCfg.periodicDynamicDids[confDidCounter];
	.d2line		4858
	rlwinm		r0,r3,0,16,31		# didIdentifier=r0 confDidCounter=r3
	lis		r4,(Dcm_LCfg+76)@ha		# didIdentifier=r4
	lwz		r28,(Dcm_LCfg+76)@l(r4)		# pDid=r28 didIdentifier=r4
	rlwinm		r4,r0,5,0,26		# didIdentifier=r4 didIdentifier=r0
	se_slwi		r0,3		# didIdentifier=r0 didIdentifier=r0
	subf		r0,r0,r4		# didIdentifier=r0 didIdentifier=r0 didIdentifier=r4
	se_add		r0,r28		# didIdentifier=r0 didIdentifier=r0 pDid=r28
	mr		r28,r0		# pDid=r28 pDid=r0
.L1089:
#          }
#       }
	.d2line		4860
	diab.addi		r0,r3,1		# didIdentifier=r0 confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L1086
.L1088:
# 
#       /*
#        * 1. Was the DID found amongst the configured ones?
#        */
#       if (NULL_PTR == pDid)
	.d2line		4865
	se_cmpi		r28,0		# pDid=r28
	bc		0,2,.L1090	# ne
#       {
#          /*
#           * The requested DID was not found. Report an error and break.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4870
.Llo2024:
	diab.li		r0,49		# didIdentifier=r0
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1091
.L1090:
#       }
#       /*
#        * 2. Is the DID statically defined?
#        */
#       else if (NULL_PTR == pDid->pDataSourcesDefine)
	.d2line		4875
	lwz		r0,12(r28)		# didIdentifier=r0 pDid=r28
	se_cmpi		r0,0		# didIdentifier=r0
	bc		0,2,.L1092	# ne
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4877
	diab.li		r0,49		# didIdentifier=r0
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1091
.L1092:
#       }
#       /*
#        * 3. Can the DID be defined in the current session?
#        */
#       else if (FALSE == Dcm_IsLevelSupported(activeSession, pDid->pDDDidInfo->p_session_levels))
	.d2line		4882
	lwz		r3,4(r28)		# confDidCounter=r3 pDid=r28
.Llo2025:
	lwz		r4,8(r3)		# didIdentifier=r4 confDidCounter=r3
	lbz		r3,8(r1)		# confDidCounter=r3
.Llo2026:
	bl		Dcm_IsLevelSupported
.Llo2027:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo2028:
	bc		0,2,.L1094	# ne
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		4884
	diab.li		r0,49		# didIdentifier=r0
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
	b		.L1091
.L1094:
#       }
#       /*
#        * 4. Can the DID be defined in the current security level?
#        */
#       else if (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, pDid->pDDDidInfo->p_security_levels))
	.d2line		4889
	lwz		r3,4(r28)		# confDidCounter=r3 pDid=r28
.Llo2029:
	lwz		r4,4(r3)		# didIdentifier=r4 confDidCounter=r3
	lbz		r3,9(r1)		# confDidCounter=r3
.Llo2030:
	bl		Dcm_IsLevelSupported
.Llo2031:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo2032:
	bc		0,2,.L1091	# ne
#       {
#          *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		4891
	diab.li		r0,51		# didIdentifier=r0
	stb		r0,0(r30)		# pErrorCode=r30 didIdentifier=r0
.L1091:
#       }
#       else
#       {
#          /*
#           * The common validation is OK, continue with defining the DID.
#           */
#       }
# 
#       /*
#        * Only define the DID if all checks are OK
#        * It is not necessary to check the pDid since it is checked above, but it will remove a SCA warning.
#        */
#       if ((0 != *pErrorCode) || (NULL_PTR == pDid))
	.d2line		4904
	lbz		r0,0(r30)		# didIdentifier=r0 pErrorCode=r30
	se_cmpi		r0,0		# didIdentifier=r0
	bc		0,2,.L1078	# ne
	se_cmpi		r28,0		# pDid=r28
	bc		1,2,.L1078	# eq
#       {
#          /*
#           * Any error will be reported below.
#           */
#       }
#       else
#       {
#          if (0x01U == subFunc) /* defineByIdentifier */
	.d2line		4912
	rlwinm		r0,r27,0,24,31		# didIdentifier=r0 subFunc=r27
	se_cmpi		r0,1		# didIdentifier=r0
	bc		0,2,.L1100	# ne
#          {
#             /*
#              * DefineDDDidByIdentifier will handle incorrect request lengths
#              */
#             *pErrorCode = DefineDDDidByIdentifier(pDid, activeSession, activeSecurityLevel, pMsgContext);
	.d2line		4917
	lbz		r4,8(r1)		# didIdentifier=r4
	lbz		r5,9(r1)
	mr		r3,r28		# pDid=r3 pDid=r28
	mr		r6,r31		# pMsgContext=r6 pMsgContext=r31
	bl		DefineDDDidByIdentifier
	stb		r3,0(r30)		# pErrorCode=r30 pDid=r3
	b		.L1101
.L1100:
#          }
#          else if (0x02U == subFunc) /* defineByMemoryAddress */
	.d2line		4919
	rlwinm		r27,r27,0,24,31		# subFunc=r27 subFunc=r27
	se_cmpi		r27,2		# subFunc=r27
	bc		0,2,.L1102	# ne
#          {
#             /*
#              * DefineDDDidByMemoryAddress will handle incorrect request lengths
#              */
#             *pErrorCode = DefineDDDidByMemoryAddress(pDid, pMsgContext);
	.d2line		4924
.Llo2064:
	mr		r3,r28		# pDid=r3 pDid=r28
	mr		r4,r31		# pMsgContext=r4 pMsgContext=r31
	bl		DefineDDDidByMemoryAddress
	stb		r3,0(r30)		# pErrorCode=r30 pDid=r3
	b		.L1101
.L1102:
#          }
#          /*
#           * Only clearDynamicallyDefinedDataIdentifier left.
#           * SCG will guarantee that only sub-functions 1, 2 and 3 will be configured.
#           *
#           * But first check so the request length was correct
#           */
#          else
#          {
#             /*
#              * Clear one DDDID
#              */
#             *pDid->pNumberOfDefinedSources = 0;
	.d2line		4937
	diab.li		r0,0		# didIdentifier=r0
	lwz		r3,16(r28)		# confDidCounter=r3 pDid=r28
.Llo2033:
	stb		r0,0(r3)		# confDidCounter=r3 didIdentifier=r0
.L1101:
#          }
# 
#          /* NvM_SetRamBlockStatus is only relevant for dynamically defined periodic DIDs */
#          if (PERIODIC_HIGH_BYTE == DcmHiByte(didIdentifier))
	.d2line		4941
.Llo2019:
	rlwinm		r29,r29,24,24,31		# didIdentifier=r29 didIdentifier=r29
	cmpi		0,0,r29,242		# didIdentifier=r29
	bc		0,2,.L1078	# ne
#          {
#             Dcm_NvMSetRamBlockStatus();
	.d2line		4943
.Llo2060:
	bl		Dcm_NvMSetRamBlockStatus
.L1078:
#          }
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		4948
	lbz		r3,0(r30)		# confDidCounter=r3 pErrorCode=r30
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2062:
	rlwinm		r3,r3,0,24,31		# pDid=r3 pDid=r3
# }
	.d2line		4949
	.d2epilogue_begin
.Llo2063:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
.Llo2022:
	lwz		r0,52(r1)		# didIdentifier=r0
	mtspr		lr,r0		# didIdentifier=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4643:
	.type		Dcm_DynamicallyDefineDataIdentifier,@function
	.size		Dcm_DynamicallyDefineDataIdentifier,.-Dcm_DynamicallyDefineDataIdentifier
# Number of nodes = 332

# Allocations for Dcm_DynamicallyDefineDataIdentifier
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$110
#	?a7		$$109
#	?a8		confDidCounter
#	?a9		didIdentifier
#	?a10		pDid
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	?a11		subFunc
# static FUNC(void, DCM_CODE) ChangeAsyncState(P2VAR(AsynchronousStateType, AUTOMATIC, DCM_APPL_DATA) pAsynchState,
	.align		1
	.section	.text_vle
        .d2line         12920,29
#$$ld
.L4659:

#$$bf	ChangeAsyncState,interprocedural,nostackparams

# Regs written: r0,r1,r3,r6,cr0,lr
	.d2_cfa_start __cie
ChangeAsyncState:
.Llo2065:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pAsynchState=r3 pAsynchState=r3
	mr		r6,r4		# ErrorCode=r6 ErrorCode=r4
	.d2prologue_end
#                                             CONST(Dcm_NegativeResponseCodeType, AUTOMATIC) ErrorCode)
# {
#    switch (ErrorCode)
	.d2line		12923
	rlwinm		r6,r6,0,24,31		# ErrorCode=r6 ErrorCode=r6
	se_cmpi		r6,0		# ErrorCode=r6
	bc		1,2,.L2642	# eq
.Llo2067:
	cmpi		0,0,r6,162		# ErrorCode=r6
.Llo2068:
	bc		1,2,.L2644	# eq
	cmpi		0,0,r6,163		# ErrorCode=r6
	bc		1,2,.L2645	# eq
.Llo2069:
	b		.L2646
.L2642:
#    {
#       case DCM_INT_NRC_POSITIVERESPONSE:
#       {
#          *pAsynchState = DCM_ASYNCH_STATE_ACCEPTED;
	.d2line		12927
.Llo2070:
	diab.li		r0,3
	stw		r0,0(r3)		# pAsynchState=r3
	b		.L2641
.L2644:
#          break;
#       }
# 
#       case DCM_INT_NRC_API_RETURNED_PENDING:
#       {
#          *pAsynchState = DCM_ASYNCH_STATE_PENDING;
	.d2line		12933
	diab.li		r0,1
	stw		r0,0(r3)		# pAsynchState=r3
	b		.L2641
.L2645:
#          break;
#       }
# 
#       case DCM_INT_NRC_API_RETURNED_FORCE_RCRRP:
#       {
#          /*
#           * State is not used but it will prevent actions in service handlers
#           * until the forced NRC 0x78 has been confirmed.
#           */
#          *pAsynchState = DCM_ASYNCH_STATE_FORCE_RCRRP_WAIT_CONF;
	.d2line		12943
.Llo2071:
	diab.li		r0,9
.Llo2072:
	stw		r0,0(r3)		# pAsynchState=r3
	b		.L2641
.L2646:
#          break;
#       }
# 
#       default:
#       {
#          /*
#           * All possible errors
#           */
#          *pAsynchState = DCM_ASYNCH_STATE_REJECTED;
	.d2line		12952
	diab.li		r0,4
	stw		r0,0(r3)		# pAsynchState=r3
.L2641:
#          break;
#       }
#    }
# }
	.d2line		12956
	.d2epilogue_begin
.Llo2066:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo2073:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4660:
	.type		ChangeAsyncState,@function
	.size		ChangeAsyncState,.-ChangeAsyncState
# Number of nodes = 23

# Allocations for ChangeAsyncState
#	?a4		pAsynchState
#	?a5		ErrorCode
# static FUNC(void, DCM_CODE) DidWriteHelperFunction(CONSTP2VAR(WriteDataByIdentifierOperationStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus,
	.align		1
	.section	.text_vle
        .d2line         14376,29
#$$ld
.L4669:

#$$bf	DidWriteHelperFunction,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
DidWriteHelperFunction:
.Llo2074:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pStatus=r31 pStatus=r3
.Llo2075:
	mr		r30,r4		# opStatus=r30 opStatus=r4
.Llo2076:
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
#                                                    Dcm_OpStatusType opStatus,
#                                                    CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Std_ReturnType stdReturnVal = E_NOT_OK;
	.d2line		14380
	diab.li		r3,1		# stdReturnVal=r3
# 
#    /*
#     * The caller will make sure the different function pointers are
#     * mutually exlusive. I.e. If a single DID is used will only
#     * SingleDidWriteDataFunc be defined and not the range pointers.
#     */
#    if (NULL_PTR != pStatus->SingleDidWriteDataFunc)
	.d2line		14387
.Llo2084:
	lwz		r0,12(r31)		# pStatus=r31
	se_cmpi		r0,0
	bc		1,2,.L3043	# eq
#    {
#       /*
#        * Write a single DID
#        */
#       stdReturnVal = pStatus->SingleDidWriteDataFunc(pStatus->pDataBuf,
	.d2line		14392
.Llo2078:
	lwz		r0,12(r31)		# pStatus=r31
.Llo2079:
	mtspr		ctr,r0
	lhz		r4,4(r31)		# pStatus=r31
	lwz		r3,8(r31)		# stdReturnVal=r3 pStatus=r31
	rlwinm		r5,r30,0,24,31		# opStatus=r30
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2085:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
.L3043:
#          pStatus->requestedDataLengthToWrite,
#          opStatus,
#          pErrorCode);
#    }
# 
#    if (NULL_PTR != pStatus->RangeDidIsAvailableFunc)
	.d2line		14398
	lwz		r0,20(r31)		# pStatus=r31
	se_cmpi		r0,0
	bc		1,2,.L3044	# eq
	.section	.text_vle
.L4681:
#    {
#       /*
#        * The range has gaps so check the availability of the
#        * requested DID.
#        */
#       Dcm_DidSupportedType supported;
#       stdReturnVal = pStatus->RangeDidIsAvailableFunc(pStatus->identifier, opStatus, &supported);
	.d2line		14405
.Llo2086:
	lwz		r0,20(r31)		# pStatus=r31
	mtspr		ctr,r0
	lhz		r3,2(r31)		# stdReturnVal=r3 pStatus=r31
	rlwinm		r4,r30,0,24,31		# opStatus=r30
	diab.addi		r5,r1,8
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2087:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
# 
#       if ((E_OK == stdReturnVal) && (DCM_DID_SUPPORTED == supported))
	.d2line		14407
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r3
	se_cmpi		r0,0
	bc		0,2,.L3045	# ne
	lbz		r0,8(r1)
	se_cmpi		r0,0
	bc		0,2,.L3045	# ne
#       {
#          /*
#           * The requested DID was supported.
#           * Disable future calls to the IsAvailableFunc in case of 
#           * RangeDidWriteDataFunc does return pending.
#           */
#          pStatus->RangeDidIsAvailableFunc = NULL_PTR;
	.d2line		14414
	diab.li		r0,0
	stw		r0,20(r31)		# pStatus=r31
	b		.L3044
.L3045:
#       }
#       else if (DCM_E_PENDING == stdReturnVal)
	.d2line		14416
	rlwinm		r0,r3,0,24,31		# stdReturnVal=r3
	se_cmpi		r0,10
	bc		0,2,.L3047	# ne
#       {
#          /*
#           * RangeDidIsAvailableFunc shall be called
#           * again in the next schedule.
#           */
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		14422
	diab.li		r0,162
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L3044
.L3047:
#       }
#       else
#       {
#          /*
#           * The requested DID was not available. Therefore consider the DID
#           * as not supported ([SWS_Dcm_00467]) and thus return NRC 0x31, RequestOutOfRange.
#           *
#           * Also handle all other response values (including E_NOT_OK)
#           * as the DID wasn't available (aka not supported).
#           *
#           * Disable the RangeDidWriteDataFunc since it shall not be called for unsupported DIDs.
#           */
#          stdReturnVal = E_NOT_OK;
	.d2line		14435
	diab.li		r3,1		# stdReturnVal=r3
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14436
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
#          pStatus->RangeDidWriteDataFunc = NULL_PTR;
	.d2line		14437
	diab.li		r0,0
	stw		r0,16(r31)		# pStatus=r31
	.section	.text_vle
.L4682:
.L3044:
#       }
#    }
# 
#    if (NULL_PTR != pStatus->RangeDidWriteDataFunc)
	.d2line		14441
	lwz		r0,16(r31)		# pStatus=r31
	se_cmpi		r0,0
	bc		1,2,.L3049	# eq
#    {
#       /*
#        * Write the requested DID 
#        */
#       stdReturnVal = pStatus->RangeDidWriteDataFunc(pStatus->identifier,
	.d2line		14446
.Llo2088:
	lwz		r0,16(r31)		# pStatus=r31
	mtspr		ctr,r0
	lhz		r3,2(r31)		# stdReturnVal=r3 pStatus=r31
	lhz		r6,4(r31)		# pStatus=r31
	lwz		r4,8(r31)		# pStatus=r31
	rlwinm		r5,r30,0,24,31		# opStatus=r30
	mr		r7,r29		# pErrorCode=r7 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2080:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
.L3049:
#          pStatus->pDataBuf,
#          opStatus,
#          pStatus->requestedDataLengthToWrite,
#          pErrorCode);
#    }
# 
#    HandleStdRetVal(stdReturnVal, pStatus->RetStatus, FALSE, pErrorCode);
	.d2line		14453
.Llo2081:
	lbz		r4,1(r31)		# pStatus=r31
.Llo2082:
	mr		r3,r3		# stdReturnVal=r3 stdReturnVal=r3
.Llo2089:
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,0
.Llo2083:
	bl		HandleStdRetVal
# }
	.d2line		14454
	.d2epilogue_begin
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
.Llo2077:
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4670:
	.type		DidWriteHelperFunction,@function
	.size		DidWriteHelperFunction,.-DidWriteHelperFunction
# Number of nodes = 147

# Allocations for DidWriteHelperFunction
#	?a4		pStatus
#	?a5		opStatus
#	?a6		pErrorCode
#	?a7		stdReturnVal
#	SP,8		supported
# FUNC(Std_ReturnType, DCM_CODE) Dcm_WriteDataByIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         4955,32
#$$ld
.L4688:

#$$bf	Dcm_WriteDataByIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_WriteDataByIdentifier
	.d2_cfa_start __cie
Dcm_WriteDataByIdentifier:
.Llo2090:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	28,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    /* Each DID is two bytes */
#    uint16 confDidCounter;
#    P2CONST(Dcm_Cfg_DidType, AUTOMATIC, DCM_APPL_CONST) pDid = NULL_PTR;
	.d2line		4959
	diab.li		r29,0		# pDid=r29
#    P2CONST(Dcm_Cfg_DidRangeType, AUTOMATIC, DCM_APPL_CONST) pDidRange = NULL_PTR;
	.d2line		4960
.Llo2132:
	diab.li		r28,0
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
# 
#    CONSTP2VAR(WriteDataByIdentifierOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.writeDataByIdentifier_status;
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		4966
.Llo2135:
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,1
	bc		0,2,.L1122	# ne
#    {
#       /*
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the write function pointer is valid. A DID with Nvm interface will never come here
#        * Using range or not is found during the init phase
#        */
#       DidWriteHelperFunction(status, DCM_PENDING, pErrorCode);
	.d2line		4973
.Llo2091:
	lis		r3,(Dcm_DspInstance+84)@ha
.Llo2092:
	e_add16i		r3,r3,(Dcm_DspInstance+84)@l
	diab.li		r4,1
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidWriteHelperFunction
#       ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		4974
	lis		r3,(Dcm_DspInstance+8)@ha
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l
	lbz		r4,0(r30)		# pErrorCode=r30
	bl		ChangeAsyncState
.L1122:
#    }
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		4977
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r0,0
	bc		0,2,.L1123	# ne
#    {
#       /*
#          * Do some initiation:
#          * - Clear the response length
#          * - Get the current session
#          * - Get the current security level
#          */
#       pMsgContext->resDataLen = 0;
	.d2line		4985
	diab.li		r0,0
	sth		r0,12(r31)		# pMsgContext=r31
# 
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * [SWS_Dcm_00339] : E_OK shall always be returned.
#        * [SWS_Dcm_00338] : E_OK shall always be returned.
#        */
#       (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		4993
	diab.addi		r3,r1,8
	bl		Dcm_GetSesCtrlType
#       (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		4994
	diab.addi		r3,r1,9
	bl		Dcm_GetSecurityLevel
# 
#       /* The request length shall not be smaller than three */
#       if (3 > pMsgContext->reqDataLen)
	.d2line		4997
	lhz		r0,4(r31)		# pMsgContext=r31
	se_cmpi		r0,3
	bc		0,0,.L1124	# ge
#       {
#          /*
#           * The request shall contain at least one DID identifier and one byte data
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5002
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1124:
	.d2line		4964
	lhz		r0,4(r31)		# pMsgContext=r31
	diab.li		r3,65534		# confDidCounter=r3
.Llo2096:
	se_add		r0,r3		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+88)@ha		# confDidCounter=r3
	sth		r0,(Dcm_DspInstance+88)@l(r3)		# confDidCounter=r3
	lwz		r3,0(r31)		# confDidCounter=r3 pMsgContext=r31
	diab.addi		r0,r3,2		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+92)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+92)@l(r3)		# confDidCounter=r3
	lwz		r3,0(r31)		# confDidCounter=r3 pMsgContext=r31
	lbz		r0,0(r3)		# confDidCounter=r3
	se_slwi		r0,8
	lbz		r3,1(r3)		# confDidCounter=r3 confDidCounter=r3
	or		r0,r0,r3		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+86)@ha		# confDidCounter=r3
	sth		r0,(Dcm_DspInstance+86)@l(r3)		# confDidCounter=r3
#       }
#       else
#       {
#          /*
#           * Before calling the application to write the DID data several checks have to be done:
#           * 1. Was the DID found amongst the configured ones?
#           * 2. Can the DID be written in the current session?
#           * 3. Can the DID be written in the current security level?
#           * 4. Does the application allow the DID to be read?
#           * 5. Does the recevied data length match the expected one (fixed or read)?
#           */
# 
#          /* To get the length of the data that shall be written, remove the 2
#           * byte DID from the request length.
#           */
#          status->requestedDataLengthToWrite = (uint16)(pMsgContext->reqDataLen - (Dcm_MsgLenType)2U);
#          status->pDataBuf = &pMsgContext->reqData[2];
#          status->identifier = GET_2BYTE_ID(&pMsgContext->reqData[0]);
# 
#          /*
#           * Try to find a matching DID in the configuration
#           */
#          for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_dids) && (NULL_PTR == pDid); confDidCounter++)
	.d2line		5025
	diab.li		r3,0		# confDidCounter=r3
.L1126:
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+64)@ha
	lhz		r4,(Dcm_LCfg+64)@l(r4)
	se_cmp		r0,r4
	bc		0,0,.L1128	# ge
	se_cmpi		r29,0		# pDid=r29
	bc		0,2,.L1128	# ne
#          {
#             if ((Dcm_LCfg.dids[confDidCounter].identifier == status->identifier) && (NULL_PTR != Dcm_LCfg.dids[confDidCounter].pDidWrite))
	.d2line		5027
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5
	se_slwi		r0,2
	subf		r0,r0,r5		# pErrorCode=r5
	lhzx		r0,r4,r0
	lis		r4,(Dcm_DspInstance+86)@ha
	lhz		r4,(Dcm_DspInstance+86)@l(r4)
	se_cmp		r0,r4
	bc		0,2,.L1129	# ne
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5
	se_slwi		r0,2
	subf		r0,r0,r5		# pErrorCode=r5
	se_add		r4,r0
	lwz		r0,8(r4)
	se_cmpi		r0,0
	bc		1,2,.L1129	# eq
#             {
#                pDid = &Dcm_LCfg.dids[confDidCounter];
	.d2line		5029
	rlwinm		r0,r3,0,16,31		# confDidCounter=r3
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r29,(Dcm_LCfg+68)@l(r4)		# pDid=r29
	rlwinm		r4,r0,5,0,26
	se_slwi		r0,2
	subf		r0,r0,r4
	se_add		r0,r29		# pDid=r29
	mr		r29,r0		# pDid=r29 pDid=r0
.L1129:
#             }
#          }
	.d2line		5031
	diab.addi		r0,r3,1		# confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L1126
.L1128:
# 
#          /*
#           * 1. Was the DID found amongst the configured ones?
#           * If so store the DID data. If not, try the range section.
#           */
#          if (NULL_PTR != pDid)
	.d2line		5037
	se_cmpi		r29,0		# pDid=r29
	bc		1,2,.L1130	# eq
	.d2line		4964
.Llo2097:
	lbz		r0,25(r29)		# pDid=r29
	lis		r3,(Dcm_DspInstance+84)@ha		# confDidCounter=r3
.Llo2098:
	stb		r0,(Dcm_DspInstance+84)@l(r3)		# confDidCounter=r3
	lhz		r0,2(r29)		# pDid=r29
	lis		r3,(Dcm_DspInstance+90)@ha		# confDidCounter=r3
	sth		r0,(Dcm_DspInstance+90)@l(r3)		# confDidCounter=r3
	lwz		r3,8(r29)		# confDidCounter=r3 pDid=r29
	lwz		r0,8(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+112)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+112)@l(r3)		# confDidCounter=r3
	lwz		r3,8(r29)		# confDidCounter=r3 pDid=r29
	lwz		r0,4(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+108)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+108)@l(r3)		# confDidCounter=r3
	lwz		r3,8(r29)		# confDidCounter=r3 pDid=r29
	lwz		r0,12(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+116)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+116)@l(r3)		# confDidCounter=r3
	lwz		r3,8(r29)		# confDidCounter=r3 pDid=r29
	lwz		r0,0(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+96)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+96)@l(r3)		# confDidCounter=r3
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+100)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+100)@l(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+104)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+104)@l(r3)		# confDidCounter=r3
	lbz		r0,24(r29)		# pDid=r29
	lis		r3,(Dcm_DspInstance+85)@ha		# confDidCounter=r3
	stb		r0,(Dcm_DspInstance+85)@l(r3)		# confDidCounter=r3
	b		.L1131
.L1130:
#          {
#             /*
#              * Store data of the found DID
#              */
#             status->fixed_length = pDid->hasFixedLength;
#             status->size = pDid->size;
#             status->p_session_levels = pDid->pDidWrite->p_session_levels;
#             status->p_security_levels = pDid->pDidWrite->p_security_levels;
#             status->modeRuleFunc = pDid->pDidWrite->modeRuleFunc;
#             status->SingleDidWriteDataFunc = pDid->pDidWrite->WriteDataFunc;
#             status->RangeDidWriteDataFunc = NULL_PTR;
#             status->RangeDidIsAvailableFunc = NULL_PTR;
#             status->RetStatus = pDid->RetStatus;
#          }
#          else
#          {
#             /*
#              * Try to find the DID in the range scope 
#              */
#             for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_did_ranges) && (NULL_PTR == pDidRange); confDidCounter++)
	.d2line		5057
.Llo2099:
	diab.li		r4,0		# confDidCounter=r4
.L1132:
.Llo2100:
	rlwinm		r5,r4,0,16,31		# pErrorCode=r5 confDidCounter=r4
	lis		r3,(Dcm_LCfg+86)@ha		# confDidCounter=r3
	lhz		r0,(Dcm_LCfg+86)@l(r3)		# confDidCounter=r3
	se_cmp		r5,r0		# pErrorCode=r5
	bc		0,0,.L1134	# ge
	se_cmpi		r28,0		# pDidRange=r28
	bc		0,2,.L1134	# ne
	.d2line		4964
	lis		r3,(Dcm_DspInstance+86)@ha		# confDidCounter=r3
	lhz		r0,(Dcm_DspInstance+86)@l(r3)		# confDidCounter=r3
	lis		r3,(Dcm_LCfg+88)@ha		# confDidCounter=r3
	lwz		r3,(Dcm_LCfg+88)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	rlwinm		r5,r4,0,16,31		# pErrorCode=r5 confDidCounter=r4
	e_mulli		r5,r5,20		# pErrorCode=r5 pErrorCode=r5
	lhzx		r3,r3,r5		# confDidCounter=r3 confDidCounter=r3
	se_cmp		r0,r3		# confDidCounter=r3
	bc		1,0,.L1135	# lt
	lis		r3,(Dcm_DspInstance+86)@ha		# confDidCounter=r3
	lhz		r0,(Dcm_DspInstance+86)@l(r3)		# confDidCounter=r3
	lis		r3,(Dcm_LCfg+88)@ha		# confDidCounter=r3
	lwz		r5,(Dcm_LCfg+88)@l(r3)		# pErrorCode=r5 confDidCounter=r3
	rlwinm		r3,r4,0,16,31		# confDidCounter=r3 confDidCounter=r4
	e_mulli		r3,r3,20		# confDidCounter=r3 confDidCounter=r3
	se_add		r3,r5		# confDidCounter=r3 confDidCounter=r3 pErrorCode=r5
	lhz		r3,2(r3)		# confDidCounter=r3 confDidCounter=r3
	se_cmp		r0,r3		# confDidCounter=r3
	bc		1,1,.L1135	# gt
#             {
#                if ((status->identifier >= Dcm_LCfg.p_did_ranges[confDidCounter].lower_limit) && 
	.d2line		5059
	lis		r3,(Dcm_LCfg+88)@ha		# confDidCounter=r3
	lwz		r0,(Dcm_LCfg+88)@l(r3)		# confDidCounter=r3
	rlwinm		r3,r4,0,16,31		# confDidCounter=r3 confDidCounter=r4
	e_mulli		r3,r3,20		# confDidCounter=r3 confDidCounter=r3
	se_add		r3,r0		# confDidCounter=r3 confDidCounter=r3
	lwz		r0,16(r3)		# confDidCounter=r3
	se_cmpi		r0,0
	bc		1,2,.L1135	# eq
#                   (status->identifier <= Dcm_LCfg.p_did_ranges[confDidCounter].upper_limit) && 
#                   (NULL_PTR != Dcm_LCfg.p_did_ranges[confDidCounter].p_did_range_write))
#                {
#                   pDidRange = &Dcm_LCfg.p_did_ranges[confDidCounter];
	.d2line		5063
	lis		r3,(Dcm_LCfg+88)@ha		# confDidCounter=r3
	lwz		r28,(Dcm_LCfg+88)@l(r3)		# pDidRange=r28 confDidCounter=r3
	rlwinm		r3,r4,0,16,31		# confDidCounter=r3 confDidCounter=r4
	e_mulli		r3,r3,20		# confDidCounter=r3 confDidCounter=r3
	se_add		r3,r28		# confDidCounter=r3 confDidCounter=r3 pDidRange=r28
	mr		r28,r3		# pDidRange=r28 pDidRange=r3
.L1135:
#                }
#             }
	.d2line		5065
	diab.addi		r3,r4,1		# confDidCounter=r3 confDidCounter=r4
	se_addi		r4,1		# confDidCounter=r4 confDidCounter=r4
	b		.L1132
.L1134:
# 
#             if (NULL_PTR != pDidRange)
	.d2line		5067
	se_cmpi		r28,0		# pDidRange=r28
	bc		1,2,.L1131	# eq
	.d2line		4964
.Llo2101:
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+84)@ha		# confDidCounter=r3
.Llo2102:
	stb		r0,(Dcm_DspInstance+84)@l(r3)		# confDidCounter=r3
	lhz		r4,4(r28)		# confDidCounter=r4 pDidRange=r28
	lis		r3,(Dcm_DspInstance+90)@ha		# confDidCounter=r3
	sth		r4,(Dcm_DspInstance+90)@l(r3)		# confDidCounter=r3 confDidCounter=r4
	lwz		r3,16(r28)		# confDidCounter=r3 pDidRange=r28
	lwz		r4,8(r3)		# confDidCounter=r4 confDidCounter=r3
	lis		r3,(Dcm_DspInstance+112)@ha		# confDidCounter=r3
	stw		r4,(Dcm_DspInstance+112)@l(r3)		# confDidCounter=r3 confDidCounter=r4
	lwz		r3,16(r28)		# confDidCounter=r3 pDidRange=r28
	lwz		r4,4(r3)		# confDidCounter=r4 confDidCounter=r3
	lis		r3,(Dcm_DspInstance+108)@ha		# confDidCounter=r3
	stw		r4,(Dcm_DspInstance+108)@l(r3)		# confDidCounter=r3 confDidCounter=r4
	lwz		r3,16(r28)		# confDidCounter=r3 pDidRange=r28
	lwz		r4,12(r3)		# confDidCounter=r4 confDidCounter=r3
	lis		r3,(Dcm_DspInstance+116)@ha		# confDidCounter=r3
	stw		r4,(Dcm_DspInstance+116)@l(r3)		# confDidCounter=r3 confDidCounter=r4
	lis		r3,(Dcm_DspInstance+96)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+96)@l(r3)		# confDidCounter=r3
	lwz		r0,8(r28)		# pDidRange=r28
	lis		r3,(Dcm_DspInstance+104)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+104)@l(r3)		# confDidCounter=r3
	lwz		r3,16(r28)		# confDidCounter=r3 pDidRange=r28
	lwz		r0,0(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+100)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+100)@l(r3)		# confDidCounter=r3
	diab.li		r0,10
	lis		r3,(Dcm_DspInstance+85)@ha		# confDidCounter=r3
	stb		r0,(Dcm_DspInstance+85)@l(r3)		# confDidCounter=r3
.L1131:
#             {
#                /*
#                 * Store data of the found Did
#                 */
#                status->fixed_length = FALSE; /* A did range is always considered to be dynamic length. */
#                status->size = pDidRange->max_data_length;
#                status->p_session_levels = pDidRange->p_did_range_write->p_session_levels;
#                status->p_security_levels = pDidRange->p_did_range_write->p_security_levels;
#                status->modeRuleFunc = pDidRange->p_did_range_write->modeRuleFunc;
#                status->SingleDidWriteDataFunc = NULL_PTR;
#                status->RangeDidIsAvailableFunc = pDidRange->IsDidAvailableFunc;
#                status->RangeDidWriteDataFunc = pDidRange->p_did_range_write->WriteDidDataFunc;
#                status->RetStatus = DCM_E_PENDING; /* A did range is always considered to asynchronous. */
#             }
#          }
# 
#          if ((NULL_PTR == pDid) && (NULL_PTR == pDidRange))
	.d2line		5084
.Llo2103:
	se_cmpi		r29,0		# pDid=r29
	bc		0,2,.L1137	# ne
.Llo2133:
	se_cmpi		r28,0		# pDidRange=r28
	bc		0,2,.L1137	# ne
#          {
#             /*
#              * The requested DID was not found. Report an error and break.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5089
.Llo2136:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1137:
#          }
#          /*
#           * 2. Can the DID be written in the current session?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSession, status->p_session_levels))
	.d2line		5094
.Llo2137:
	lbz		r3,8(r1)		# confDidCounter=r3
	lis		r4,(Dcm_DspInstance+112)@ha		# confDidCounter=r4
.Llo2104:
	lwz		r4,(Dcm_DspInstance+112)@l(r4)		# confDidCounter=r4 confDidCounter=r4
.Llo2105:
	bl		Dcm_IsLevelSupported
.Llo2106:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo2107:
	bc		0,2,.L1139	# ne
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5096
.Llo2138:
	diab.li		r0,49
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1139:
#          }
#          /*
#           * 3. Can the DID be written in the current security level?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, status->p_security_levels))
	.d2line		5101
	lbz		r3,9(r1)		# confDidCounter=r3
	lis		r4,(Dcm_DspInstance+108)@ha		# confDidCounter=r4
.Llo2108:
	lwz		r4,(Dcm_DspInstance+108)@l(r4)		# confDidCounter=r4 confDidCounter=r4
.Llo2109:
	bl		Dcm_IsLevelSupported
.Llo2110:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo2111:
	bc		0,2,.L1141	# ne
#          {
#             *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		5103
	diab.li		r0,51
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1141:
#          }
#          /*
#           * 4. [SWS_Dcm_00822]: If the Did can be written in the current mode conditions?
#           */
#          else if (!Dcm_IsCurrentModesAllowed(status->modeRuleFunc, pErrorCode))
	.d2line		5108
	lis		r3,(Dcm_DspInstance+116)@ha		# confDidCounter=r3
.Llo2112:
	lwz		r3,(Dcm_DspInstance+116)@l(r3)		# confDidCounter=r3 confDidCounter=r3
.Llo2113:
	mr		r4,r30		# pErrorCode=r4 pErrorCode=r30
	bl		Dcm_IsCurrentModesAllowed
.Llo2114:
	e_andi.		r3,r3,255		# confDidCounter=r3 confDidCounter=r3
.Llo2115:
	bc		0,2,.L1143	# ne
#          {
#             /*
#              * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#              */
#             HandleNrcResponsePending(*pErrorCode);
	.d2line		5113
	lbz		r0,0(r30)		# pErrorCode=r30
	cmpi		0,0,r0,120
	bc		0,2,.L1155	# ne
	diab.li		r0,162
	b		.L1156
.L1155:
	lbz		r0,0(r30)		# pErrorCode=r30
.L1156:
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1143:
	.d2line		4964
	lis		r3,(Dcm_DspInstance+88)@ha		# confDidCounter=r3
.Llo2116:
	lhz		r0,(Dcm_DspInstance+88)@l(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+90)@ha		# confDidCounter=r3
	lhz		r3,(Dcm_DspInstance+90)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	se_cmp		r0,r3		# confDidCounter=r3
	bc		0,1,.L1145	# le
#          }
#          /*
#           * 5. Does the recevied data length match the expected fixed one?
#           */
#          else if (status->requestedDataLengthToWrite > status->size)
#          {
#             /*
#              * No matter if the DID is fixed length or not. The request length shall not bigger than the DID size.
#              */
#             *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5123
.Llo2117:
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1125
.L1145:
#          }
#          else if (FALSE == status->fixed_length)
	.d2line		5125
	lis		r3,(Dcm_DspInstance+84)@ha		# confDidCounter=r3
.Llo2118:
	lbz		r0,(Dcm_DspInstance+84)@l(r3)		# confDidCounter=r3
	se_cmpi		r0,0
	bc		1,2,.L1125	# eq
	.d2line		4964
.Llo2119:
	lis		r3,(Dcm_DspInstance+88)@ha		# confDidCounter=r3
.Llo2120:
	lhz		r0,(Dcm_DspInstance+88)@l(r3)		# confDidCounter=r3
	lis		r3,(Dcm_DspInstance+90)@ha		# confDidCounter=r3
	lhz		r3,(Dcm_DspInstance+90)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	se_cmp		r0,r3		# confDidCounter=r3
	bc		1,2,.L1125	# eq
#          {
#             /*
#              * The dynamic length for this DID is within range,
#              * continue and write the DID with the received length.
#              */
#          }
#          else if (status->requestedDataLengthToWrite != status->size)
#          {
#             /*
#              * The DID request length does not match the expected fixed length.
#              * No given response value according to specification.
#              */
#             *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5138
.Llo2121:
	diab.li		r0,19
	stb		r0,0(r30)		# pErrorCode=r30
.L1125:
#          }
#          else
#          {
#             /*
#              * The fixed length match the configured one, continue with write the did.
#              */
#          }
#       }
# 
#       /*
#        * Only write the data if all checks are OK
#        */
#       if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		5151
	lbz		r0,0(r30)		# pErrorCode=r30
	se_cmpi		r0,0
	bc		0,2,.L1123	# ne
#       {
# 
#          /*
#           * Write the actual data.
#           */
#          DidWriteHelperFunction(status, DCM_INITIAL, pErrorCode);
	.d2line		5157
	lis		r3,(Dcm_DspInstance+84)@ha		# confDidCounter=r3
.Llo2122:
	e_add16i		r3,r3,(Dcm_DspInstance+84)@l		# confDidCounter=r3 confDidCounter=r3
.Llo2123:
	diab.li		r4,0		# pErrorCode=r4
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidWriteHelperFunction
#          ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5158
	lis		r3,(Dcm_DspInstance+8)@ha		# confDidCounter=r3
.Llo2124:
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# confDidCounter=r3 confDidCounter=r3
.Llo2125:
	lbz		r4,0(r30)		# pErrorCode=r4 pErrorCode=r30
	bl		ChangeAsyncState
.L1123:
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_CANCEL == Dcm_DspInstance.asynch_state)
	.d2line		5162
.Llo2134:
	lis		r3,(Dcm_DspInstance+8)@ha		# confDidCounter=r3
.Llo2126:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# confDidCounter=r3
	se_cmpi		r0,2
	bc		0,2,.L1152	# ne
#    {
#       /*
#        * The return result is not interesting since we cancel the service
#        *
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the write function pointer is valid. A did with Nvm interface will never come here
#        */
#       DidWriteHelperFunction(status, DCM_CANCEL, pErrorCode);
	.d2line		5170
.Llo2127:
	lis		r3,(Dcm_DspInstance+84)@ha		# confDidCounter=r3
.Llo2128:
	e_add16i		r3,r3,(Dcm_DspInstance+84)@l		# confDidCounter=r3 confDidCounter=r3
.Llo2129:
	diab.li		r4,2		# pErrorCode=r4
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidWriteHelperFunction
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		5171
	diab.li		r0,0
	stb		r0,0(r30)		# pErrorCode=r30
.L1152:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		5174
	lbz		r0,0(r30)		# pErrorCode=r30
	se_cmpi		r0,0
	bc		0,2,.L1153	# ne
#    {
#       /*
#        * The positive response only contains the DID identifier.
#        */
#       SET_2BYTE_ID(&pMsgContext->resData[0], status->identifier);
	.d2line		5179
	lis		r3,(Dcm_DspInstance+86)@ha		# confDidCounter=r3
.Llo2130:
	lhz		r0,(Dcm_DspInstance+86)@l(r3)		# confDidCounter=r3
	rlwinm		r0,r0,24,24,31
	lwz		r4,8(r31)		# confDidCounter=r4 pMsgContext=r31
	stb		r0,0(r4)		# confDidCounter=r4
	lhz		r0,(Dcm_DspInstance+86)@l(r3)		# confDidCounter=r3
	lwz		r3,8(r31)		# confDidCounter=r3 pMsgContext=r31
	stb		r0,1(r3)		# confDidCounter=r3
#       pMsgContext->resDataLen = 2;
	.d2line		5180
	diab.li		r0,2
	sth		r0,12(r31)		# pMsgContext=r31
.L1153:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		5183
.Llo2093:
	lbz		r3,0(r30)		# confDidCounter=r3 pErrorCode=r30
.Llo2094:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2095:
	rlwinm		r3,r3,0,24,31		# confDidCounter=r3 confDidCounter=r3
# }
	.d2line		5184
	.d2epilogue_begin
.Llo2131:
	lmw		r28,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)
	mtspr		lr,r0
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4689:
	.type		Dcm_WriteDataByIdentifier,@function
	.size		Dcm_WriteDataByIdentifier,.-Dcm_WriteDataByIdentifier
# Number of nodes = 675

# Allocations for Dcm_WriteDataByIdentifier
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$113
#	?a7		$$112
#	?a8		$$111
#	?a9		$$37
#	?a10		confDidCounter
#	?a11		pDid
#	?a12		pDidRange
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	not allocated	status
# static FUNC(void, DCM_CODE) DidControlHelpFunc(CONSTP2CONST(DidControlStatusType, AUTOMATIC, DCM_APPL_DATA) status,
	.align		1
	.section	.text_vle
        .d2line         14318,29
#$$ld
.L4703:

#$$bf	DidControlHelpFunc,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
DidControlHelpFunc:
.Llo2139:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
.Llo2162:
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)		# stdReturnVal=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# status=r31 status=r3
	mr		r6,r4		# opStatus=r6 opStatus=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
#                                                Dcm_OpStatusType opStatus,
#                                                CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Std_ReturnType stdReturnVal = E_NOT_OK;
	.d2line		14322
	diab.li		r0,1		# stdReturnVal=r0
# 
#    /*
#     *  Is the received inputOutputControlParameter supported?
#     */
#    if (status->ioctlsubFunction == IOCP_RCTECU)
	.d2line		14327
	lbz		r3,0(r31)		# status=r31
.Llo2140:
	se_cmpi		r3,0
	bc		0,2,.L3029	# ne
#    {
#       /*
#        * Request for Return Control To ECU
#        * The handler is always generated, guaranteed by the SCG [constr_6030].
#        */
#       stdReturnVal = Dcm_ReturnControlToECUWrapper(status->pDidCtrl->pDidControl->rctecu_index, opStatus, pErrorCode);
	.d2line		14333
.Llo2141:
	lwz		r3,12(r31)		# status=r31
.Llo2160:
	lwz		r3,16(r3)
	lhz		r3,8(r3)
	rlwinm		r4,r6,0,24,31		# opStatus=r6
.Llo2143:
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		Dcm_ReturnControlToECUWrapper
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L3030
.L3029:
#    }
#    else if ((status->ioctlsubFunction == IOCP_RTD) && ((uint16)0U != status->pDidCtrl->pDidControl->rtd_index))
	.d2line		14335
.Llo2144:
	lbz		r3,0(r31)		# status=r31
	se_cmpi		r3,1
	bc		0,2,.L3031	# ne
	lwz		r3,12(r31)		# status=r31
	lwz		r3,16(r3)
	lhz		r3,10(r3)
	se_cmpi		r3,0
	bc		1,2,.L3031	# eq
#    {
#       /*
#        * Request for Reset To Default and a handler is configured
#        */
#       stdReturnVal = Dcm_ResetToDefaultWrapper(status->pDidCtrl->pDidControl->rtd_index, opStatus, pErrorCode);
	.d2line		14340
.Llo2145:
	lwz		r3,12(r31)		# status=r31
.Llo2146:
	lwz		r3,16(r3)
	lhz		r3,10(r3)
	rlwinm		r4,r6,0,24,31		# opStatus=r6
.Llo2147:
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		Dcm_ResetToDefaultWrapper
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L3030
.L3031:
#    }
#    else if ((status->ioctlsubFunction == IOCP_FCS) && ((uint16)0U != status->pDidCtrl->pDidControl->fcs_index))
	.d2line		14342
.Llo2148:
	lbz		r3,0(r31)		# status=r31
	se_cmpi		r3,2
	bc		0,2,.L3033	# ne
	lwz		r3,12(r31)		# status=r31
	lwz		r3,16(r3)
	lhz		r3,12(r3)
	se_cmpi		r3,0
	bc		1,2,.L3033	# eq
#    {
#       /*
#        * Request for Freeze Current State and a handler is configured
#        */
#       stdReturnVal = Dcm_FreezeCurrentStateWrapper(status->pDidCtrl->pDidControl->fcs_index, opStatus, pErrorCode);
	.d2line		14347
.Llo2149:
	lwz		r3,12(r31)		# status=r31
.Llo2150:
	lwz		r3,16(r3)
	lhz		r3,12(r3)
	rlwinm		r4,r6,0,24,31		# opStatus=r6
.Llo2151:
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		Dcm_FreezeCurrentStateWrapper
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L3030
.L3033:
#    }
#    else if ((status->ioctlsubFunction == IOCP_STA) && ((uint16)0U != status->pDidCtrl->pDidControl->sta_index))
	.d2line		14349
.Llo2152:
	lbz		r3,0(r31)		# status=r31
	se_cmpi		r3,3
	bc		0,2,.L3035	# ne
	lwz		r3,12(r31)		# status=r31
	lwz		r3,16(r3)
	lhz		r3,14(r3)
	se_cmpi		r3,0
	bc		1,2,.L3035	# eq
#    {
#       /*
#        * Request for Short Term Adjustment and a handler is configured
#        */
#       stdReturnVal = Dcm_ShortTermAdjustmentWrapper(status->pDidCtrl->pDidControl->sta_index,
	.d2line		14354
.Llo2153:
	lwz		r3,12(r31)		# status=r31
.Llo2154:
	lwz		r3,16(r3)
	lhz		r3,14(r3)
	lhz		r5,2(r31)		# status=r31
	lwz		r4,8(r31)		# status=r31
.Llo2155:
	rlwinm		r6,r6,0,24,31		# opStatus=r6 opStatus=r6
	mr		r7,r30		# pErrorCode=r7 pErrorCode=r30
	bl		Dcm_ShortTermAdjustmentWrapper
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L3030
.L3035:
#                                                     status->ControlStateInfo,
#                                                     status->DynDataLengh,
#                                                     opStatus,
#                                                     pErrorCode);
#    }
#    else
#    {
#       /*
#        * 1. Incorrect input output control parameter
#        * 2. Correct input output control parameter but a handler was not configured.
#        */
#       *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		14366
.Llo2156:
	diab.li		r3,49
	stb		r3,0(r30)		# pErrorCode=r30
.L3030:
#    }
# 
#    HandleStdRetVal(stdReturnVal, status->pDidCtrl->RetStatus, FALSE, pErrorCode);
	.d2line		14369
.Llo2157:
	lwz		r3,12(r31)		# stdReturnVal=r3 status=r31
.Llo2158:
	lbz		r4,24(r3)		# stdReturnVal=r3
.Llo2159:
	mr		r3,r0		# stdReturnVal=r3 stdReturnVal=r0
	mr		r6,r30		# pErrorCode=r6 pErrorCode=r30
	diab.li		r5,0
.Llo2161:
	bl		HandleStdRetVal
# }
	.d2line		14370
	.d2epilogue_begin
.Llo2163:
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
.Llo2142:
	lwz		r0,36(r1)		# stdReturnVal=r0
	mtspr		lr,r0		# stdReturnVal=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4704:
	.type		DidControlHelpFunc,@function
	.size		DidControlHelpFunc,.-DidControlHelpFunc
# Number of nodes = 183

# Allocations for DidControlHelpFunc
#	?a4		status
#	?a5		opStatus
#	?a6		pErrorCode
#	?a7		stdReturnVal
# FUNC(Std_ReturnType, DCM_CODE) Dcm_InputOutputControlByIdentifier(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         5189,32
#$$ld
.L4718:

#$$bf	Dcm_InputOutputControlByIdentifier,interprocedural,rasave,nostackparams
	.globl		Dcm_InputOutputControlByIdentifier
	.d2_cfa_start __cie
Dcm_InputOutputControlByIdentifier:
.Llo2164:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
.Llo2193:
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)		# stdReturnVal=r0
	.d2_cfa_offset    108,-1
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    /* Each DID is two bytes */
#    uint16 confDidCounter;
#    CONST(uint16, AUTOMATIC) didIdentifier = GET_2BYTE_ID(&pMsgContext->reqData[0]); /* Request buffer itself is always valid */
#    Dcm_SesCtrlType activeSession;
#    Dcm_SecLevelType activeSecurityLevel;
#    Std_ReturnType stdReturnVal = E_OK;
	.d2line		5196
	diab.li		r0,0		# stdReturnVal=r0
	.d2line		5193
.Llo2194:
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r29,0(r3)		# stdReturnVal=r29
.Llo2195:
	se_slwi		r29,8		# stdReturnVal=r29
	lbz		r0,1(r3)		# stdReturnVal=r0
	or		r0,r0,r29		# stdReturnVal=r0 stdReturnVal=r0 stdReturnVal=r29
.Llo2191:
	mr		r29,r0		# didIdentifier=r29 didIdentifier=r0
#    CONSTP2VAR(DidControlStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.did_control_status;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pBuf;
# 
#    /* 
#     * The SCG guarantees the Rx buffer is at least eight bytes.
#     * If the inputOutputControlParameter is present (correct or not) is checked later.
#     */
#    CONST(uint8, AUTOMATIC) ioControlParameter = pMsgContext->reqData[2];
	.d2line		5204
.Llo2196:
	lbz		r27,2(r3)
.Llo2342:
	mr		r27,r27		# ioControlParameter=r27 ioControlParameter=r27
# 
# 
#    if (DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state)
	.d2line		5207
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r0
.Llo2192:
	se_cmpi		r0,1		# stdReturnVal=r0
	bc		0,2,.L1179	# ne
#    {
#       /*
#        * Check for IOCTL/ReadDataFunc call
#        */
#       if (FALSE == status->ControlStatusRecordRead)
	.d2line		5212
.Llo2165:
	lis		r3,(Dcm_DspInstance+41)@ha
.Llo2166:
	lbz		r0,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r0
.Llo2197:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1180	# ne
#       {
#          /*
#           * IOCTL call
#           */
#          DidControlHelpFunc(status,
	.d2line		5217
.Llo2198:
	lis		r3,(Dcm_DspInstance+40)@ha
	e_add16i		r3,r3,(Dcm_DspInstance+40)@l
	diab.li		r4,1
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidControlHelpFunc
#                             DCM_PENDING,
#                             pErrorCode);
#          ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5220
	lis		r3,(Dcm_DspInstance+8)@ha
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l
	lbz		r4,0(r30)		# pErrorCode=r30
	bl		ChangeAsyncState
	b		.L1179
.L1180:
#       }
#       else
#       {
#          /*
#           * ReadDataFunc call
#           */
#          stdReturnVal = status->pDidCtrl->pDidControl->ReadDataFunc(DCM_PENDING, status->pRequestData);
	.d2line		5227
	lis		r3,(Dcm_DspInstance+52)@ha
	lwz		r3,(Dcm_DspInstance+52)@l(r3)
	lwz		r3,16(r3)
	lwz		r0,16(r3)		# stdReturnVal=r0
	mtspr		ctr,r0		# stdReturnVal=ctr
	lis		r3,(Dcm_DspInstance+44)@ha
	lwz		r4,(Dcm_DspInstance+44)@l(r3)
	diab.li		r3,1
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2199:
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
#          if (DCM_INT_E_RESPONSE_PENDING != stdReturnVal)
	.d2line		5228
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo2200:
	cmpi		0,0,r3,202		# stdReturnVal=r3
.Llo2201:
	bc		1,2,.L1182	# eq
#          {
#             HandleStdRetVal(stdReturnVal, status->pDidCtrl->RetStatus, FALSE, pErrorCode);
	.d2line		5230
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lbz		r4,24(r3)		# stdReturnVal=r3
	mr		r3,r0		# stdReturnVal=r3 stdReturnVal=r0
	mr		r6,r30		# pErrorCode=r6 pErrorCode=r30
	diab.li		r5,0
	bl		HandleStdRetVal
#             ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5231
.Llo2202:
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2203:
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# stdReturnVal=r3 stdReturnVal=r3
.Llo2204:
	lbz		r4,0(r30)		# pErrorCode=r30
	bl		ChangeAsyncState
# 
#             if (DCM_ASYNCH_STATE_ACCEPTED == Dcm_DspInstance.asynch_state)
	.d2line		5233
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2205:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		0,2,.L1179	# ne
#             {
#                /*
#                 * Since accepted shall ReadData during DCM_ASYNCH_STATE_ACCEPTED below not be called again
#                 * Ugly solution, but by changing state to pending will the IOCBI terminate.
#                 */
#                Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x2F_COMPLETE;
	.d2line		5239
.Llo2206:
	diab.li		r0,11		# stdReturnVal=r0
.Llo2207:
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
	b		.L1179
.L1182:
#             }
#          }
#          else
#          {
#             /*
#              * Wait for the next schedule
#              */
#             *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		5247
.Llo2208:
	diab.li		r0,162		# stdReturnVal=r0
.Llo2209:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
.L1179:
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		5252
.Llo2210:
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2211:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1185	# ne
#    {
#       /*
#        * Do some initiation:
#        * - Clear the response length
#        * - Get the current session
#        * - Get the current security level
#        */
#       pMsgContext->resDataLen = 0;
	.d2line		5260
.Llo2212:
	diab.li		r28,0
	sth		r28,12(r31)		# pMsgContext=r31
# 
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * [SWS_Dcm_00339] : E_OK shall always be returned.
#        * [SWS_Dcm_00338] : E_OK shall always be returned.
#        */
#       (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		5268
	diab.addi		r3,r1,8		# stdReturnVal=r3
	bl		Dcm_GetSesCtrlType
#       (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		5269
	diab.addi		r3,r1,9		# stdReturnVal=r3
	bl		Dcm_GetSecurityLevel
	.d2line		5197
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2213:
	stw		r28,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3
	lis		r3,(Dcm_DspInstance+41)@ha		# stdReturnVal=r3
	stb		r28,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r3
# 
#       status->pDidCtrl = NULL_PTR;
#       status->ControlStatusRecordRead = FALSE;
# 
#       /*
#        * The request length shall at least be three bytes.
#        * For short term adjustment, it might be more but that is checked later.
#        */
#       if (pMsgContext->reqDataLen < 3)
	.d2line		5278
	lhz		r0,4(r31)		# stdReturnVal=r0 pMsgContext=r31
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		0,0,.L1186	# ge
#       {
#          /*
#           * The request shall contain at least one DID identifier and one byte data with the inputOutputControlParameter
#           * No given value according to specification.
#           * ErrorCode will be set either during the internal checks or during the call to the IOCP functions.
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5285
.Llo2214:
	diab.li		r0,19		# stdReturnVal=r0
.Llo2215:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1186:
#       }
#       else if ((ioControlParameter != IOCP_FCS) &&
	.d2line		5287
.Llo2216:
	rlwinm		r0,r27,0,24,31		# stdReturnVal=r0 ioControlParameter=r27
.Llo2217:
	se_cmpi		r0,2		# stdReturnVal=r0
	bc		1,2,.L1188	# eq
.Llo2218:
	rlwinm		r0,r27,0,24,31		# stdReturnVal=r0 ioControlParameter=r27
.Llo2219:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		1,2,.L1188	# eq
.Llo2220:
	rlwinm		r0,r27,0,24,31		# stdReturnVal=r0 ioControlParameter=r27
.Llo2221:
	se_cmpi		r0,1		# stdReturnVal=r0
	bc		1,2,.L1188	# eq
.Llo2222:
	rlwinm		r0,r27,0,24,31		# stdReturnVal=r0 ioControlParameter=r27
.Llo2223:
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		1,2,.L1188	# eq
#                (ioControlParameter != IOCP_RCTECU) &&
#                (ioControlParameter != IOCP_RTD) &&
#                (ioControlParameter != IOCP_STA))
#       {
#          /*
#           * Wrong inputOutputControlParameter or invalid DID doesn't matter since they will return
#           * same NRC 0x31. Since it's easier to check the inputOutputControlParameter here, let's do it.
#           */
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5296
.Llo2224:
	diab.li		r0,49		# stdReturnVal=r0
.Llo2225:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1188:
#       }
#       else
#       {
#          /*
#           * Before calling the application with the input output control functions, the DID data several checks have to be done:
#           * 1. Was the DID found amongst the configured ones?
#           * 2. Can the input/output control functions be called in the current session?
#           * 3. Can the input/output control functions be called in the current security level?
#           * 4. [SWS_Dcm_00823]: If the Did can be control in the current mode conditions?
#           * 5. Will the ControlStatusRecord fit into the response?
#           * 6. Is the received inputOutputControlParameter supported?
#           * 7. Does the received data length match the expected one, only for ShortTermAdjustment?
#           */
# 
#          for (confDidCounter = 0; (confDidCounter < Dcm_LCfg.num_dids) && (NULL_PTR == status->pDidCtrl); confDidCounter++)
	.d2line		5311
.Llo2226:
	diab.li		r3,0		# confDidCounter=r3
.L1190:
.Llo2183:
	rlwinm		r0,r3,0,16,31		# stdReturnVal=r0 confDidCounter=r3
.Llo2227:
	lis		r4,(Dcm_LCfg+64)@ha
	lhz		r4,(Dcm_LCfg+64)@l(r4)
	se_cmp		r0,r4		# stdReturnVal=r0
	bc		0,0,.L1192	# ge
.Llo2228:
	lis		r4,(Dcm_DspInstance+52)@ha
	lwz		r0,(Dcm_DspInstance+52)@l(r4)		# stdReturnVal=r0
.Llo2229:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1192	# ne
#          {
#             if ((Dcm_LCfg.dids[confDidCounter].identifier == didIdentifier) && (NULL_PTR != Dcm_LCfg.dids[confDidCounter].pDidControl))
	.d2line		5313
.Llo2230:
	rlwinm		r0,r3,0,16,31		# stdReturnVal=r0 confDidCounter=r3
.Llo2231:
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5 stdReturnVal=r0
	se_slwi		r0,2		# stdReturnVal=r0 stdReturnVal=r0
	subf		r0,r0,r5		# stdReturnVal=r0 stdReturnVal=r0 pErrorCode=r5
	lhzx		r0,r4,r0		# stdReturnVal=r0
	rlwinm		r4,r29,0,16,31		# didIdentifier=r29
	se_cmp		r0,r4		# stdReturnVal=r0
	bc		0,2,.L1193	# ne
.Llo2232:
	rlwinm		r0,r3,0,16,31		# stdReturnVal=r0 confDidCounter=r3
.Llo2233:
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5 stdReturnVal=r0
	se_slwi		r0,2		# stdReturnVal=r0 stdReturnVal=r0
	subf		r0,r0,r5		# stdReturnVal=r0 stdReturnVal=r0 pErrorCode=r5
	se_add		r4,r0		# stdReturnVal=r0
	lwz		r0,16(r4)		# stdReturnVal=r0
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		1,2,.L1193	# eq
#             {
#                /*
#                 * Found a DID with specified identifier and input/output control configured.
#                 */
#                status->pDidCtrl = &Dcm_LCfg.dids[confDidCounter];
	.d2line		5318
.Llo2234:
	rlwinm		r0,r3,0,16,31		# stdReturnVal=r0 confDidCounter=r3
	.d2line		5197
.Llo2235:
	lis		r4,(Dcm_LCfg+68)@ha
	lwz		r4,(Dcm_LCfg+68)@l(r4)
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5 stdReturnVal=r0
	se_slwi		r0,2		# stdReturnVal=r0 stdReturnVal=r0
	subf		r0,r0,r5		# stdReturnVal=r0 stdReturnVal=r0 pErrorCode=r5
	se_add		r0,r4		# stdReturnVal=r0 stdReturnVal=r0
	lis		r4,(Dcm_DspInstance+52)@ha
	stw		r0,(Dcm_DspInstance+52)@l(r4)		# stdReturnVal=r0
.L1193:
#             }
#          }
	.d2line		5320
.Llo2236:
	diab.addi		r0,r3,1		# stdReturnVal=r0 confDidCounter=r3
	se_addi		r3,1		# confDidCounter=r3 confDidCounter=r3
	b		.L1190
.L1192:
	.d2line		5197
.Llo2184:
	lis		r3,(Dcm_DspInstance+40)@ha		# confDidCounter=r3
.Llo2185:
	stb		r27,(Dcm_DspInstance+40)@l(r3)		# confDidCounter=r3 ioControlParameter=r27
	lwz		r3,8(r31)		# confDidCounter=r3 pMsgContext=r31
	diab.addi		r0,r3,3		# stdReturnVal=r0 confDidCounter=r3
.Llo2237:
	lis		r3,(Dcm_DspInstance+44)@ha		# confDidCounter=r3
	stw		r0,(Dcm_DspInstance+44)@l(r3)		# confDidCounter=r3 stdReturnVal=r0
# 
#          /*
#           * The requested IOCTL subfunction is copied and stored for future use
#           */
#          status->ioctlsubFunction = ioControlParameter;
# 
#          /*
#           * Pointer to the request data.
#           */
#          status->pRequestData = &pMsgContext->resData[3];
# 
#          if ((NULL_PTR == status->pDidCtrl) || (NULL_PTR == status->pDidCtrl->pDidControl))
	.d2line		5332
	lis		r3,(Dcm_DspInstance+52)@ha		# confDidCounter=r3
	lwz		r0,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r0 confDidCounter=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		1,2,.L1238	# eq
.Llo2186:
	lis		r3,(Dcm_DspInstance+52)@ha		# confDidCounter=r3
.Llo2187:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	lwz		r0,16(r3)		# stdReturnVal=r0 confDidCounter=r3
.Llo2238:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1194	# ne
.L1238:
#          {
#             /*
#              * The requested DID was not found. Report an error and break.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5337
.Llo2188:
	diab.li		r0,49		# stdReturnVal=r0
.Llo2239:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1194:
#          }
#          /*
#           * 2. Can the DID be used in the current session?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSession, status->pDidCtrl->pDidControl->p_session_levels))
	.d2line		5342
.Llo2240:
	lis		r3,(Dcm_DspInstance+52)@ha		# confDidCounter=r3
.Llo2189:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# confDidCounter=r3 confDidCounter=r3
	lwz		r3,16(r3)		# confDidCounter=r3 confDidCounter=r3
	lwz		r4,24(r3)		# confDidCounter=r3
	lbz		r3,8(r1)		# confDidCounter=r3
.Llo2190:
	bl		Dcm_IsLevelSupported
.Llo2241:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1196	# ne
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5344
.Llo2242:
	diab.li		r0,49		# stdReturnVal=r0
.Llo2243:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1196:
#          }
#          /*
#           * 3. Can the DID be used in the current security level?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, status->pDidCtrl->pDidControl->p_security_levels))
	.d2line		5349
.Llo2244:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2245:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r4,20(r3)		# stdReturnVal=r3
	lbz		r3,9(r1)		# stdReturnVal=r3
.Llo2246:
	bl		Dcm_IsLevelSupported
.Llo2247:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1198	# ne
#          {
#             *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		5351
.Llo2248:
	diab.li		r0,51		# stdReturnVal=r0
.Llo2249:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1198:
#          }
#          /*
#           * 4. [SWS_Dcm_00823]: If the Did can be control in the current mode conditions?
#           */
#          else if (!Dcm_IsCurrentModesAllowed(status->pDidCtrl->pDidControl->modeRuleFunc, pErrorCode))
	.d2line		5356
.Llo2250:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2251:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,28(r3)		# stdReturnVal=r3 stdReturnVal=r3
.Llo2252:
	mr		r4,r30		# pErrorCode=r4 pErrorCode=r30
	bl		Dcm_IsCurrentModesAllowed
.Llo2253:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1200	# ne
#          {
#             /*
#              * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#              */
#             HandleNrcResponsePending(*pErrorCode);
	.d2line		5361
.Llo2254:
	lbz		r0,0(r30)		# stdReturnVal=r0 pErrorCode=r30
.Llo2255:
	cmpi		0,0,r0,120		# stdReturnVal=r0
	bc		0,2,.L1239	# ne
.Llo2167:
	diab.li		r0,162		# stdReturnVal=r0
.Llo2256:
	b		.L1240
.L1239:
.Llo2257:
	lbz		r0,0(r30)		# stdReturnVal=r0 pErrorCode=r30
.L1240:
.Llo2258:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1200:
#          }
#          else if (DCM_INT_E_RESPONSE_TOO_LONG == Dcm_DsdStartResponse((Dcm_MsgLenType)(status->pDidCtrl->size + 3U)))
	.d2line		5363
.Llo2168:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2259:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r3,2(r3)		# stdReturnVal=r3 stdReturnVal=r3
	se_addi		r3,3		# stdReturnVal=r3 stdReturnVal=r3
	rlwinm		r3,r3,0,16,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo2260:
	bl		Dcm_DsdStartResponse
.Llo2261:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	cmpi		0,0,r3,200		# stdReturnVal=r3
	bc		0,2,.L1202	# ne
#          {
#             *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		5365
.Llo2262:
	diab.li		r0,20		# stdReturnVal=r0
.Llo2263:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1202:
	.d2line		5197
.Llo2264:
	lis		r3,(Dcm_DspInstance+40)@ha		# stdReturnVal=r3
.Llo2265:
	lbz		r0,(Dcm_DspInstance+40)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		1,2,.L1204	# eq
#          }
#          else
#          {
#             /* Sub function dependent checks and actions */
#             if (status->ioctlsubFunction != IOCP_STA)
#             {
#                if (pMsgContext->reqDataLen != (status->pDidCtrl->pDidControl->control_enable_mask_record_size + (Dcm_MsgLenType)3U)) /* DID + IOCP */
	.d2line		5372
.Llo2266:
	lhz		r0,4(r31)		# stdReturnVal=r0 pMsgContext=r31
.Llo2267:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r3,0(r3)		# stdReturnVal=r3 stdReturnVal=r3
	se_addi		r3,3		# stdReturnVal=r3 stdReturnVal=r3
	se_cmp		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	bc		1,2,.L1205	# eq
#                {
#                   /*
#                    * [SWS_Dcm_01273] [SWS_Dcm_01274]
#                    * The SCG guarantee that control_enable_mask_record_size has the correct value, which might be zero
#                    * The request (not STA) was not according to configuration, return error
#                    */
#                   *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5379
.Llo2268:
	diab.li		r0,19		# stdReturnVal=r0
.Llo2269:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1205:
#                }
#                else
#                {
#                   /*
#                    * Copy the mask to the RAM storage since it will otherwise be overwritten when calling the IOBCI functions.
#                    */
#                   Dcm_Memcpy(Dcm_LCfg.p_response_buffer, &pMsgContext->reqData[3], status->pDidCtrl->pDidControl->control_enable_mask_record_size);
	.d2line		5386
.Llo2270:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2271:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r5,0(r3)		# pErrorCode=r5 stdReturnVal=r3
	lis		r3,(Dcm_LCfg+20)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
.Llo2272:
	lwz		r4,0(r31)		# pErrorCode=r4 pMsgContext=r31
	se_addi		r4,3		# pErrorCode=r4 pErrorCode=r4
	bl		Dcm_Memcpy
	b		.L1187
.L1204:
	.d2line		5197
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2273:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lbz		r0,25(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		1,2,.L1208	# eq
#                }
#             }
#             else
#             {
#                if ((status->pDidCtrl->hasFixedLength) && /* Note that when fixed length is configured they must match EXACTLY */
	.d2line		5391
.Llo2274:
	lhz		r4,4(r31)		# pErrorCode=r4 pMsgContext=r31
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2275:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r0,2(r3)		# stdReturnVal=r0 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
.Llo2276:
	lhz		r3,0(r3)		# stdReturnVal=r3 stdReturnVal=r3
.Llo2277:
	se_add		r3,r0		# stdReturnVal=r3 stdReturnVal=r3 stdReturnVal=r0
	se_addi		r3,3		# stdReturnVal=r3 stdReturnVal=r3
	se_cmp		r4,r3		# pErrorCode=r4 stdReturnVal=r3
	bc		1,2,.L1208	# eq
#                    (pMsgContext->reqDataLen != (status->pDidCtrl->size + status->pDidCtrl->pDidControl->control_enable_mask_record_size + (Dcm_MsgLenType)3U))) /* DID + IOCP */
#                {
#                   /*
#                    * [SWS_Dcm_01273] [SWS_Dcm_01274]
#                    * The SCG guarantee that control_enable_mask_record_size has the correct value, which might be zero
#                    * The ShortTermAdjustment request was not according to configuration, return error
#                    */
#                   *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5399
.Llo2278:
	diab.li		r0,19		# stdReturnVal=r0
.Llo2279:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1208:
#                }
#                else if (pMsgContext->reqDataLen > (Dcm_MsgLenType)(status->pDidCtrl->size + status->pDidCtrl->pDidControl->control_enable_mask_record_size + (Dcm_MsgLenType)3U)) /* DID + IOCP */
	.d2line		5401
.Llo2280:
	lhz		r0,4(r31)		# stdReturnVal=r0 pMsgContext=r31
.Llo2281:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r4,2(r3)		# pErrorCode=r4 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r3,0(r3)		# stdReturnVal=r3 stdReturnVal=r3
	se_add		r4,r3		# pErrorCode=r4 pErrorCode=r4 stdReturnVal=r3
	diab.addi		r3,r4,3		# stdReturnVal=r3 pErrorCode=r4
	rlwinm		r3,r3,0,16,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmp		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	bc		0,1,.L1210	# le
#                {
#                   /*
#                    * [SWS_Dcm_01273] [SWS_Dcm_01274]
#                    * The SCG guarantee that control_enable_mask_record_size has the correct value, which might be zero
#                    *
#                    * Note that this is a implicit case equal to !status->pDidCtrl->hasFixedLength,
#                    * which is OK since the size check is narrower in this case.
#                    *
#                    * The ShortTermAdjustment request was not according to configuration, return error
#                    */
#                   *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5412
.Llo2282:
	diab.li		r0,19		# stdReturnVal=r0
.Llo2283:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1187
.L1210:
#                }
#                else
#                {
#                   /*
#                    * Copy the mask to the RAM storage since it will otherwise be overwritten when calling the IOBCI functions.
#                    */
#                   Dcm_Memcpy(Dcm_LCfg.p_response_buffer, &pMsgContext->reqData[3 + status->pDidCtrl->size], status->pDidCtrl->pDidControl->control_enable_mask_record_size);
	.d2line		5419
.Llo2284:
	lwz		r0,0(r31)		# stdReturnVal=r0 pMsgContext=r31
.Llo2285:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r4,2(r3)		# pErrorCode=r4 stdReturnVal=r3
	se_add		r4,r0		# pErrorCode=r4 pErrorCode=r4 stdReturnVal=r0
	se_addi		r4,3		# pErrorCode=r4 pErrorCode=r4
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r5,0(r3)		# pErrorCode=r5 stdReturnVal=r3
	lis		r3,(Dcm_LCfg+20)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	bl		Dcm_Memcpy
	.d2line		5197
.Llo2286:
	lwz		r3,0(r31)		# stdReturnVal=r3 pMsgContext=r31
.Llo2287:
	diab.addi		r0,r3,3		# stdReturnVal=r0 stdReturnVal=r3
	lis		r3,(Dcm_DspInstance+48)@ha		# stdReturnVal=r3
.Llo2288:
	stw		r0,(Dcm_DspInstance+48)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
.Llo2289:
	lhz		r0,4(r31)		# stdReturnVal=r0 pMsgContext=r31
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r3,0(r3)		# stdReturnVal=r3 stdReturnVal=r3
	subf		r0,r3,r0		# stdReturnVal=r0 stdReturnVal=r3 stdReturnVal=r0
	diab.li		r3,65533		# stdReturnVal=r3
	se_add		r0,r3		# stdReturnVal=r0 stdReturnVal=r0 stdReturnVal=r3
	lis		r3,(Dcm_DspInstance+42)@ha		# stdReturnVal=r3
	sth		r0,(Dcm_DspInstance+42)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
.L1187:
#                   status->ControlStateInfo = &pMsgContext->reqData[3];
#                   status->DynDataLengh = pMsgContext->reqDataLen - status->pDidCtrl->pDidControl->control_enable_mask_record_size - (Dcm_MsgLenType)3U; /* Subtract DID and IOCP */
#                }
#             }
#          }
#       }
# 
#       if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		5427
.Llo2169:
	lbz		r0,0(r30)		# stdReturnVal=r0 pErrorCode=r30
.Llo2290:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1185	# ne
#       {
#          /* All checks are OK */
#          DidControlHelpFunc(status,
	.d2line		5430
.Llo2291:
	lis		r3,(Dcm_DspInstance+40)@ha		# stdReturnVal=r3
.Llo2292:
	e_add16i		r3,r3,(Dcm_DspInstance+40)@l		# stdReturnVal=r3 stdReturnVal=r3
.Llo2293:
	diab.li		r4,0		# pErrorCode=r4
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidControlHelpFunc
#                             DCM_INITIAL,
#                             pErrorCode);
#          ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5433
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2294:
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# stdReturnVal=r3 stdReturnVal=r3
.Llo2295:
	lbz		r4,0(r30)		# pErrorCode=r4 pErrorCode=r30
	bl		ChangeAsyncState
.L1185:
#       }
#    } /* End of (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state) */
# 
#    if (DCM_ASYNCH_STATE_CANCEL == Dcm_DspInstance.asynch_state)
	.d2line		5437
.Llo2170:
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2296:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,2		# stdReturnVal=r0
	bc		0,2,.L1213	# ne
#    {
#       /*
#        * The return result is not interesting since we cancel the service
#        */
#       /*
#        * Check for IOCTL/ReadDataFunc call
#        */
#       if (FALSE == status->ControlStatusRecordRead)
	.d2line		5445
.Llo2171:
	lis		r3,(Dcm_DspInstance+41)@ha		# stdReturnVal=r3
.Llo2172:
	lbz		r0,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1214	# ne
#       {
#          DidControlHelpFunc(status,
	.d2line		5447
.Llo2297:
	lis		r3,(Dcm_DspInstance+40)@ha		# stdReturnVal=r3
.Llo2298:
	e_add16i		r3,r3,(Dcm_DspInstance+40)@l		# stdReturnVal=r3 stdReturnVal=r3
.Llo2299:
	diab.li		r4,2		# pErrorCode=r4
.Llo2173:
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		DidControlHelpFunc
	b		.L1215
.L1214:
	.d2line		5197
.Llo2174:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2300:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r0,16(r3)		# stdReturnVal=r0 stdReturnVal=r3
	mtspr		ctr,r0		# stdReturnVal=ctr
	lis		r3,(Dcm_DspInstance+44)@ha		# stdReturnVal=r3
	lwz		r4,(Dcm_DspInstance+44)@l(r3)		# pErrorCode=r4 stdReturnVal=r3
.Llo2175:
	diab.li		r3,2		# stdReturnVal=r3
.Llo2301:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.L1215:
#                             DCM_CANCEL,
#                             pErrorCode);
#       }
#       else
#       {
#          /*
#           * MISRA-C:2004 RULE 16.10 VIOLATION:
#           * If a function returns error information, then that error information shall be tested.
#           * The return result is not interesting since we cancel the service
#           */
#          (void)status->pDidCtrl->pDidControl->ReadDataFunc(DCM_CANCEL, status->pRequestData);
#       }
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		5460
	diab.li		r0,0		# stdReturnVal=r0
.Llo2302:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
.L1213:
#    }
# 
#    if (DCM_ASYNCH_STATE_ACCEPTED == Dcm_DspInstance.asynch_state)
	.d2line		5463
.Llo2176:
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2303:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,3		# stdReturnVal=r0
	bc		0,2,.L1216	# ne
#    {
#       if ((Dcm_MsgLenType)0x00U == status->pDidCtrl->pDidControl->control_enable_mask_record_size)
	.d2line		5465
.Llo2304:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2305:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r0,0(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1217	# ne
#       {
#          /*
#           * Only one signal and thus no controlEnableMaskRecord in request.
#           * underControl is always at least one byte to also handle this case.
#           */
#          if (IOCP_RCTECU == status->ioctlsubFunction)
	.d2line		5471
.Llo2306:
	lis		r3,(Dcm_DspInstance+40)@ha		# stdReturnVal=r3
.Llo2307:
	lbz		r0,(Dcm_DspInstance+40)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1218	# ne
	.d2line		5197
.Llo2308:
	diab.li		r0,0		# stdReturnVal=r0
.Llo2309:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,4(r3)		# stdReturnVal=r3 stdReturnVal=r3
	stb		r0,0(r3)		# stdReturnVal=r3 stdReturnVal=r0
	b		.L1220
.L1218:
.Llo2310:
	diab.li		r0,1		# stdReturnVal=r0
.Llo2311:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,4(r3)		# stdReturnVal=r3 stdReturnVal=r3
	stb		r0,0(r3)		# stdReturnVal=r3 stdReturnVal=r0
	b		.L1220
.L1217:
	.section	.text_vle
.L4734:
#          {
#             /*
#              * [VSTAR_Dcm_00054]
#              * Clear underControl
#              */
#             status->pDidCtrl->pDidControl->p_under_control[0] = (uint8)0x00U;
#          }
#          else
#          {
#             /*
#              * [SWS_Dcm_01280]
#              * Set underControl
#              */
#             status->pDidCtrl->pDidControl->p_under_control[0] = (uint8)0x01U;
#          }
#       }
#       else
#       {
#          /*
#          * More than one signal or DcmDspDidControlMaskSize is present, thus controlEnableMaskRecord in request.
#          */
#          Dcm_MsgLenType i;
#          for (i = (Dcm_MsgLenType)0U; i < status->pDidCtrl->pDidControl->control_enable_mask_record_size; i++)
	.d2line		5494
.Llo2312:
	diab.li		r3,0		# i=r3
.L1221:
.Llo2343:
	rlwinm		r6,r3,0,16,31		# pErrorCode=r6 i=r3
	lis		r4,(Dcm_DspInstance+52)@ha		# pErrorCode=r4
.Llo2177:
	lwz		r4,(Dcm_DspInstance+52)@l(r4)		# pErrorCode=r4 pErrorCode=r4
	lwz		r4,16(r4)		# pErrorCode=r4 pErrorCode=r4
	lhz		r0,0(r4)		# stdReturnVal=r0 pErrorCode=r4
.Llo2313:
	se_cmp		r6,r0		# pErrorCode=r6 stdReturnVal=r0
	bc		0,0,.L1220	# ge
#          {
#             if (IOCP_RCTECU == status->ioctlsubFunction)
	.d2line		5496
.Llo2314:
	lis		r4,(Dcm_DspInstance+40)@ha		# pErrorCode=r4
	lbz		r0,(Dcm_DspInstance+40)@l(r4)		# stdReturnVal=r0 pErrorCode=r4
.Llo2315:
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1224	# ne
	.d2line		5197
.Llo2316:
	lis		r4,(Dcm_DspInstance+52)@ha		# pErrorCode=r4
	lwz		r4,(Dcm_DspInstance+52)@l(r4)		# pErrorCode=r4 pErrorCode=r4
	lwz		r4,16(r4)		# pErrorCode=r4 pErrorCode=r4
	lwz		r5,4(r4)		# pErrorCode=r5 pErrorCode=r4
	rlwinm		r6,r3,0,16,31		# pErrorCode=r6 i=r3
	lbzx		r0,r5,r6		# stdReturnVal=r0 pErrorCode=r5
.Llo2317:
	lis		r4,(Dcm_LCfg+20)@ha		# pErrorCode=r4
	lwz		r4,(Dcm_LCfg+20)@l(r4)		# pErrorCode=r4 pErrorCode=r4
	lbzx		r4,r4,r6		# pErrorCode=r4 pErrorCode=r4
	andc		r0,r0,r4		# stdReturnVal=r0 stdReturnVal=r0 pErrorCode=r4
	stbx		r0,r5,r6		# pErrorCode=r5 stdReturnVal=r0
	b		.L1225
.L1224:
.Llo2318:
	lis		r4,(Dcm_DspInstance+52)@ha		# pErrorCode=r4
	lwz		r4,(Dcm_DspInstance+52)@l(r4)		# pErrorCode=r4 pErrorCode=r4
	lwz		r4,16(r4)		# pErrorCode=r4 pErrorCode=r4
	lwz		r5,4(r4)		# pErrorCode=r5 pErrorCode=r4
	rlwinm		r6,r3,0,16,31		# pErrorCode=r6 i=r3
	lbzx		r0,r5,r6		# stdReturnVal=r0 pErrorCode=r5
.Llo2319:
	lis		r4,(Dcm_LCfg+20)@ha		# pErrorCode=r4
	lwz		r4,(Dcm_LCfg+20)@l(r4)		# pErrorCode=r4 pErrorCode=r4
	lbzx		r4,r4,r6		# pErrorCode=r4 pErrorCode=r4
	or		r0,r0,r4		# stdReturnVal=r0 stdReturnVal=r0 pErrorCode=r4
	stbx		r0,r5,r6		# pErrorCode=r5 stdReturnVal=r0
.L1225:
#             {
#                /*
#                 * [VSTAR_Dcm_00054]
#                 * Remove the bits of controlEnableMaskRecord from underControl
#                 */
#                status->pDidCtrl->pDidControl->p_under_control[i] &= (uint8)~Dcm_LCfg.p_response_buffer[i];
#             }
#             else
#             {
#                /*
#                 * [SWS_Dcm_01280]
#                 * Add the bits of controlEnableMaskRecord to underControl
#                 */
#                status->pDidCtrl->pDidControl->p_under_control[i] |= Dcm_LCfg.p_response_buffer[i];
#             }
#          }
	.d2line		5512
.Llo2320:
	diab.addi		r6,r3,1		# pErrorCode=r6 i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L1221
	.section	.text_vle
.L4735:
.L1220:
#       }
# 
#       /*
#        * For multiple signals and paged buffering will the ReadData wrapper allocate the buffers needed
#        */
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       if (TRUE == status->pDidCtrl->pDidControl->multiple_signals)
#       {
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)3U, &pBuf);
#          status->pRequestData = NULL_PTR;
#       }
#       else
# #endif
#       {
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)(status->pDidCtrl->size + 3U), &pBuf);
	.d2line		5527
.Llo2178:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2321:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r3,2(r3)		# stdReturnVal=r3 stdReturnVal=r3
	se_addi		r3,3		# stdReturnVal=r3 stdReturnVal=r3
	rlwinm		r3,r3,0,16,31		# stdReturnVal=r3 stdReturnVal=r3
.Llo2322:
	diab.addi		r4,r1,12		# pErrorCode=r4
.Llo2179:
	bl		Dcm_DsdRequestResponseBuffer
.Llo2323:
	mr		r4,r3		# stdReturnVal=r4 stdReturnVal=r3
	.d2line		5197
	lwz		r3,12(r1)		# stdReturnVal=r3
	diab.addi		r0,r3,3		# stdReturnVal=r0 stdReturnVal=r3
	lis		r3,(Dcm_DspInstance+44)@ha		# stdReturnVal=r3
.Llo2324:
	stw		r0,(Dcm_DspInstance+44)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
#          status->pRequestData = &pBuf[3];
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		5531
.Llo2325:
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r3 stdReturnVal=r4
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1226	# ne
#       {
#          SET_2BYTE_ID(&pBuf[0], status->pDidCtrl->identifier);
	.d2line		5533
.Llo2326:
	lis		r4,(Dcm_DspInstance+52)@ha		# stdReturnVal=r4
.Llo2327:
	lwz		r3,(Dcm_DspInstance+52)@l(r4)		# stdReturnVal=r3 stdReturnVal=r4
	lhz		r0,0(r3)		# stdReturnVal=r0 stdReturnVal=r3
	rlwinm		r0,r0,24,24,31		# stdReturnVal=r0 stdReturnVal=r0
	lwz		r3,12(r1)		# stdReturnVal=r3
	stb		r0,0(r3)		# stdReturnVal=r3 stdReturnVal=r0
	lwz		r3,(Dcm_DspInstance+52)@l(r4)		# stdReturnVal=r3 stdReturnVal=r4
	lbz		r0,1(r3)		# stdReturnVal=r0 stdReturnVal=r3
	lwz		r3,12(r1)		# stdReturnVal=r3
	stb		r0,1(r3)		# stdReturnVal=r3 stdReturnVal=r0
#          pBuf[2] = status->ioctlsubFunction;
	.d2line		5534
	lis		r3,(Dcm_DspInstance+40)@ha		# stdReturnVal=r3
	lbz		r0,(Dcm_DspInstance+40)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	lwz		r3,12(r1)		# stdReturnVal=r3
	stb		r0,2(r3)		# stdReturnVal=r3 stdReturnVal=r0
# 
#          /*
#           * Check for IOCTL/ReadDataFunc call
#           */
#          if (FALSE == status->ControlStatusRecordRead)
	.d2line		5539
	lis		r3,(Dcm_DspInstance+41)@ha		# stdReturnVal=r3
	lbz		r0,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r0 stdReturnVal=r3
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L1228	# ne
#          {
#             /*
#              * For multiple signals and paged buffering will the ReadData wrapper allocate the buffers needed
#              */
#             stdReturnVal = status->pDidCtrl->pDidControl->ReadDataFunc(DCM_INITIAL, status->pRequestData);
	.d2line		5544
.Llo2328:
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
.Llo2329:
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r3,16(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lwz		r0,16(r3)		# stdReturnVal=r0 stdReturnVal=r3
	mtspr		ctr,r0		# stdReturnVal=ctr
	lis		r3,(Dcm_DspInstance+44)@ha		# stdReturnVal=r3
	lwz		r4,(Dcm_DspInstance+44)@l(r3)		# stdReturnVal=r4 stdReturnVal=r3
	diab.li		r3,0		# stdReturnVal=r3
.Llo2330:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2331:
	mr		r4,r3		# stdReturnVal=r4 stdReturnVal=r3
#             Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		5545
	diab.li		r0,1		# stdReturnVal=r0
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
.Llo2332:
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
.Llo2333:
	b		.L1226
.L1228:
	.d2line		5197
.Llo2334:
	diab.li		r4,0		# stdReturnVal=r4
.Llo2335:
	lis		r3,(Dcm_DspInstance+41)@ha		# stdReturnVal=r3
	stb		r4,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r3 stdReturnVal=r4
#          }
#          else
#          {
#             /*
#              * ReadDataFunc call is finished.Changing it for IOCTL function
#              */
#             status->ControlStatusRecordRead = FALSE;
#             stdReturnVal = E_OK;
.L1226:
#          }
#       }
# 
#       if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
	.d2line		5557
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r3 stdReturnVal=r4
	cmpi		0,0,r3,202		# stdReturnVal=r3
	bc		0,2,.L1230	# ne
#       {
#          /* Wait for the next schedule trying to get a buffer */
#          stdReturnVal = DCM_E_PENDING;
	.d2line		5560
	diab.li		r4,10		# stdReturnVal=r4
	b		.L1231
.L1230:
#       }
#       else if (DCM_INT_E_RESPONSE_TOO_LONG == stdReturnVal)
	.d2line		5562
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r3 stdReturnVal=r4
	cmpi		0,0,r3,200		# stdReturnVal=r3
	bc		0,2,.L1231	# ne
#       {
#          *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		5564
	diab.li		r0,20		# stdReturnVal=r0
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
.L1231:
#       }
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned
#           *  E_OK
#           *  E_NOT_OK
#           *  DCM_INT_E_RESPONSE_FULL
#           */
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		5576
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r3 stdReturnVal=r4
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1234	# ne
#       {
#          /*
#           * Got the data, all finished and a response can be sent.
#           */
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_0x2F_COMPLETE;
	.d2line		5581
	diab.li		r0,11		# stdReturnVal=r0
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
	b		.L1216
.L1234:
	.d2line		5197
	lis		r3,(Dcm_DspInstance+52)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_DspInstance+52)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lbz		r0,24(r3)		# stdReturnVal=r0 stdReturnVal=r3
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r3 stdReturnVal=r4
	se_cmp		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	bc		0,2,.L1236	# ne
	diab.li		r0,1		# stdReturnVal=r0
	lis		r3,(Dcm_DspInstance+41)@ha		# stdReturnVal=r3
	stb		r0,(Dcm_DspInstance+41)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
#       }
#       else if (status->pDidCtrl->RetStatus == stdReturnVal)
#       {
#          /*
#           * Changing state for IOCTL function
#           */
#          status->ControlStatusRecordRead = TRUE;
#          Dcm_DspInstance.asynch_state = DCM_ASYNCH_STATE_PENDING;
	.d2line		5589
	lis		r3,(Dcm_DspInstance+8)@ha		# stdReturnVal=r3
	stw		r0,(Dcm_DspInstance+8)@l(r3)		# stdReturnVal=r3 stdReturnVal=r0
#          *pErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		5590
	diab.li		r0,162		# stdReturnVal=r0
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
	b		.L1216
.L1236:
#       }
#       else
#       {
# 
#          /*
#           * Failed to get the response, return failure(DCM_E_REQUESTOUTOFRANGE)/E_PENDING is not allowed when useport is SYNC(DCM_E_CONDITIONSNOTCORRECT).
#           */
#          *pErrorCode = (stdReturnVal == E_NOT_OK) ? DCM_E_REQUESTOUTOFRANGE : DCM_E_CONDITIONSNOTCORRECT;
	.d2line		5598
.Llo2336:
	rlwinm		r4,r4,0,24,31		# stdReturnVal=r4 stdReturnVal=r4
.Llo2337:
	se_cmpi		r4,1		# stdReturnVal=r4
	diab.li		r3,49		# stdReturnVal=r3
	isel		r3,r3,r0,2		# stdReturnVal=r3 stdReturnVal=r3 stdReturnVal=r0
.L1241:
.Llo2338:
	diab.li		r0,34		# stdReturnVal=r0
.Llo2339:
	isel		r0,r3,r0,2		# stdReturnVal=r0 stdReturnVal=r3 stdReturnVal=r0
.L1242:
.Llo2340:
	stb		r0,0(r30)		# pErrorCode=r30 stdReturnVal=r0
.L1216:
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		5602
.Llo2180:
	lbz		r3,0(r30)		# stdReturnVal=r3 pErrorCode=r30
.Llo2182:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2181:
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
# }
	.d2line		5603
	.d2epilogue_begin
.Llo2341:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,52(r1)		# stdReturnVal=r0
	mtspr		lr,r0		# stdReturnVal=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4719:
	.type		Dcm_InputOutputControlByIdentifier,@function
	.size		Dcm_InputOutputControlByIdentifier,.-Dcm_InputOutputControlByIdentifier
# Number of nodes = 1041

# Allocations for Dcm_InputOutputControlByIdentifier
#	not allocated	OpStatus
#	?a4		pMsgContext
#	?a5		pErrorCode
#	?a6		$$116
#	?a7		$$115
#	?a8		$$114
#	?a9		$$41
#	?a10		$$40
#	?a11		$$39
#	?a12		$$38
#	?a13		confDidCounter
#	?a14		didIdentifier
#	SP,8		activeSession
#	SP,9		activeSecurityLevel
#	?a15		stdReturnVal
#	not allocated	status
#	SP,12		pBuf
#	?a16		ioControlParameter
#	?a17		i
# static FUNC(void, DCM_CODE) RoutineControlHelpFunc(CONSTP2VAR(RoutineControlStatusType, AUTOMATIC, DCM_APPL_CONST) pStatus,
	.align		1
	.section	.text_vle
        .d2line         6333,29
#$$ld
.L4742:

#$$bf	RoutineControlHelpFunc,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
RoutineControlHelpFunc:
.Llo2344:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_offset_list	30,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# pStatus=r31 pStatus=r3
.Llo2345:
	mr		r0,r4		# opStatus=r0 opStatus=r4
.Llo2346:
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
#                                                    Dcm_OpStatusType opStatus,
#                                                    CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    Std_ReturnType stdReturnVal = E_NOT_OK;
	.d2line		6337
	diab.li		r5,1		# stdReturnVal=r5
#    uint16 dataLength = pStatus->currentDataLength;
	.d2line		6338
.Llo2357:
	lhz		r3,2(r31)		# pStatus=r31
	sth		r3,8(r1)
# 
#    /*
#     * If coming this far, the service is configured and the SCG will guarantee that
#     * the routine control pointer is valid.
#     */
#    if (pStatus->subFunction == LEV_RCTP_STR)
	.d2line		6344
	lbz		r3,0(r31)		# pStatus=r31
	se_cmpi		r3,1
	bc		0,2,.L1429	# ne
#    {
#       /*
#        * Request for Starting routine which shall always be supported.
#        */
#       stdReturnVal= pStatus->pCurrentRoutine->StartFunc(pStatus->pRequestData, opStatus, &Dcm_LCfg.p_response_buffer[0], &dataLength, pErrorCode);
	.d2line		6349
.Llo2358:
	lwz		r3,4(r31)		# pStatus=r31
	lwz		r3,4(r3)
	mtspr		ctr,r3
	lis		r3,(Dcm_LCfg+20)@ha
	lwz		r5,(Dcm_LCfg+20)@l(r3)		# stdReturnVal=r5
	lwz		r3,8(r31)		# pStatus=r31
	rlwinm		r4,r0,0,24,31		# opStatus=r0
.Llo2348:
	diab.addi		r6,r1,8
	mr		r7,r30		# pErrorCode=r7 pErrorCode=r30
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2360:
	mr		r5,r3		# stdReturnVal=r5 stdReturnVal=r3
#       if (E_OK == stdReturnVal)
	.d2line		6350
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1431	# ne
#       {
#          Dcm_LCfg.p_routine_state[pStatus->routineIndex] = DCM_ROUTINE_STATE_STARTED;
	.d2line		6352
.Llo2361:
	diab.li		r0,1		# opStatus=r0
.Llo2349:
	lis		r3,(Dcm_LCfg+164)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_LCfg+164)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r4,12(r31)		# pStatus=r31
	rlwinm		r4,r4,2,14,29
	stwx		r0,r3,r4		# stdReturnVal=r3 opStatus=r0
	b		.L1431
.L1429:
#       }
#    }
#    else if ((pStatus->subFunction == LEV_RCTP_STPR) && (NULL_PTR != pStatus->pCurrentRoutine->StopFunc))
	.d2line		6355
	lbz		r3,0(r31)		# pStatus=r31
	se_cmpi		r3,2
	bc		0,2,.L1432	# ne
	lwz		r3,4(r31)		# pStatus=r31
	lwz		r3,8(r3)
	se_cmpi		r3,0
	bc		1,2,.L1432	# eq
#    {
#       /*
#        * Request for stopping routine if a handler is configured
#        */
#       if (DCM_ROUTINE_STATE_STARTED == Dcm_LCfg.p_routine_state[pStatus->routineIndex])
	.d2line		6360
	lis		r3,(Dcm_LCfg+164)@ha
	lwz		r3,(Dcm_LCfg+164)@l(r3)
	lhz		r4,12(r31)		# pStatus=r31
	rlwinm		r4,r4,2,14,29
	lwzx		r3,r3,r4
	se_cmpi		r3,1
	bc		0,2,.L1433	# ne
#       {
#          stdReturnVal= pStatus->pCurrentRoutine->StopFunc(pStatus->pRequestData, opStatus, &Dcm_LCfg.p_response_buffer[0], &dataLength, pErrorCode);
	.d2line		6362
.Llo2362:
	lwz		r3,4(r31)		# pStatus=r31
	lwz		r3,8(r3)
	mtspr		ctr,r3
	lis		r3,(Dcm_LCfg+20)@ha
	lwz		r5,(Dcm_LCfg+20)@l(r3)		# stdReturnVal=r5
	lwz		r3,8(r31)		# pStatus=r31
	rlwinm		r4,r0,0,24,31		# opStatus=r0
	diab.addi		r6,r1,8
	mr		r7,r30		# pErrorCode=r7 pErrorCode=r30
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2350:
	mr		r5,r3		# stdReturnVal=r5 stdReturnVal=r3
#          if (E_OK == stdReturnVal)
	.d2line		6363
	rlwinm		r3,r3,0,24,31		# stdReturnVal=r3 stdReturnVal=r3
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1431	# ne
#          {
#             Dcm_LCfg.p_routine_state[pStatus->routineIndex] = DCM_ROUTINE_STATE_STOPPED;
	.d2line		6365
.Llo2363:
	diab.li		r0,2		# opStatus=r0
.Llo2351:
	lis		r3,(Dcm_LCfg+164)@ha		# stdReturnVal=r3
	lwz		r3,(Dcm_LCfg+164)@l(r3)		# stdReturnVal=r3 stdReturnVal=r3
	lhz		r4,12(r31)		# pStatus=r31
	rlwinm		r4,r4,2,14,29
	stwx		r0,r3,r4		# stdReturnVal=r3 opStatus=r0
	b		.L1431
.L1433:
#          }
#       }
#       else
#       {
#          *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		6370
.Llo2352:
	diab.li		r0,36
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1431
.L1432:
#       }
#    }
#    else if ((pStatus->subFunction == LEV_RCTP_RRR) && (NULL_PTR != pStatus->pCurrentRoutine->RequestResultsFunc))
	.d2line		6373
.Llo2353:
	lbz		r3,0(r31)		# pStatus=r31
	se_cmpi		r3,3
	bc		0,2,.L1437	# ne
	lwz		r3,4(r31)		# pStatus=r31
	lwz		r3,12(r3)
	se_cmpi		r3,0
	bc		1,2,.L1437	# eq
#    {
#       /*
#        * Request for requesting results if a handler is configured
#        */
#       if (DCM_ROUTINE_STATE_INIT != Dcm_LCfg.p_routine_state[pStatus->routineIndex])
	.d2line		6378
	lis		r3,(Dcm_LCfg+164)@ha
	lwz		r3,(Dcm_LCfg+164)@l(r3)
	lhz		r4,12(r31)		# pStatus=r31
	rlwinm		r4,r4,2,14,29
	lwzx		r3,r3,r4
	se_cmpi		r3,0
	bc		1,2,.L1438	# eq
#       {
#          stdReturnVal= pStatus->pCurrentRoutine->RequestResultsFunc(opStatus, &Dcm_LCfg.p_response_buffer[0], &dataLength, pErrorCode);
	.d2line		6380
.Llo2364:
	lwz		r3,4(r31)		# pStatus=r31
	lwz		r3,12(r3)
	mtspr		ctr,r3
	lis		r3,(Dcm_LCfg+20)@ha
	lwz		r4,(Dcm_LCfg+20)@l(r3)
	rlwinm		r3,r0,0,24,31		# opStatus=r0
	diab.addi		r5,r1,8		# stdReturnVal=r5
	mr		r6,r30		# pErrorCode=r6 pErrorCode=r30
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2354:
	mr		r5,r3		# stdReturnVal=r5 stdReturnVal=r3
	b		.L1431
.L1438:
#       }
#       else
#       {
#          *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		6384
.Llo2365:
	diab.li		r0,36
.Llo2366:
	stb		r0,0(r30)		# pErrorCode=r30
	b		.L1431
.L1437:
#       }
#    }
#    else
#    {
#       /*
#        * [SWS_Dcm_00869]
#        * Sub Function not supported by RoutineIdentifier.
#        */
#       *pErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;
	.d2line		6393
.Llo2355:
	diab.li		r0,18
	stb		r0,0(r30)		# pErrorCode=r30
.L1431:
#    }
# 
#    if (E_OK == stdReturnVal)
	.d2line		6396
	rlwinm		r3,r5,0,24,31		# stdReturnVal=r3 stdReturnVal=r5
	se_cmpi		r3,0		# stdReturnVal=r3
	bc		0,2,.L1441	# ne
#    {
#       /*
#        * Routine function returns ok. Update currentDataLength with outData.
#        */
#       pStatus->currentDataLength = dataLength;
	.d2line		6401
	lhz		r0,8(r1)		# opStatus=r0
	sth		r0,2(r31)		# pStatus=r31 opStatus=r0
.L1441:
#    }
# 
#    HandleStdRetVal(stdReturnVal, DCM_E_PENDING, TRUE, pErrorCode);
	.d2line		6404
.Llo2347:
	mr		r3,r5		# stdReturnVal=r3 stdReturnVal=r5
	diab.li		r4,10
.Llo2356:
	mr		r6,r30		# pErrorCode=r6 pErrorCode=r30
	diab.li		r5,1		# stdReturnVal=r5
.Llo2367:
	bl		HandleStdRetVal
# }
	.d2line		6405
	.d2epilogue_begin
	lmw		r30,24(r1)		# offset r1+24  0x18
	.d2_cfa_restore_list	3,10
.Llo2359:
	lwz		r0,36(r1)		# opStatus=r0
	mtspr		lr,r0		# opStatus=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4743:
	.type		RoutineControlHelpFunc,@function
	.size		RoutineControlHelpFunc,.-RoutineControlHelpFunc
# Number of nodes = 237

# Allocations for RoutineControlHelpFunc
#	?a4		pStatus
#	?a5		opStatus
#	?a6		pErrorCode
#	?a7		stdReturnVal
#	SP,8		dataLength
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) StoreSupportedTypes(CONST(uint8, DCM_CONST) sid,
	.align		1
	.section	.text_vle
        .d2line         12428,53
#$$ld
.L4757:

#$$bf	StoreSupportedTypes,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
StoreSupportedTypes:
.Llo2368:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
.Llo2381:
	stmw		r23,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	23,31,1,1
	stw		r0,68(r1)		# delta=r0
	.d2_cfa_offset    108,-1
	mr		r31,r3		# sid=r31 sid=r3
	mr		r4,r4		# requestData=r4 requestData=r4
	mr		r30,r5		# requestDataLength=r30 requestDataLength=r5
	mr		r29,r6		# responseData=r29 responseData=r6
	mr		r28,r7		# pResponseDataLength=r28 pResponseDataLength=r7
	mr		r27,r8		# pSupport=r27 pSupport=r8
	.d2prologue_end
#                                                                         CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) requestData,
#                                                                         Dcm_MsgLenType requestDataLength,
#                                                                         CONSTP2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) responseData,
#                                                                         CONSTP2VAR(Dcm_MsgLenType, AUTOMATIC, DCM_APPL_DATA) pResponseDataLength,
#                                                                         CONSTP2CONST(uint8, AUTOMATIC, DCM_APPL_DATA) pSupport)
# {
#    uint8 supportPos;
#    uint8 responsePos = 0;
	.d2line		12436
	diab.li		r23,0		# responsePos=r23
#    uint8 infoTypes[6]; /* Store the info types temporary since the Tx and Rx buffers might be the same */
#    uint16 i;
#    Dcm_NegativeResponseCodeType ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12439
	diab.li		r26,0
# 
#    /*
#     * For OBD service 0x02, RequestFreezeFrameData, every PID is followed by a "frame"
#     * Therefore will there only be a maximum of three availability PIDs every second byte
#     * The length of each availability PID depends also on which request.
#     */
#    CONST(uint8, DCM_CONST) delta       = (uint8)((SID_REQ_FREEZE_FRAME_DATA == sid) ? 0x02U : 0x01U);
	.d2line		12446
.Llo2379:
	rlwinm		r3,r3,0,24,31		# sid=r3 sid=r3
	se_cmpi		r3,2		# sid=r3
	diab.li		r3,2		# sid=r3
	isel		r3,r3,r0,2		# delta=r3 sid=r3 delta=r0
.L2523:
.Llo2369:
	diab.li		r0,1		# delta=r0
.Llo2370:
	isel		r25,r3,r0,2		# delta=r25 delta=r3 delta=r0
.L2524:
#    CONST(uint8, DCM_CONST) pidLength   = (uint8)((SID_REQ_FREEZE_FRAME_DATA == sid) ? 0x06U : 0x05U);
	.d2line		12447
.Llo2382:
	rlwinm		r3,r31,0,24,31		# delta=r3 sid=r31
.Llo2383:
	se_cmpi		r3,2		# delta=r3
	diab.li		r3,6		# delta=r3
	isel		r3,r3,r0,2		# pidLength=r3 delta=r3 pidLength=r0
.L2525:
.Llo2384:
	diab.li		r0,5		# pidLength=r0
.Llo2385:
	isel		r24,r3,r0,2		# pidLength=r24 pidLength=r3 pidLength=r0
.L2526:
# 
#    /*
#     * Store the request since Tx and Rx buffers might be the same.
#     */
#    Dcm_Memcpy(&infoTypes[0], requestData, requestDataLength);
	.d2line		12452
.Llo2372:
	diab.addi		r3,r1,8		# pidLength=r3
.Llo2386:
	rlwinm		r5,r30,0,16,31		# requestDataLength=r30
.Llo2373:
	mr		r4,r4		# requestData=r4 requestData=r4
.Llo2374:
	bl		Dcm_Memcpy
# 
#    for (i = 0; (i < requestDataLength) && (DCM_INT_NRC_POSITIVERESPONSE == ErrorCode); i += delta)
	.d2line		12454
	diab.li		r7,0		# i=r7
.L2512:
.Llo2378:
	rlwinm		r0,r7,0,16,31		# pidLength=r0 i=r7
	rlwinm		r5,r30,0,16,31		# requestDataLength=r30
	se_cmp		r0,r5		# pidLength=r0
	bc		0,0,.L2514	# ge
	rlwinm		r3,r26,0,24,31		# pidLength=r3 ErrorCode=r26
	se_cmpi		r3,0		# pidLength=r3
	bc		0,2,.L2514	# ne
#    {
#       if ((uint8)0U != (uint8)(infoTypes[i] % 0x20U))
	.d2line		12456
	diab.addi		r3,r1,8		# pidLength=r3
	rlwinm		r0,r7,0,16,31		# pidLength=r0 i=r7
	lbzx		r0,r3,r0		# pidLength=r0 pidLength=r3
	rlwinm		r0,r0,0,27,31		# pidLength=r0 pidLength=r0
	e_andi.		r0,r0,255		# pidLength=r0 pidLength=r0
	bc		1,2,.L2515	# eq
#       {
#          /*
#           * It was a request for vehicle information which is not allowed in this context.
#           *
#           * According to section 5.5 ISO 14230-4, A module shall always respond to a request either with positive
#           * or negative response when no transmission error has been detected.
#           * NRC 0x12 is interpreted as subFunctionNotSupported-InvalidFormat.
#           */
#          ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;
	.d2line		12465
	diab.li		r26,18		# ErrorCode=r26
	b		.L2516
.L2515:
#       }
#       else if ((SID_REQ_FREEZE_FRAME_DATA == sid) && (0x00U != infoTypes[i + 1U]))
	.d2line		12467
	rlwinm		r3,r31,0,24,31		# pidLength=r3 sid=r31
	se_cmpi		r3,2		# pidLength=r3
	bc		0,2,.L2517	# ne
	diab.addi		r3,r1,8		# pidLength=r3
	rlwinm		r0,r7,0,16,31		# pidLength=r0 i=r7
	se_add		r3,r0		# pidLength=r3 pidLength=r3 pidLength=r0
	lbz		r0,1(r3)		# pidLength=r0 pidLength=r3
	se_cmpi		r0,0		# pidLength=r0
	bc		0,2,.L2516	# ne
.L2517:
#       {
#          /*
#           * [SWS_Dcm_00409] All requests regarding record-numbers that are not 0 shall be ignored.
#           */
#       }
#       else
#       {
#          /*
#           * It was a request for supported info types. Add the data to the response buffer.
#           */
#          supportPos = infoTypes[i] / 0x20U;
	.d2line		12478
	diab.addi		r3,r1,8		# pidLength=r3
	rlwinm		r0,r7,0,16,31		# pidLength=r0 i=r7
	lbzx		r6,r3,r0		# supportPos=r6 pidLength=r3
.Llo2376:
	rlwinm		r6,r6,27,29,31		# supportPos=r6 supportPos=r6
	mr		r6,r6		# supportPos=r6 supportPos=r6
# 
#          /*
#           * Zero availability IDs shall not be included if not a request
#           * using UDS service 0x31, RoutineControl
#           */
#          if ((FALSE != IsObdRangeSupported(supportPos, pSupport)) || (SID_ROUTINE_CONTROL == sid))
	.d2line		12484
	mr		r3,r6		# supportPos=r3 supportPos=r6
	mr		r4,r27		# pSupport=r4 pSupport=r27
	bl		IsObdRangeSupported
	e_andi.		r3,r3,255		# pidLength=r3 pidLength=r3
	bc		0,2,.L2527	# ne
	rlwinm		r3,r31,0,24,31		# pidLength=r3 sid=r31
	cmpi		0,0,r3,49		# pidLength=r3
	bc		0,2,.L2516	# ne
.L2527:
#          {
#             /* Start with the info type itself */
#             responseData[responsePos] = infoTypes[i]; responsePos++;
	.d2line		12487
	diab.addi		r3,r1,8		# pidLength=r3
	rlwinm		r0,r7,0,16,31		# pidLength=r0 i=r7
	lbzx		r3,r3,r0		# pidLength=r3 pidLength=r3
	rlwinm		r0,r23,0,24,31		# pidLength=r0 responsePos=r23
	stbx		r3,r29,r0		# responseData=r29 pidLength=r3
	diab.addi		r23,r23,1		# responsePos=r23 responsePos=r23
	mr		r23,r23		# responsePos=r23 responsePos=r23
# 
#             /*
#              * Possibly add the frame byte in case of SID 0x02 which always is 0x00
#              */
#             if (SID_REQ_FREEZE_FRAME_DATA == sid)
	.d2line		12492
	rlwinm		r3,r31,0,24,31		# pidLength=r3 sid=r31
	se_cmpi		r3,2		# pidLength=r3
	bc		0,2,.L2520	# ne
#             {
#                responseData[responsePos] = 0x00; responsePos++;
	.d2line		12494
	diab.li		r0,0		# pidLength=r0
	rlwinm		r3,r23,0,24,31		# pidLength=r3 responsePos=r23
	stbx		r0,r29,r3		# responseData=r29 pidLength=r0
	diab.addi		r0,r23,1		# pidLength=r0 responsePos=r23
	diab.addi		r23,r23,1		# responsePos=r23 responsePos=r23
.L2520:
#             }
# 
#             responseData[responsePos] = pSupport[(supportPos * 4U) + 0U]; responsePos++;
	.d2line		12497
	rlwinm		r3,r6,2,22,29		# pidLength=r3 supportPos=r6
	lbzux		r0,r3,r27		# pidLength=r0 pidLength=r3
	rlwinm		r3,r23,0,24,31		# pidLength=r3 responsePos=r23
	stbx		r0,r29,r3		# responseData=r29 pidLength=r0
	diab.addi		r0,r23,1		# pidLength=r0 responsePos=r23
	mr		r0,r0		# responsePos=r0 responsePos=r0
#             responseData[responsePos] = pSupport[(supportPos * 4U) + 1U]; responsePos++;
	.d2line		12498
	rlwinm		r4,r6,2,22,29		# pSupport=r4 supportPos=r6
	se_add		r4,r27		# pSupport=r4 pSupport=r4 pSupport=r27
	lbz		r3,1(r4)		# pidLength=r3 pSupport=r4
	rlwinm		r0,r0,0,24,31		# responsePos=r0 responsePos=r0
	stbx		r3,r29,r0		# responseData=r29 pidLength=r3
	diab.addi		r0,r23,2		# responsePos=r0 responsePos=r23
	mr		r0,r0		# responsePos=r0 responsePos=r0
#             responseData[responsePos] = pSupport[(supportPos * 4U) + 2U]; responsePos++;
	.d2line		12499
	lbz		r3,2(r4)		# pidLength=r3 pSupport=r4
	rlwinm		r0,r0,0,24,31		# responsePos=r0 responsePos=r0
	stbx		r3,r29,r0		# responseData=r29 pidLength=r3
	diab.addi		r0,r23,3		# responsePos=r0 responsePos=r23
	mr		r0,r0		# responsePos=r0 responsePos=r0
#             responseData[responsePos] = pSupport[(supportPos * 4U) + 3U]; responsePos++;
	.d2line		12500
	lbz		r3,3(r4)		# pidLength=r3 pSupport=r4
	rlwinm		r0,r0,0,24,31		# responsePos=r0 responsePos=r0
	stbx		r3,r29,r0		# responseData=r29 pidLength=r3
	diab.addi		r23,r23,4		# responsePos=r23 responsePos=r23
	mr		r23,r23		# responsePos=r23 responsePos=r23
# 
#             *pResponseDataLength += pidLength;
	.d2line		12502
	lhz		r3,0(r28)		# pidLength=r3 pResponseDataLength=r28
	rlwinm		r0,r24,0,24,31		# responsePos=r0 pidLength=r24
	se_add		r0,r3		# responsePos=r0 responsePos=r0 pidLength=r3
	sth		r0,0(r28)		# pResponseDataLength=r28 responsePos=r0
.L2516:
#          }
#          else
#          {
#             /*
#              * PIDs which are not supported by the ECU shall not be inclued in the response message.
#              * Continue with the request.
#              */
#          }
#       }
#    }
	.d2line		12512
	rlwinm		r0,r25,0,24,31		# pidLength=r0 delta=r25
	se_add		r0,r7		# pidLength=r0 pidLength=r0 i=r7
	mr		r7,r0		# i=r7 i=r0
	b		.L2512
.L2514:
# 
#    if ((DCM_INT_NRC_POSITIVERESPONSE == ErrorCode) && (0 == *pResponseDataLength))
	.d2line		12514
.Llo2377:
	rlwinm		r3,r26,0,24,31		# pidLength=r3 ErrorCode=r26
	se_cmpi		r3,0		# pidLength=r3
	bc		0,2,.L2522	# ne
.Llo2371:
	lhz		r0,0(r28)		# pidLength=r0 pResponseDataLength=r28
.Llo2387:
	se_cmpi		r0,0		# pidLength=r0
#    {
#       /*
#        * If no supported PIDs at all, no response will be sent.
#        *
#        * According to section 5.5 ISO 14230-4, A module shall always respond to a request either with positive
#        * or negative response when no transmission error has been detected.
#        * NRC 0x12 is interpreted as subFunctionNotSupported-InvalidFormat
#        */
#       ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;
	.d2line		12523
	diab.li		r3,18		# pidLength=r3
	isel		r26,r3,r26,2		# ErrorCode=r26 pidLength=r3 ErrorCode=r26
.L2522:
#    }
# 
#    return ErrorCode;
	.d2line		12526
.Llo2375:
	rlwinm		r3,r26,0,24,31		# pidLength=r3 ErrorCode=r26
# }
	.d2line		12527
	.d2epilogue_begin
	lmw		r23,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	2,10
.Llo2380:
	lwz		r0,68(r1)		# pidLength=r0
	mtspr		lr,r0		# pidLength=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4758:
	.type		StoreSupportedTypes,@function
	.size		StoreSupportedTypes,.-StoreSupportedTypes
# Number of nodes = 225

# Allocations for StoreSupportedTypes
#	?a4		sid
#	?a5		requestData
#	?a6		requestDataLength
#	?a7		responseData
#	?a8		pResponseDataLength
#	?a9		pSupport
#	?a10		supportPos
#	?a11		responsePos
#	SP,8		infoTypes
#	?a12		i
#	?a13		ErrorCode
#	?a14		delta
#	?a15		pidLength
# FUNC(Std_ReturnType, DCM_CODE) Dcm_RoutineControl(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         5609,32
#$$ld
.L4785:

#$$bf	Dcm_RoutineControl,interprocedural,rasave,nostackparams
	.globl		Dcm_RoutineControl
	.d2_cfa_start __cie
Dcm_RoutineControl:
.Llo2388:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r0,r3		# OpStatus=r0 OpStatus=r3
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pErrorCode=r30 pErrorCode=r5
	.d2prologue_end
# {
#    CONST(uint16, DCM_CONST) routineId = GET_2BYTE_ID(&pMsgContext->reqData[1]);
#    CONSTP2VAR(RoutineControlStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.routine_control_status;
#    boolean udsRequest = TRUE; /* Assume UDS request (e.g. will OBD never return PENDING), but set to false in case of OBD. */
	.d2line		5613
	diab.li		r28,1		# udsRequest=r28
	.d2line		5611
.Llo2474:
	lwz		r3,0(r31)		# pMsgContext=r31
.Llo2389:
	lbz		r4,1(r3)
.Llo2468:
	se_slwi		r4,8
	lbz		r29,2(r3)
	or		r4,r4,r29
.Llo2473:
	mr		r29,r4		# routineId=r29 routineId=r4
# 
#    /*
#     * Assignment from request buffer can always be done since the buffer is always valid.
#     * If valid data is present or not is a secondary question.
#     * "OpStatus" is not a trusted source for PENDING since a ModeRule might have
#     * returned NRC 0x78. Thus will the service, from a DSD point of view, be
#     * PENDING but not the service itself.
#     * On the other hand is OpStatus a reliable source for force respond pending
#     * confirmation. The infrastructure for changing async_state to the force respond
#     * pending configuration is missing why OpStatus is used.
#     */
#    if ((DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state) ||
	.d2line		5625
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r3,(Dcm_DspInstance+8)@l(r3)
	se_cmpi		r3,1
	bc		1,2,.L1330	# eq
.Llo2390:
	rlwinm		r3,r0,0,24,31		# OpStatus=r0
.Llo2470:
	se_cmpi		r3,3
	bc		0,2,.L1284	# ne
.L1330:
#        (DCM_FORCE_RCRRP_OK == OpStatus))
#    {
#       RoutineControlHelpFunc(status,
	.d2line		5628
	lis		r3,(Dcm_DspInstance+12)@ha
	e_add16i		r3,r3,(Dcm_DspInstance+12)@l
	mr		r4,r0		# OpStatus=r4 OpStatus=r0
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		RoutineControlHelpFunc
#                               OpStatus,
#                               pErrorCode);
#       ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5631
.Llo2391:
	lis		r3,(Dcm_DspInstance+8)@ha
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l
	lbz		r4,0(r30)		# OpStatus=r4 pErrorCode=r30
	bl		ChangeAsyncState
.L1284:
#    }
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		5634
	lis		r3,(Dcm_DspInstance+8)@ha
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# OpStatus=r0
.Llo2392:
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1285	# ne
	.d2line		5612
.Llo2393:
	lwz		r3,0(r31)		# pMsgContext=r31
	lbz		r0,0(r3)		# OpStatus=r0
.Llo2394:
	lis		r3,(Dcm_DspInstance+12)@ha
	stb		r0,(Dcm_DspInstance+12)@l(r3)		# OpStatus=r0
#    {
#       /*
#        * Do some initiation:
#        * - Clear the response length
#        * - Get the current session
#        * - Get the current security level
#        */
#       status->subFunction = pMsgContext->reqData[0];
#       pMsgContext->resDataLen = 0;
	.d2line		5643
	diab.li		r0,0		# OpStatus=r0
	sth		r0,12(r31)		# pMsgContext=r31 OpStatus=r0
	lis		r3,(Dcm_DspInstance+16)@ha
	stw		r0,(Dcm_DspInstance+16)@l(r3)		# OpStatus=r0
# 
#       status->pCurrentRoutine = NULL_PTR;
# 
#       if (pMsgContext->reqDataLen < 3)
	.d2line		5647
	lhz		r0,4(r31)		# OpStatus=r0 pMsgContext=r31
	se_cmpi		r0,3		# OpStatus=r0
	bc		0,0,.L1286	# ge
#       {
#          /*
#           * The request shall contain at least one byte sub-function and two bytes routineIdentifier
#           * No given value according to specification.
#           */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5653
.Llo2395:
	diab.li		r0,19		# OpStatus=r0
.Llo2396:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1286:
#       }
#       /*
#        * [SWS_Dcm_00701]: On reception of the UDS Service RoutineControl (0x31), for every
#        * requested TID inside the OBD range (E000- E0FF), the DCM module shall get the
#        * TID value as defined for OBD Service 0x08
#        */
#       else if (OBDTESTID_HIGH_BYTE == DcmHiByte(routineId))
	.d2line		5660
.Llo2397:
	rlwinm		r0,r29,24,24,31		# OpStatus=r0 routineId=r29
.Llo2398:
	cmpi		0,0,r0,224		# OpStatus=r0
	bc		0,2,.L1288	# ne
	.section	.text_vle
.L4795:
#       {
#          CONST(uint8, AUTOMATIC) obdRoutineId = DcmLoByte(routineId);
	.d2line		5662
.Llo2399:
	rlwinm		r0,r29,0,24,31		# OpStatus=r0 routineId=r29
.Llo2400:
	stb		r29,8(r1)		# routineId=r29
# 
#          udsRequest = FALSE;
	.d2line		5664
	diab.li		r28,0		# udsRequest=r28
# 
#          if (0U == (obdRoutineId % 0x20U))
	.d2line		5666
.Llo2475:
	e_andi.		r0,r0,31		# OpStatus=r0 OpStatus=r0
.Llo2401:
	bc		0,2,.L1289	# ne
#          {
#             if (3 != pMsgContext->reqDataLen )
	.d2line		5668
	lhz		r0,4(r31)		# OpStatus=r0 pMsgContext=r31
.Llo2402:
	se_cmpi		r0,3		# OpStatus=r0
	bc		1,2,.L1290	# eq
#             {
#                /*
#                 * Only one identifier is allowed when using UDS 0x31
#                 * which means 3 bytes length: 1 byte subfunction plus two byte routine identifier
#                 */
#                *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5674
.Llo2403:
	diab.li		r0,19		# OpStatus=r0
.Llo2404:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1290:
#             }
#             else
#             {
#                /*
#                 * At least the first byte is a request for supported TID types.
#                 * If not the following ones are correct, this will be handled in StoreSupportedTypes.
#                 * The info type itself (low byte of routine identifier) will be set by StoreSupportedTypes
#                 */
#                pMsgContext->resData[0] = status->subFunction;
	.d2line		5683
.Llo2405:
	lis		r3,(Dcm_DspInstance+12)@ha
	lbz		r0,(Dcm_DspInstance+12)@l(r3)		# OpStatus=r0
.Llo2406:
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,0(r3)		# OpStatus=r0
#                pMsgContext->resData[1] = OBDTESTID_HIGH_BYTE;
	.d2line		5684
	diab.li		r0,224		# OpStatus=r0
	lwz		r3,8(r31)		# pMsgContext=r31
	stb		r0,1(r3)		# OpStatus=r0
#                pMsgContext->resDataLen = 2;
	.d2line		5685
	diab.li		r0,2		# OpStatus=r0
	sth		r0,12(r31)		# pMsgContext=r31 OpStatus=r0
#                *pErrorCode = StoreSupportedTypes(SID_ROUTINE_CONTROL,
	.d2line		5686
	lwz		r6,8(r31)		# pMsgContext=r31
	se_addi		r6,2
	lis		r3,Dcm_pPbCfg@ha
	lwz		r3,Dcm_pPbCfg@l(r3)
	lwz		r8,32(r3)
	diab.addi		r4,r1,8		# OpStatus=r4
	diab.addi		r7,r31,12		# pMsgContext=r31
	diab.li		r3,49
	diab.li		r5,1		# pErrorCode=r5
	bl		StoreSupportedTypes
.Llo2407:
	stb		r3,0(r30)		# pErrorCode=r30
	b		.L1285
.L1289:
#                                                       &obdRoutineId, (Dcm_MsgLenType) 1U,
#                                                       &pMsgContext->resData[2], &pMsgContext->resDataLen,
#                                                       Dcm_pPbCfg->p_req_ctrl_support);
#             }
#          }
#          else if (FALSE == IsIdentifierSupported(Dcm_pPbCfg->p_req_ctrl_support, obdRoutineId))
	.d2line		5692
	lis		r3,Dcm_pPbCfg@ha
	lwz		r3,Dcm_pPbCfg@l(r3)
	lwz		r3,32(r3)
	lbz		r4,8(r1)		# OpStatus=r4
	bl		IsIdentifierSupported
	e_andi.		r3,r3,255
	bc		0,2,.L1293	# ne
#          {
#             /*
#              * According to ISO 15031-5:2006(E) Table 7 - Proper response from server/ECU for ISO 15765-4 protocol,
#              * "the ECU shall not respond if Service 0x08 unsupported TID is requested".
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5698
	diab.li		r0,49		# OpStatus=r0
.Llo2408:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1293:
	.section	.text_vle
.L4800:
#          }
#          else
#          {
#             P2CONST(Dcm_Cfg_ReqCtrlType, AUTOMATIC, DCM_APPL_DATA)  pReqCtrl = NULL_PTR;
	.d2line		5702
.Llo2409:
	diab.li		r27,0		# pReqCtrl=r27
#             uint16 counter;
#             for (counter = 0; (counter < Dcm_LCfg.num_req_ctrl) && (NULL_PTR == pReqCtrl); counter++)
	.d2line		5704
.Llo2477:
	diab.li		r3,0
.L1295:
.Llo2479:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
.Llo2410:
	lis		r4,(Dcm_LCfg+100)@ha		# OpStatus=r4
	lbz		r4,(Dcm_LCfg+100)@l(r4)		# OpStatus=r4 OpStatus=r4
	se_cmp		r0,r4		# OpStatus=r0 OpStatus=r4
	bc		0,0,.L1297	# ge
.Llo2411:
	se_cmpi		r27,0		# pReqCtrl=r27
	bc		0,2,.L1297	# ne
#             {
#                if (Dcm_LCfg.p_req_ctrl[counter].identifier == obdRoutineId)
	.d2line		5706
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
.Llo2412:
	lis		r4,(Dcm_LCfg+104)@ha		# OpStatus=r4
	lwz		r4,(Dcm_LCfg+104)@l(r4)		# OpStatus=r4 OpStatus=r4
	rlwinm		r5,r0,4,0,27		# pErrorCode=r5 OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r5		# OpStatus=r0 OpStatus=r0 pErrorCode=r5
	lbzx		r0,r4,r0		# OpStatus=r0 OpStatus=r4
	lbz		r4,8(r1)		# OpStatus=r4
	se_cmp		r0,r4		# OpStatus=r0 OpStatus=r4
	bc		0,2,.L1298	# ne
#                {
#                   pReqCtrl = &Dcm_LCfg.p_req_ctrl[counter];
	.d2line		5708
.Llo2413:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
.Llo2414:
	lis		r4,(Dcm_LCfg+104)@ha		# OpStatus=r4
	lwz		r27,(Dcm_LCfg+104)@l(r4)		# pReqCtrl=r27 OpStatus=r4
	rlwinm		r4,r0,4,0,27		# OpStatus=r4 OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r4		# OpStatus=r0 OpStatus=r0 OpStatus=r4
	se_add		r0,r27		# OpStatus=r0 OpStatus=r0 pReqCtrl=r27
.Llo2415:
	mr		r27,r0		# pReqCtrl=r27 pReqCtrl=r0
.L1298:
#                }
#             }
	.d2line		5710
	diab.addi		r0,r3,1		# OpStatus=r0 counter=r3
	se_addi		r3,1		# counter=r3 counter=r3
	b		.L1295
.L1297:
# 
#             if (NULL_PTR == pReqCtrl)
	.d2line		5712
	se_cmpi		r27,0		# pReqCtrl=r27
	bc		0,2,.L1299	# ne
#             {
#                /*
#                 * The code never end up here if correctly used with the SCG since catched
#                 * with IsIdentifierSupported. ReqCtrl TIDs not part of the LCfg shall not be possible
#                 * to enable using calibration. But to be on safe side, this check is present.
#                 */
#                *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5719
.Llo2480:
	diab.li		r0,49		# OpStatus=r0
.Llo2416:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1299:
#             }
#             else if (pMsgContext->reqDataLen != (pReqCtrl->in_size + 3))
	.d2line		5721
.Llo2417:
	lhz		r0,4(r31)		# OpStatus=r0 pMsgContext=r31
.Llo2418:
	lhz		r3,2(r27)		# counter=r3 pReqCtrl=r27
.Llo2481:
	se_addi		r3,3		# counter=r3 counter=r3
	se_cmp		r0,r3		# OpStatus=r0 counter=r3
	bc		1,2,.L1301	# eq
#             {
#                /*
#                 * The configured data and the received data does not match.
#                 * Return an error.
#                 */
#                *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5727
.Llo2419:
	diab.li		r0,19		# OpStatus=r0
.Llo2420:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1301:
#             }
#             else if (pMsgContext->resMaxDataLen < (pMsgContext->resDataLen + pReqCtrl->out_size + 3))
	.d2line		5729
.Llo2421:
	lhz		r0,20(r31)		# OpStatus=r0 pMsgContext=r31
.Llo2422:
	lhz		r3,12(r31)		# counter=r3 pMsgContext=r31
.Llo2482:
	lhz		r4,4(r27)		# OpStatus=r4 pReqCtrl=r27
	se_add		r3,r4		# counter=r3 counter=r3 OpStatus=r4
	se_addi		r3,3		# counter=r3 counter=r3
	se_cmp		r0,r3		# OpStatus=r0 counter=r3
	bc		0,0,.L1303	# ge
#             {
#                /*
#                 * The result will not fit into the response buffer.
#                 * Return an error.
#                 */
#                *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		5735
.Llo2423:
	diab.li		r0,20		# OpStatus=r0
.Llo2424:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1303:
	.section	.text_vle
.L4812:
#             }
#             else
#             {
#                P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) pReqBuf = NULL_PTR;
	.d2line		5739
.Llo2425:
	diab.li		r0,0		# pReqBuf=r0
#                if (0 != pReqCtrl->in_size)
	.d2line		5740
	lhz		r0,2(r27)		# pReqBuf=r0 pReqCtrl=r27
.Llo2498:
	se_cmpi		r0,0		# pReqBuf=r0
	bc		1,2,.L1305	# eq
#                {
#                   /*
#                    * Since input data has been configured, the next byte in the request shall be used as in data.
#                    */
#                   pReqBuf = &pMsgContext->reqData[3];
	.d2line		5745
.Llo2499:
	lwz		r4,0(r31)		# OpStatus=r4 pMsgContext=r31
.Llo2426:
	se_addi		r4,3		# OpStatus=r4 OpStatus=r4
.Llo2427:
	mr		r4,r4		# pReqBuf=r4 pReqBuf=r4
	b		.L1306
.L1305:
#                }
#                else
#                {
#                   /*
#                    * Since no input data has been configured, use a dummy pointer as indata.
#                    */
#                   pReqBuf = &pMsgContext->reqData[0];
	.d2line		5752
.Llo2500:
	lwz		r4,0(r31)		# OpStatus=r4 pMsgContext=r31
.Llo2501:
	mr		r4,r4		# pReqBuf=r4 pReqBuf=r4
.L1306:
#                }
# 
#                /*
#                 * Finally, call the RequestControl function.
#                 */
#                pMsgContext->resData[0]   = status->subFunction;
	.d2line		5758
	lis		r3,(Dcm_DspInstance+12)@ha		# counter=r3
.Llo2483:
	lbz		r0,(Dcm_DspInstance+12)@l(r3)		# pReqBuf=r0 counter=r3
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r0,0(r3)		# counter=r3 pReqBuf=r0
#                SET_2BYTE_ID(&pMsgContext->resData[1], routineId);
	.d2line		5759
	rlwinm		r0,r29,24,24,31		# pReqBuf=r0 routineId=r29
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r0,1(r3)		# counter=r3 pReqBuf=r0
	rlwinm		r0,r29,0,24,31		# pReqBuf=r0 routineId=r29
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r29,2(r3)		# counter=r3 routineId=r29
# 
#                if (E_OK != pReqCtrl->RequestControlFunc(Dcm_LCfg.p_response_buffer, pReqBuf))
	.d2line		5761
	lwz		r0,8(r27)		# pReqBuf=r0 pReqCtrl=r27
	mtspr		ctr,r0		# pReqBuf=ctr
	lis		r3,(Dcm_LCfg+20)@ha		# counter=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# counter=r3 counter=r3
.Llo2484:
	mr		r4,r4		# pReqBuf=r4 pReqBuf=r4
.Llo2502:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2485:
	e_andi.		r3,r3,255		# counter=r3 counter=r3
.Llo2486:
	bc		1,2,.L1308	# eq
#                {
#                   *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		5763
	diab.li		r0,34		# pReqBuf=r0
.Llo2503:
	stb		r0,0(r30)		# pErrorCode=r30 pReqBuf=r0
	b		.L1285
.L1308:
#                }
#                else
#                {
#                   /*
#                    * Copy the out data to the response buffer
#                    * Add three for the subfunction and routine identifier
#                    *
#                    * OpStatus is not a parameter of the Obd control API, No need to handle asynchronous state.
#                    */
#                   Dcm_Memcpy(&pMsgContext->resData[3], Dcm_LCfg.p_response_buffer, pReqCtrl->out_size);
	.d2line		5773
.Llo2504:
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
.Llo2487:
	se_addi		r3,3		# counter=r3 counter=r3
.Llo2488:
	lis		r4,(Dcm_LCfg+20)@ha		# OpStatus=r4
.Llo2428:
	lwz		r4,(Dcm_LCfg+20)@l(r4)		# OpStatus=r4 OpStatus=r4
.Llo2429:
	lhz		r5,4(r27)		# pErrorCode=r5 pReqCtrl=r27
	bl		Dcm_Memcpy
#                   pMsgContext->resDataLen = pReqCtrl->out_size + 3;
	.d2line		5774
	lhz		r3,4(r27)		# counter=r3 pReqCtrl=r27
.Llo2489:
	se_addi		r3,3		# counter=r3 counter=r3
	sth		r3,12(r31)		# pMsgContext=r31 counter=r3
	.section	.text_vle
.L4813:
	.section	.text_vle
.L4801:
	.section	.text_vle
.L4796:
.Llo2478:
	b		.L1285
.L1288:
	.section	.text_vle
.L4818:
#                }
#             }
#          }
#       }
#       else
#       {
#          uint16 counter;
#          Dcm_SesCtrlType activeSession;
#          Dcm_SecLevelType activeSecurityLevel;
# 
#          /*
#           * MISRA-C:2004 RULE 16.10 VIOLATION:
#           * If a function returns error information, then that error information shall be tested.
#           * [SWS_Dcm_00339] : E_OK shall always be returned.
#           * [SWS_Dcm_00338] : E_OK shall always be returned.
#           */
#          (void)Dcm_GetSesCtrlType(&activeSession);
	.d2line		5791
	diab.addi		r3,r1,9		# counter=r3
	bl		Dcm_GetSesCtrlType
#          (void)Dcm_GetSecurityLevel(&activeSecurityLevel);
	.d2line		5792
	diab.addi		r3,r1,10		# counter=r3
	bl		Dcm_GetSecurityLevel
# 
#          /*
#           * Before calling the application with the routine control functions, the routine several checks have to be done:
#           * 1. Was the Routine found amongst the configured ones?
#           * 2. Can the Routine be executed in the current session?
#           * 3. Can the Routine be executed in the current security level?
#           * 4. Can the Routine be executed in the current mode conditions?
#           * 5. Is the requested start/stop/requestresult routine configured? If so, run it.
#           * 6. Does the outlength fit into the response buffer?
#           */
# 
#          /*
#           * Try to find a matching Routine in the configuration
#           * Not using break since it will increase the essential cyclomatic complexity beyond borders.
#           */
#          for (counter = 0; (counter < Dcm_LCfg.num_routine_ctrl) && (NULL_PTR == status->pCurrentRoutine); counter++)
	.d2line		5808
	diab.li		r3,0		# counter=r3
.L1311:
.Llo2505:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
.Llo2430:
	lis		r4,(Dcm_LCfg+120)@ha		# OpStatus=r4
	lhz		r4,(Dcm_LCfg+120)@l(r4)		# OpStatus=r4 OpStatus=r4
	se_cmp		r0,r4		# OpStatus=r0 OpStatus=r4
	bc		0,0,.L1313	# ge
.Llo2431:
	lis		r4,(Dcm_DspInstance+16)@ha		# OpStatus=r4
.Llo2432:
	lwz		r0,(Dcm_DspInstance+16)@l(r4)		# OpStatus=r0 OpStatus=r4
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1313	# ne
#          {
#             if (Dcm_LCfg.p_routine_ctrl[counter].identifier == routineId)
	.d2line		5810
.Llo2433:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
.Llo2434:
	lis		r4,(Dcm_LCfg+124)@ha		# OpStatus=r4
	lwz		r4,(Dcm_LCfg+124)@l(r4)		# OpStatus=r4 OpStatus=r4
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5 OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r5		# OpStatus=r0 OpStatus=r0 pErrorCode=r5
.Llo2435:
	lhzx		r4,r4,r0		# OpStatus=r4 OpStatus=r4
.Llo2436:
	rlwinm		r0,r29,0,16,31		# OpStatus=r0 routineId=r29
	se_cmp		r4,r0		# OpStatus=r4 OpStatus=r0
	bc		0,2,.L1314	# ne
#             {
#                status->pCurrentRoutine = &Dcm_LCfg.p_routine_ctrl[counter];
	.d2line		5812
.Llo2437:
	rlwinm		r0,r3,0,16,31		# OpStatus=r0 counter=r3
	.d2line		5612
.Llo2438:
	lis		r4,(Dcm_LCfg+124)@ha		# OpStatus=r4
	lwz		r4,(Dcm_LCfg+124)@l(r4)		# OpStatus=r4 OpStatus=r4
	rlwinm		r5,r0,5,0,26		# pErrorCode=r5 OpStatus=r0
	se_slwi		r0,2		# OpStatus=r0 OpStatus=r0
	subf		r0,r0,r5		# OpStatus=r0 OpStatus=r0 pErrorCode=r5
	se_add		r0,r4		# OpStatus=r0 OpStatus=r0 OpStatus=r4
	lis		r4,(Dcm_DspInstance+16)@ha		# OpStatus=r4
	stw		r0,(Dcm_DspInstance+16)@l(r4)		# OpStatus=r4 OpStatus=r0
	lis		r4,(Dcm_DspInstance+24)@ha		# OpStatus=r4
	sth		r3,(Dcm_DspInstance+24)@l(r4)		# OpStatus=r4 counter=r3
.L1314:
#                status->routineIndex = counter;
#             }
#          }
	.d2line		5815
.Llo2439:
	diab.addi		r0,r3,1		# OpStatus=r0 counter=r3
	se_addi		r3,1		# counter=r3 counter=r3
	b		.L1311
.L1313:
	.d2line		5612
.Llo2506:
	lhz		r0,4(r31)		# OpStatus=r0 pMsgContext=r31
.Llo2440:
	diab.li		r3,65533		# counter=r3
.Llo2507:
	se_add		r0,r3		# OpStatus=r0 OpStatus=r0 counter=r3
	lis		r3,(Dcm_DspInstance+14)@ha		# counter=r3
	sth		r0,(Dcm_DspInstance+14)@l(r3)		# counter=r3 OpStatus=r0
	lwz		r3,0(r31)		# counter=r3 pMsgContext=r31
	diab.addi		r0,r3,3		# OpStatus=r0 counter=r3
	lis		r3,(Dcm_DspInstance+20)@ha		# counter=r3
	stw		r0,(Dcm_DspInstance+20)@l(r3)		# counter=r3 OpStatus=r0
# 
#          /*
#           * Skip 1 byte subfunction (start/stop/requestresult and 2 byte routine identifier
#           */
#          status->currentDataLength = pMsgContext->reqDataLen - 3;
#          status->pRequestData      = &pMsgContext->reqData[3];
# 
#          /*
#           * 1. [SWS_Dcm_00568]: Was the Routine found amongst the configured ones?
#           */
#          if (NULL_PTR == status->pCurrentRoutine)
	.d2line		5826
	lis		r3,(Dcm_DspInstance+16)@ha		# counter=r3
	lwz		r0,(Dcm_DspInstance+16)@l(r3)		# OpStatus=r0 counter=r3
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1315	# ne
#          {
#             /*
#              * The requested DID was not found. Report an error and break.
#              */
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5831
.Llo2441:
	diab.li		r0,49		# OpStatus=r0
.Llo2442:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1315:
#          }
#          /*
#           * 2. [SWS_Dcm_00570]: Can the Routine be executed in the current session?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSession, status->pCurrentRoutine->p_session_levels))
	.d2line		5836
.Llo2443:
	lis		r3,(Dcm_DspInstance+16)@ha		# counter=r3
.Llo2508:
	lwz		r3,(Dcm_DspInstance+16)@l(r3)		# counter=r3 counter=r3
	lwz		r4,20(r3)		# OpStatus=r4 counter=r3
	lbz		r3,9(r1)		# counter=r3
.Llo2509:
	bl		Dcm_IsLevelSupported
.Llo2510:
	e_andi.		r3,r3,255		# counter=r3 counter=r3
.Llo2511:
	bc		0,2,.L1317	# ne
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		5838
	diab.li		r0,49		# OpStatus=r0
.Llo2444:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1317:
#          }
#          /*
#           * 3. [SWS_Dcm_00571]: Can the Routine be executed in the current security level?
#           */
#          else if (FALSE == Dcm_IsLevelSupported(activeSecurityLevel, status->pCurrentRoutine->p_security_levels))
	.d2line		5843
.Llo2445:
	lis		r3,(Dcm_DspInstance+16)@ha		# counter=r3
.Llo2512:
	lwz		r3,(Dcm_DspInstance+16)@l(r3)		# counter=r3 counter=r3
	lwz		r4,16(r3)		# OpStatus=r4 counter=r3
	lbz		r3,10(r1)		# counter=r3
.Llo2513:
	bl		Dcm_IsLevelSupported
.Llo2514:
	e_andi.		r3,r3,255		# counter=r3 counter=r3
.Llo2515:
	bc		0,2,.L1319	# ne
#          {
#             *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		5845
	diab.li		r0,51		# OpStatus=r0
.Llo2446:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1319:
#          }
#          /*
#           * 4. [SWS_Dcm_00824]: Can the Routine be executed in the current mode conditions?
#           */
#          else if (!Dcm_IsCurrentModesAllowed(status->pCurrentRoutine->modeRuleFunc, pErrorCode))
	.d2line		5850
.Llo2447:
	lis		r3,(Dcm_DspInstance+16)@ha		# counter=r3
.Llo2516:
	lwz		r3,(Dcm_DspInstance+16)@l(r3)		# counter=r3 counter=r3
	lwz		r3,24(r3)		# counter=r3 counter=r3
.Llo2517:
	mr		r4,r30		# pErrorCode=r4 pErrorCode=r30
	bl		Dcm_IsCurrentModesAllowed
.Llo2518:
	e_andi.		r3,r3,255		# counter=r3 counter=r3
.Llo2519:
	bc		0,2,.L1321	# ne
#          {
#             /*
#              * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#              */
#             HandleNrcResponsePending(*pErrorCode);
	.d2line		5855
	lbz		r0,0(r30)		# OpStatus=r0 pErrorCode=r30
.Llo2448:
	cmpi		0,0,r0,120		# OpStatus=r0
	bc		0,2,.L1331	# ne
.Llo2449:
	diab.li		r0,162		# OpStatus=r0
.Llo2450:
	b		.L1332
.L1331:
.Llo2451:
	lbz		r0,0(r30)		# OpStatus=r0 pErrorCode=r30
.L1332:
.Llo2452:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1285
.L1321:
#          }
#          /*
#           * 5. Is the requested start/stop/requestresult routine configured? If so, run it.
#           */
#          else
#          {
#             RoutineControlHelpFunc(status,
	.d2line		5862
.Llo2453:
	lis		r3,(Dcm_DspInstance+12)@ha		# counter=r3
.Llo2520:
	e_add16i		r3,r3,(Dcm_DspInstance+12)@l		# counter=r3 counter=r3
.Llo2521:
	diab.li		r4,0		# pErrorCode=r4
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		RoutineControlHelpFunc
#                                    DCM_INITIAL,
#                                    pErrorCode);
#             ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		5865
	lis		r3,(Dcm_DspInstance+8)@ha		# counter=r3
.Llo2522:
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# counter=r3 counter=r3
.Llo2523:
	lbz		r4,0(r30)		# pErrorCode=r4 pErrorCode=r30
	bl		ChangeAsyncState
	.section	.text_vle
.L4819:
.L1285:
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_CANCEL == Dcm_DspInstance.asynch_state)
	.d2line		5870
	lis		r3,(Dcm_DspInstance+8)@ha		# counter=r3
.Llo2490:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# OpStatus=r0 counter=r3
.Llo2454:
	se_cmpi		r0,2		# OpStatus=r0
	bc		0,2,.L1323	# ne
#    {
#       /*
#        * A request for an OBD RID will never return pending.
#        * Thus will the cancel operation only consider the UDS TID.
#        *
#        * The return result is not interesting since we cancel the service
#        * Shall always stop execution reqardless of error code.
#        */
#       RoutineControlHelpFunc(status,
	.d2line		5879
.Llo2455:
	lis		r3,(Dcm_DspInstance+12)@ha		# counter=r3
.Llo2491:
	e_add16i		r3,r3,(Dcm_DspInstance+12)@l		# counter=r3 counter=r3
.Llo2492:
	diab.li		r4,2		# OpStatus=r4
	mr		r5,r30		# pErrorCode=r5 pErrorCode=r30
	bl		RoutineControlHelpFunc
#                              DCM_CANCEL,
#                              pErrorCode);
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		5882
	diab.li		r0,0		# OpStatus=r0
.Llo2456:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
.L1323:
#    }
# 
#    if ((DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode) && udsRequest)
	.d2line		5885
.Llo2457:
	lbz		r0,0(r30)		# OpStatus=r0 pErrorCode=r30
.Llo2458:
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1324	# ne
.Llo2459:
	rlwinm		r28,r28,0,24,31		# udsRequest=r28 udsRequest=r28
	se_cmpi		r28,0		# udsRequest=r28
	bc		1,2,.L1324	# eq
#    {
#       /*
#        * Prepare the UDS positive response. The OBD response has already been handled.
#        * Ignore the cancel state since DSD will not send anything regardless of the error code.
#        */
# 
#       /*
#        * Will the response fit into the Tx buffer?
#        * If not, return an error to the tester (handled below).
#        */
#       if (pMsgContext->resMaxDataLen < (status->currentDataLength + 3)) /* result + SubFunction + routineId */
	.d2line		5896
.Llo2476:
	lhz		r0,20(r31)		# OpStatus=r0 pMsgContext=r31
.Llo2460:
	lis		r3,(Dcm_DspInstance+14)@ha		# counter=r3
.Llo2493:
	lhz		r3,(Dcm_DspInstance+14)@l(r3)		# counter=r3 counter=r3
	se_addi		r3,3		# counter=r3 counter=r3
	se_cmp		r0,r3		# OpStatus=r0 counter=r3
	bc		0,0,.L1325	# ge
#       {
#          *pErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		5898
.Llo2461:
	diab.li		r0,20		# OpStatus=r0
.Llo2462:
	stb		r0,0(r30)		# pErrorCode=r30 OpStatus=r0
	b		.L1324
.L1325:
#       }
#       else
#       {
#          /*
#           * Create the response header and copy the response data
#           */
#          pMsgContext->resDataLen  = status->currentDataLength + 3; /* SubFunction + routineId */
	.d2line		5905
.Llo2463:
	lis		r4,(Dcm_DspInstance+14)@ha		# OpStatus=r4
.Llo2464:
	lhz		r3,(Dcm_DspInstance+14)@l(r4)		# counter=r3 OpStatus=r4
.Llo2494:
	se_addi		r3,3		# counter=r3 counter=r3
	sth		r3,12(r31)		# pMsgContext=r31 counter=r3
#          pMsgContext->resData[0]   = status->subFunction;
	.d2line		5906
	lis		r3,(Dcm_DspInstance+12)@ha		# counter=r3
	lbz		r0,(Dcm_DspInstance+12)@l(r3)		# OpStatus=r0 counter=r3
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r0,0(r3)		# counter=r3 OpStatus=r0
#          SET_2BYTE_ID(&pMsgContext->resData[1], routineId);
	.d2line		5907
	rlwinm		r0,r29,24,24,31		# OpStatus=r0 routineId=r29
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r0,1(r3)		# counter=r3 OpStatus=r0
	rlwinm		r0,r29,0,24,31		# OpStatus=r0 routineId=r29
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	stb		r29,2(r3)		# counter=r3 routineId=r29
# 
#          if (0 != status->currentDataLength)
	.d2line		5909
	lhz		r0,(Dcm_DspInstance+14)@l(r4)		# OpStatus=r0 OpStatus=r4
	se_cmpi		r0,0		# OpStatus=r0
	bc		1,2,.L1324	# eq
#          {
#             Dcm_Memcpy(&pMsgContext->resData[3], &Dcm_LCfg.p_response_buffer[0], status->currentDataLength);
	.d2line		5911
.Llo2465:
	lis		r3,(Dcm_DspInstance+14)@ha		# counter=r3
.Llo2495:
	lhz		r5,(Dcm_DspInstance+14)@l(r3)		# pErrorCode=r5 counter=r3
	lwz		r3,8(r31)		# counter=r3 pMsgContext=r31
	se_addi		r3,3		# counter=r3 counter=r3
.Llo2496:
	lis		r4,(Dcm_LCfg+20)@ha		# OpStatus=r4
.Llo2466:
	lwz		r4,(Dcm_LCfg+20)@l(r4)		# OpStatus=r4 OpStatus=r4
.Llo2467:
	bl		Dcm_Memcpy
.L1324:
#          }
#          else
#          {
#             /*
#              * No out signal, do not do anything.
#              */
#          }
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		5922
.Llo2469:
	lbz		r3,0(r30)		# counter=r3 pErrorCode=r30
.Llo2471:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2472:
	rlwinm		r3,r3,0,24,31		# counter=r3 counter=r3
# }
	.d2line		5923
	.d2epilogue_begin
.Llo2497:
	lmw		r27,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,52(r1)		# OpStatus=r0
	mtspr		lr,r0		# OpStatus=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4786:
	.type		Dcm_RoutineControl,@function
	.size		Dcm_RoutineControl,.-Dcm_RoutineControl
# Number of nodes = 758

# Allocations for Dcm_RoutineControl
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		$$120
#	?a8		$$119
#	?a9		$$118
#	?a10		$$117
#	?a11		$$42
#	?a12		routineId
#	not allocated	status
#	?a13		udsRequest
#	SP,8		obdRoutineId
#	?a14		pReqCtrl
#	?a15		counter
#	?a16		pReqBuf
#	?a17		counter
#	SP,9		activeSession
#	SP,10		activeSecurityLevel
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) HandleMemoryOpResult(Dcm_ReturnMemOperationType memOperationResult, Dcm_MemoryOperationKindType operationKind)
	.align		1
	.section	.text_vle
        .d2line         12857,53
#$$ld
.L4829:

#$$bf	HandleMemoryOpResult,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r6,cr0,lr
	.d2_cfa_start __cie
HandleMemoryOpResult:
.Llo2524:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
.Llo2541:
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r6,r3		# memOperationResult=r6 memOperationResult=r3
	mr		r4,r4		# operationKind=r4 operationKind=r4
	.d2prologue_end
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    switch (memOperationResult)
	.d2line		12861
	rlwinm		r6,r6,0,24,31		# memOperationResult=r6 memOperationResult=r6
	se_cmpi		r6,2		# memOperationResult=r6
	bc		1,1,.L4839	# gt
.Llo2525:
	bc		1,2,.L2626	# eq
.Llo2526:
	se_cmpi		r6,0		# memOperationResult=r6
	bc		1,2,.L2624	# eq
.Llo2538:
	se_cmpi		r6,1		# memOperationResult=r6
	bc		1,2,.L2629	# eq
.Llo2527:
	b		.L2632
.L4839:
.Llo2528:
	se_cmpi		r6,3		# memOperationResult=r6
	bc		1,2,.L2630	# eq
.Llo2539:
	se_cmpi		r6,4		# memOperationResult=r6
	bc		1,2,.L2631	# eq
.Llo2529:
	b		.L2632
.L2624:
#    {
#       case DCM_MEM_OPERATION_OK:
#       {
#          ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12865
.Llo2530:
	diab.li		r3,0		# ErrorCode=r3
.Llo2542:
	b		.L2625
.L2626:
#          break;
#       }
#       case DCM_MEM_OPERATION_FAILED:
#       {
#          if (DCM_MEM_OPERATION_READ == operationKind)
	.d2line		12870
.Llo2540:
	se_cmpi		r4,0		# operationKind=r4
#          {
#             /* [SWS_Dcm_00644] */
#             ErrorCode = DCM_E_GENERALREJECT;
	.d2line		12873
.Llo2543:
	diab.li		r3,16		# ErrorCode=r3
	isel		r3,r3,r0,2		# ErrorCode=r3 ErrorCode=r3 ErrorCode=r0
.L2627:
#          }
#          else
#          {
#             /* [SWS_Dcm_00643] */
#             ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;
	.d2line		12878
.Llo2531:
	diab.li		r0,114		# ErrorCode=r0
.Llo2544:
	isel		r3,r3,r0,2		# ErrorCode=r3 ErrorCode=r3 ErrorCode=r0
.Llo2545:
	b		.L2625
.L2629:
#          }
#          break;
#       }
#       case DCM_MEM_OPERATION_PENDING:
#       {
#          ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		12884
.Llo2532:
	diab.li		r3,162		# ErrorCode=r3
.Llo2533:
	b		.L2625
.L2630:
#          break;
#       }
#       case DCM_MEM_OPERATION_FORCE_RCRRP:
#       {
#          /*
#           * The function has returned forced response pending
#           * Force a NRC 0x78 (requestCorrectlyReceived-ResponsePending) and wait for the confirm
#           */
#          ErrorCode = DCM_INT_NRC_API_RETURNED_FORCE_RCRRP;
	.d2line		12893
.Llo2534:
	diab.li		r3,163		# ErrorCode=r3
.Llo2546:
	b		.L2625
.L2631:
#          break;
#       }
#       case DCM_MEM_OPERATION_FAILED_ROOR:
#       {
#          /*
#           * [VSTAR_Dcm_00001] [VSTAR_Dcm_00002]
#           *
#           * The function has failed due to request out of range for parameter MemorySize (extension to Autosar)
#           */
#          ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12903
.Llo2535:
	diab.li		r3,49		# ErrorCode=r3
.Llo2547:
	b		.L2625
.L2632:
#          break;
#       }
#       default:
#       {
#          /* Impossible, all valid return values covered. */
#          ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		12909
.Llo2536:
	diab.li		r3,34		# ErrorCode=r3
.L2625:
#          break;
#       }
#    }
# 
#    return ErrorCode;
	.d2line		12914
.Llo2537:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		12915
	.d2epilogue_begin
.Llo2548:
	lwz		r0,20(r1)		# ErrorCode=r0
	mtspr		lr,r0		# ErrorCode=lr
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4830:
	.type		HandleMemoryOpResult,@function
	.size		HandleMemoryOpResult,.-HandleMemoryOpResult
# Number of nodes = 35

# Allocations for HandleMemoryOpResult
#	?a4		memOperationResult
#	?a5		operationKind
#	?a6		ErrorCode
# static FUNC(Std_ReturnType, DCM_CODE) GenericMemoryAddressOperation(Dcm_OpStatusType OpStatus,
	.align		1
	.section	.text_vle
        .d2line         12532,39
#$$ld
.L4842:

#$$bf	GenericMemoryAddressOperation,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
GenericMemoryAddressOperation:
.Llo2549:
	stwu		r1,-80(r1)		
	.d2_cfa_def_cfa_offset	80
	mfspr		r0,lr
.Llo2597:
	stmw		r27,60(r1)		# offset r1+60  0x3c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,84(r1)		# memOperationResult=r0
	.d2_cfa_offset    108,-1
	mr		r3,r3		# OpStatus=r3 OpStatus=r3
	mr		r31,r4		# pMsgContext=r31 pMsgContext=r4
	mr		r30,r5		# pMemConf=r30 pMemConf=r5
	mr		r29,r6		# operationKind=r29 operationKind=r6
	mr		r28,r7		# pMemoryInitialisationFunc=r28 pMemoryInitialisationFunc=r7
	mr		r27,r8		# pErrorCode=r27 pErrorCode=r8
	.d2prologue_end
#                                                          CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
#                                                          CONSTP2CONST(Dcm_Cfg_MemoryType, AUTOMATIC, DCM_APPL_CONST) pMemConf,
#                                                          Dcm_MemoryOperationKindType operationKind,
#                                                          MemoryInitialisationFuncType pMemoryInitialisationFunc,
#                                                          CONSTP2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
# {
#    MemoryDataStructureType dataStructure;
# 
#    Dcm_Cfg_MemoryRangePointerType pSelectedMemoryRange;
#    Dcm_ReturnMemOperationType memOperationResult = DCM_MEM_OPERATION_OK;
	.d2line		12542
	diab.li		r0,0		# memOperationResult=r0
# 
#    CONSTP2VAR(MemoryAddressOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.memoryAddressOperation_status;
# 
#    /*
#     * "OpStatus" is not a trusted source for PENDING since a ModeRule might have
#     * returned NRC 0x78. Thus will the service, from a DSD point of view, be
#     * PENDING but not the service itself.
#     * On the other hand is OpStatus a reliable source for force respond pending
#     * confirmation. The infrastructure for changing async_state to the force respond
#     * pending configuration is missing why OpStatus is used.
#     */
#    if ((DCM_ASYNCH_STATE_PENDING == Dcm_DspInstance.asynch_state) ||
	.d2line		12554
.Llo2598:
	lis		r4,(Dcm_DspInstance+8)@ha
.Llo2573:
	lwz		r0,(Dcm_DspInstance+8)@l(r4)		# memOperationResult=r0
.Llo2599:
	se_cmpi		r0,1		# memOperationResult=r0
	bc		1,2,.L2562	# eq
.Llo2574:
	rlwinm		r0,r3,0,24,31		# memOperationResult=r0 OpStatus=r3
.Llo2581:
	se_cmpi		r0,3		# memOperationResult=r0
	bc		0,2,.L2541	# ne
.L2562:
#        (DCM_FORCE_RCRRP_OK == OpStatus))
#    {
#       memOperationResult = pMemConf->MemoryOperationFunc(OpStatus, 0, 0, 0, status->pendingBuffer);
	.d2line		12557
.Llo2550:
	lwz		r0,4(r30)		# memOperationResult=r0 pMemConf=r30
	mtspr		ctr,r0		# memOperationResult=ctr
	lis		r4,(Dcm_DspInstance+80)@ha
	lwz		r7,(Dcm_DspInstance+80)@l(r4)
.Llo2551:
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
.Llo2552:
	diab.li		r4,0
	diab.li		r5,0
	diab.li		r6,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#       *pErrorCode = HandleMemoryOpResult(memOperationResult, operationKind);
	.d2line		12558
.Llo2600:
	mr		r0,r3		# memOperationResult=r0 memOperationResult=r3
	mr		r4,r29		# operationKind=r4 operationKind=r29
	bl		HandleMemoryOpResult
	stb		r3,0(r27)		# pErrorCode=r27 memOperationResult=r3
#       ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		12559
	lis		r3,(Dcm_DspInstance+8)@ha		# memOperationResult=r3
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# memOperationResult=r3 memOperationResult=r3
.Llo2601:
	lbz		r4,0(r27)		# pErrorCode=r27
	bl		ChangeAsyncState
.L2541:
#    }
# 
#    if (DCM_ASYNCH_STATE_INIT == Dcm_DspInstance.asynch_state)
	.d2line		12562
	lis		r3,(Dcm_DspInstance+8)@ha		# OpStatus=r3
.Llo2553:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# memOperationResult=r0 OpStatus=r3
.Llo2602:
	se_cmpi		r0,0		# memOperationResult=r0
	bc		0,2,.L2542	# ne
#    {
#       dataStructure.include_memory_id_byte   = (uint8)((TRUE == pMemConf->use_memory_id) ? 1U : 0U);
	.d2line		12564
.Llo2554:
	lbz		r0,0(r30)		# memOperationResult=r0 pMemConf=r30
.Llo2603:
	se_cmpi		r0,1		# memOperationResult=r0
	diab.li		r3,1		# OpStatus=r3
.Llo2555:
	isel		r3,r3,r0,2		# OpStatus=r3 OpStatus=r3 memOperationResult=r0
.L2563:
.Llo2604:
	diab.li		r0,0		# memOperationResult=r0
.Llo2605:
	isel		r0,r3,r0,2		# memOperationResult=r0 OpStatus=r3 memOperationResult=r0
.L2564:
.Llo2556:
	stb		r0,8(r1)		# memOperationResult=r0
# 
#       /*
#        * There will always be at least one byte in the request buffer.
#        * If it is valid or not is checked below
#        */
#       dataStructure.memory_address_format   = pMsgContext->reqData[0] & 0x0FU;
	.d2line		12570
	lwz		r3,0(r31)		# OpStatus=r3 pMsgContext=r31
.Llo2557:
	lbz		r3,0(r3)		# OpStatus=r3 OpStatus=r3
	rlwinm		r3,r3,0,28,31		# OpStatus=r3 OpStatus=r3
	stb		r3,9(r1)		# OpStatus=r3
#       dataStructure.memory_address_length   = dataStructure.memory_address_format - dataStructure.include_memory_id_byte;
	.d2line		12571
	rlwinm		r0,r0,0,24,31		# memOperationResult=r0 memOperationResult=r0
	subf		r0,r0,r3		# memOperationResult=r0 memOperationResult=r0 OpStatus=r3
	stb		r0,10(r1)		# memOperationResult=r0
#       dataStructure.memory_size_length      = pMsgContext->reqData[0] >> 4;
	.d2line		12572
	lwz		r3,0(r31)		# OpStatus=r3 pMsgContext=r31
	lbz		r0,0(r3)		# memOperationResult=r0 OpStatus=r3
	se_srwi		r0,4		# memOperationResult=r0 memOperationResult=r0
	stb		r0,11(r1)		# memOperationResult=r0
# 
#       /*
#        * Request must include 1 byte addressAndLengthFormatIdentifier
#        */
#       if (pMsgContext->reqDataLen < 1)
	.d2line		12577
	lhz		r0,4(r31)		# memOperationResult=r0 pMsgContext=r31
	se_cmpi		r0,0		# memOperationResult=r0
	bc		1,1,.L2543	# gt
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		12579
.Llo2558:
	diab.li		r0,19		# memOperationResult=r0
.Llo2606:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2543:
#       }
#       /*
#        * Check acceptable address width.
#        * MemoryAddressFormat (Memory address length + optional memory id byte) minimum 1 bytes (ref. ISO14229)
#        * Memory address length maximum 4 bytes + optional memory id byte (constrained by AUTOSAR Dcm_WriteMemory/Dcm_ReadMemory)
#        * NRC is defined by ISO 14229, table 142
#        */
#       else if ((0 == dataStructure.memory_address_format) || (dataStructure.memory_address_length > 4))
	.d2line		12587
.Llo2607:
	lbz		r0,9(r1)		# memOperationResult=r0
.Llo2608:
	se_cmpi		r0,0		# memOperationResult=r0
	bc		1,2,.L2565	# eq
.Llo2609:
	lbz		r0,10(r1)		# memOperationResult=r0
.Llo2610:
	se_cmpi		r0,4		# memOperationResult=r0
	bc		0,1,.L2545	# le
.L2565:
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12589
.Llo2611:
	diab.li		r0,49		# memOperationResult=r0
.Llo2612:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2545:
#       }
#       /* Check acceptable data length parameter size.
#        * Minimum 1 bytes (ref. ISO14229)
#        * Maximum 4 bytes (constrained by AUTOSAR Dcm_WriteMemory/Dcm_ReadMemory)
#        * NRC is defined by ISO 14229, table 142
#        */
#       else if ((0 == dataStructure.memory_size_length) || (dataStructure.memory_size_length > 4))
	.d2line		12596
.Llo2613:
	lbz		r0,11(r1)		# memOperationResult=r0
.Llo2614:
	se_cmpi		r0,0		# memOperationResult=r0
	bc		1,2,.L2566	# eq
.Llo2615:
	lbz		r0,11(r1)		# memOperationResult=r0
.Llo2616:
	se_cmpi		r0,4		# memOperationResult=r0
	bc		0,1,.L2547	# le
.L2566:
#       {
#          *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12598
.Llo2617:
	diab.li		r0,49		# memOperationResult=r0
.Llo2618:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2547:
#       }
#       /*
#        * Read: Check that memory address and memory size parameters fits in request
#        */
#       else if ((DCM_MEM_OPERATION_READ == operationKind) &&
	.d2line		12603
.Llo2619:
	se_cmpi		r29,0		# operationKind=r29
	bc		0,2,.L2549	# ne
	lhz		r0,4(r31)		# memOperationResult=r0 pMsgContext=r31
.Llo2620:
	lbz		r3,8(r1)		# OpStatus=r3
.Llo2559:
	lbz		r4,10(r1)
	se_add		r3,r4		# OpStatus=r3 OpStatus=r3
	lbz		r4,11(r1)
	se_add		r3,r4		# OpStatus=r3 OpStatus=r3
	se_addi		r3,1		# OpStatus=r3 OpStatus=r3
	se_cmp		r0,r3		# memOperationResult=r0 OpStatus=r3
	bc		1,2,.L2549	# eq
#                (pMsgContext->reqDataLen != (1 + dataStructure.include_memory_id_byte + dataStructure.memory_address_length + dataStructure.memory_size_length)))
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		12606
.Llo2560:
	diab.li		r0,19		# memOperationResult=r0
.Llo2621:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2549:
#       }
#       /*
#        * Write: Check that memory address and memory size parameters fits in request
#        */
#       else if ((DCM_MEM_OPERATION_WRITE == operationKind) &&
	.d2line		12611
.Llo2622:
	se_cmpi		r29,1		# operationKind=r29
	bc		0,2,.L2551	# ne
	lhz		r0,4(r31)		# memOperationResult=r0 pMsgContext=r31
.Llo2623:
	lbz		r4,8(r1)
	lbz		r3,10(r1)		# OpStatus=r3
.Llo2561:
	se_add		r4,r3		# OpStatus=r3
	lbz		r3,11(r1)		# OpStatus=r3
	se_add		r4,r3		# OpStatus=r3
	diab.addi		r3,r4,1		# OpStatus=r3
	se_cmp		r0,r3		# memOperationResult=r0 OpStatus=r3
	bc		0,0,.L2551	# ge
#                (pMsgContext->reqDataLen < (1 + dataStructure.include_memory_id_byte + dataStructure.memory_address_length + dataStructure.memory_size_length)))
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		12614
.Llo2562:
	diab.li		r0,19		# memOperationResult=r0
.Llo2624:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2551:
#       }
#       else
#       {
#          dataStructure.memory_address_offset   = 1 + dataStructure.include_memory_id_byte;
	.d2line		12618
.Llo2625:
	lbz		r3,8(r1)		# OpStatus=r3
.Llo2563:
	se_addi		r3,1		# OpStatus=r3 OpStatus=r3
	stb		r3,12(r1)		# OpStatus=r3
#          dataStructure.memory_size_offset      = dataStructure.memory_address_offset + dataStructure.memory_address_length;
	.d2line		12619
	se_extzb		r3		# OpStatus=r3
	lbz		r0,10(r1)		# memOperationResult=r0
.Llo2626:
	se_add		r3,r0		# OpStatus=r3 OpStatus=r3 memOperationResult=r0
	stb		r3,13(r1)		# OpStatus=r3
#          dataStructure.data_record_offset      = dataStructure.memory_size_offset + dataStructure.memory_size_length;
	.d2line		12620
	se_extzb		r3		# OpStatus=r3
	lbz		r0,11(r1)		# memOperationResult=r0
	se_add		r0,r3		# memOperationResult=r0 memOperationResult=r0 OpStatus=r3
	stb		r0,14(r1)		# memOperationResult=r0
#          dataStructure.memory_identifier      = (TRUE == pMemConf->use_memory_id) ? pMsgContext->reqData[1] : 0;
	.d2line		12621
	lbz		r0,0(r30)		# memOperationResult=r0 pMemConf=r30
	se_cmpi		r0,1		# memOperationResult=r0
	bc		0,2,.L2567	# ne
.Llo2564:
	lwz		r3,0(r31)		# OpStatus=r3 pMsgContext=r31
.Llo2565:
	lbz		r0,1(r3)		# memOperationResult=r0 OpStatus=r3
.Llo2627:
	b		.L2568
.L2567:
.Llo2566:
	diab.li		r0,0		# memOperationResult=r0
.L2568:
.Llo2628:
	stb		r0,15(r1)		# memOperationResult=r0
#          dataStructure.memory_address         = ParseMemoryParameter(&pMsgContext->reqData[dataStructure.memory_address_offset], dataStructure.memory_address_length);
	.d2line		12622
	lwz		r3,0(r31)		# OpStatus=r3 pMsgContext=r31
.Llo2567:
	lbz		r0,12(r1)		# memOperationResult=r0
	se_add		r3,r0		# OpStatus=r3 OpStatus=r3 memOperationResult=r0
.Llo2568:
	lbz		r4,10(r1)
	bl		ParseMemoryParameter
.Llo2629:
	stw		r3,16(r1)		# memOperationResult=r3
#          dataStructure.memory_size            = ParseMemoryParameter(&pMsgContext->reqData[dataStructure.memory_size_offset], dataStructure.memory_size_length);
	.d2line		12623
.Llo2630:
	lwz		r3,0(r31)		# memOperationResult=r3 pMsgContext=r31
	lbz		r0,13(r1)		# memOperationResult=r0
	se_add		r3,r0		# memOperationResult=r3 memOperationResult=r3 memOperationResult=r0
.Llo2631:
	lbz		r4,11(r1)
.Llo2632:
	bl		ParseMemoryParameter
.Llo2633:
	stw		r3,20(r1)		# memOperationResult=r3
# 
#          /*
#           * Do some neccessary checking dependant on type of operation
#           */
#          *pErrorCode = pMemoryInitialisationFunc(pMsgContext, dataStructure, status);
	.d2line		12628
.Llo2634:
	diab.addi		r6,r1,24
	diab.addi		r7,r1,8
	lwz		r4,8(r1)
	lwz		r5,12(r1)
	stw		r4,24(r1)
	stw		r5,28(r1)
	lwz		r4,16(r1)
	stw		r4,32(r1)
	stw		r3,36(r1)		# memOperationResult=r3
	mtspr		ctr,r28		# pMemoryInitialisationFunc=ctr pMemoryInitialisationFunc=r28
	lis		r5,(Dcm_DspInstance+76)@ha
	e_add16i		r5,r5,(Dcm_DspInstance+76)@l
	addi		r4,r1,24
	mr		r3,r31		# pMsgContext=r3 pMsgContext=r31
.Llo2635:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x38 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2575:
	stb		r3,0(r27)		# pErrorCode=r27 pMsgContext=r3
# 
#          /*
#           * An error might have occur in the read/write specific sections above
#           */
#          if (DCM_INT_NRC_POSITIVERESPONSE != *pErrorCode)
	.d2line		12633
.Llo2576:
	e_andi.		r0,r3,255		# memOperationResult=r0 pMsgContext=r3
	bc		0,2,.L2542	# ne
#          {
#             /*
#              * The error is handled below
#              */
#          }
#          else
#          {
#             pSelectedMemoryRange = GetMemoryRange(dataStructure.memory_identifier, dataStructure.memory_address, dataStructure.memory_size, pMemConf);
	.d2line		12641
.Llo2577:
	lbz		r3,15(r1)		# pMsgContext=r3
	lwz		r4,16(r1)
	lwz		r5,20(r1)
	mr		r6,r30		# pMemConf=r6 pMemConf=r30
	bl		GetMemoryRange
	.d2line		12644
.Llo2578:
	mr.		r31,r3		# pSelectedMemoryRange=?a13 pSelectedMemoryRange=r3
# 
#             /* Check that requested memory range is configured */
#             if (NULL_PTR == pSelectedMemoryRange)
.Llo2591:
	bc		0,2,.L2555	# ne
#             {
#                /*
#                 * [SWS_Dcm_00489], [SWS_Dcm_01052]
#                 * [SWS_Dcm_00493], [SWS_Dcm_01053]
#                 */
#                *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12650
.Llo2579:
	diab.li		r0,49		# memOperationResult=r0
.Llo2636:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2555:
#             }
#             /* Check that requested memory range is accessible in current security level */
#             else if (!IsMemoryRangeAcessible(pSelectedMemoryRange))
	.d2line		12653
.Llo2637:
	mr		r3,r31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r31
	bl		IsMemoryRangeAcessible
	rlwinm		r3,r3,0,24,31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2557	# ne
#             {
#                /*
#                 * [SWS_Dcm_00490]
#                 * [SWS_Dcm_00494]
#                 */
#                *pErrorCode = DCM_E_SECURITYACCESSDENIED;
	.d2line		12659
	diab.li		r0,51		# memOperationResult=r0
.Llo2638:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2557:
#             }
#             /*
#              * Is the complete memory range accessible in the current mode condition?
#              */
#             else if (!Dcm_IsCurrentModesAllowed(pSelectedMemoryRange->modeRuleFunc, pErrorCode))
	.d2line		12664
.Llo2639:
	lwz		r3,16(r31)		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r31
	mr		r4,r27		# pErrorCode=r4 pErrorCode=r27
	bl		Dcm_IsCurrentModesAllowed
	rlwinm		r3,r3,0,24,31		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
	se_cmpi		r3,0		# pSelectedMemoryRange=r3
	bc		0,2,.L2559	# ne
#             {
#                /*
#                 * [SWS_Dcm_00825]
#                 * [SWS_Dcm_00826]
#                 * The NRC was set during the call to Dcm_IsCurrentModesAllowed
#                 */
#                HandleNrcResponsePending(*pErrorCode);
	.d2line		12671
.Llo2592:
	lbz		r0,0(r27)		# memOperationResult=r0 pErrorCode=r27
.Llo2640:
	cmpi		0,0,r0,120		# memOperationResult=r0
	bc		0,2,.L2569	# ne
.Llo2585:
	diab.li		r0,162		# memOperationResult=r0
.Llo2641:
	b		.L2570
.L2569:
.Llo2642:
	lbz		r0,0(r27)		# memOperationResult=r0 pErrorCode=r27
.L2570:
.Llo2643:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
	b		.L2542
.L2559:
#             }
#             else
#             {
#                /*
#                 * [SWS_Dcm_00491]
#                 * [SWS_Dcm_00495]
#                 * Request ok
#                 */
#                memOperationResult = pMemConf->MemoryOperationFunc(DCM_INITIAL,
	.d2line		12680
.Llo2586:
	lwz		r0,4(r30)		# memOperationResult=r0 pMemConf=r30
	mtspr		ctr,r0		# memOperationResult=ctr
	lbz		r4,15(r1)		# pErrorCode=r4
	lis		r3,(Dcm_DspInstance+76)@ha		# pSelectedMemoryRange=r3
.Llo2593:
	lwz		r7,(Dcm_DspInstance+76)@l(r3)		# pSelectedMemoryRange=r3
	lwz		r5,16(r1)
	lwz		r6,20(r1)		# pMemConf=r6
	diab.li		r3,0		# pSelectedMemoryRange=r3
.Llo2594:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                   dataStructure.memory_identifier,
#                                                                   dataStructure.memory_address,
#                                                                   dataStructure.memory_size,
#                                                                   status->buffer);
#                *pErrorCode = HandleMemoryOpResult(memOperationResult, operationKind);
	.d2line		12685
.Llo2644:
	mr		r0,r3		# memOperationResult=r0 memOperationResult=r3
	mr		r4,r29		# operationKind=r4 operationKind=r29
	bl		HandleMemoryOpResult
.Llo2595:
	stb		r3,0(r27)		# pErrorCode=r27 pSelectedMemoryRange=r3
#                ChangeAsyncState(&Dcm_DspInstance.asynch_state, *pErrorCode);
	.d2line		12686
	lis		r3,(Dcm_DspInstance+8)@ha		# pSelectedMemoryRange=r3
	e_add16i		r3,r3,(Dcm_DspInstance+8)@l		# pSelectedMemoryRange=r3 pSelectedMemoryRange=r3
.Llo2596:
	lbz		r4,0(r27)		# operationKind=r4 pErrorCode=r27
	bl		ChangeAsyncState
.L2542:
#             }
#          }
#       }
#    }
# 
#    if (DCM_ASYNCH_STATE_CANCEL == Dcm_DspInstance.asynch_state)
	.d2line		12692
.Llo2580:
	lis		r3,(Dcm_DspInstance+8)@ha		# OpStatus=r3
.Llo2569:
	lwz		r0,(Dcm_DspInstance+8)@l(r3)		# memOperationResult=r0 OpStatus=r3
.Llo2645:
	se_cmpi		r0,2		# memOperationResult=r0
	bc		0,2,.L2561	# ne
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Ignore the return value since the protocol is about to stop anyway.
#        * Just cancel the pending operation and mark the service as processed.
#        */
#       (void)pMemConf->MemoryOperationFunc(DCM_CANCEL, 0, 0, 0, status->pendingBuffer);
	.d2line		12700
.Llo2570:
	lwz		r0,4(r30)		# memOperationResult=r0 pMemConf=r30
.Llo2587:
	mtspr		ctr,r0		# memOperationResult=ctr
	lis		r3,(Dcm_DspInstance+80)@ha		# OpStatus=r3
.Llo2571:
	lwz		r7,(Dcm_DspInstance+80)@l(r3)		# OpStatus=r3
.Llo2589:
	diab.li		r3,2		# memOperationResult=r3
.Llo2572:
	diab.li		r4,0		# pErrorCode=r4
	diab.li		r5,0
	diab.li		r6,0		# pMemConf=r6
.Llo2588:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12701
.Llo2582:
	diab.li		r0,0		# memOperationResult=r0
.Llo2646:
	stb		r0,0(r27)		# pErrorCode=r27 memOperationResult=r0
.L2561:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		12704
.Llo2583:
	lbz		r3,0(r27)		# OpStatus=r3 pErrorCode=r27
.Llo2590:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2584:
	rlwinm		r3,r3,0,24,31		# memOperationResult=r3 memOperationResult=r3
# }
	.d2line		12705
	.d2epilogue_begin
.Llo2647:
	lmw		r27,60(r1)		# offset r1+60  0x3c
	.d2_cfa_restore_list	3,10
	lwz		r0,84(r1)		# memOperationResult=r0
	mtspr		lr,r0		# memOperationResult=lr
	diab.addi		r1,r1,80		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4843:
	.type		GenericMemoryAddressOperation,@function
	.size		GenericMemoryAddressOperation,.-GenericMemoryAddressOperation
# Number of nodes = 548

# Allocations for GenericMemoryAddressOperation
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pMemConf
#	?a7		operationKind
#	?a8		pMemoryInitialisationFunc
#	?a9		pErrorCode
#	SP,24		$$66
#	?a10		$$65
#	?a11		$$64
#	?a12		$$63
#	SP,8		dataStructure
#	?a13		pSelectedMemoryRange
#	?a14		memOperationResult
#	not allocated	status
# FUNC(Std_ReturnType, DCM_CODE) Dcm_ReadMemoryByAddress(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         5928,32
#$$ld
.L4866:

#$$bf	Dcm_ReadMemoryByAddress,interprocedural,rasave,nostackparams
	.globl		Dcm_ReadMemoryByAddress
	.d2_cfa_start __cie
Dcm_ReadMemoryByAddress:
.Llo2648:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r8,r5		# pErrorCode=r8 pErrorCode=r5
	.d2prologue_end
# {
#    return GenericMemoryAddressOperation(OpStatus, pMsgContext, Dcm_LCfg.p_read_memory, DCM_MEM_OPERATION_READ, &ReadMemoryInitialisation, pErrorCode);
	.d2line		5930
	lis		r5,(Dcm_LCfg+156)@ha
.Llo2650:
	lwz		r5,(Dcm_LCfg+156)@l(r5)
	lis		r7,ReadMemoryInitialisation@ha
	e_add16i		r7,r7,ReadMemoryInitialisation@l
	mr		r0,r3		# OpStatus=r0 OpStatus=r3
	mr		r0,r4		# pMsgContext=r0 pMsgContext=r4
	diab.li		r6,0
.Llo2651:
	mr		r8,r8		# pErrorCode=r8 pErrorCode=r8
.Llo2652:
	bl		GenericMemoryAddressOperation
.Llo2649:
	rlwinm		r3,r3,0,24,31
# }
	.d2line		5931
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4867:
	.type		Dcm_ReadMemoryByAddress,@function
	.size		Dcm_ReadMemoryByAddress,.-Dcm_ReadMemoryByAddress
# Number of nodes = 21

# Allocations for Dcm_ReadMemoryByAddress
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
# FUNC(Std_ReturnType, DCM_CODE) Dcm_WriteMemoryByAddress(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         5936,32
#$$ld
.L4874:

#$$bf	Dcm_WriteMemoryByAddress,interprocedural,rasave,nostackparams
	.globl		Dcm_WriteMemoryByAddress
	.d2_cfa_start __cie
Dcm_WriteMemoryByAddress:
.Llo2653:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r8,r5		# pErrorCode=r8 pErrorCode=r5
	.d2prologue_end
# {
#    return GenericMemoryAddressOperation(OpStatus, pMsgContext, Dcm_LCfg.p_write_memory, DCM_MEM_OPERATION_WRITE, &WriteMemoryInitialisation, pErrorCode);
	.d2line		5938
	lis		r5,(Dcm_LCfg+152)@ha
.Llo2655:
	lwz		r5,(Dcm_LCfg+152)@l(r5)
	lis		r7,WriteMemoryInitialisation@ha
	e_add16i		r7,r7,WriteMemoryInitialisation@l
	mr		r0,r3		# OpStatus=r0 OpStatus=r3
	mr		r0,r4		# pMsgContext=r0 pMsgContext=r4
	diab.li		r6,1
.Llo2656:
	mr		r8,r8		# pErrorCode=r8 pErrorCode=r8
.Llo2657:
	bl		GenericMemoryAddressOperation
.Llo2654:
	rlwinm		r3,r3,0,24,31
# }
	.d2line		5939
	.d2epilogue_begin
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4875:
	.type		Dcm_WriteMemoryByAddress,@function
	.size		Dcm_WriteMemoryByAddress,.-Dcm_WriteMemoryByAddress
# Number of nodes = 21

# Allocations for Dcm_WriteMemoryByAddress
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
# FUNC(Std_ReturnType, DCM_CODE) Dcm_RequestDownload(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         5944,32
#$$ld
.L4882:

#$$bf	Dcm_RequestDownload,interprocedural,rasave,nostackparams
	.globl		Dcm_RequestDownload
	.d2_cfa_start __cie
Dcm_RequestDownload:
.Llo2658:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
	stmw		r27,44(r1)		# offset r1+44  0x2c
	.d2_cfa_offset_list	27,31,1,1
	stw		r0,68(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# OpStatus=r31 OpStatus=r3
.Llo2659:
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
.Llo2660:
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
# {
#    uint32 maxBlockLength;
#    uint8 dataFormatIdentifier;
#    MemoryDataStructureType dataStructure;
#    CONSTP2VAR(SoftwareDownloadOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.softwareDownloadOperation_status;
#    Dcm_Cfg_RxChannelPointerType pRxChannel = FindPduRxChannel(pMsgContext->dcmRxPduId);
	.d2line		5950
	lhz		r3,24(r30)		# pMsgContext=r30
	bl		FindPduRxChannel
.Llo2662:
	mr		r28,r3		# pRxChannel=r28 pRxChannel=r3
# 
#    dataStructure.memory_address_offset = 2;  /* dataFormatIdentifier and addressAndLengthFormatIdentifier */
	.d2line		5952
	diab.li		r0,2
	stb		r0,12(r1)
# 
#    if ((DCM_PENDING == OpStatus) || (DCM_FORCE_RCRRP_OK == OpStatus))
	.d2line		5954
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
.Llo2673:
	se_cmpi		r3,1
	bc		1,2,.L1382	# eq
.Llo2663:
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
	se_cmpi		r3,3
	bc		0,2,.L1365	# ne
.L1382:
	.section	.text_vle
.L4895:
	.d2line		5949
	diab.li		r4,0
	lis		r3,(Dcm_DspInstance+140)@ha
	stw		r4,(Dcm_DspInstance+140)@l(r3)
#    {
#       /*
#        * No need to check if RequestDownloadFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        *
#        * Set block length to 0 since it's a in/out parameter. But the pointer must still be valid.
#        */
#       status->blockLength = 0;
#       Std_ReturnType stdRetVal = Dcm_LCfg.p_software_download->RequestDownloadFunc(OpStatus,
	.d2line		5964
	lis		r3,(Dcm_LCfg+160)@ha
	lwz		r3,(Dcm_LCfg+160)@l(r3)
	lwz		r0,0(r3)
	mtspr		ctr,r0
	lis		r7,(Dcm_DspInstance+140)@ha
	e_add16i		r7,r7,(Dcm_DspInstance+140)@l
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
	mr		r8,r29		# pErrorCode=r8 pErrorCode=r29
	diab.li		r5,0
	diab.li		r6,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x1f8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                      0,
#                                                                      0,
#                                                                      0,
#                                                                      &status->blockLength,
#                                                                      pErrorCode);
# 
#       HandleStdRetVal(stdRetVal, DCM_E_PENDING, TRUE, pErrorCode);
	.d2line		5971
.Llo2675:
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	diab.li		r4,10
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,1
	bl		HandleStdRetVal
	.section	.text_vle
.L4896:
.L1365:
#    }
# 
#    if (DCM_INITIAL == OpStatus)
	.d2line		5974
.Llo2676:
	rlwinm		r3,r31,0,24,31		# OpStatus=r31
	se_cmpi		r3,0
	bc		0,2,.L1366	# ne
#    {
#       if (NULL_PTR == pRxChannel)
	.d2line		5976
	se_cmpi		r28,0		# pRxChannel=r28
	bc		0,2,.L1367	# ne
#       {
#          /*
#           * Per design has pMsgContext->dcmRxPduId always a valid value,
#           * i.e.from 0 up to maximum number of RxChannels.Therefore will FindPduRxChannel
#           * always return a valid pointer. A check for NULL_PTR cannot be tested but
#           * is used anyway for safety purpose.
#           */
#          *pErrorCode =  DCM_E_CONDITIONSNOTCORRECT;
	.d2line		5984
	diab.li		r0,34
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1366
.L1367:
#       }
#       else if (pMsgContext->reqDataLen < 4)
	.d2line		5986
	lhz		r0,4(r30)		# pMsgContext=r30
	se_cmpi		r0,4
	bc		0,0,.L1369	# ge
#       {
#          /*
#             * Request shall include
#             * - One byte dataFormatIdentifier
#             * - One byte addressAndLengthFormatIdentifier
#             * - At least one byte memoryAddress
#             * - At least one byte memorySize
#             */
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		5995
	diab.li		r0,19
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1366
.L1369:
#       }
#       else
#       {
#          /*
#           * Fetch some data from the request
#           */
#          dataFormatIdentifier                = pMsgContext->reqData[0];
	.d2line		6002
	lwz		r3,0(r30)		# pMsgContext=r30
	lbz		r27,0(r3)
.Llo2671:
	mr		r27,r27		# dataFormatIdentifier=r27 dataFormatIdentifier=r27
#          dataStructure.memory_address_length = pMsgContext->reqData[1] & 0x0FU;
	.d2line		6003
	lbz		r0,1(r3)
	rlwinm		r0,r0,0,28,31
	stb		r0,10(r1)
#          dataStructure.memory_size_length    = pMsgContext->reqData[1] >> 4;
	.d2line		6004
	lwz		r3,0(r30)		# pMsgContext=r30
	lbz		r3,1(r3)
	se_srwi		r3,4
	stb		r3,11(r1)
	.d2line		5949
	lwz		r3,12(r28)		# pRxChannel=r28
	lhz		r4,2(r3)
	lis		r3,(Dcm_DspInstance+140)@ha
	stw		r4,(Dcm_DspInstance+140)@l(r3)
#          status->blockLength                 = pRxChannel->p_buffer->size;
# 
#          /*
#           * Check acceptable address width.
#           * Memory address length minimum 1 bytes (ref. ISO14229)
#           * Memory address length maximum 4 bytes (constrained by AUTOSAR Dcm_ProcessRequestDownload)
#           */
#          if ((0 == dataStructure.memory_address_length) || (dataStructure.memory_address_length > 4))
	.d2line		6012
	e_andi.		r0,r0,255
	bc		1,2,.L1383	# eq
	lbz		r0,10(r1)
	se_cmpi		r0,4
	bc		0,1,.L1371	# le
.L1383:
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		6014
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1366
.L1371:
#          }
#          /*
#           * Check acceptable data length parameter size.
#           * Memory size length minimum 1 bytes (ref. ISO14229)
#           * Memory size length maximum 4 bytes (constrained by AUTOSAR Dcm_ProcessRequestDownload)
#           */
#          else if ((0 == dataStructure.memory_size_length) || (dataStructure.memory_size_length > 4))
	.d2line		6021
	lbz		r0,11(r1)
	se_cmpi		r0,0
	bc		1,2,.L1384	# eq
	lbz		r0,11(r1)
	se_cmpi		r0,4
	bc		0,1,.L1373	# le
.L1384:
#          {
#             *pErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		6023
	diab.li		r0,49
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1366
.L1373:
#          }
#          /*
#           * Check that  memory address and memory size parameters match the request
#           */
#          else if (pMsgContext->reqDataLen != (dataStructure.memory_address_offset + dataStructure.memory_address_length + dataStructure.memory_size_length))
	.d2line		6028
	lhz		r4,4(r30)		# pMsgContext=r30
	lbz		r3,12(r1)
	lbz		r0,10(r1)
	se_add		r3,r0
	lbz		r0,11(r1)
	se_add		r3,r0
	se_cmp		r4,r3
	bc		1,2,.L1375	# eq
#          {
#             *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		6030
	diab.li		r0,19
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1366
.L1375:
	.section	.text_vle
.L4901:
	.d2line		5949
	diab.li		r0,0
	lis		r3,(Dcm_DspInstance+144)@ha
	stb		r0,(Dcm_DspInstance+144)@l(r3)
	lis		r3,(Dcm_DspInstance+136)@ha
	stw		r0,(Dcm_DspInstance+136)@l(r3)
#          }
#          else
#          {
#             /*
#              * Intialise blockSequenceCounter, bytesReceived, etc.
#              */
#             status->blockSequenceCounter = 0;
#             status->transferredBytes = 0;
# 
#             /*
#              * Fetch the memoryAddress and memorySize
#              */
#             dataStructure.memory_size_offset = dataStructure.memory_address_offset + dataStructure.memory_address_length;
	.d2line		6043
	lbz		r0,12(r1)
	lbz		r4,10(r1)
	add		r3,r0,r4
	stb		r3,13(r1)
#             dataStructure.memory_address     = ParseMemoryParameter(&pMsgContext->reqData[dataStructure.memory_address_offset], dataStructure.memory_address_length);
	.d2line		6044
	lwz		r3,0(r30)		# pMsgContext=r30
	se_add		r3,r0
	bl		ParseMemoryParameter
	stw		r3,16(r1)
#             dataStructure.memory_size        = ParseMemoryParameter(&pMsgContext->reqData[dataStructure.memory_size_offset], dataStructure.memory_size_length);
	.d2line		6045
	lwz		r3,0(r30)		# pMsgContext=r30
	lbz		r0,13(r1)
	se_add		r3,r0
	lbz		r4,11(r1)
	bl		ParseMemoryParameter
	stw		r3,20(r1)
	lis		r4,(Dcm_DspInstance+132)@ha
	stw		r3,(Dcm_DspInstance+132)@l(r4)
#             status->requestedBytes           = dataStructure.memory_size;
# 
#             /*
#              * No need to check if RequestDownloadFunc is NULL_PTR or not.
#              * If coming this far, the service is configured and the SCG will guarantee that
#              * the pointer is valid.
#              */
#             Std_ReturnType stdRetVal = Dcm_LCfg.p_software_download->RequestDownloadFunc( DCM_INITIAL,
	.d2line		6053
	lis		r4,(Dcm_LCfg+160)@ha
	lwz		r4,(Dcm_LCfg+160)@l(r4)
	lwz		r0,0(r4)
	mtspr		ctr,r0
	lwz		r5,16(r1)
	mr		r6,r3
	lis		r7,(Dcm_DspInstance+140)@ha
	e_add16i		r7,r7,(Dcm_DspInstance+140)@l
	rlwinm		r4,r27,0,24,31		# dataFormatIdentifier=r27
	diab.li		r3,0
	mr		r8,r29		# pErrorCode=r8 pErrorCode=r29
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x1f8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                            dataFormatIdentifier,
#                                                                            dataStructure.memory_address,
#                                                                            dataStructure.memory_size,
#                                                                            &status->blockLength,
#                                                                            pErrorCode);
# 
#             HandleStdRetVal(stdRetVal, DCM_E_PENDING, TRUE, pErrorCode);
	.d2line		6060
.Llo2672:
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	diab.li		r4,10
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,1
	bl		HandleStdRetVal
	.section	.text_vle
.L4902:
.L1366:
#          }
#       }
#    }
# 
#    if (DCM_CANCEL == OpStatus)
	.d2line		6065
.Llo2677:
	rlwinm		r31,r31,0,24,31		# OpStatus=r31 OpStatus=r31
	se_cmpi		r31,2		# OpStatus=r31
	bc		0,2,.L1377	# ne
	.d2line		5949
.Llo2661:
	diab.li		r4,0
	lis		r3,(Dcm_DspInstance+140)@ha
	stw		r4,(Dcm_DspInstance+140)@l(r3)
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Ignore the return value since the protocol is about to stop anyway.
#        * Just cancel the pending operation and mark the service as processed.
#        *
#        * No need to check if RequestDownloadFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        *
#        * Set block length to 0 since it's a in/out parameter. But the pointer must still be valid.
#        */
#       status->blockLength = 0;
#       (void)Dcm_LCfg.p_software_download->RequestDownloadFunc(DCM_CANCEL,
	.d2line		6080
	lis		r3,(Dcm_LCfg+160)@ha
	lwz		r3,(Dcm_LCfg+160)@l(r3)
	lwz		r0,0(r3)
	mtspr		ctr,r0
	lis		r7,(Dcm_DspInstance+140)@ha
	e_add16i		r7,r7,(Dcm_DspInstance+140)@l
	diab.li		r3,2
	mr		r8,r29		# pErrorCode=r8 pErrorCode=r29
	diab.li		r5,0
	diab.li		r6,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x1f8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                0,
#                                                                0,
#                                                                0,
#                                                                &status->blockLength,
#                                                                pErrorCode);
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6086
	diab.li		r0,0
	stb		r0,0(r29)		# pErrorCode=r29
.L1377:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		6089
	lbz		r0,0(r29)		# pErrorCode=r29
	se_cmpi		r0,0
	bc		0,2,.L1378	# ne
#    {
#       /*
#        * Prepare the positive response. Ignore the cancel state since DSD
#        * will not send anything regardless of the error code.
#        */
# 
#       if (NULL_PTR == pRxChannel)
	.d2line		6096
	se_cmpi		r28,0		# pRxChannel=r28
	bc		0,2,.L1379	# ne
#       {
#          /*
#          * Per design has pMsgContext->dcmRxPduId always a valid value,
#          * i.e.from 0 up to maximum number of RxChannels.Therefore will FindPduRxChannel
#          * always return a valid pointer. A check for NULL_PTR cannot be tested but
#          * is used anyway for safety purpose.
#          */
#          *pErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		6104
	diab.li		r0,34
	stb		r0,0(r29)		# pErrorCode=r29
	b		.L1378
.L1379:
	.d2line		5949
	diab.li		r0,1
	lis		r3,(Dcm_DspInstance+128)@ha
	stw		r0,(Dcm_DspInstance+128)@l(r3)
#       }
#       else
#       {
#          /*
#           * Indicate download is active.
#           */
#          status->pendingDataTransferState = DATA_TRANSFER_NEGOTIATED;
# 
#          /*
#           * Request was accepted, create the response.
#           * The max block length depends on the application and the configured receive buffer
#           */
#          maxBlockLength = pRxChannel->p_buffer->size;
	.d2line		6117
	lwz		r3,12(r28)		# pRxChannel=r28
	lhz		r5,2(r3)		# maxBlockLength=r5
.Llo2666:
	mr		r5,r5		# maxBlockLength=r5 maxBlockLength=r5
#          if (maxBlockLength > status->blockLength)
	.d2line		6118
	lis		r3,(Dcm_DspInstance+140)@ha
	lwz		r0,(Dcm_DspInstance+140)@l(r3)
	se_cmpl		r0,r5		# maxBlockLength=r5
	bc		0,0,.L1381	# ge
#          {
#             maxBlockLength = status->blockLength;
	.d2line		6120
.Llo2674:
	lis		r3,(Dcm_DspInstance+140)@ha
	lwz		r5,(Dcm_DspInstance+140)@l(r3)		# maxBlockLength=r5
	mr		r5,r5		# maxBlockLength=r5 maxBlockLength=r5
.L1381:
#          }
# 
#          pMsgContext->resDataLen = 5;
	.d2line		6123
	diab.li		r0,5		# maxBlockLength=r0
	sth		r0,12(r30)		# pMsgContext=r30 maxBlockLength=r0
#          pMsgContext->resData[0] = (Dcm_MsgItemType)0x40U; /* lengthFormatIdentifier: 4 bytes length */
	.d2line		6124
	diab.li		r0,64		# maxBlockLength=r0
	lwz		r3,8(r30)		# pMsgContext=r30
	stb		r0,0(r3)		# maxBlockLength=r0
#          pMsgContext->resData[1] = DcmHiByte(DcmHiWord(maxBlockLength));
	.d2line		6125
	rlwinm		r0,r5,16,16,31		# maxBlockLength=r0 maxBlockLength=r5
	rlwinm		r0,r0,24,24,31		# maxBlockLength=r0 maxBlockLength=r0
	lwz		r3,8(r30)		# pMsgContext=r30
	stb		r0,1(r3)		# maxBlockLength=r0
#          pMsgContext->resData[2] = DcmLoByte(DcmHiWord(maxBlockLength));
	.d2line		6126
	rlwinm		r0,r5,16,24,31		# maxBlockLength=r0 maxBlockLength=r5
	lwz		r3,8(r30)		# pMsgContext=r30
	stb		r0,2(r3)		# maxBlockLength=r0
#          pMsgContext->resData[3] = DcmHiByte(DcmLoWord(maxBlockLength));
	.d2line		6127
	mr		r0,r5		# maxBlockLength=r0 maxBlockLength=r5
	rlwinm		r4,r0,24,24,31		# maxBlockLength=r0
	lwz		r3,8(r30)		# pMsgContext=r30
	stb		r4,3(r3)
#          pMsgContext->resData[4] = DcmLoByte(DcmLoWord(maxBlockLength));
	.d2line		6128
	rlwinm		r0,r0,0,24,31		# maxBlockLength=r0 maxBlockLength=r0
	lwz		r3,8(r30)		# pMsgContext=r30
	stb		r5,4(r3)		# maxBlockLength=r5
.L1378:
#       }
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		6132
.Llo2664:
	lbz		r3,0(r29)		# maxBlockLength=r3 pErrorCode=r29
.Llo2667:
	mr		r3,r3		# maxBlockLength=r3
.Llo2668:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2669:
	rlwinm		r3,r3,0,24,31		# maxBlockLength=r3 maxBlockLength=r3
# }
	.d2line		6133
	.d2epilogue_begin
.Llo2670:
	lmw		r27,44(r1)		# offset r1+44  0x2c
	.d2_cfa_restore_list	3,10
.Llo2665:
	lwz		r0,68(r1)		# maxBlockLength=r0
	mtspr		lr,r0		# maxBlockLength=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4883:
	.type		Dcm_RequestDownload,@function
	.size		Dcm_RequestDownload,.-Dcm_RequestDownload
# Number of nodes = 520

# Allocations for Dcm_RequestDownload
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		maxBlockLength
#	?a8		dataFormatIdentifier
#	SP,8		dataStructure
#	not allocated	status
#	?a9		pRxChannel
#	?a10		stdRetVal
#	?a11		stdRetVal
# static FUNC(void, DCM_CODE) TransferData_Initial(P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		1
	.section	.text_vle
        .d2line         14561,29
#$$ld
.L4909:

#$$bf	TransferData_Initial,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
TransferData_Initial:
.Llo2678:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stw		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_offset_list	31,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
	mr		r31,r4		# pErrorCode=r31 pErrorCode=r4
	.d2prologue_end
# {
#    CONSTP2VAR(SoftwareDownloadOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.softwareDownloadOperation_status;
# 
#    /*
#     * Assignment from request buffer can always be done since the buffer is always valid.
#     * If valid data is present or not is a secondary question.
#     */
#    CONST(uint8, DCM_CONST) newSequenceNumber = (uint8)pMsgContext->reqData[0];
	.d2line		14569
	lwz		r4,0(r3)		# pMsgContext=r3
.Llo2688:
	lbz		r5,0(r4)
.Llo2690:
	mr		r5,r5		# newSequenceNumber=r5 newSequenceNumber=r5
# 
#    if (pMsgContext->reqDataLen < 2)
	.d2line		14571
	lhz		r0,4(r3)		# pMsgContext=r3
	se_cmpi		r0,2
	bc		0,0,.L3078	# ge
#    {
#       *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		14573
.Llo2689:
	diab.li		r0,19
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3078:
#    }
#    else if (DATA_TRANSFER_NEGOTIATED > status->pendingDataTransferState)
	.d2line		14575
	lis		r4,(Dcm_DspInstance+128)@ha
	lwz		r0,(Dcm_DspInstance+128)@l(r4)
	se_cmpi		r0,0
	bc		1,1,.L3080	# gt
#    {
#       *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		14577
	diab.li		r0,36
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3080:
#    }
#    else if (newSequenceNumber == status->blockSequenceCounter)
	.d2line		14579
	rlwinm		r0,r5,0,24,31		# newSequenceNumber=r5
	lis		r4,(Dcm_DspInstance+144)@ha
	lbz		r4,(Dcm_DspInstance+144)@l(r4)
	se_cmp		r0,r4
	bc		0,2,.L3082	# ne
	.d2line		14563
.Llo2679:
	lis		r4,(Dcm_DspInstance+148)@ha
	lwz		r0,(Dcm_DspInstance+148)@l(r4)
.Llo2680:
	lhz		r3,4(r3)		# pMsgContext=r3 pMsgContext=r3
	diab.addi		r3,r3,-1		# pMsgContext=r3 pMsgContext=r3
	se_cmpl		r0,r3		# pMsgContext=r3
	bc		1,2,.L3083	# eq
#    {
#       /*
#        * SS-ISO 14429 Table 378:
#        * Data has been written. The client did not receive the response.
#        * The server would send the positive response message immediately without writing the data
#        * once again into its memory.
#        *
#        * However, if application rejected the previous block data, a rejection will be sent again.
#        *
#        * First some validations to check the repeated request is identical, with respect to the length,
#        * compared to the old one. Safe to do a type cast since pMsgContext->reqDataLen will be at least 1
#        * due to the check done in the beginning.
#        */
#       if (status->previousReceivedBytes != (uint32)(pMsgContext->reqDataLen - 1))
#       {
#          *pErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		14595
.Llo2681:
	diab.li		r0,19
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3083:
#       }
#       else
#       {
#          *pErrorCode = status->negativeResponseCode;
	.d2line		14599
	lis		r3,(Dcm_DspInstance+145)@ha		# pMsgContext=r3
.Llo2682:
	lbz		r0,(Dcm_DspInstance+145)@l(r3)		# pMsgContext=r3
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3082:
	.d2line		14563
.Llo2691:
	lis		r4,(Dcm_DspInstance+136)@ha
	lwz		r0,(Dcm_DspInstance+136)@l(r4)
	lis		r4,(Dcm_DspInstance+132)@ha
	lwz		r4,(Dcm_DspInstance+132)@l(r4)
	se_cmpl		r0,r4
	bc		1,0,.L3086	# lt
#       }
#    }
#    else if (status->transferredBytes >= status->requestedBytes)
#    {
#       /*
#        * SS-ISO 14429 Table 378:
#        * if the RequestDownload or RequestUpload service is active, but the server has
#        * already received all data as determined by the memorySize parameter in the active
#        * RequestDownload or RequestUpload service.
#        */
#       *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		14610
	diab.li		r0,36
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3086:
#    }
#    else if (newSequenceNumber != (uint8)(status->blockSequenceCounter + 1))
	.d2line		14612
	rlwinm		r0,r5,0,24,31		# newSequenceNumber=r5
	lis		r4,(Dcm_DspInstance+144)@ha
	lbz		r4,(Dcm_DspInstance+144)@l(r4)
	se_addi		r4,1
	rlwinm		r4,r4,0,24,31
	se_cmp		r0,r4
	bc		1,2,.L3088	# eq
#    {
#       /*
#        * SS-ISO 14429 Table 378:
#        * This return code shall be sent if the server detects an error in the sequence of the
#        * blockSequenceCounter.
#        */
#       *pErrorCode = DCM_E_WRONGBLOCKSEQUENCECOUNTER;
	.d2line		14619
	diab.li		r0,115
	stb		r0,0(r31)		# pErrorCode=r31
	b		.L3077
.L3088:
	.d2line		14563
	diab.li		r0,0
	lis		r4,(Dcm_DspInstance+145)@ha
	stb		r0,(Dcm_DspInstance+145)@l(r4)
	lis		r4,(Dcm_DspInstance+144)@ha
	stb		r5,(Dcm_DspInstance+144)@l(r4)		# newSequenceNumber=r5
	diab.li		r0,2
	lis		r4,(Dcm_DspInstance+128)@ha
	stw		r0,(Dcm_DspInstance+128)@l(r4)
	lhz		r4,4(r3)		# pMsgContext=r3
	diab.addi		r0,r4,-1
	lis		r5,(Dcm_DspInstance+148)@ha		# newSequenceNumber=r5
	stw		r0,(Dcm_DspInstance+148)@l(r5)		# newSequenceNumber=r5
	lis		r4,(Dcm_DspInstance+136)@ha
	lwz		r0,(Dcm_DspInstance+136)@l(r4)
	lwz		r5,(Dcm_DspInstance+148)@l(r5)		# newSequenceNumber=r5 newSequenceNumber=r5
	se_add		r0,r5		# newSequenceNumber=r5
	stw		r0,(Dcm_DspInstance+136)@l(r4)
	.section	.text_vle
.L4916:
#    }
#    else
#    {
#       status->negativeResponseCode = DCM_INT_NRC_POSITIVERESPONSE;
# 
#       /*
#        * Get the block sequence counter from the request
#        * It shall be echoed in the positive response.
#        */
#       status->blockSequenceCounter = newSequenceNumber;
# 
#       /*
#        * update software phase
#        */
#       status->pendingDataTransferState = DATA_TRANSFER_ONGOING;
# 
#       /*
#        * Record the number of data received.
#        *
#        * Safe to do a type cast since pMsgContext->reqDataLen will be at least 1
#        * due to the check done in the beginning.
#        */
#       status->previousReceivedBytes = (uint32)(pMsgContext->reqDataLen - 1);
# 
#       /*
#        * Record the number of data received.
#        */
#       status->transferredBytes += status->previousReceivedBytes;
# 
#       /*
#        * No need to check if WriteMemoryFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        */
#       {
#          CONST(Dcm_ReturnMemOperationType, AUTOMATIC) memOpRetVal = Dcm_LCfg.p_software_download->WriteMemoryFunc(DCM_INITIAL,
	.d2line		14655
.Llo2692:
	lis		r4,(Dcm_LCfg+160)@ha
	lwz		r4,(Dcm_LCfg+160)@l(r4)
	lwz		r0,4(r4)
	mtspr		ctr,r0
	lhz		r6,4(r3)		# pMsgContext=r3
	diab.addi		r6,r6,-1
	lwz		r7,0(r3)		# pMsgContext=r3
	se_addi		r7,1
	diab.li		r3,0		# pMsgContext=r3
.Llo2683:
	diab.li		r4,0
	diab.li		r5,0		# newSequenceNumber=r5
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                                                                   0x00,  /* MemoryIdentifier, vague in SWS so currently always 0 */
#                                                                                                                   0x00,  /* MemoryAddress, always 0x00 since delivered in service 0x34 */
#                                                                                                                   pMsgContext->reqDataLen - 1, /* Remove the blockSequenceCounter */
#                                                                                                                   &pMsgContext->reqData[1]);      /* Remove the blockSequenceCounter */
#          *pErrorCode = HandleMemoryOpResult(memOpRetVal, DCM_MEM_OPERATION_WRITE);
	.d2line		14660
.Llo2693:
	mr		r0,r3		# memOpRetVal=r0 memOpRetVal=r3
	diab.li		r4,1
	bl		HandleMemoryOpResult
.Llo2684:
	stb		r3,0(r31)		# pErrorCode=r31 pMsgContext=r3
	.section	.text_vle
.L4917:
	.d2line		14563
.Llo2685:
	lbz		r0,0(r31)		# pMsgContext=r0 pErrorCode=r31
.Llo2686:
	lis		r3,(Dcm_DspInstance+145)@ha		# pMsgContext=r3
	stb		r0,(Dcm_DspInstance+145)@l(r3)		# pMsgContext=r3 pMsgContext=r0
.L3077:
#       }
# 
#       /*
#        * Store the error code if the request is repeated using the same block sequence counter.
#        */
#       status->negativeResponseCode = *pErrorCode;
#    }
# }
	.d2line		14668
	.d2epilogue_begin
.Llo2687:
	lwz		r31,28(r1)		# offset r1+28  0x1c
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# pMsgContext=r0
	mtspr		lr,r0		# pMsgContext=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4910:
	.type		TransferData_Initial,@function
	.size		TransferData_Initial,.-TransferData_Initial
# Number of nodes = 191

# Allocations for TransferData_Initial
#	?a4		pMsgContext
#	?a5		pErrorCode
#	not allocated	status
#	?a6		newSequenceNumber
#	?a7		memOpRetVal
# FUNC(Std_ReturnType, DCM_CODE) Dcm_TransferData(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         6138,32
#$$ld
.L4925:

#$$bf	Dcm_TransferData,interprocedural,rasave,nostackparams
	.globl		Dcm_TransferData
	.d2_cfa_start __cie
Dcm_TransferData:
.Llo2694:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# OpStatus=r31 OpStatus=r3
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
# {
#    if ((DCM_PENDING == OpStatus) || (DCM_FORCE_RCRRP_OK == OpStatus))
	.d2line		6140
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
	se_cmpi		r3,1		# OpStatus=r3
	bc		1,2,.L1404	# eq
.Llo2695:
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
.Llo2696:
	se_cmpi		r3,3		# OpStatus=r3
	bc		0,2,.L1400	# ne
.L1404:
	.section	.text_vle
.L4931:
#    {
#       /*
#        * No need to check if WriteMemoryFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        */
#       CONST(Dcm_ReturnMemOperationType, AUTOMATIC) memOpRetVal = Dcm_LCfg.p_software_download->WriteMemoryFunc(OpStatus,
	.d2line		6147
	lis		r3,(Dcm_LCfg+160)@ha		# OpStatus=r3
	lwz		r3,(Dcm_LCfg+160)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,4(r3)		# OpStatus=r3
	mtspr		ctr,r0
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
	diab.li		r4,0
	diab.li		r5,0
	diab.li		r6,0
	diab.li		r7,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                   0x00,
#                                                                   0x00,
#                                                                   0x00,
#                                                                   NULL_PTR);
#       *pErrorCode = HandleMemoryOpResult(memOpRetVal, DCM_MEM_OPERATION_WRITE);
	.d2line		6152
.Llo2709:
	mr		r0,r3		# memOpRetVal=r0 memOpRetVal=r3
	diab.li		r4,1
	bl		HandleMemoryOpResult
.Llo2710:
	stb		r3,0(r29)		# pErrorCode=r29 OpStatus=r3
	.section	.text_vle
.L4932:
.L1400:
#    }
# 
#    if (DCM_INITIAL == OpStatus)
	.d2line		6155
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
	se_cmpi		r3,0		# OpStatus=r3
	bc		0,2,.L1401	# ne
#    {
#       TransferData_Initial(pMsgContext, pErrorCode);
	.d2line		6157
	mr		r3,r30		# pMsgContext=r3 pMsgContext=r30
	mr		r4,r29		# pErrorCode=r4 pErrorCode=r29
	bl		TransferData_Initial
.L1401:
#    }
# 
#    if (DCM_CANCEL == OpStatus)
	.d2line		6160
	rlwinm		r31,r31,0,24,31		# OpStatus=r31 OpStatus=r31
	se_cmpi		r31,2		# OpStatus=r31
	bc		0,2,.L1402	# ne
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Ignore the return value since the protocol is about to stop anyway.
#        * Just cancel the pending operation and mark the service as processed.
#        *
#        * No need to check if WriteMemoryFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        */
#       (void)Dcm_LCfg.p_software_download->WriteMemoryFunc(DCM_CANCEL,
	.d2line		6172
.Llo2697:
	lis		r3,(Dcm_LCfg+160)@ha		# OpStatus=r3
.Llo2698:
	lwz		r3,(Dcm_LCfg+160)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,4(r3)		# OpStatus=r0 OpStatus=r3
	mtspr		ctr,r0		# OpStatus=ctr
	diab.li		r3,2		# OpStatus=r3
.Llo2699:
	diab.li		r4,0		# pErrorCode=r4
	diab.li		r5,0
	diab.li		r6,0
	diab.li		r7,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0xf8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                          0x00,
#                                                          0x00,
#                                                          0x00,
#                                                          NULL_PTR);
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6177
	diab.li		r0,0		# OpStatus=r0
.Llo2700:
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
.L1402:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		6180
.Llo2701:
	lbz		r0,0(r29)		# OpStatus=r0 pErrorCode=r29
.Llo2702:
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1403	# ne
	.section	.text_vle
.L4937:
#    {
#       CONSTP2VAR(SoftwareDownloadOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.softwareDownloadOperation_status;
# 
#       /*
#        * Prepare the positive response. Ignore the cancel state since DSD
#        * will not send anything regardless of the error code.
#        *
#        * Request was accepted, create the response which currently only contains an echo of the
#        * requested block sequence counter.
#        */
#       pMsgContext->resDataLen  = 1;
	.d2line		6191
.Llo2703:
	diab.li		r0,1		# OpStatus=r0
.Llo2704:
	sth		r0,12(r30)		# pMsgContext=r30 OpStatus=r0
#       pMsgContext->resData[0]   = status->blockSequenceCounter;
	.d2line		6192
	lis		r3,(Dcm_DspInstance+144)@ha		# OpStatus=r3
	lbz		r0,(Dcm_DspInstance+144)@l(r3)		# OpStatus=r0 OpStatus=r3
	lwz		r3,8(r30)		# OpStatus=r3 pMsgContext=r30
	stb		r0,0(r3)		# OpStatus=r3 OpStatus=r0
	.section	.text_vle
.L4938:
.L1403:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		6195
.Llo2705:
	lbz		r3,0(r29)		# OpStatus=r3 pErrorCode=r29
.Llo2708:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2706:
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
# }
	.d2line		6196
	.d2epilogue_begin
.Llo2707:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# OpStatus=r0
	mtspr		lr,r0		# OpStatus=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4926:
	.type		Dcm_TransferData,@function
	.size		Dcm_TransferData,.-Dcm_TransferData
# Number of nodes = 108

# Allocations for Dcm_TransferData
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	?a7		memOpRetVal
#	not allocated	status
# FUNC(Std_ReturnType, DCM_CODE) Dcm_RequestTransferExit(Dcm_OpStatusType OpStatus, P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_APPL_DATA) pErrorCode)
	.align		2
	.section	.text_vle
        .d2line         6201,32
#$$ld
.L4943:

#$$bf	Dcm_RequestTransferExit,interprocedural,rasave,nostackparams
	.globl		Dcm_RequestTransferExit
	.d2_cfa_start __cie
Dcm_RequestTransferExit:
.Llo2711:
	stwu		r1,-32(r1)		
	.d2_cfa_def_cfa_offset	32
	mfspr		r0,lr
	stmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	29,31,1,1
	stw		r0,36(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# OpStatus=r31 OpStatus=r3
	mr		r30,r4		# pMsgContext=r30 pMsgContext=r4
	mr		r29,r5		# pErrorCode=r29 pErrorCode=r5
	.d2prologue_end
# {
#    CONSTP2VAR(SoftwareDownloadOperationStatusType, AUTOMATIC, DCM_APPL_DATA) status = &Dcm_DspInstance.softwareDownloadOperation_status;
# 
#    if ((DCM_PENDING == OpStatus) || (DCM_FORCE_RCRRP_OK == OpStatus))
	.d2line		6205
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
	se_cmpi		r3,1		# OpStatus=r3
	bc		1,2,.L1417	# eq
.Llo2712:
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
.Llo2713:
	se_cmpi		r3,3		# OpStatus=r3
	bc		0,2,.L1411	# ne
.L1417:
	.section	.text_vle
.L4949:
#    {
#       /*
#        * No need to check if RequestTransferExitFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        */
#       Std_ReturnType stdRetVal = Dcm_LCfg.p_software_download->RequestTransferExitFunc(OpStatus,
	.d2line		6212
	lis		r3,(Dcm_LCfg+160)@ha		# OpStatus=r3
	lwz		r3,(Dcm_LCfg+160)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,8(r3)		# OpStatus=r3
	mtspr		ctr,r0
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
	diab.li		r4,0
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,0
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                         NULL_PTR,
#                                                                         0,
#                                                                         pErrorCode);
# 
#       HandleStdRetVal(stdRetVal, DCM_E_PENDING, TRUE, pErrorCode);
	.d2line		6217
.Llo2726:
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	diab.li		r4,10
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,1
	bl		HandleStdRetVal
	.section	.text_vle
.L4950:
.L1411:
#    }
# 
#    if (DCM_INITIAL == OpStatus)
	.d2line		6220
.Llo2727:
	rlwinm		r3,r31,0,24,31		# OpStatus=r3 OpStatus=r31
	se_cmpi		r3,0		# OpStatus=r3
	bc		0,2,.L1412	# ne
#    {
#       if (DATA_TRANSFER_ONGOING != status->pendingDataTransferState)
	.d2line		6222
	lis		r3,(Dcm_DspInstance+128)@ha		# OpStatus=r3
	lwz		r0,(Dcm_DspInstance+128)@l(r3)		# OpStatus=r0 OpStatus=r3
	se_cmpi		r0,2		# OpStatus=r0
	bc		1,2,.L1413	# eq
#       {
#          *pErrorCode = DCM_E_REQUESTSEQUENCEERROR;
	.d2line		6224
	diab.li		r0,36		# OpStatus=r0
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
	b		.L1412
.L1413:
	.section	.text_vle
.L4955:
#       }
#       else
#       {
#          /*
#           * No need to check if RequestTransferExitFunc is NULL_PTR or not.
#           * If coming this far, the service is configured and the SCG will guarantee that
#           * the pointer is valid.
#           */
#          CONST(uint32, DCM_CONST) parameterRecordSize = pMsgContext->reqDataLen;
	.d2line		6233
	lhz		r0,4(r30)		# OpStatus=r0 pMsgContext=r30
	.d2line		6234
	mr.		r5,r0		# parameterRecordSize=?a8 parameterRecordSize=?a11
#          CONSTP2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) parameterRecord = (parameterRecordSize != 0) ? &pMsgContext->reqData[0] : NULL_PTR;
.Llo2728:
	bc		1,2,.L1418	# eq
	lwz		r4,0(r30)		# pMsgContext=r30
.Llo2732:
	mr		r4,r4		# parameterRecord=r4 parameterRecord=r4
	b		.L1419
.L1418:
.Llo2733:
	diab.li		r4,0		# parameterRecord=r4
.L1419:
# 
#          Std_ReturnType stdRetVal = Dcm_LCfg.p_software_download->RequestTransferExitFunc(DCM_INITIAL,
	.d2line		6236
.Llo2729:
	lis		r3,(Dcm_LCfg+160)@ha		# OpStatus=r3
	lwz		r3,(Dcm_LCfg+160)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,8(r3)		# OpStatus=r0 OpStatus=r3
	mtspr		ctr,r0		# OpStatus=ctr
	diab.li		r3,0		# OpStatus=r3
	mr		r4,r4		# parameterRecord=r4 parameterRecord=r4
.Llo2734:
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
.Llo2730:
	mr		r5,r5		# parameterRecordSize=r5 parameterRecordSize=r5
.Llo2731:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                            parameterRecord,
#                                                                            parameterRecordSize,
#                                                                            pErrorCode);
# 
#          HandleStdRetVal(stdRetVal, DCM_E_PENDING, TRUE, pErrorCode);
	.d2line		6241
.Llo2735:
	mr		r0,r3		# stdRetVal=r0 stdRetVal=r3
	diab.li		r4,10		# parameterRecord=r4
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,1		# parameterRecordSize=r5
	bl		HandleStdRetVal
	.section	.text_vle
.L4956:
.L1412:
#       }
#    }
# 
#    if (DCM_CANCEL == OpStatus)
	.d2line		6245
.Llo2736:
	rlwinm		r31,r31,0,24,31		# OpStatus=r31 OpStatus=r31
	se_cmpi		r31,2		# OpStatus=r31
	bc		0,2,.L1415	# ne
#    {
#       /*
#        * MISRA-C:2004 RULE 16.10 VIOLATION:
#        * If a function returns error information, then that error information shall be tested.
#        * Ignore the return value since the protocol is about to stop anyway.
#        * Just cancel the pending operation and mark the service as processed.
#        *
#        * No need to check if RequestTransferExitFunc is NULL_PTR or not.
#        * If coming this far, the service is configured and the SCG will guarantee that
#        * the pointer is valid.
#        */
#       (void)Dcm_LCfg.p_software_download->RequestTransferExitFunc(DCM_CANCEL,
	.d2line		6257
.Llo2714:
	lis		r3,(Dcm_LCfg+160)@ha		# OpStatus=r3
.Llo2715:
	lwz		r3,(Dcm_LCfg+160)@l(r3)		# OpStatus=r3 OpStatus=r3
	lwz		r0,8(r3)		# OpStatus=r0 OpStatus=r3
	mtspr		ctr,r0		# OpStatus=ctr
	diab.li		r3,2		# OpStatus=r3
.Llo2716:
	diab.li		r4,0		# parameterRecord=r4
	mr		r6,r29		# pErrorCode=r6 pErrorCode=r29
	diab.li		r5,0		# parameterRecordSize=r5
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x78 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
#                                                                   NULL_PTR,
#                                                                   0,
#                                                                   pErrorCode);
#       *pErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		6261
	diab.li		r0,0		# OpStatus=r0
.Llo2717:
	stb		r0,0(r29)		# pErrorCode=r29 OpStatus=r0
.L1415:
#    }
# 
#    if (DCM_INT_NRC_POSITIVERESPONSE == *pErrorCode)
	.d2line		6264
.Llo2718:
	lbz		r0,0(r29)		# OpStatus=r0 pErrorCode=r29
.Llo2719:
	se_cmpi		r0,0		# OpStatus=r0
	bc		0,2,.L1416	# ne
	.d2line		6203
.Llo2720:
	diab.li		r0,0		# OpStatus=r0
.Llo2721:
	lis		r3,(Dcm_DspInstance+128)@ha		# OpStatus=r3
	stw		r0,(Dcm_DspInstance+128)@l(r3)		# OpStatus=r3 OpStatus=r0
#    {
#       /*
#        * Prepare the positive response. Ignore the cancel state since DSD
#        * will not send anything regardless of the error code.
#        */
# 
#       /*
#        * Indicate the whole software process is finished.
#        */
#       status->pendingDataTransferState = DATA_TRANSFER_IDLE;
# 
#       /*
#        * Request was accepted, create the response.
#        * Currently, it's not possible to provide any transferResponseParameterRecord according to ISO 14229
#        * Therefore will always the result be empty.
#        */
#       pMsgContext->resDataLen = 0;
	.d2line		6281
	sth		r0,12(r30)		# pMsgContext=r30 OpStatus=r0
.L1416:
#    }
# 
#    return Dcm_ErrorCodeToStdReturnType(*pErrorCode);
	.d2line		6284
.Llo2722:
	lbz		r3,0(r29)		# OpStatus=r3 pErrorCode=r29
.Llo2725:
	bl		Dcm_ErrorCodeToStdReturnType
.Llo2723:
	rlwinm		r3,r3,0,24,31		# OpStatus=r3 OpStatus=r3
# }
	.d2line		6285
	.d2epilogue_begin
.Llo2724:
	lmw		r29,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	3,10
	lwz		r0,36(r1)		# OpStatus=r0
	mtspr		lr,r0		# OpStatus=lr
	se_addi		r1,32		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4944:
	.type		Dcm_RequestTransferExit,@function
	.size		Dcm_RequestTransferExit,.-Dcm_RequestTransferExit
# Number of nodes = 156

# Allocations for Dcm_RequestTransferExit
#	?a4		OpStatus
#	?a5		pMsgContext
#	?a6		pErrorCode
#	not allocated	status
#	?a7		stdRetVal
#	?a8		parameterRecordSize
#	?a9		parameterRecord
#	?a10		stdRetVal
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadCommonPid(CONST(uint8, AUTOMATIC) sid,
	.align		1
	.section	.text_vle
        .d2line         11594,53
#$$ld
.L4967:

#$$bf	ReadCommonPid,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadCommonPid:
.Llo2737:
	stwu		r1,-64(r1)		
	.d2_cfa_def_cfa_offset	64
	mfspr		r0,lr
	stmw		r21,20(r1)		# offset r1+20  0x14
	.d2_cfa_offset_list	21,31,1,1
	stw		r0,68(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# sid=r31 sid=r3
	mr		r28,r4		# obdId=r28 obdId=r4
	mr		r30,r6		# position=r30 position=r6
	mr		r29,r7		# sizeOfMemory=r29 sizeOfMemory=r7
	.d2prologue_end
#                                                                   CONST(uint8, AUTOMATIC) obdId,
#                                                                   CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus,
#                                                                   CONST(uint8, AUTOMATIC) position,
#                                                                   CONST(uint8, AUTOMATIC) sizeOfMemory)
# {
#    uint8 i;
#    uint16                        num_bytes;
#    uint8                         num_bits_left;
#    uint16                        DataIndex = 0;
	.d2line		11603
	diab.li		r23,0		# DataIndex=r23
#    Std_ReturnType                stdReturnVal                    = E_OK;
	.d2line		11604
.Llo2786:
	mr		r23,r23		# stdReturnVal=r23 stdReturnVal=r23
#    P2CONST(Dcm_Cfg_PidType, AUTOMATIC, DCM_APPL_DATA)  pPid      = NULL_PTR;
	.d2line		11605
.Llo2787:
	mr		r23,r23		# pPid=r23 pPid=r23
#    P2CONST(Dcm_Cfg_PidDataType, AUTOMATIC, DCM_APPL_DATA)  pData = NULL_PTR;
	.d2line		11606
	diab.li		r3,0
# 
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  resBuffer;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  dddidResBuffer;
# 
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    /*
#     * Find the pointer to the requested ID
#     */
#    pPid = NULL_PTR;
# 
#    for (i = 0; (i < Dcm_LCfg.num_pids) && (NULL_PTR == pPid); i++)
.L2360:
	.d2line		11618
.Llo2738:
	rlwinm		r0,r3,0,24,31		# pPid=r0 i=r3
.Llo2739:
	lis		r4,(Dcm_LCfg+92)@ha
	lbz		r4,(Dcm_LCfg+92)@l(r4)
	se_cmp		r0,r4		# pPid=r0
	bc		0,0,.L2362	# ge
	cmpi		0,0,r23,0		# pPid=r23
	bc		0,2,.L2362	# ne
#    {
#       if (Dcm_LCfg.p_pids[i].identifier == obdId)
	.d2line		11620
	rlwinm		r0,r3,0,24,31		# pPid=r0 i=r3
	lis		r4,(Dcm_LCfg+96)@ha
	lwz		r4,(Dcm_LCfg+96)@l(r4)
	rlwinm		r5,r0,5,0,26		# pPid=r0
	se_slwi		r0,3		# pPid=r0 pPid=r0
	subf		r0,r0,r5		# pPid=r0 pPid=r0
	lbzx		r0,r4,r0		# pPid=r0
	rlwinm		r4,r28,0,24,31		# obdId=r28
	se_cmp		r0,r4		# pPid=r0
	bc		0,2,.L2363	# ne
#       {
#          pPid = &(Dcm_LCfg.p_pids)[i];
	.d2line		11622
	rlwinm		r0,r3,0,24,31		# pPid=r0 i=r3
	lis		r4,(Dcm_LCfg+96)@ha
	lwz		r23,(Dcm_LCfg+96)@l(r4)		# pPid=r23
	rlwinm		r4,r0,5,0,26		# pPid=r0
	se_slwi		r0,3		# pPid=r0 pPid=r0
	subf		r0,r0,r4		# pPid=r0 pPid=r0
	add		r23,r23,r0		# pPid=r23 pPid=r23 pPid=r0
	mr		r0,r23		# pPid=r0 pPid=r23
.L2363:
#       }
#    }
	.d2line		11624
	diab.addi		r0,r3,1		# pPid=r0 i=r3
	se_addi		r3,1		# i=r3 i=r3
	b		.L2360
.L2362:
# 
#    if (NULL_PTR == pPid)
	.d2line		11626
	cmpi		0,0,r23,0		# pPid=r23
	bc		0,2,.L2364	# ne
#    {
#       /* Pid is not configured. */
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11629
.Llo2749:
	diab.li		r3,160		# ErrorCode=r3
.Llo2801:
	b		.L2365
.L2364:
#    }
#    else if ((DCM_SERVICE_01 != pPid->service_type) && (DCM_SERVICE_01_02 != pPid->service_type))
	.d2line		11631
.Llo2802:
	lwz		r0,4(r23)		# pPid=r0 pPid=r23
	se_cmpi		r0,0		# pPid=r0
	bc		1,2,.L2366	# eq
	lwz		r0,4(r23)		# pPid=r0 pPid=r23
	se_cmpi		r0,1		# pPid=r0
	bc		1,2,.L2366	# eq
#    {
#       /*
#        * Pid is not for OBD Service 0x01, therefore this Pid will not be marked in the support info.
#        * It is treated as unconfigured.
#        */
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11637
	diab.li		r3,160		# ErrorCode=r3
.Llo2803:
	b		.L2365
.L2366:
#    }
#    else if (FALSE == IsIdentifierSupported(Dcm_pPbCfg->p_pids_support_01, pPid->identifier))
	.d2line		11639
.Llo2804:
	lis		r3,Dcm_pPbCfg@ha		# i=r3
.Llo2750:
	lwz		r3,Dcm_pPbCfg@l(r3)		# i=r3 i=r3
	lwz		r3,24(r3)		# i=r3 i=r3
.Llo2751:
	lbz		r4,0(r23)		# pPid=r23
	bl		IsIdentifierSupported
.Llo2752:
	e_andi.		r3,r3,255		# i=r3 i=r3
.Llo2753:
	bc		0,2,.L2368	# ne
#    {
#       /* Pid is disabled. */
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11642
	diab.li		r3,160		# ErrorCode=r3
.Llo2805:
	b		.L2365
.L2368:
#    }
#    else
#    {
#        /*
#         * Finally try to get the response buffer
#         */
#       if (SID_REQ_CURRENT_POWERTRAIN_DIAG_DATA == sid )
	.d2line		11649
.Llo2806:
	rlwinm		r3,r31,0,24,31		# i=r3 sid=r31
.Llo2754:
	se_cmpi		r3,1		# i=r3
	bc		0,2,.L2370	# ne
#       {
#          /*
#           * OBD service 0x01 is the caller.
#           */
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)pPid->size + (Dcm_MsgLenType)1U, &resBuffer);
	.d2line		11654
.Llo2755:
	lbz		r3,1(r23)		# i=r3 pPid=r23
.Llo2756:
	se_addi		r3,1		# i=r3 i=r3
	rlwinm		r3,r3,0,16,31		# i=r3 i=r3
.Llo2757:
	diab.addi		r4,r1,8
	bl		Dcm_DsdRequestResponseBuffer
.Llo2788:
	mr		r24,r3		# stdReturnVal=r24 stdReturnVal=r3
	b		.L2371
.L2370:
#       }
#       else if (SID_READ_DATA_BY_IDENTIFIER == sid)
	.d2line		11656
.Llo2789:
	rlwinm		r3,r31,0,24,31		# i=r3 sid=r31
.Llo2758:
	cmpi		0,0,r3,34		# i=r3
	bc		0,2,.L2372	# ne
#       {
#          /*
#           * UDS service 0x22 is the caller.
#           * According to ISO 14229 Table C.1, OBDDataIdentifier has two bytes
#           * identifier.
#           */
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)pPid->size + (Dcm_MsgLenType)2U, &resBuffer);
	.d2line		11663
.Llo2759:
	lbz		r3,1(r23)		# i=r3 pPid=r23
.Llo2760:
	se_addi		r3,2		# i=r3 i=r3
	rlwinm		r3,r3,0,16,31		# i=r3 i=r3
.Llo2761:
	diab.addi		r4,r1,8
	bl		Dcm_DsdRequestResponseBuffer
.Llo2790:
	mr		r24,r3		# stdReturnVal=r24 stdReturnVal=r3
	b		.L2371
.L2372:
#       }
#       else
#       {
#          /*
#           * UDS service 0x2C is the caller.
#           * No identifier
#           */
#          stdReturnVal = Dcm_DsdRequestResponseBuffer((Dcm_MsgLenType)sizeOfMemory, &dddidResBuffer);
	.d2line		11671
.Llo2791:
	rlwinm		r3,r29,0,24,31		# i=r3 sizeOfMemory=r29
	diab.addi		r4,r1,12
	bl		Dcm_DsdRequestResponseBuffer
.Llo2792:
	mr		r24,r3		# stdReturnVal=r24 stdReturnVal=r3
#          resBuffer = Dcm_LCfg.p_dddid_sourceBuffer;
	.d2line		11672
	lis		r3,(Dcm_LCfg+28)@ha		# i=r3
.Llo2762:
	lwz		r0,(Dcm_LCfg+28)@l(r3)		# pPid=r0 i=r3
	stw		r0,8(r1)		# pPid=r0
.L2371:
#       }
# 
#       if (E_OK == stdReturnVal)
	.d2line		11675
.Llo2763:
	rlwinm		r3,r24,0,24,31		# i=r3 stdReturnVal=r24
.Llo2764:
	se_cmpi		r3,0		# i=r3
	bc		0,2,.L2374	# ne
#       {
#          /*
#           * Fetch the data. Any error will be handled below.
#           * Start to store the requested Pid.
#           */
#          DataIndex = 0;
	.d2line		11681
.Llo2765:
	diab.li		r25,0		# DataIndex=r25
#          if (SID_REQ_CURRENT_POWERTRAIN_DIAG_DATA == sid )
	.d2line		11682
.Llo2785:
	rlwinm		r3,r31,0,24,31		# i=r3 sid=r31
.Llo2766:
	se_cmpi		r3,1		# i=r3
	bc		0,2,.L2375	# ne
#          {
#             /*
#              * OBD service 0x01 is the caller.
#              */
#             resBuffer[DataIndex] = obdId;
	.d2line		11687
.Llo2767:
	lwz		r3,8(r1)		# i=r3
.Llo2768:
	stb		r28,0(r3)		# i=r3 obdId=r28
#             DataIndex++;
	.d2line		11688
	diab.addi		r0,r25,1		# pPid=r0 DataIndex=r25
	se_addi		r25,1		# DataIndex=r25 DataIndex=r25
	b		.L2376
.L2375:
#          }
#          else if (SID_READ_DATA_BY_IDENTIFIER == sid)
	.d2line		11690
.Llo2769:
	rlwinm		r3,r31,0,24,31		# i=r3 sid=r31
.Llo2770:
	cmpi		0,0,r3,34		# i=r3
	bc		0,2,.L2376	# ne
#          {
#             /*
#              * UDS service 0x22 is the caller.
#              * According to ISO 14229 Table C.1, OBDDataIdentifier has two bytes
#              * identifier.
#              */
#             SET_2BYTE_ID(&resBuffer[DataIndex], GET_OBD_DID(obdId));
	.d2line		11697
.Llo2771:
	rlwinm		r0,r28,0,24,31		# pPid=r0 obdId=r28
	e_ori		r0,r0,62464		# pPid=r0 pPid=r0
	rlwinm		r0,r0,24,24,31		# pPid=r0 pPid=r0
	lwz		r3,8(r1)		# i=r3
.Llo2772:
	stb		r0,0(r3)		# i=r3 pPid=r0
	lwz		r3,8(r1)		# i=r3
	rlwinm		r0,r25,0,16,31		# pPid=r0 DataIndex=r25
	se_add		r3,r0		# i=r3 i=r3 pPid=r0
	stb		r28,1(r3)		# i=r3 obdId=r28
#             DataIndex += 2U;
	.d2line		11698
	diab.addi		r0,r25,2		# pPid=r0 DataIndex=r25
	se_addi		r25,2		# DataIndex=r25 DataIndex=r25
.L2376:
#          }
#          else
#          {
#             /* 0x2C dynamically Defined Data Identifier, No source Id shall be copied. */
#          }
# 
#          /*
#           * Possibly not added pid data shall be set to zero [SWS_Dcm_00623] [SWS_Dcm_00944]
#           */
#          Dcm_Memset(&resBuffer[DataIndex], 0, pPid->size);
	.d2line		11708
.Llo2773:
	lwz		r3,8(r1)		# i=r3
.Llo2774:
	rlwinm		r0,r25,0,16,31		# pPid=r0 DataIndex=r25
	se_add		r3,r0		# i=r3 i=r3 pPid=r0
.Llo2775:
	lbz		r5,1(r23)		# pPid=r23
	diab.li		r4,0
	bl		Dcm_Memset
# 
#          if (0 < pPid->num_support_infos)
	.d2line		11710
	lbz		r0,8(r23)		# pPid=r0 pPid=r23
	se_cmpi		r0,0		# pPid=r0
	bc		0,1,.L2380	# le
#          {
#             /* Store support info first */
#             Dcm_Memcpy(&resBuffer[DataIndex], pPid->p_support_info, pPid->num_support_infos);
	.d2line		11713
.Llo2745:
	lwz		r3,8(r1)		# i=r3
.Llo2776:
	rlwinm		r0,r25,0,16,31		# pPid=r0 DataIndex=r25
	se_add		r3,r0		# i=r3 i=r3 pPid=r0
.Llo2777:
	lbz		r5,8(r23)		# pPid=r23
	lwz		r4,12(r23)		# pPid=r23
	bl		Dcm_Memcpy
.L2380:
#          }
# 
#          for (i = 0; (i < pPid->num_pidDatas) && (E_OK == stdReturnVal); i++)
	.d2line		11716
	diab.li		r28,0		# i=r28
.L2381:
.Llo2778:
	rlwinm		r0,r28,0,24,31		# pPid=r0 i=r28
	lbz		r3,16(r23)		# i=r3 pPid=r23
	se_cmp		r0,r3		# pPid=r0 i=r3
	bc		0,0,.L2383	# ge
	rlwinm		r3,r24,0,24,31		# i=r3 stdReturnVal=r24
	se_cmpi		r3,0		# i=r3
	bc		0,2,.L2383	# ne
#          {
#             /* Store all pid data in buffer bitwise */
#             pData = &pPid->p_pidDatas[i];
	.d2line		11719
	lwz		r22,20(r23)		# pData=r22 pPid=r23
.Llo2800:
	rlwinm		r0,r28,3,21,28		# pPid=r0 i=r28
	add		r22,r22,r0		# pData=r22 pData=r22 pPid=r0
	mr		r0,r22		# pData=r0 pData=r22
# 
#             stdReturnVal = pData->ReadDataFunc(&Dcm_LCfg.p_response_buffer[0]);
	.d2line		11721
	lwz		r0,4(r22)		# pData=r0 pData=r22
	mtspr		ctr,r0		# pData=ctr
	lis		r3,(Dcm_LCfg+20)@ha		# i=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# i=r3 i=r3
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x8 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2793:
	mr		r24,r3		# stdReturnVal=r24 stdReturnVal=r3
# 
#             num_bytes     = (uint16) (pData->size / 8U);    /* pData->size will never be greater than 2040 bits => 255 bytes */
	.d2line		11723
.Llo2794:
	lhz		r26,2(r22)		# num_bits_left=r26 pData=r22
.Llo2784:
	rlwinm		r27,r26,29,19,31		# num_bytes=r27 num_bits_left=r26
.Llo2782:
	mr		r27,r27		# num_bytes=r27 num_bytes=r27
#             num_bits_left = (uint8) (pData->size % 8U);
	.d2line		11724
	rlwinm		r26,r26,0,29,31		# num_bits_left=r26 num_bits_left=r26
	mr		r26,r26		# num_bits_left=r26 num_bits_left=r26
# 
#             if (0 != num_bytes )
	.d2line		11726
	rlwinm		r6,r27,0,16,31		# num_bytes=r6 num_bytes=r27
	se_cmpi		r6,0		# num_bytes=r6
	bc		1,2,.L2385	# eq
#             {
#                WriteSignalToBuf_uint8N(&Dcm_LCfg.p_response_buffer[0], 
	.d2line		11728
.Llo2795:
	lwz		r4,8(r1)
.Llo2796:
	rlwinm		r0,r25,0,16,31		# pData=r0 DataIndex=r25
	se_add		r4,r0		# pData=r0
	lis		r3,(Dcm_LCfg+20)@ha		# i=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# i=r3 i=r3
	lhz		r5,0(r22)		# pData=r22
	mr		r6,r27		# num_bytes=r6 num_bytes=r27
	bl		WriteSignalToBuf_uint8N
.L2385:
#                                        &resBuffer[DataIndex],
#                                        pData->data_Pos, 
#                                        num_bytes);
#             }
#             else
#             {
#                /* Do nothing */
#             }
# 
#             if (0 != num_bits_left)
	.d2line		11738
	rlwinm		r6,r26,0,24,31		# num_bytes=r6 num_bits_left=r26
	se_cmpi		r6,0		# num_bytes=r6
	bc		1,2,.L2387	# eq
#             {
#                /* Store the last bits.*/
#                WriteSignalToBuf_08(Dcm_LCfg.p_response_buffer[num_bytes], 
	.d2line		11741
	lis		r3,(Dcm_LCfg+20)@ha		# i=r3
	lwz		r3,(Dcm_LCfg+20)@l(r3)		# i=r3 i=r3
	rlwinm		r6,r27,0,16,31		# num_bytes=r6 num_bytes=r27
	lbzx		r3,r3,r6		# i=r3 i=r3
	lwz		r4,8(r1)
	rlwinm		r0,r25,0,16,31		# pData=r0 DataIndex=r25
	se_add		r4,r0		# pData=r0
	lhz		r5,0(r22)		# pData=r22
	se_slwi		r27,3		# num_bytes=r27 num_bytes=r27
	se_add		r5,r27		# num_bytes=r27
	mr		r6,r26		# num_bits_left=r6 num_bits_left=r26
	bl		WriteSignalToBuf_08
.L2387:
#                                    &resBuffer[DataIndex],
#                                    pData->data_Pos + (num_bytes * 8U), 
#                                    num_bits_left);
#             }
#             else
#             {
#                /* All data be saved. Do nothing.*/
#             }
#          }
	.d2line		11750
	diab.addi		r0,r28,1		# pData=r0 i=r28
	se_addi		r28,1		# i=r28 i=r28
	b		.L2381
.L2383:
# 
#          if (E_OK == stdReturnVal)
	.d2line		11752
.Llo2783:
	rlwinm		r24,r24,0,24,31		# stdReturnVal=r24 stdReturnVal=r24
	se_cmpi		r24,0		# stdReturnVal=r24
	bc		0,2,.L2388	# ne
#          {
#              if (SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER == sid)
	.d2line		11754
.Llo2779:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	cmpi		0,0,r31,44		# sid=r31
	bc		0,2,.L2389	# ne
#              {
#                /*
#                 * If only one portion of data is needed, more copy actions needed.
#                 */
#                 Dcm_Memcpy(&dddidResBuffer[0], &resBuffer[position], (Dcm_MsgLenType)sizeOfMemory);
	.d2line		11759
.Llo2740:
	lwz		r4,8(r1)
.Llo2746:
	rlwinm		r30,r30,0,24,31		# position=r30 position=r30
	se_add		r4,r30		# position=r30
	lwz		r3,12(r1)		# i=r3
	rlwinm		r5,r29,0,24,31		# sizeOfMemory=r29
	bl		Dcm_Memcpy
.L2389:
#              }
#              ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		11761
	diab.li		r3,0		# ErrorCode=r3
.Llo2807:
	b		.L2365
.L2388:
#          }
#          else if (SID_REQ_CURRENT_POWERTRAIN_DIAG_DATA == sid )
	.d2line		11763
.Llo2741:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	se_cmpi		r31,1		# sid=r31
#          {
#             ErrorCode = DCM_E_GENERALREJECT;
	.d2line		11765
	diab.li		r3,16		# i=r3
.Llo2780:
	isel		r3,r3,r21,2		# ErrorCode=r3 i=r3 ErrorCode=r21
.L2391:
#          }
#          else
#          {
#             ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		11769
.Llo2742:
	diab.li		r0,34		# pPid=r0
.Llo2797:
	isel		r3,r3,r0,2		# ErrorCode=r3 ErrorCode=r3 pPid=r0
	b		.L2365
.L2374:
#          }
#       }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#       else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#       {
#          /*
#           * It will continue to read data later.
#           */
#          ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#       }
# #endif
#       else
#       {
#          /*
#           * Dcm_DsdRequestResponseBuffer returned one of:
#           *  DCM_INT_E_RESPONSE_FULL
#           *  DCM_INT_E_RESPONSE_TOO_LONG
#           *  E_NOT_OK
#           *
#           * DCM_INT_E_RESPONSE_FULL shall never happen since PIDs always have a fixed length.
#           * Therefore will the requested size in the beginning never be exceeded.
#           *
#           * Abort, as neither of these make sense to retrieve the data.
#           */
#          if (SID_REQ_CURRENT_POWERTRAIN_DIAG_DATA == sid )
	.d2line		11794
.Llo2743:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
.Llo2798:
	se_cmpi		r31,1		# sid=r31
#          {
#             ErrorCode = DCM_E_GENERALREJECT;
	.d2line		11796
	diab.li		r3,16		# i=r3
.Llo2781:
	isel		r3,r3,r21,2		# ErrorCode=r3 i=r3 ErrorCode=r21
.L2394:
#          }
#          else
#          {
#             ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		11800
.Llo2744:
	diab.li		r0,49		# pPid=r0
.Llo2799:
	isel		r3,r3,r0,2		# ErrorCode=r3 ErrorCode=r3 pPid=r0
.L2365:
#          }
#       }
#    } /* end else */
# 
#    return ErrorCode;
	.d2line		11805
.Llo2747:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		11806
	.d2epilogue_begin
.Llo2808:
	lmw		r21,20(r1)		# offset r1+20  0x14
	.d2_cfa_restore_list	2,10
	lwz		r0,68(r1)		# pPid=r0
	mtspr		lr,r0		# pPid=lr
	diab.addi		r1,r1,64		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo2748:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4968:
	.type		ReadCommonPid,@function
	.size		ReadCommonPid,.-ReadCommonPid
# Number of nodes = 421

# Allocations for ReadCommonPid
#	?a4		sid
#	?a5		obdId
#	not allocated	pStatus
#	?a6		position
#	?a7		sizeOfMemory
#	?a8		$$122
#	?a9		$$121
#	?a10		i
#	?a11		num_bytes
#	?a12		num_bits_left
#	?a13		DataIndex
#	?a14		stdReturnVal
#	?a15		pPid
#	?a16		pData
#	SP,8		resBuffer
#	SP,12		dddidResBuffer
#	?a17		ErrorCode
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadCommonOBDInfoTypeIdentifier(CONST(uint8, AUTOMATIC) sid,
	.align		1
	.section	.text_vle
        .d2line         11907,53
#$$ld
.L4998:

#$$bf	ReadCommonOBDInfoTypeIdentifier,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
ReadCommonOBDInfoTypeIdentifier:
.Llo2809:
	stwu		r1,-48(r1)		
	.d2_cfa_def_cfa_offset	48
	mfspr		r0,lr
	stmw		r24,16(r1)		# offset r1+16  0x10
	.d2_cfa_offset_list	24,31,1,1
	stw		r0,52(r1)
	.d2_cfa_offset    108,-1
	mr		r31,r3		# sid=r31 sid=r3
	mr		r30,r4		# obdId=r30 obdId=r4
	mr		r29,r5		# pStatus=r29 pStatus=r5
	mr		r28,r6		# position=r28 position=r6
	mr		r27,r7		# sizeOfMemory=r27 sizeOfMemory=r7
	.d2prologue_end
#                                                                                      CONST(uint8, AUTOMATIC) obdId,
#                                                                                      CONSTP2VAR(ReadDataByIdentifierStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus,
#                                                                                      CONST(uint8, AUTOMATIC) position,
#                                                                                      CONST(uint8, AUTOMATIC) sizeOfMemory)
# {
#    uint8                         i;
#    Std_ReturnType                stdReturnVal = E_OK;
	.d2line		11914
	diab.li		r26,0		# stdReturnVal=r26
#    P2CONST(Dcm_Cfg_VehicleInfoType, AUTOMATIC, DCM_APPL_DATA)  pVehInfo = NULL_PTR;
# 
#    Dcm_MsgLenType totalAnswerSize;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  resBuffer;
#    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA)  dddidResBuffer;
# 
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    if (FALSE == IsIdentifierSupported(Dcm_pPbCfg->p_vehicle_info_type_support, obdId))
	.d2line		11923
.Llo2855:
	lis		r3,Dcm_pPbCfg@ha
.Llo2810:
	lwz		r3,Dcm_pPbCfg@l(r3)
	lwz		r3,36(r3)
	mr		r4,r30		# obdId=r4 obdId=r30
.Llo2821:
	bl		IsIdentifierSupported
	e_andi.		r3,r3,255
	bc		0,2,.L2442	# ne
#    {
#       /*
#        * According to ISO 15031-5:2006(E) Table 7 - Proper response from server/ECU for ISO 15765-4 protocol,
#        * "the ECU shall not respond if Service 0x09 unsupported INFOTYPE is requested".
#        * The NRC will be send according to ISO 15031-5:2006(E), Chapter 5.3.4, Table 12.
#        */
#       ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11930
.Llo2822:
	diab.li		r31,160		# ErrorCode=r31
.Llo2826:
	b		.L2443
.L2442:
#    }
#    else
#    {
#       /*
#        * Find the pointer to the requested ID
#        */
#       for (i = 0; (i < Dcm_LCfg.num_vehicle_info) && (NULL_PTR == pVehInfo); i++)
	.d2line		11937
.Llo2811:
	diab.li		r4,0		# i=r4
.L2444:
.Llo2831:
	rlwinm		r0,r4,0,24,31		# i=r4
	lis		r3,(Dcm_LCfg+112)@ha
	lbz		r3,(Dcm_LCfg+112)@l(r3)
	se_cmp		r0,r3
	bc		0,0,.L2446	# ge
	se_cmpi		r26,0		# pVehInfo=r26
	bc		0,2,.L2446	# ne
#       {
#          if (Dcm_LCfg.p_vehicle_info[i].identifier == obdId)
	.d2line		11939
	lis		r3,(Dcm_LCfg+116)@ha
	lwz		r3,(Dcm_LCfg+116)@l(r3)
	rlwinm		r0,r4,3,21,28		# i=r4
	lbzx		r3,r3,r0
	rlwinm		r0,r30,0,24,31		# obdId=r30
	se_cmp		r3,r0
	bc		0,2,.L2447	# ne
#          {
#             pVehInfo = &(Dcm_LCfg.p_vehicle_info)[i];
	.d2line		11941
	lis		r3,(Dcm_LCfg+116)@ha
	lwz		r26,(Dcm_LCfg+116)@l(r3)		# pVehInfo=r26
	rlwinm		r0,r4,3,21,28		# i=r4
	se_add		r0,r26		# pVehInfo=r26
	mr		r26,r0		# pVehInfo=r26 pVehInfo=r0
.L2447:
#          }
#       }
	.d2line		11943
	diab.addi		r0,r4,1		# i=r4
	se_addi		r4,1		# i=r4 i=r4
	b		.L2444
.L2446:
# 
#       if (NULL_PTR == pVehInfo)
	.d2line		11945
	se_cmpi		r26,0		# pVehInfo=r26
	bc		0,2,.L2448	# ne
#       {
#          /*
#           * According to ISO 15031-5:2006(E) Table 7 - Proper response from server/ECU for ISO 15765-4 protocol,
#           * "the ECU shall not respond if Service 0x09 unsupported INFOTYPE is requested".
#           * The NRC will be send according to ISO 15031-5:2006(E), Chapter 5.3.4, Table 12.
#           *
#           * The code never end up here if correctly used with the SCG since catched
#           * with IsIdentifierSupported. INFOTYPEs not part of the LCfg shall not be possible
#           * to enable using calibration. But to be on safe side, this check is present.
#           */
#          ErrorCode = DCM_INT_NRC_ID_NOT_SUPPORTED;
	.d2line		11956
.Llo2812:
	diab.li		r31,160		# ErrorCode=r31
.Llo2859:
	b		.L2443
.L2448:
#       }
#       else
#       {
#          /*
#           * Fetch the data. Any error will be handled below.
#           * Start to store the requested info type.
#           */
#          if (SID_REQ_VEHICLE_INFORMATION == sid)
	.d2line		11964
.Llo2813:
	rlwinm		r3,r31,0,24,31		# sid=r31
	se_cmpi		r3,9
	bc		0,2,.L2450	# ne
#          {
#             /*
#              * OBD service 0x09 is the caller.
#              */
#             totalAnswerSize = (Dcm_MsgLenType)pVehInfo->size + 1U;
	.d2line		11969
	lbz		r24,1(r26)		# totalAnswerSize=r24 pVehInfo=r26
.Llo2856:
	se_addi		r24,1		# totalAnswerSize=r24 totalAnswerSize=r24
	mr		r24,r24		# totalAnswerSize=r24 totalAnswerSize=r24
#             stdReturnVal =  Dcm_DsdRequestResponseBuffer(totalAnswerSize, &resBuffer);
	.d2line		11970
	rlwinm		r3,r24,0,16,31		# totalAnswerSize=r24
	diab.addi		r4,r1,8		# i=r4
	bl		Dcm_DsdRequestResponseBuffer
.Llo2836:
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L2451
.L2450:
#          }
#          else if (SID_READ_DATA_BY_IDENTIFIER == sid)
	.d2line		11972
.Llo2837:
	rlwinm		r3,r31,0,24,31		# sid=r31
	cmpi		0,0,r3,34
	bc		0,2,.L2452	# ne
#          {
#             /*
#              * UDS service 0x22 requests the vechInfo.
#              * According to ISO 14229 Table C.1, OBDInfoTypeDataIdentifier has two bytes
#              * identifier. Even though identifier need 2 bytes long, the NofDataItems (1 byte)
#              * which will be updated by application is ignored later, so only 1 byte needs to be added.
#              */
#             totalAnswerSize = (Dcm_MsgLenType)pVehInfo->size + 1U;
	.d2line		11980
	lbz		r24,1(r26)		# totalAnswerSize=r24 pVehInfo=r26
.Llo2857:
	se_addi		r24,1		# totalAnswerSize=r24 totalAnswerSize=r24
	mr		r24,r24		# totalAnswerSize=r24 totalAnswerSize=r24
#             stdReturnVal =  Dcm_DsdRequestResponseBuffer(totalAnswerSize, &resBuffer);
	.d2line		11981
	rlwinm		r3,r24,0,16,31		# totalAnswerSize=r24
	diab.addi		r4,r1,8		# i=r4
	bl		Dcm_DsdRequestResponseBuffer
.Llo2838:
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
	b		.L2451
.L2452:
#          }
#          else
#          {
#             /*
#              * UDS service 0x2C is the caller.
#              * No identifier
#              */
#             totalAnswerSize = sizeOfMemory;
	.d2line		11989
.Llo2839:
	rlwinm		r24,r27,0,24,31		# totalAnswerSize=r24 sizeOfMemory=r27
.Llo2858:
	mr		r24,r24		# totalAnswerSize=r24 totalAnswerSize=r24
#             stdReturnVal =  Dcm_DsdRequestResponseBuffer(totalAnswerSize, &dddidResBuffer);
	.d2line		11990
	rlwinm		r3,r24,0,16,31		# totalAnswerSize=r24
	diab.addi		r4,r1,12		# i=r4
	bl		Dcm_DsdRequestResponseBuffer
.Llo2840:
	mr		r0,r3		# stdReturnVal=r0 stdReturnVal=r3
#             resBuffer = Dcm_LCfg.p_dddid_sourceBuffer;
	.d2line		11991
	lis		r3,(Dcm_LCfg+28)@ha
.Llo2841:
	lwz		r3,(Dcm_LCfg+28)@l(r3)
.Llo2842:
	stw		r3,8(r1)
.L2451:
#          }
# 
#          if (E_OK == stdReturnVal)
	.d2line		11994
	rlwinm		r0,r0,0,24,31		# stdReturnVal=r0 stdReturnVal=r0
	se_cmpi		r0,0		# stdReturnVal=r0
	bc		0,2,.L2454	# ne
#          {
#             if (SID_REQ_VEHICLE_INFORMATION == sid)
	.d2line		11996
.Llo2843:
	rlwinm		r3,r31,0,24,31		# sid=r31
	se_cmpi		r3,9
	bc		0,2,.L2455	# ne
#             {
#                /*
#                 * OBD service 0x09 is the caller.
#                 */
#                resBuffer[0] = obdId;
	.d2line		12001
	lwz		r3,8(r1)
	stb		r30,0(r3)		# obdId=r30
#                stdReturnVal = pVehInfo->GetInfotypeValueDataFunc(pStatus->read_did_info.current_opstatus, &resBuffer[1]);
	.d2line		12002
	lwz		r0,4(r26)		# stdReturnVal=r0 pVehInfo=r26
	mtspr		ctr,r0		# stdReturnVal=ctr
	lbz		r3,22(r29)		# pStatus=r29
	lwz		r4,8(r1)		# i=r4
.Llo2832:
	se_addi		r4,1		# i=r4 i=r4
.Llo2833:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2823:
	mr		r4,r3		# stdReturnVal=r4 stdReturnVal=r3
	b		.L2456
.L2455:
#             }
#             else if (SID_READ_DATA_BY_IDENTIFIER == sid)
	.d2line		12004
.Llo2824:
	rlwinm		r3,r31,0,24,31		# sid=r31
	cmpi		0,0,r3,34
	bc		0,2,.L2457	# ne
#             {
#                /*
#                 * UDS service 0x22 requests the vechInfo.
#                 */
#                stdReturnVal = pVehInfo->GetInfotypeValueDataFunc(pStatus->read_did_info.current_opstatus, &resBuffer[1]);
	.d2line		12009
	lwz		r0,4(r26)		# stdReturnVal=r0 pVehInfo=r26
	mtspr		ctr,r0		# stdReturnVal=ctr
	lbz		r3,22(r29)		# pStatus=r29
	lwz		r4,8(r1)		# i=r4
.Llo2834:
	se_addi		r4,1		# i=r4 i=r4
.Llo2835:
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2844:
	mr		r4,r3		# stdReturnVal=r4 stdReturnVal=r3
#                /*
#                 * According to ISO 14229 Table C.1, OBDInfoTypeDataIdentifier has two bytes
#                 * identifier.
#                 * NofDataItems which is updated by application in 'resBuffer[1]' will be
#                 * ignored (by over writing the two byte identifier from resBuffer[0] location)
#                 * while sending response.
#                 */
#                SET_2BYTE_ID(&resBuffer[0], GET_VEHINFO_DID(obdId));
	.d2line		12017
	rlwinm		r0,r30,0,24,31		# stdReturnVal=r0 obdId=r30
	e_ori		r0,r0,63488		# stdReturnVal=r0 stdReturnVal=r0
	rlwinm		r0,r0,24,24,31		# stdReturnVal=r0 stdReturnVal=r0
	lwz		r3,8(r1)
.Llo2845:
	stb		r0,0(r3)		# stdReturnVal=r0
.Llo2846:
	lwz		r3,8(r1)
	stb		r30,1(r3)		# obdId=r30
	b		.L2456
.L2457:
#             }
#             else
#             {
#                /* 0x2C dynamically Defined Data Identifier, No source Id shall be copied. */
#                stdReturnVal = pVehInfo->GetInfotypeValueDataFunc(pStatus->read_did_info.current_opstatus, &resBuffer[0]);
	.d2line		12022
.Llo2847:
	lwz		r0,4(r26)		# stdReturnVal=r0 pVehInfo=r26
	mtspr		ctr,r0		# stdReturnVal=ctr
	lbz		r3,22(r29)		# pStatus=r29
	lwz		r4,8(r1)		# i=r4
#$$fn 0x1ff9 0x0 0x0 0x1
#$$tl 0x18 0x0 0x0 0x1
#$$rs 1 u
	bcctrl		20,0
.Llo2825:
	mr		r4,r3		# stdReturnVal=r4 stdReturnVal=r3
.L2456:
#             }
# 
#             if (DCM_E_PENDING == stdReturnVal)
	.d2line		12025
.Llo2848:
	rlwinm		r3,r4,0,24,31		# stdReturnVal=r4
.Llo2849:
	se_cmpi		r3,10
	bc		0,2,.L2460	# ne
#             {
#                /*
#                 * The function call returned pending.
#                 * Do not finalize the session and wait for new scheduled call.
#                 */
#                ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
	.d2line		12031
.Llo2814:
	diab.li		r31,162		# ErrorCode=r31
#                pStatus->read_did_info.current_opstatus = DCM_PENDING;
	.d2line		12032
.Llo2860:
	diab.li		r0,1		# stdReturnVal=r0
.Llo2850:
	stb		r0,22(r29)		# pStatus=r29 stdReturnVal=r0
#                Dcm_DsdReleaseResponseBuffer(totalAnswerSize);
	.d2line		12033
	rlwinm		r3,r24,0,16,31		# totalAnswerSize=r24
	bl		Dcm_DsdReleaseResponseBuffer
.Llo2851:
	b		.L2443
.L2460:
#             }
#             else if (E_OK == stdReturnVal)
	.d2line		12035
.Llo2815:
	rlwinm		r4,r4,0,24,31		# stdReturnVal=r4 stdReturnVal=r4
	se_cmpi		r4,0		# stdReturnVal=r4
	bc		0,2,.L2462	# ne
#             {
#                if (SID_DYNAMICALLY_DEFINE_DATA_IDENTIFIER == sid)
	.d2line		12037
.Llo2827:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	cmpi		0,0,r31,44		# sid=r31
	bc		0,2,.L2463	# ne
#                {
#                   /*
#                    * If only one portion of data is needed, more copy actions needed.
#                    */
#                   Dcm_Memcpy(&dddidResBuffer[0], &resBuffer[position], (Dcm_MsgLenType)sizeOfMemory);
	.d2line		12042
.Llo2816:
	lwz		r4,8(r1)		# stdReturnVal=r4
.Llo2830:
	rlwinm		r28,r28,0,24,31		# position=r28 position=r28
	se_add		r4,r28		# stdReturnVal=r4 stdReturnVal=r4 position=r28
.Llo2852:
	lwz		r3,12(r1)
	rlwinm		r5,r27,0,24,31		# sizeOfMemory=r27
	bl		Dcm_Memcpy
.L2463:
#                }
#                ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12044
	diab.li		r31,0		# ErrorCode=r31
.Llo2861:
	b		.L2443
.L2462:
#             }
#             else if (SID_REQ_VEHICLE_INFORMATION == sid )
	.d2line		12046
.Llo2817:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	se_cmpi		r31,9		# sid=r31
#             {
#                ErrorCode = DCM_E_GENERALREJECT;
	.d2line		12048
	diab.li		r3,16		# ErrorCode=r3
.Llo2862:
	isel		r3,r3,r25,2		# ErrorCode=r3 ErrorCode=r3 ErrorCode=r25
.L2465:
#             }
#             else
#             {
#                ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
	.d2line		12052
.Llo2818:
	diab.li		r0,34		# stdReturnVal=r0
.Llo2853:
	isel		r31,r3,r0,2		# ErrorCode=r31 ErrorCode=r3 stdReturnVal=r0
	b		.L2443
.L2454:
#             }
#          }
# #if (DCM_PAGEDBUFFER_ENABLED == STD_ON)
#          else if (DCM_INT_E_RESPONSE_PENDING == stdReturnVal)
#          {
#             /*
#              * It will continue to read data later.
#              */
#             ErrorCode = DCM_INT_NRC_API_RETURNED_PENDING;
#          }
# #endif
#          else
#          {
#             /*
#              * Dcm_DsdRequestResponseBuffer returned one of:
#              *  DCM_INT_E_RESPONSE_FULL
#              *  DCM_INT_E_RESPONSE_TOO_LONG
#              *  E_NOT_OK
#              *
#              * DCM_INT_E_RESPONSE_FULL shall never happen since InfoTypes always have a fixed length.
#              * Therefore will the requested size in the beginning never be exceeded.
#              */
#             if (SID_REQ_VEHICLE_INFORMATION == sid )
	.d2line		12075
.Llo2819:
	rlwinm		r31,r31,0,24,31		# sid=r31 sid=r31
	se_cmpi		r31,9		# sid=r31
#             {
#                ErrorCode = DCM_E_GENERALREJECT;
	.d2line		12077
	diab.li		r3,16		# ErrorCode=r3
.Llo2863:
	isel		r3,r3,r25,2		# ErrorCode=r3 ErrorCode=r3 ErrorCode=r25
.L2468:
#             }
#             else
#             {
#                ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12081
.Llo2820:
	diab.li		r0,49		# stdReturnVal=r0
.Llo2854:
	isel		r31,r3,r0,2		# ErrorCode=r31 ErrorCode=r3 stdReturnVal=r0
.L2443:
#             }
#          }
#       }
#    }
# 
#    return ErrorCode;
	.d2line		12087
.Llo2828:
	rlwinm		r3,r31,0,24,31		# ErrorCode=r3 ErrorCode=r31
# }
	.d2line		12088
	.d2epilogue_begin
.Llo2864:
	lmw		r24,16(r1)		# offset r1+16  0x10
	.d2_cfa_restore_list	2,10
.Llo2865:
	lwz		r0,52(r1)		# stdReturnVal=r0
	mtspr		lr,r0		# stdReturnVal=lr
	diab.addi		r1,r1,48		
	.d2_cfa_def_cfa_offset	0
	blr
.Llo2829:
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L4999:
	.type		ReadCommonOBDInfoTypeIdentifier,@function
	.size		ReadCommonOBDInfoTypeIdentifier,.-ReadCommonOBDInfoTypeIdentifier
# Number of nodes = 303

# Allocations for ReadCommonOBDInfoTypeIdentifier
#	?a4		sid
#	?a5		obdId
#	?a6		pStatus
#	?a7		position
#	?a8		sizeOfMemory
#	?a9		i
#	?a10		stdReturnVal
#	?a11		pVehInfo
#	?a12		totalAnswerSize
#	SP,8		resBuffer
#	SP,12		dddidResBuffer
#	?a13		ErrorCode
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) ReadMemoryInitialisation(CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         12710,53
#$$ld
.L5020:

#$$bf	ReadMemoryInitialisation,interprocedural,nostackparams

# Regs written: r0,r1,r3,r4,r5,r6,cr0,lr
	.d2_cfa_start __cie
ReadMemoryInitialisation:
.Llo2866:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r3,r3		# pMsgContext=r3 pMsgContext=r3
	mr		r4,r4		# dataStructure=r4 dataStructure=r4
	mr		r5,r5		# pStatus=r5 pStatus=r5
	.d2prologue_end
#                                                                              MemoryDataStructureType dataStructure,
#                                                                              CONSTP2VAR(MemoryAddressOperationStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    /*
#     * Memory sizes of zero bytes is not allowed
#     */
#    if (0 == dataStructure.memory_size)
	.d2line		12719
	lwz		r0,12(r4)		# dataStructure=r4
	se_cmpi		r0,0
	bc		0,2,.L2592	# ne
#    {
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12721
.Llo2867:
	diab.li		r3,49		# ErrorCode=r3
.Llo2872:
	b		.L2593
.L2592:
#    }
#    /*
#     * Check that requested number of bytes to be read fits in the response buffer
#     */
#    else if (pMsgContext->resMaxDataLen < dataStructure.memory_size)
	.d2line		12726
.Llo2868:
	lhz		r6,20(r3)		# pMsgContext=r3
	lwz		r0,12(r4)		# dataStructure=r4
	se_cmpl		r6,r0
	bc		0,0,.L2594	# ge
#    {
#       ErrorCode = DCM_E_RESPONSETOOLONG; /* [SWS_Dcm_01059] */
	.d2line		12728
.Llo2869:
	diab.li		r3,20		# ErrorCode=r3
.Llo2873:
	b		.L2593
.L2594:
#    }
#    else
#    {
#       /*
#        * Operation can continue, no errors
#        */
#       pStatus->buffer            = &pMsgContext->resData[0];
	.d2line		12735
.Llo2870:
	lwz		r0,8(r3)		# pMsgContext=r3
	stw		r0,0(r5)		# pStatus=r5
#       pStatus->pendingBuffer     = &pMsgContext->resData[0]; /* The data buffer is an out-parameter in case of read and shall always be valid */
	.d2line		12736
	lwz		r0,8(r3)		# pMsgContext=r3
	stw		r0,4(r5)		# pStatus=r5
# 
#       /* Type-cast to smaller type ok since a response length > pMsgContext->resMaxDataLen is checked in next if-statement */
#       pMsgContext->resDataLen  = (Dcm_MsgLenType)dataStructure.memory_size;
	.d2line		12739
	lwz		r0,12(r4)		# dataStructure=r4
	sth		r0,12(r3)		# pMsgContext=r3
# 
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12741
	diab.li		r3,0		# ErrorCode=r3
.L2593:
#    }
# 
#    return ErrorCode;
	.d2line		12744
.Llo2871:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		12745
	.d2epilogue_begin
.Llo2874:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L5021:
	.type		ReadMemoryInitialisation,@function
	.size		ReadMemoryInitialisation,.-ReadMemoryInitialisation
# Number of nodes = 58

# Allocations for ReadMemoryInitialisation
#	?a4		pMsgContext
#	?a5		dataStructure
#	?a6		pStatus
#	?a7		ErrorCode
# static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) WriteMemoryInitialisation(CONSTP2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext,
	.align		1
	.section	.text_vle
        .d2line         12750,53
#$$ld
.L5030:

#$$bf	WriteMemoryInitialisation,interprocedural,rasave,nostackparams
	.d2_cfa_start __cie
WriteMemoryInitialisation:
.Llo2875:
	stwu		r1,-16(r1)		
	.d2_cfa_def_cfa_offset	16
	mfspr		r0,lr
	stw		r0,20(r1)
	.d2_cfa_offset    108,-1
	mr		r6,r3		# pMsgContext=r6 pMsgContext=r3
	mr		r4,r4		# dataStructure=r4 dataStructure=r4
	mr		r5,r5		# pStatus=r5 pStatus=r5
	.d2prologue_end
#                                                                               MemoryDataStructureType dataStructure,
#                                                                               CONSTP2VAR(MemoryAddressOperationStatusType, AUTOMATIC, DCM_APPL_DATA) pStatus)
# {
#    Dcm_NegativeResponseCodeType ErrorCode;
# 
#    /*
#     * Memory sizes of zero bytes is not allowed
#     */
#    if (0 == dataStructure.memory_size)
	.d2line		12759
	lwz		r0,12(r4)		# dataStructure=r4
	se_cmpi		r0,0
	bc		0,2,.L2600	# ne
#    {
#       ErrorCode = DCM_E_REQUESTOUTOFRANGE;
	.d2line		12761
.Llo2876:
	diab.li		r3,49		# ErrorCode=r3
.Llo2877:
	b		.L2601
.L2600:
#    }
#    /*
#     * Check if the request is complete including data to be written
#     * Add 1 for the ALFID
#     */
#    else if (pMsgContext->reqDataLen != (1 + dataStructure.include_memory_id_byte + dataStructure.memory_address_length + dataStructure.memory_size_length + dataStructure.memory_size))
	.d2line		12767
.Llo2881:
	lhz		r0,4(r6)		# pMsgContext=r6
	lbz		r3,0(r4)		# dataStructure=r4
	lbz		r7,2(r4)		# dataStructure=r4
	se_add		r3,r7
	lbz		r7,3(r4)		# dataStructure=r4
	se_add		r7,r3
	lwz		r3,12(r4)		# dataStructure=r4
	se_add		r7,r3
	diab.addi		r3,r7,1
	se_cmpl		r0,r3
	bc		1,2,.L2602	# eq
#    {
#       ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
	.d2line		12769
	diab.li		r3,19		# ErrorCode=r3
.Llo2882:
	b		.L2601
.L2602:
#    }
#    else
#    {
#       /*
#        * Operation can continue, no errors
#        */
#       pStatus->buffer            = &pMsgContext->reqData[dataStructure.data_record_offset];
	.d2line		12776
.Llo2883:
	lwz		r0,0(r6)		# pMsgContext=r6
	lbz		r3,6(r4)		# ErrorCode=r3 dataStructure=r4
.Llo2884:
	se_add		r0,r3		# ErrorCode=r3
	stw		r0,0(r5)		# pStatus=r5
#       pStatus->pendingBuffer     = NULL_PTR; /* The data buffer is an in-parameter in case of write */
	.d2line		12777
	diab.li		r0,0
	stw		r0,4(r5)		# pStatus=r5
#       pMsgContext->resDataLen  = 1 + dataStructure.include_memory_id_byte + dataStructure.memory_address_length + dataStructure.memory_size_length; /* Add 1 for the ALFID */
	.d2line		12778
	lbz		r3,0(r4)		# ErrorCode=r3 dataStructure=r4
	lbz		r0,2(r4)		# dataStructure=r4
	se_add		r0,r3		# ErrorCode=r3
	lbz		r3,3(r4)		# ErrorCode=r3 dataStructure=r4
	se_add		r3,r0		# ErrorCode=r3 ErrorCode=r3
	se_addi		r3,1		# ErrorCode=r3 ErrorCode=r3
	sth		r3,12(r6)		# pMsgContext=r6 ErrorCode=r3
# 
#       /*
#        * Copy the request to the response buffer except for the data
#        */
#       Dcm_Memcpy(&pMsgContext->resData[0], &pMsgContext->reqData[0], pMsgContext->resDataLen);
	.d2line		12783
	rlwinm		r5,r3,0,16,31		# pStatus=r5 ErrorCode=r3
.Llo2880:
	lwz		r3,8(r6)		# ErrorCode=r3 pMsgContext=r6
.Llo2885:
	lwz		r4,0(r6)		# dataStructure=r4 pMsgContext=r6
.Llo2879:
	bl		Dcm_Memcpy
# 
#       ErrorCode = DCM_INT_NRC_POSITIVERESPONSE;
	.d2line		12785
.Llo2878:
	diab.li		r3,0		# ErrorCode=r3
.L2601:
#    }
# 
#    return ErrorCode;
	.d2line		12788
.Llo2886:
	rlwinm		r3,r3,0,24,31		# ErrorCode=r3 ErrorCode=r3
# }
	.d2line		12789
	.d2epilogue_begin
.Llo2887:
	lwz		r0,20(r1)
	mtspr		lr,r0
	se_addi		r1,16		
	.d2_cfa_def_cfa_offset	0
	blr
#$$ef
	.d2_cfa_end 2
	.section	.text_vle
#$$ld
.L5031:
	.type		WriteMemoryInitialisation,@function
	.size		WriteMemoryInitialisation,.-WriteMemoryInitialisation
# Number of nodes = 111

# Allocations for WriteMemoryInitialisation
#	?a4		pMsgContext
#	?a5		dataStructure
#	?a6		pStatus
#	?a7		ErrorCode

# Allocations for module
	.section	.text_vle
	.0byte		.L5038
	.section	.text_vle
	.type		masks08,@object
	.size		masks08,9
	.align		2
masks08:
	.byte		0
	.byte		1
	.byte		3
	.byte		7
	.byte		15
	.byte		31
	.byte		63
	.byte		127
	.byte		255
	.section	.text_vle
	.type		readDtcReqLengths,@object
	.size		readDtcReqLengths,52
	.align		1
readDtcReqLengths:
	.short		0
	.short		2
	.short		2
	.short		1
	.short		5
	.short		2
	.short		5
	.short		3
	.short		3
	.short		4
	.short		1
	.short		1
	.short		1
	.short		1
	.short		1
	.short		2
	.short		5
	.short		2
	.short		2
	.short		2
	.short		1
	.short		1
	.short		0
	.short		3
	.short		6
	.short		6
	.section	.text_vle
	.type		resetToMode,@object
	.size		resetToMode,3
	.align		2
resetToMode:
	.byte		1
	.byte		2
	.byte		3
	.section	.text_vle
	.type		powerShutdownToMode,@object
	.size		powerShutdownToMode,2
	.align		2
powerShutdownToMode:
	.byte		0
	.byte		1
	.section	.text_vle
#$$ld
.L5:
.L5449:	.d2filenum "C:\\WINDRI~1\\COMPIL~1\\DIAB-5~1.4\\include\\diab/lpragma.h"
.L5440:	.d2filenum "..\\..\\BuildSystem\\..\\TTs\\AUTOSAR\\ar422\\ComStack_Types.h"
.L5361:	.d2filenum "d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\inc\\Dcm_PBCfg_Types.h"
.L5341:	.d2filenum "gen\\MPC5746R_ECU\\WindRiver\\Dcm_Lcfg.h"
.L5044:	.d2filenum "d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\inc\\Dcm_Int.h"
.L5039:	.d2filenum "d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\inc\\Dcm_LCfg_Types.h"
.L3101:	.d2filenum "d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\src\\Dcm_Dsp.c"
	.d2_line_end


	.section	.debug_abbrev,,n
.L9:
	.section	.debug_abbrev,,n
	.uleb128	1
	.uleb128	17
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	37
	.uleb128	8
	.uleb128	27
	.uleb128	8
	.uleb128	19
	.uleb128	15
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	16
	.uleb128	6
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	2
	.uleb128	46
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	63
	.uleb128	12
	.uleb128	39
	.uleb128	12
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	3
	.uleb128	46
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	39
	.uleb128	12
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	4
	.uleb128	5
	.byte		0x0
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	2
	.uleb128	6
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	5
	.uleb128	52
	.byte		0x0
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	2
	.uleb128	6
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	6
	.uleb128	46
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	73
	.uleb128	16
	.uleb128	39
	.uleb128	12
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	7
	.uleb128	52
	.byte		0x0
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	2
	.uleb128	9
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	8
	.uleb128	11
	.byte		0x1
	.uleb128	1
	.uleb128	16
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	9
	.uleb128	46
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	73
	.uleb128	16
	.uleb128	63
	.uleb128	12
	.uleb128	39
	.uleb128	12
	.uleb128	17
	.uleb128	1
	.uleb128	18
	.uleb128	1
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	10
	.uleb128	5
	.byte		0x0
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	2
	.uleb128	9
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	11
	.uleb128	52
	.byte		0x0
	.uleb128	63
	.uleb128	12
	.uleb128	60
	.uleb128	12
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	12
	.uleb128	19
	.byte		0x1
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	11
	.uleb128	15
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	13
	.uleb128	13
	.byte		0x0
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	56
	.uleb128	9
	.uleb128	50
	.uleb128	11
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	14
	.uleb128	13
	.byte		0x0
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	11
	.uleb128	15
	.uleb128	13
	.uleb128	11
	.uleb128	12
	.uleb128	11
	.uleb128	56
	.uleb128	9
	.uleb128	50
	.uleb128	11
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	15
	.uleb128	4
	.byte		0x1
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	1
	.uleb128	19
	.uleb128	3
	.uleb128	8
	.uleb128	11
	.uleb128	15
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	16
	.uleb128	40
	.byte		0x0
	.uleb128	3
	.uleb128	8
	.uleb128	28
	.uleb128	13
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	17
	.uleb128	4
	.byte		0x1
	.uleb128	58
	.uleb128	6
	.uleb128	59
	.uleb128	15
	.uleb128	57
	.uleb128	15
	.uleb128	1
	.uleb128	19
	.uleb128	11
	.uleb128	15
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	18
	.uleb128	22
	.byte		0x0
	.uleb128	3
	.uleb128	8
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	19
	.uleb128	36
	.byte		0x0
	.uleb128	3
	.uleb128	8
	.uleb128	62
	.uleb128	11
	.uleb128	11
	.uleb128	11
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	20
	.uleb128	38
	.byte		0x0
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	21
	.uleb128	15
	.byte		0x0
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	22
	.uleb128	21
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	73
	.uleb128	16
	.uleb128	39
	.uleb128	12
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	23
	.uleb128	5
	.byte		0x0
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	24
	.uleb128	1
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	73
	.uleb128	16
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	25
	.uleb128	33
	.byte		0x0
	.uleb128	47
	.uleb128	15
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.uleb128	26
	.uleb128	21
	.byte		0x1
	.uleb128	1
	.uleb128	19
	.uleb128	39
	.uleb128	12
	.uleb128	0
	.uleb128	0
	.section	.debug_abbrev,,n
	.sleb128	0


	.section	.debug_info,,n
.L2:
	.4byte		.L3-.L1
.L1:
	.2byte		0x2
	.4byte		.L9
	.byte		0x4
	.section	.debug_info,,n
	.sleb128	1
	.4byte		.L7-.L2
	.byte		"d:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\BSWs\\DIAG\\Dcm\\ssc\\make\\..\\src\\Dcm_Dsp.c"
	.byte		0
	.byte		"Diab Data, Inc:dcc Rel 5.9.6.4:PPCE200Z4204N3V"
	.byte		0
	.byte		"D:\\VSB_Demo\\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\\VSTAR\\Application\\MetaWares"
	.byte		0
	.uleb128	12
	.4byte		.L4
	.4byte		.L5
	.4byte		.L8
	.section	.debug_info,,n
.L3102:
	.sleb128	2
	.4byte		.L3098-.L2
	.byte		"Dcm_DspStateMachineInit"
	.byte		0
	.4byte		.L3101
	.uleb128	2395
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3099
	.4byte		.L3100
	.section	.debug_info,,n
	.sleb128	0
.L3098:
	.section	.debug_info,,n
.L3107:
	.sleb128	3
	.4byte		.L3104-.L2
	.byte		"ResetPeriodicStatusVariables"
	.byte		0
	.4byte		.L3101
	.uleb128	13136
	.uleb128	29
	.byte		0x1
	.4byte		.L3105
	.4byte		.L3106
	.section	.debug_info,,n
	.sleb128	0
.L3104:
	.section	.debug_info,,n
.L3112:
	.sleb128	2
	.4byte		.L3109-.L2
	.byte		"Dcm_DspResetPeriodicTransmission"
	.byte		0
	.4byte		.L3101
	.uleb128	13114
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3110
	.4byte		.L3111
	.section	.debug_info,,n
	.sleb128	0
.L3109:
	.section	.debug_info,,n
.L3117:
	.sleb128	3
	.4byte		.L3114-.L2
	.byte		"ResetAllDDDiDsAndPeriodicDids"
	.byte		0
	.4byte		.L3101
	.uleb128	14230
	.uleb128	29
	.byte		0x1
	.4byte		.L3115
	.4byte		.L3116
	.section	.debug_info,,n
	.sleb128	4
	.4byte		.L3101
	.uleb128	14230
	.uleb128	29
	.byte		"ddidInitPolicy"
	.byte		0
	.4byte		.L3118
	.4byte		.L3120
	.sleb128	4
	.4byte		.L3101
	.uleb128	14230
	.uleb128	29
	.byte		"ddpridInitPolicy"
	.byte		0
	.4byte		.L3121
	.4byte		.L3123
	.section	.debug_info,,n
.L3124:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14232
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L3127
.L3128:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14233
	.uleb128	12
	.byte		"ddpridClear"
	.byte		0
	.4byte		.L3129
	.4byte		.L3131
	.section	.debug_info,,n
	.sleb128	0
.L3114:
	.section	.debug_info,,n
.L3136:
	.sleb128	2
	.4byte		.L3133-.L2
	.byte		"Dcm_DspInit"
	.byte		0
	.4byte		.L3101
	.uleb128	2354
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3134
	.4byte		.L3135
	.section	.debug_info,,n
	.sleb128	0
.L3133:
	.section	.debug_info,,n
.L3141:
	.sleb128	2
	.4byte		.L3138-.L2
	.byte		"Dcm_DspHandleTimers"
	.byte		0
	.4byte		.L3101
	.uleb128	2377
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3139
	.4byte		.L3140
	.section	.debug_info,,n
	.sleb128	0
.L3138:
	.section	.debug_info,,n
.L3146:
	.sleb128	2
	.4byte		.L3143-.L2
	.byte		"Dcm_DspGetPeriodicDataTrigger"
	.byte		0
	.4byte		.L3101
	.uleb128	13802
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3144
	.4byte		.L3145
	.section	.debug_info,,n
	.sleb128	0
.L3143:
	.section	.debug_info,,n
.L3151:
	.sleb128	2
	.4byte		.L3148-.L2
	.byte		"Dcm_DspStateMachine"
	.byte		0
	.4byte		.L3101
	.uleb128	2403
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3149
	.4byte		.L3150
	.section	.debug_info,,n
	.sleb128	0
.L3148:
	.section	.debug_info,,n
.L3158:
	.sleb128	6
	.4byte		.L3153-.L2
	.byte		"ReadOneDDDidByDid"
	.byte		0
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.4byte		.L3156
	.byte		0x1
	.4byte		.L3154
	.4byte		.L3155
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"pSource"
	.byte		0
	.4byte		.L3159
	.4byte		.L3164
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"sampleBufRemainLen"
	.byte		0
	.4byte		.L3125
	.4byte		.L3165
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L3167
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L3169
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"sourceType"
	.byte		0
	.4byte		.L3170
	.4byte		.L3172
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"pReadDidInfo"
	.byte		0
	.4byte		.L3173
	.4byte		.L3177
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"useSampleBuffer"
	.byte		0
	.4byte		.L3129
	.4byte		.L3178
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"didSize"
	.byte		0
	.4byte		.L3179
	.4byte		.L3181
	.sleb128	4
	.4byte		.L3101
	.uleb128	13153
	.uleb128	39
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3185
.L3186:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13163
	.uleb128	34
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L3187
	.section	.debug_info,,n
.L3188:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13164
	.uleb128	34
	.byte		"conditionCheckReadResponse"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3189:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13165
	.uleb128	28
	.byte		"compositeHeaderSize"
	.byte		0
	.4byte		.L3190
	.4byte		.L3191
.L3192:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13166
	.uleb128	19
	.byte		"totalLength"
	.byte		0
	.4byte		.L3193
	.4byte		.L3194
	.section	.debug_info,,n
	.sleb128	0
.L3153:
	.section	.debug_info,,n
.L3204:
	.sleb128	6
	.4byte		.L3196-.L2
	.byte		"GetMemoryRange"
	.byte		0
	.4byte		.L3101
	.uleb128	12812
	.uleb128	55
	.4byte		.L3199
	.byte		0x1
	.4byte		.L3197
	.4byte		.L3198
	.sleb128	4
	.4byte		.L3101
	.uleb128	12812
	.uleb128	55
	.byte		"memoryId"
	.byte		0
	.4byte		.L3157
	.4byte		.L3205
	.sleb128	4
	.4byte		.L3101
	.uleb128	12812
	.uleb128	55
	.byte		"memoryAddress"
	.byte		0
	.4byte		.L3206
	.4byte		.L3208
	.sleb128	4
	.4byte		.L3101
	.uleb128	12812
	.uleb128	55
	.byte		"memorySize"
	.byte		0
	.4byte		.L3206
	.4byte		.L3209
	.sleb128	4
	.4byte		.L3101
	.uleb128	12812
	.uleb128	55
	.byte		"p_memory"
	.byte		0
	.4byte		.L3210
	.4byte		.L3215
.L3216:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12817
	.uleb128	35
	.byte		"memoryRange"
	.byte		0
	.4byte		.L3199
	.4byte		.L3217
.L3218:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12818
	.uleb128	10
	.byte		"rangeIdx"
	.byte		0
	.4byte		.L3157
	.4byte		.L3219
	.section	.debug_info,,n
	.sleb128	0
.L3196:
	.section	.debug_info,,n
.L3224:
	.sleb128	6
	.4byte		.L3221-.L2
	.byte		"IsMemoryRangeAcessible"
	.byte		0
	.4byte		.L3101
	.uleb128	12840
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L3222
	.4byte		.L3223
	.sleb128	4
	.4byte		.L3101
	.uleb128	12840
	.uleb128	32
	.byte		"p_memoryRange"
	.byte		0
	.4byte		.L3225
	.4byte		.L3226
.L3227:
	.sleb128	7
	.4byte		.L3101
	.uleb128	12842
	.uleb128	21
	.byte		"activeSecLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L3221:
	.section	.debug_info,,n
.L3232:
	.sleb128	6
	.4byte		.L3229-.L2
	.byte		"ReadOneDDDidByMemory"
	.byte		0
	.4byte		.L3101
	.uleb128	13458
	.uleb128	39
	.4byte		.L3156
	.byte		0x1
	.4byte		.L3230
	.4byte		.L3231
	.sleb128	4
	.4byte		.L3101
	.uleb128	13458
	.uleb128	39
	.byte		"pSource"
	.byte		0
	.4byte		.L3159
	.4byte		.L3233
	.sleb128	4
	.4byte		.L3101
	.uleb128	13458
	.uleb128	39
	.byte		"pSampleBuffer"
	.byte		0
	.4byte		.L3234
	.4byte		.L3236
	.sleb128	4
	.4byte		.L3101
	.uleb128	13458
	.uleb128	39
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3237
.L3238:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13466
	.uleb128	53
	.byte		"pSelectedMemoryRange"
	.byte		0
	.4byte		.L3239
	.4byte		.L3240
.L3241:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13467
	.uleb128	34
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L3242
.L3243:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13468
	.uleb128	43
	.byte		"pBuf"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L3229:
	.section	.debug_info,,n
.L3248:
	.sleb128	6
	.4byte		.L3245-.L2
	.byte		"ReadOnePeriodicDid"
	.byte		0
	.4byte		.L3101
	.uleb128	13523
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L3246
	.4byte		.L3247
	.sleb128	4
	.4byte		.L3101
	.uleb128	13523
	.uleb128	32
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L3253
	.sleb128	4
	.4byte		.L3101
	.uleb128	13523
	.uleb128	32
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L3254
	.sleb128	4
	.4byte		.L3101
	.uleb128	13523
	.uleb128	32
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L3255
.L3256:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13527
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L3257
.L3258:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13528
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3259:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13529
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L3260
.L3261:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13531
	.uleb128	11
	.byte		"sample_idx"
	.byte		0
	.4byte		.L3125
	.4byte		.L3262
.L3263:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13532
	.uleb128	11
	.byte		"didSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	14
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3267
	.4byte		.L3264
	.4byte		.L3265
.L3268:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13549
	.uleb128	31
	.byte		"compositeHeaderSize"
	.byte		0
	.4byte		.L3190
	.4byte		.L3269
	.section	.debug_info,,n
	.sleb128	0
.L3267:
	.section	.debug_info,,n
	.sleb128	0
.L3245:
	.section	.debug_info,,n
.L3274:
	.sleb128	3
	.4byte		.L3271-.L2
	.byte		"ReadAllRequestedPeriodicDids"
	.byte		0
	.4byte		.L3101
	.uleb128	13639
	.uleb128	29
	.byte		0x1
	.4byte		.L3272
	.4byte		.L3273
.L3275:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13641
	.uleb128	11
	.byte		"didIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L3276
.L3277:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13642
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3278:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13643
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L3279:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13644
	.uleb128	70
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L3280
.L3281:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13646
	.uleb128	12
	.byte		"isPending"
	.byte		0
	.4byte		.L3129
	.4byte		.L3282
	.section	.debug_info,,n
	.sleb128	0
.L3271:
	.section	.debug_info,,n
.L3287:
	.sleb128	2
	.4byte		.L3284-.L2
	.byte		"Dcm_DspTransmitPeriodicDataTrigger"
	.byte		0
	.4byte		.L3101
	.uleb128	13791
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3285
	.4byte		.L3286
	.section	.debug_info,,n
	.sleb128	0
.L3284:
	.section	.debug_info,,n
.L3292:
	.sleb128	2
	.4byte		.L3289-.L2
	.byte		"Dcm_SE_GetPeriodicData"
	.byte		0
	.4byte		.L3101
	.uleb128	2424
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3290
	.4byte		.L3291
	.section	.debug_info,,n
	.sleb128	0
.L3289:
	.section	.debug_info,,n
.L3297:
	.sleb128	6
	.4byte		.L3294-.L2
	.byte		"AllSentSamplesConfirmed"
	.byte		0
	.4byte		.L3101
	.uleb128	13708
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L3295
	.4byte		.L3296
	.sleb128	4
	.4byte		.L3101
	.uleb128	13708
	.uleb128	32
	.byte		"pStatus"
	.byte		0
	.4byte		.L3298
	.4byte		.L3303
	.section	.debug_info,,n
	.sleb128	0
.L3294:
	.section	.debug_info,,n
.L3308:
	.sleb128	6
	.4byte		.L3305-.L2
	.byte		"AllPeriodicDIDsSent"
	.byte		0
	.4byte		.L3101
	.uleb128	13716
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L3306
	.4byte		.L3307
	.sleb128	4
	.4byte		.L3101
	.uleb128	13716
	.uleb128	32
	.byte		"pStatus"
	.byte		0
	.4byte		.L3298
	.4byte		.L3309
	.section	.debug_info,,n
	.sleb128	0
.L3305:
	.section	.debug_info,,n
.L3314:
	.sleb128	3
	.4byte		.L3311-.L2
	.byte		"SendPeriodicDids"
	.byte		0
	.4byte		.L3101
	.uleb128	13724
	.uleb128	29
	.byte		0x1
	.4byte		.L3312
	.4byte		.L3313
.L3315:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13726
	.uleb128	11
	.byte		"index"
	.byte		0
	.4byte		.L3125
	.4byte		.L3316
.L3317:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13727
	.uleb128	19
	.byte		"sendResult"
	.byte		0
	.4byte		.L3156
	.4byte		.L3318
.L3319:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13728
	.uleb128	70
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L3320
	.section	.debug_info,,n
	.sleb128	0
.L3311:
	.section	.debug_info,,n
.L3325:
	.sleb128	2
	.4byte		.L3322-.L2
	.byte		"Dcm_SE_TransmitPeriodicData"
	.byte		0
	.4byte		.L3101
	.uleb128	2446
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3323
	.4byte		.L3324
	.section	.debug_info,,n
	.sleb128	0
.L3322:
	.section	.debug_info,,n
.L3330:
	.sleb128	2
	.4byte		.L3327-.L2
	.byte		"Dcm_DspConfirmation"
	.byte		0
	.4byte		.L3101
	.uleb128	2467
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3328
	.4byte		.L3329
	.sleb128	4
	.4byte		.L3101
	.uleb128	2467
	.uleb128	22
	.byte		"Result"
	.byte		0
	.4byte		.L3331
	.4byte		.L3332
	.section	.debug_info,,n
	.sleb128	0
.L3327:
	.section	.debug_info,,n
.L3337:
	.sleb128	2
	.4byte		.L3334-.L2
	.byte		"Dcm_DspEnableDtcSetting"
	.byte		0
	.4byte		.L3101
	.uleb128	2529
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3335
	.4byte		.L3336
	.section	.debug_info,,n
	.sleb128	0
.L3334:
	.section	.debug_info,,n
.L3342:
	.sleb128	2
	.4byte		.L3339-.L2
	.byte		"Dcm_DspServiceCancelled"
	.byte		0
	.4byte		.L3101
	.uleb128	2563
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3340
	.4byte		.L3341
	.section	.debug_info,,n
	.sleb128	0
.L3339:
	.section	.debug_info,,n
.L3347:
	.sleb128	2
	.4byte		.L3344-.L2
	.byte		"Dcm_DspResetPendingSecurityLevel"
	.byte		0
	.4byte		.L3101
	.uleb128	2580
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L3345
	.4byte		.L3346
	.section	.debug_info,,n
	.sleb128	0
.L3344:
	.section	.debug_info,,n
.L3352:
	.sleb128	9
	.4byte		.L3349-.L2
	.byte		"Dcm_EcuReset"
	.byte		0
	.4byte		.L3101
	.uleb128	2588
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3350
	.4byte		.L3351
	.section	.debug_info,,n
	.sleb128	10
	.4byte		.L3101
	.uleb128	2588
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	2588
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3357
	.sleb128	4
	.4byte		.L3101
	.uleb128	2588
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3358
.L3359:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2590
	.uleb128	28
	.byte		"resetType"
	.byte		0
	.4byte		.L3190
	.4byte		.L3360
	.section	.debug_info,,n
	.sleb128	0
.L3349:
	.section	.debug_info,,n
.L3370:
	.sleb128	6
	.4byte		.L3362-.L2
	.byte		"FindPduRxChannel"
	.byte		0
	.4byte		.L3101
	.uleb128	3001
	.uleb128	53
	.4byte		.L3365
	.byte		0x1
	.4byte		.L3363
	.4byte		.L3364
	.sleb128	4
	.4byte		.L3101
	.uleb128	3001
	.uleb128	53
	.byte		"pPdu"
	.byte		0
	.4byte		.L3371
	.4byte		.L3372
.L3373:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3003
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L3374
.L3375:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3004
	.uleb128	61
	.byte		"channel"
	.byte		0
	.4byte		.L3366
	.4byte		.L3376
	.section	.debug_info,,n
	.sleb128	0
.L3362:
	.section	.debug_info,,n
.L3386:
	.sleb128	9
	.4byte		.L3378-.L2
	.byte		"Dcm_DspGetSessionConfiguration"
	.byte		0
	.4byte		.L3101
	.uleb128	14295
	.uleb128	44
	.4byte		.L3381
	.byte		0x1
	.byte		0x1
	.4byte		.L3379
	.4byte		.L3380
	.sleb128	4
	.4byte		.L3101
	.uleb128	14295
	.uleb128	44
	.byte		"requestedSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L3387
.L3388:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14297
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L3389
.L3390:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14298
	.uleb128	59
	.byte		"pSession"
	.byte		0
	.4byte		.L3382
	.4byte		.L3391
	.section	.debug_info,,n
	.sleb128	0
.L3378:
	.section	.debug_info,,n
.L3396:
	.sleb128	9
	.4byte		.L3393-.L2
	.byte		"Dcm_DiagnosticSessionControl"
	.byte		0
	.4byte		.L3101
	.uleb128	2670
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3394
	.4byte		.L3395
	.sleb128	4
	.4byte		.L3101
	.uleb128	2670
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3397
	.sleb128	4
	.4byte		.L3101
	.uleb128	2670
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3398
	.sleb128	4
	.4byte		.L3101
	.uleb128	2670
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3399
.L3400:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2674
	.uleb128	33
	.byte		"pRxChannel"
	.byte		0
	.4byte		.L3365
	.4byte		.L3401
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3405
	.4byte		.L3402
	.4byte		.L3403
.L3406:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2699
	.uleb128	43
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L3408
	.section	.debug_info,,n
	.sleb128	0
.L3405:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3412
	.4byte		.L3409
	.4byte		.L3410
.L3413:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2747
	.uleb128	41
	.byte		"requestedSession"
	.byte		0
	.4byte		.L3414
	.4byte		.L3415
	.section	.debug_info,,n
	.sleb128	0
.L3412:
	.section	.debug_info,,n
	.sleb128	0
.L3393:
	.section	.debug_info,,n
.L3425:
	.sleb128	6
	.4byte		.L3417-.L2
	.byte		"IsSecurityLevelSupported"
	.byte		0
	.4byte		.L3101
	.uleb128	7074
	.uleb128	52
	.4byte		.L3420
	.byte		0x1
	.4byte		.L3418
	.4byte		.L3419
	.sleb128	4
	.4byte		.L3101
	.uleb128	7074
	.uleb128	52
	.byte		"SecurityLevel"
	.byte		0
	.4byte		.L3157
	.4byte		.L3426
.L3427:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7076
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L3428
.L3429:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7077
	.uleb128	60
	.byte		"pSecurityType"
	.byte		0
	.4byte		.L3421
	.4byte		.L3430
	.section	.debug_info,,n
	.sleb128	0
.L3417:
	.section	.debug_info,,n
.L3435:
	.sleb128	3
	.4byte		.L3432-.L2
	.byte		"SecurityAccessGetSeed"
	.byte		0
	.4byte		.L3101
	.uleb128	10588
	.uleb128	29
	.byte		0x1
	.4byte		.L3433
	.4byte		.L3434
	.sleb128	4
	.4byte		.L3101
	.uleb128	10588
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L3437
	.sleb128	4
	.4byte		.L3101
	.uleb128	10588
	.uleb128	29
	.byte		"SecurityLevel"
	.byte		0
	.4byte		.L3157
	.4byte		.L3438
	.sleb128	4
	.4byte		.L3101
	.uleb128	10588
	.uleb128	29
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3439
	.sleb128	4
	.4byte		.L3101
	.uleb128	10588
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3440
.L3441:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10594
	.uleb128	50
	.byte		"pSecurityType"
	.byte		0
	.4byte		.L3442
	.4byte		.L3443
.L3444:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10595
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3445:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10601
	.uleb128	48
	.byte		"securityAccesDataRecord"
	.byte		0
	.4byte		.L3234
	.4byte		.L3446
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3450
	.4byte		.L3447
	.4byte		.L3448
.L3451:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10642
	.uleb128	14
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L3452
	.section	.debug_info,,n
	.sleb128	0
.L3450:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3456
	.4byte		.L3453
	.4byte		.L3454
.L3457:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10655
	.uleb128	40
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L3458
	.section	.debug_info,,n
	.sleb128	0
.L3456:
	.section	.debug_info,,n
	.sleb128	0
.L3432:
	.section	.debug_info,,n
.L3463:
	.sleb128	3
	.4byte		.L3460-.L2
	.byte		"SecurityAccessCompareKey"
	.byte		0
	.4byte		.L3101
	.uleb128	10699
	.uleb128	29
	.byte		0x1
	.4byte		.L3461
	.4byte		.L3462
	.sleb128	4
	.4byte		.L3101
	.uleb128	10699
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3467
	.sleb128	4
	.4byte		.L3101
	.uleb128	10699
	.uleb128	29
	.byte		"SecurityLevel"
	.byte		0
	.4byte		.L3157
	.4byte		.L3468
	.sleb128	4
	.4byte		.L3101
	.uleb128	10699
	.uleb128	29
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3469
	.sleb128	4
	.4byte		.L3101
	.uleb128	10699
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3470
.L3471:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10705
	.uleb128	50
	.byte		"pSecurityType"
	.byte		0
	.4byte		.L3442
	.4byte		.L3472
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3476
	.4byte		.L3473
	.4byte		.L3474
.L3477:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10735
	.uleb128	51
	.byte		"pKey"
	.byte		0
	.4byte		.L3234
	.4byte		.L3478
.L3479:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10736
	.uleb128	40
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L3480
	.section	.debug_info,,n
	.sleb128	0
.L3476:
	.section	.debug_info,,n
	.sleb128	0
.L3460:
	.section	.debug_info,,n
.L3485:
	.sleb128	9
	.4byte		.L3482-.L2
	.byte		"Dcm_SecurityAccess"
	.byte		0
	.4byte		.L3101
	.uleb128	2910
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3483
	.4byte		.L3484
	.sleb128	4
	.4byte		.L3101
	.uleb128	2910
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3486
	.sleb128	4
	.4byte		.L3101
	.uleb128	2910
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3487
	.sleb128	4
	.4byte		.L3101
	.uleb128	2910
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3488
.L3489:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2912
	.uleb128	28
	.byte		"SecurityAccessType"
	.byte		0
	.4byte		.L3190
	.4byte		.L3490
.L3491:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2913
	.uleb128	28
	.byte		"SecurityLevel"
	.byte		0
	.4byte		.L3190
	.4byte		.L3492
	.section	.debug_info,,n
	.sleb128	0
.L3482:
	.section	.debug_info,,n
.L3501:
	.sleb128	6
	.4byte		.L3497-.L2
	.byte		"GetCommunicationMode"
	.byte		0
	.4byte		.L3101
	.uleb128	3020
	.uleb128	50
	.4byte		.L3500
	.byte		0x1
	.4byte		.L3498
	.4byte		.L3499
	.sleb128	4
	.4byte		.L3101
	.uleb128	3020
	.uleb128	50
	.byte		"pSubFunction"
	.byte		0
	.4byte		.L3157
	.4byte		.L3502
	.sleb128	4
	.4byte		.L3101
	.uleb128	3020
	.uleb128	50
	.byte		"pCommunicationType"
	.byte		0
	.4byte		.L3157
	.4byte		.L3503
.L3504:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3022
	.uleb128	30
	.byte		"communicationMode"
	.byte		0
	.4byte		.L3500
	.4byte		.L3505
.L3506:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3023
	.uleb128	29
	.byte		"subFunctionCommunicationType"
	.byte		0
	.4byte		.L3507
	.4byte		.L3508
	.section	.debug_info,,n
	.sleb128	0
.L3497:
	.section	.debug_info,,n
.L3516:
	.sleb128	9
	.4byte		.L3513-.L2
	.byte		"Dcm_CommunicationControl"
	.byte		0
	.4byte		.L3101
	.uleb128	2940
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3514
	.4byte		.L3515
	.sleb128	10
	.4byte		.L3101
	.uleb128	2940
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	2940
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3517
	.sleb128	4
	.4byte		.L3101
	.uleb128	2940
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3518
.L3519:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2942
	.uleb128	10
	.byte		"communicationType"
	.byte		0
	.4byte		.L3157
	.4byte		.L3520
.L3521:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2943
	.uleb128	10
	.byte		"subnetNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3522
.L3523:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2944
	.uleb128	30
	.byte		"communicationMode"
	.byte		0
	.4byte		.L3500
	.4byte		.L3524
.L3525:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2945
	.uleb128	22
	.byte		"network"
	.byte		0
	.4byte		.L3526
	.4byte		.L3527
.L3528:
	.sleb128	5
	.4byte		.L3101
	.uleb128	2946
	.uleb128	33
	.byte		"pRxChannel"
	.byte		0
	.4byte		.L3365
	.4byte		.L3529
	.section	.debug_info,,n
	.sleb128	0
.L3513:
	.section	.debug_info,,n
.L3534:
	.sleb128	9
	.4byte		.L3531-.L2
	.byte		"Dcm_TesterPresent"
	.byte		0
	.4byte		.L3101
	.uleb128	3079
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3532
	.4byte		.L3533
	.sleb128	10
	.4byte		.L3101
	.uleb128	3079
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	3079
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3535
	.sleb128	4
	.4byte		.L3101
	.uleb128	3079
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3536
	.section	.debug_info,,n
	.sleb128	0
.L3531:
	.section	.debug_info,,n
.L3541:
	.sleb128	9
	.4byte		.L3538-.L2
	.byte		"Dcm_ControlDTCSetting"
	.byte		0
	.4byte		.L3101
	.uleb128	3107
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3539
	.4byte		.L3540
	.sleb128	10
	.4byte		.L3101
	.uleb128	3107
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	3107
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3542
	.sleb128	4
	.4byte		.L3101
	.uleb128	3107
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3543
.L3544:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3109
	.uleb128	28
	.byte		"DTCSettingType"
	.byte		0
	.4byte		.L3190
	.4byte		.L3545
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3549
	.4byte		.L3546
	.4byte		.L3547
.L3550:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3148
	.uleb128	60
	.byte		"dtcSettingsResult"
	.byte		0
	.4byte		.L3551
	.4byte		.L3553
	.section	.debug_info,,n
	.sleb128	0
.L3549:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3557
	.4byte		.L3554
	.4byte		.L3555
.L3558:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3181
	.uleb128	60
	.byte		"dtcSettingsResult"
	.byte		0
	.4byte		.L3551
	.4byte		.L3559
	.section	.debug_info,,n
	.sleb128	0
.L3557:
	.section	.debug_info,,n
	.sleb128	0
.L3538:
	.section	.debug_info,,n
.L3565:
	.sleb128	3
	.4byte		.L3562-.L2
	.byte		"ClearDtcInformation"
	.byte		0
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		0x1
	.4byte		.L3563
	.4byte		.L3564
	.sleb128	4
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3566
	.sleb128	4
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		"groupOfDtc"
	.byte		0
	.4byte		.L3567
	.4byte		.L3568
	.sleb128	4
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		"dtcFormat"
	.byte		0
	.4byte		.L3569
	.4byte		.L3571
	.sleb128	4
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		"clearMemoryErrorCode"
	.byte		0
	.4byte		.L3572
	.4byte		.L3573
	.sleb128	4
	.4byte		.L3101
	.uleb128	12093
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3574
.L3575:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12098
	.uleb128	45
	.byte		"Status"
	.byte		0
	.4byte		.L3576
	.4byte		.L3578
	.section	.debug_info,,n
	.sleb128	0
.L3562:
	.section	.debug_info,,n
.L3584:
	.sleb128	9
	.4byte		.L3581-.L2
	.byte		"Dcm_ClearDiagnosticInformation"
	.byte		0
	.4byte		.L3101
	.uleb128	3215
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3582
	.4byte		.L3583
	.sleb128	4
	.4byte		.L3101
	.uleb128	3215
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3585
	.sleb128	4
	.4byte		.L3101
	.uleb128	3215
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3586
	.sleb128	4
	.4byte		.L3101
	.uleb128	3215
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3587
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3591
	.4byte		.L3588
	.4byte		.L3589
.L3592:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3238
	.uleb128	32
	.byte		"groupOfDTC"
	.byte		0
	.4byte		.L3567
	.4byte		.L3593
	.section	.debug_info,,n
	.sleb128	0
.L3591:
	.section	.debug_info,,n
	.sleb128	0
.L3581:
	.section	.debug_info,,n
.L3599:
	.sleb128	6
	.4byte		.L3595-.L2
	.byte		"GetSeverityType"
	.byte		0
	.4byte		.L3101
	.uleb128	7094
	.uleb128	44
	.4byte		.L3598
	.byte		0x1
	.4byte		.L3596
	.4byte		.L3597
	.sleb128	4
	.4byte		.L3101
	.uleb128	7094
	.uleb128	44
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3600
.L3601:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7096
	.uleb128	24
	.byte		"RetValue"
	.byte		0
	.4byte		.L3598
	.4byte		.L3602
	.section	.debug_info,,n
	.sleb128	0
.L3595:
	.section	.debug_info,,n
.L3609:
	.sleb128	6
	.4byte		.L3605-.L2
	.byte		"GetDTCOriginReadDTCInformation"
	.byte		0
	.4byte		.L3101
	.uleb128	8258
	.uleb128	42
	.4byte		.L3608
	.byte		0x1
	.4byte		.L3606
	.4byte		.L3607
	.sleb128	4
	.4byte		.L3101
	.uleb128	8258
	.uleb128	42
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3610
.L3611:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8260
	.uleb128	22
	.byte		"retVal"
	.byte		0
	.4byte		.L3608
	.4byte		.L3612
	.section	.debug_info,,n
	.sleb128	0
.L3605:
	.section	.debug_info,,n
.L3618:
	.sleb128	3
	.4byte		.L3615-.L2
	.byte		"ReportNumberOfDTCsByStatusMask"
	.byte		0
	.4byte		.L3101
	.uleb128	7137
	.uleb128	29
	.byte		0x1
	.4byte		.L3616
	.4byte		.L3617
	.sleb128	4
	.4byte		.L3101
	.uleb128	7137
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3619
	.sleb128	4
	.4byte		.L3101
	.uleb128	7137
	.uleb128	29
	.byte		"DtcKind"
	.byte		0
	.4byte		.L3620
	.4byte		.L3621
	.sleb128	4
	.4byte		.L3101
	.uleb128	7137
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3622
.L3623:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7142
	.uleb128	41
	.byte		"NumOfDtc"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3624:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7143
	.uleb128	41
	.byte		"DtcStatusMask"
	.byte		0
	.4byte		.L3625
	.4byte		.L3626
.L3627:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7144
	.uleb128	41
	.byte		"StatusAvailabilityMask"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3628:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7145
	.uleb128	41
	.byte		"Status"
	.byte		0
	.4byte		.L3629
	.4byte		.L3630
.L3631:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7146
	.uleb128	41
	.byte		"FilterWithSeverity"
	.byte		0
	.4byte		.L3129
	.4byte		.L3632
	.section	.debug_info,,n
	.sleb128	0
.L3615:
	.section	.debug_info,,n
.L3637:
	.sleb128	3
	.4byte		.L3634-.L2
	.byte		"ReportDTCFaultDetectionCounter"
	.byte		0
	.4byte		.L3101
	.uleb128	7243
	.uleb128	28
	.byte		0x1
	.4byte		.L3635
	.4byte		.L3636
	.sleb128	4
	.4byte		.L3101
	.uleb128	7243
	.uleb128	28
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3638
	.sleb128	4
	.4byte		.L3101
	.uleb128	7243
	.uleb128	28
	.byte		"DtcKind"
	.byte		0
	.4byte		.L3620
	.4byte		.L3639
	.sleb128	4
	.4byte		.L3101
	.uleb128	7243
	.uleb128	28
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3640
.L3641:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7248
	.uleb128	37
	.byte		"GetNextDtc"
	.byte		0
	.4byte		.L3129
	.4byte		.L3642
.L3643:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7249
	.uleb128	37
	.byte		"NumberOfDtc"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3644:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7250
	.uleb128	37
	.byte		"TotalAnswerSize"
	.byte		0
	.4byte		.L3193
	.4byte		.L3645
.L3646:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7252
	.uleb128	29
	.byte		"getBufferRes"
	.byte		0
	.4byte		.L3156
	.4byte		.L3647
.L3648:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7253
	.uleb128	44
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3652
	.4byte		.L3649
	.4byte		.L3650
.L3653:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7333
	.uleb128	20
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	16
.L3654:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7334
	.uleb128	19
	.byte		"DtcFDC"
	.byte		0
	.4byte		.L3655
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3657:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7335
	.uleb128	68
	.byte		"Status"
	.byte		0
	.4byte		.L3658
	.4byte		.L3660
	.section	.debug_info,,n
	.sleb128	0
.L3652:
	.section	.debug_info,,n
	.sleb128	0
.L3634:
	.section	.debug_info,,n
.L3665:
	.sleb128	3
	.4byte		.L3662-.L2
	.byte		"ReportSeverityInformationOfDTC"
	.byte		0
	.4byte		.L3101
	.uleb128	7419
	.uleb128	28
	.byte		0x1
	.4byte		.L3663
	.4byte		.L3664
	.sleb128	4
	.4byte		.L3101
	.uleb128	7419
	.uleb128	28
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L3666
	.sleb128	4
	.4byte		.L3101
	.uleb128	7419
	.uleb128	28
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3667
.L3668:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7422
	.uleb128	31
	.byte		"StatusAvailabilityMask"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3669:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7423
	.uleb128	31
	.byte		"DtcFunctionalUnit"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L3670:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7424
	.uleb128	31
	.byte		"DtcStatus"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3671:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7425
	.uleb128	31
	.byte		"DtcSeverity"
	.byte		0
	.4byte		.L3598
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	11
.L3672:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7426
	.uleb128	31
	.byte		"RequestedDtc"
	.byte		0
	.4byte		.L3567
	.4byte		.L3673
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3677
	.4byte		.L3674
	.4byte		.L3675
.L3678:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7456
	.uleb128	13
	.byte		"StartIndex"
	.byte		0
	.4byte		.L3157
	.4byte		.L3679
	.section	.debug_info,,n
	.sleb128	0
.L3677:
	.section	.debug_info,,n
	.sleb128	0
.L3662:
	.section	.debug_info,,n
.L3684:
	.sleb128	3
	.4byte		.L3681-.L2
	.byte		"ReportDTCsByStatusMask"
	.byte		0
	.4byte		.L3101
	.uleb128	7482
	.uleb128	29
	.byte		0x1
	.4byte		.L3682
	.4byte		.L3683
	.sleb128	4
	.4byte		.L3101
	.uleb128	7482
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3685
	.sleb128	4
	.4byte		.L3101
	.uleb128	7482
	.uleb128	29
	.byte		"DtcKind"
	.byte		0
	.4byte		.L3620
	.4byte		.L3686
	.sleb128	4
	.4byte		.L3101
	.uleb128	7482
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3687
.L3688:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7487
	.uleb128	60
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3689:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7488
	.uleb128	28
	.byte		"getBufferRes"
	.byte		0
	.4byte		.L3156
	.4byte		.L3690
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3694
	.4byte		.L3691
	.4byte		.L3692
.L3695:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7492
	.uleb128	29
	.byte		"StatusAvailabilityMask"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3699
	.4byte		.L3696
	.4byte		.L3697
.L3700:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7499
	.uleb128	36
	.byte		"subFunction0x0Aor0x15"
	.byte		0
	.4byte		.L3701
	.4byte		.L3702
.L3703:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7501
	.uleb128	36
	.byte		"includeMemorySelection"
	.byte		0
	.4byte		.L3701
	.4byte		.L3704
.L3705:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7502
	.uleb128	43
	.byte		"positiveResponseHeaderSize"
	.byte		0
	.4byte		.L3706
	.4byte		.L3707
.L3708:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7503
	.uleb128	34
	.byte		"memorySelection"
	.byte		0
	.4byte		.L3190
	.4byte		.L3709
.L3710:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7505
	.uleb128	32
	.byte		"DtcStatusMask"
	.byte		0
	.4byte		.L3625
	.4byte		.L3711
.L3712:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7506
	.uleb128	17
	.byte		"NumDTC"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3716
	.4byte		.L3713
	.4byte		.L3714
.L3717:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7596
	.uleb128	46
	.byte		"TotalAnswerSize"
	.byte		0
	.4byte		.L3706
	.4byte		.L3718
	.section	.debug_info,,n
	.sleb128	0
.L3716:
	.section	.debug_info,,n
	.sleb128	0
.L3699:
	.section	.debug_info,,n
	.sleb128	0
.L3694:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3722
	.4byte		.L3719
	.4byte		.L3720
.L3723:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7652
	.uleb128	15
	.byte		"GetNextDtc"
	.byte		0
	.4byte		.L3129
	.4byte		.L3724
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3728
	.4byte		.L3725
	.4byte		.L3726
.L3729:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7659
	.uleb128	20
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	16
.L3730:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7660
	.uleb128	35
	.byte		"DtcStatus"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L3731:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7661
	.uleb128	68
	.byte		"Status"
	.byte		0
	.4byte		.L3658
	.4byte		.L3732
	.section	.debug_info,,n
	.sleb128	0
.L3728:
	.section	.debug_info,,n
	.sleb128	0
.L3722:
	.section	.debug_info,,n
	.sleb128	0
.L3681:
	.section	.debug_info,,n
.L3737:
	.sleb128	3
	.4byte		.L3734-.L2
	.byte		"ReportDTCSnapshotIdentification"
	.byte		0
	.4byte		.L3101
	.uleb128	7739
	.uleb128	29
	.byte		0x1
	.4byte		.L3735
	.4byte		.L3736
	.sleb128	4
	.4byte		.L3101
	.uleb128	7739
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3738
	.sleb128	4
	.4byte		.L3101
	.uleb128	7739
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3739
.L3740:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7743
	.uleb128	12
	.byte		"NumDtc"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3741:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7744
	.uleb128	19
	.byte		"TotalAnswerSize"
	.byte		0
	.4byte		.L3193
	.4byte		.L3742
.L3743:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7745
	.uleb128	12
	.byte		"GetNextRecord"
	.byte		0
	.4byte		.L3129
	.4byte		.L3744
.L3745:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7747
	.uleb128	44
	.byte		"getBufferRes"
	.byte		0
	.4byte		.L3156
	.4byte		.L3746
.L3747:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7748
	.uleb128	44
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3751
	.4byte		.L3748
	.4byte		.L3749
.L3752:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7807
	.uleb128	20
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	16
.L3753:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7808
	.uleb128	19
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3754:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7809
	.uleb128	68
	.byte		"Status"
	.byte		0
	.4byte		.L3658
	.4byte		.L3755
	.section	.debug_info,,n
	.sleb128	0
.L3751:
	.section	.debug_info,,n
	.sleb128	0
.L3734:
	.section	.debug_info,,n
.L3760:
	.sleb128	6
	.4byte		.L3757-.L2
	.byte		"GetOneSnapShotDataRecord"
	.byte		0
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L3758
	.4byte		.L3759
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"dtc"
	.byte		0
	.4byte		.L3206
	.4byte		.L3761
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"dtcStatus"
	.byte		0
	.4byte		.L3157
	.4byte		.L3762
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"dtcStatusIndicators"
	.byte		0
	.4byte		.L3157
	.4byte		.L3763
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"dataRecordNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3764
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"DtcOrigin"
	.byte		0
	.4byte		.L3608
	.4byte		.L3765
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"isService19"
	.byte		0
	.4byte		.L3701
	.4byte		.L3766
	.sleb128	4
	.4byte		.L3101
	.uleb128	8561
	.uleb128	53
	.byte		"pDataState"
	.byte		0
	.4byte		.L3767
	.4byte		.L3771
.L3772:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8569
	.uleb128	44
	.byte		"dataRecordSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3773:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8570
	.uleb128	37
	.byte		"demGetSizeRetVal"
	.byte		0
	.4byte		.L3774
	.4byte		.L3775
.L3776:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8571
	.uleb128	34
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L3777
.L3778:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8572
	.uleb128	25
	.byte		"responseBufferResult"
	.byte		0
	.4byte		.L3156
	.4byte		.L3779
.L3780:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8573
	.uleb128	43
	.byte		"responseBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3781:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8574
	.uleb128	42
	.byte		"getSnapshotRetVal"
	.byte		0
	.4byte		.L3782
	.4byte		.L3783
.L3784:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8588
	.uleb128	28
	.byte		"headerLen"
	.byte		0
	.4byte		.L3190
	.4byte		.L3785
	.section	.debug_info,,n
	.sleb128	0
.L3757:
	.section	.debug_info,,n
.L3790:
	.sleb128	3
	.4byte		.L3787-.L2
	.byte		"ReportDTCSnapshotRecordByDTCNumber"
	.byte		0
	.4byte		.L3101
	.uleb128	7887
	.uleb128	29
	.byte		0x1
	.4byte		.L3788
	.4byte		.L3789
	.sleb128	4
	.4byte		.L3101
	.uleb128	7887
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3791
	.sleb128	4
	.4byte		.L3101
	.uleb128	7887
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3792
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3796
	.4byte		.L3793
	.4byte		.L3794
.L3797:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7901
	.uleb128	32
	.byte		"Dtc"
	.byte		0
	.4byte		.L3567
	.4byte		.L3798
.L3799:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7902
	.uleb128	31
	.byte		"dataRecordNumber"
	.byte		0
	.4byte		.L3190
	.4byte		.L3800
.L3801:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7903
	.uleb128	33
	.byte		"includeMemorySelection"
	.byte		0
	.4byte		.L3701
	.4byte		.L3802
.L3803:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7904
	.uleb128	40
	.byte		"additionalHeaderSize"
	.byte		0
	.4byte		.L3706
	.4byte		.L3804
.L3805:
	.sleb128	5
	.4byte		.L3101
	.uleb128	7905
	.uleb128	31
	.byte		"memorySelection"
	.byte		0
	.4byte		.L3190
	.4byte		.L3806
.L3807:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7907
	.uleb128	22
	.byte		"totalAnswerSize"
	.byte		0
	.4byte		.L3193
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3808:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7908
	.uleb128	46
	.byte		"responseBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3809:
	.sleb128	7
	.4byte		.L3101
	.uleb128	7909
	.uleb128	16
	.byte		"dtcStatus"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L3796:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3813
	.4byte		.L3810
	.4byte		.L3811
.L3814:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8033
	.uleb128	16
	.byte		"snapDataNumberLoop"
	.byte		0
	.4byte		.L3157
	.4byte		.L3815
.L3816:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8034
	.uleb128	16
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3817
	.section	.debug_info,,n
	.sleb128	0
.L3813:
	.section	.debug_info,,n
	.sleb128	0
.L3787:
	.section	.debug_info,,n
.L3822:
	.sleb128	3
	.4byte		.L3819-.L2
	.byte		"ReportDTCSnapshotRecordByRecordNumber"
	.byte		0
	.4byte		.L3101
	.uleb128	8135
	.uleb128	29
	.byte		0x1
	.4byte		.L3820
	.4byte		.L3821
	.sleb128	4
	.4byte		.L3101
	.uleb128	8135
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3823
	.sleb128	4
	.4byte		.L3101
	.uleb128	8135
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3824
.L3825:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8138
	.uleb128	38
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3826
	.4byte		.L3828
.L3829:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8139
	.uleb128	13
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3830:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8140
	.uleb128	13
	.byte		"DtcStatus"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3831:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8158
	.uleb128	11
	.byte		"bufSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
	.section	.debug_info,,n
	.sleb128	0
.L3819:
	.section	.debug_info,,n
.L3836:
	.sleb128	6
	.4byte		.L3833-.L2
	.byte		"GetStartIndexOfEDR"
	.byte		0
	.4byte		.L3101
	.uleb128	8215
	.uleb128	30
	.4byte		.L3157
	.byte		0x1
	.4byte		.L3834
	.4byte		.L3835
	.sleb128	4
	.4byte		.L3101
	.uleb128	8215
	.uleb128	30
	.byte		"subServiceIdentifier"
	.byte		0
	.4byte		.L3157
	.4byte		.L3837
	.sleb128	4
	.4byte		.L3101
	.uleb128	8215
	.uleb128	30
	.byte		"reqDataNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3838
.L3839:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8217
	.uleb128	10
	.byte		"startindex"
	.byte		0
	.4byte		.L3157
	.4byte		.L3840
	.section	.debug_info,,n
	.sleb128	0
.L3833:
	.section	.debug_info,,n
.L3845:
	.sleb128	6
	.4byte		.L3842-.L2
	.byte		"GetOneExtendedDataRecordByDtc"
	.byte		0
	.4byte		.L3101
	.uleb128	8759
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L3843
	.4byte		.L3844
	.sleb128	4
	.4byte		.L3101
	.uleb128	8759
	.uleb128	53
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.4byte		.L3846
	.sleb128	4
	.4byte		.L3101
	.uleb128	8759
	.uleb128	53
	.byte		"DtcOrigin"
	.byte		0
	.4byte		.L3608
	.4byte		.L3847
	.sleb128	4
	.4byte		.L3101
	.uleb128	8759
	.uleb128	53
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3848
	.sleb128	4
	.4byte		.L3101
	.uleb128	8759
	.uleb128	53
	.byte		"pDataState"
	.byte		0
	.4byte		.L3767
	.4byte		.L3849
.L3850:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8764
	.uleb128	37
	.byte		"demGetSizeRetVal"
	.byte		0
	.4byte		.L3774
	.4byte		.L3851
.L3852:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8765
	.uleb128	51
	.byte		"demGetEDRetVal"
	.byte		0
	.4byte		.L3853
	.4byte		.L3854
.L3855:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8766
	.uleb128	34
	.byte		"ExtendedDataRecordSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3856:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8767
	.uleb128	25
	.byte		"responseBufferResult"
	.byte		0
	.4byte		.L3156
	.4byte		.L3857
.L3858:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8768
	.uleb128	44
	.byte		"responseBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3859:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8769
	.uleb128	34
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L3860
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3864
	.4byte		.L3861
	.4byte		.L3862
.L3865:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8844
	.uleb128	17
	.byte		"tempBufSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
	.section	.debug_info,,n
	.sleb128	0
.L3864:
	.section	.debug_info,,n
	.sleb128	0
.L3842:
	.section	.debug_info,,n
.L3870:
	.sleb128	3
	.4byte		.L3867-.L2
	.byte		"GetTotalSizeOfExtendedDataRecordByDtc"
	.byte		0
	.4byte		.L3101
	.uleb128	8947
	.uleb128	29
	.byte		0x1
	.4byte		.L3868
	.4byte		.L3869
	.sleb128	4
	.4byte		.L3101
	.uleb128	8947
	.uleb128	29
	.byte		"DtcOrigin"
	.byte		0
	.4byte		.L3608
	.4byte		.L3871
	.sleb128	4
	.4byte		.L3101
	.uleb128	8947
	.uleb128	29
	.byte		"pStatus"
	.byte		0
	.4byte		.L3872
	.4byte		.L3876
	.sleb128	4
	.4byte		.L3101
	.uleb128	8947
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3877
.L3878:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8951
	.uleb128	11
	.byte		"dataRecordSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3879:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8952
	.uleb128	37
	.byte		"getSizeRetVal"
	.byte		0
	.4byte		.L3774
	.4byte		.L3880
.L3881:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8953
	.uleb128	10
	.byte		"extDataNumberLoop"
	.byte		0
	.4byte		.L3157
	.4byte		.L3882
.L3883:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8954
	.uleb128	10
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3157
	.4byte		.L3884
	.section	.debug_info,,n
	.sleb128	0
.L3867:
	.section	.debug_info,,n
.L3889:
	.sleb128	3
	.4byte		.L3886-.L2
	.byte		"ReportDTCExtendedDataRecordByDTCNumber"
	.byte		0
	.4byte		.L3101
	.uleb128	8336
	.uleb128	29
	.byte		0x1
	.4byte		.L3887
	.4byte		.L3888
	.sleb128	4
	.4byte		.L3101
	.uleb128	8336
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3890
	.sleb128	4
	.4byte		.L3101
	.uleb128	8336
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3891
.L3892:
	.sleb128	7
	.4byte		.L3101
	.uleb128	8339
	.uleb128	45
	.byte		"responseBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3896
	.4byte		.L3893
	.4byte		.L3894
.L3897:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8351
	.uleb128	31
	.byte		"ExtendedDataNumber"
	.byte		0
	.4byte		.L3190
	.4byte		.L3898
	.section	.debug_info,,n
	.sleb128	0
.L3896:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3902
	.4byte		.L3899
	.4byte		.L3900
.L3903:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8395
	.uleb128	33
	.byte		"includeMemorySelection"
	.byte		0
	.4byte		.L3701
	.4byte		.L3904
.L3905:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8396
	.uleb128	40
	.byte		"additionalHeaderSize"
	.byte		0
	.4byte		.L3706
	.4byte		.L3906
.L3907:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8397
	.uleb128	31
	.byte		"memorySelection"
	.byte		0
	.4byte		.L3190
	.4byte		.L3908
	.section	.debug_info,,n
	.sleb128	0
.L3902:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3912
	.4byte		.L3909
	.4byte		.L3910
.L3913:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8476
	.uleb128	16
	.byte		"extDataNumberLoop"
	.byte		0
	.4byte		.L3157
	.4byte		.L3914
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3918
	.4byte		.L3915
	.4byte		.L3916
.L3919:
	.sleb128	5
	.4byte		.L3101
	.uleb128	8489
	.uleb128	37
	.byte		"recordNumber"
	.byte		0
	.4byte		.L3190
	.4byte		.L3920
	.section	.debug_info,,n
	.sleb128	0
.L3918:
	.section	.debug_info,,n
	.sleb128	0
.L3912:
	.section	.debug_info,,n
	.sleb128	0
.L3886:
	.section	.debug_info,,n
.L3925:
	.sleb128	3
	.4byte		.L3922-.L2
	.byte		"HelpFncReportDTCBySeverityMaskRecord"
	.byte		0
	.4byte		.L3101
	.uleb128	10110
	.uleb128	29
	.byte		0x1
	.4byte		.L3923
	.4byte		.L3924
	.sleb128	4
	.4byte		.L3101
	.uleb128	10110
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3926
.L3927:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10112
	.uleb128	38
	.byte		"GetNextDtc"
	.byte		0
	.4byte		.L3129
	.4byte		.L3928
.L3929:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10113
	.uleb128	29
	.byte		"getBufferRes"
	.byte		0
	.4byte		.L3156
	.4byte		.L3930
.L3931:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10114
	.uleb128	47
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L3935
	.4byte		.L3932
	.4byte		.L3933
.L3936:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10122
	.uleb128	17
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	16
.L3937:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10123
	.uleb128	32
	.byte		"DtcStatus"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3938:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10124
	.uleb128	30
	.byte		"DtcSeverity"
	.byte		0
	.4byte		.L3598
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L3939:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10125
	.uleb128	16
	.byte		"DtcFunctionalUnit"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3940:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10126
	.uleb128	65
	.byte		"Status"
	.byte		0
	.4byte		.L3658
	.4byte		.L3941
	.section	.debug_info,,n
	.sleb128	0
.L3935:
	.section	.debug_info,,n
	.sleb128	0
.L3922:
	.section	.debug_info,,n
.L3946:
	.sleb128	3
	.4byte		.L3943-.L2
	.byte		"ReportDTCBySeverityMaskRecord"
	.byte		0
	.4byte		.L3101
	.uleb128	10199
	.uleb128	29
	.byte		0x1
	.4byte		.L3944
	.4byte		.L3945
	.sleb128	4
	.4byte		.L3101
	.uleb128	10199
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L3947
	.sleb128	4
	.4byte		.L3101
	.uleb128	10199
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3948
.L3949:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10202
	.uleb128	43
	.byte		"dtcStatusMask"
	.byte		0
	.4byte		.L3625
	.4byte		.L3950
.L3951:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10203
	.uleb128	43
	.byte		"statusAvailabilityMask"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L3952:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10204
	.uleb128	43
	.byte		"numOfDtc"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L3953:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10205
	.uleb128	43
	.byte		"totalAnswerSize"
	.byte		0
	.4byte		.L3193
	.4byte		.L3954
.L3955:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10206
	.uleb128	43
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
	.section	.debug_info,,n
	.sleb128	0
.L3943:
	.section	.debug_info,,n
.L3960:
	.sleb128	3
	.4byte		.L3957-.L2
	.byte		"ReportDtcInformationByOccurrence"
	.byte		0
	.4byte		.L3101
	.uleb128	10328
	.uleb128	29
	.byte		0x1
	.4byte		.L3958
	.4byte		.L3959
	.sleb128	4
	.4byte		.L3101
	.uleb128	10328
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L3961
	.sleb128	4
	.4byte		.L3101
	.uleb128	10328
	.uleb128	29
	.byte		"DtcRequest"
	.byte		0
	.4byte		.L3962
	.4byte		.L3963
	.sleb128	4
	.4byte		.L3101
	.uleb128	10328
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L3964
.L3965:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10333
	.uleb128	27
	.byte		"Dtc"
	.byte		0
	.4byte		.L3206
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L3966:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10334
	.uleb128	27
	.byte		"DtcStatus"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L3967:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10335
	.uleb128	27
	.byte		"StatusAvailabilityMask"
	.byte		0
	.4byte		.L3625
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L3957:
	.section	.debug_info,,n
.L3973:
	.sleb128	9
	.4byte		.L3970-.L2
	.byte		"Dcm_ReadDTCInformation"
	.byte		0
	.4byte		.L3101
	.uleb128	3253
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L3971
	.4byte		.L3972
	.sleb128	4
	.4byte		.L3101
	.uleb128	3253
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L3974
	.sleb128	4
	.4byte		.L3101
	.uleb128	3253
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L3975
	.sleb128	4
	.4byte		.L3101
	.uleb128	3253
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L3976
	.section	.debug_info,,n
	.sleb128	0
.L3970:
	.section	.debug_info,,n
.L3982:
	.sleb128	3
	.4byte		.L3979-.L2
	.byte		"WriteSignalToBuf_uint8N"
	.byte		0
	.4byte		.L3101
	.uleb128	3908
	.uleb128	29
	.byte		0x1
	.4byte		.L3980
	.4byte		.L3981
	.sleb128	4
	.4byte		.L3101
	.uleb128	3908
	.uleb128	29
	.byte		"pSrcData"
	.byte		0
	.4byte		.L3983
	.4byte		.L3984
	.sleb128	4
	.4byte		.L3101
	.uleb128	3908
	.uleb128	29
	.byte		"pDestination"
	.byte		0
	.4byte		.L3235
	.4byte		.L3985
	.sleb128	4
	.4byte		.L3101
	.uleb128	3908
	.uleb128	29
	.byte		"bitPos"
	.byte		0
	.4byte		.L3125
	.4byte		.L3986
	.sleb128	4
	.4byte		.L3101
	.uleb128	3908
	.uleb128	29
	.byte		"byteCount"
	.byte		0
	.4byte		.L3125
	.4byte		.L3987
.L3988:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3913
	.uleb128	11
	.byte		"byteOffset"
	.byte		0
	.4byte		.L3157
	.4byte		.L3989
.L3990:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3914
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L3991
.L3992:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3916
	.uleb128	11
	.byte		"srcValue"
	.byte		0
	.4byte		.L3125
	.4byte		.L3993
.L3994:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3917
	.uleb128	11
	.byte		"lsbValue"
	.byte		0
	.4byte		.L3157
	.4byte		.L3995
.L3996:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3918
	.uleb128	11
	.byte		"msbValue"
	.byte		0
	.4byte		.L3157
	.4byte		.L3997
.L3998:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3919
	.uleb128	11
	.byte		"byte"
	.byte		0
	.4byte		.L3157
	.4byte		.L3999
.L4000:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3921
	.uleb128	11
	.byte		"mask"
	.byte		0
	.4byte		.L3125
	.4byte		.L4001
.L4002:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3922
	.uleb128	11
	.byte		"lsbMask"
	.byte		0
	.4byte		.L3157
	.4byte		.L4003
.L4004:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3923
	.uleb128	11
	.byte		"msbMask"
	.byte		0
	.4byte		.L3157
	.4byte		.L4005
	.section	.debug_info,,n
	.sleb128	0
.L3979:
	.section	.debug_info,,n
.L4010:
	.sleb128	3
	.4byte		.L4007-.L2
	.byte		"WriteSignalToBuf_08"
	.byte		0
	.4byte		.L3101
	.uleb128	3977
	.uleb128	29
	.byte		0x1
	.4byte		.L4008
	.4byte		.L4009
	.sleb128	4
	.4byte		.L3101
	.uleb128	3977
	.uleb128	29
	.byte		"srcData"
	.byte		0
	.4byte		.L3157
	.4byte		.L4011
	.sleb128	4
	.4byte		.L3101
	.uleb128	3977
	.uleb128	29
	.byte		"pDestination"
	.byte		0
	.4byte		.L3235
	.4byte		.L4012
	.sleb128	4
	.4byte		.L3101
	.uleb128	3977
	.uleb128	29
	.byte		"bitPos"
	.byte		0
	.4byte		.L3125
	.4byte		.L4013
	.sleb128	4
	.4byte		.L3101
	.uleb128	3977
	.uleb128	29
	.byte		"bitSize"
	.byte		0
	.4byte		.L3157
	.4byte		.L4014
.L4015:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3982
	.uleb128	11
	.byte		"srcValue"
	.byte		0
	.4byte		.L3125
	.4byte		.L4016
.L4017:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3983
	.uleb128	11
	.byte		"lsbValue"
	.byte		0
	.4byte		.L3157
	.4byte		.L4018
.L4019:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3984
	.uleb128	11
	.byte		"msbValue"
	.byte		0
	.4byte		.L3157
	.4byte		.L4020
.L4021:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3985
	.uleb128	11
	.byte		"byte"
	.byte		0
	.4byte		.L3157
	.4byte		.L4022
.L4023:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3987
	.uleb128	11
	.byte		"mask"
	.byte		0
	.4byte		.L3125
	.4byte		.L4024
.L4025:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3988
	.uleb128	10
	.byte		"lsbMask"
	.byte		0
	.4byte		.L3157
	.4byte		.L4026
.L4027:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3989
	.uleb128	10
	.byte		"msbMask"
	.byte		0
	.4byte		.L3157
	.4byte		.L4028
.L4029:
	.sleb128	5
	.4byte		.L3101
	.uleb128	3991
	.uleb128	11
	.byte		"byteOffset"
	.byte		0
	.4byte		.L3157
	.4byte		.L4030
	.section	.debug_info,,n
	.sleb128	0
.L4007:
	.section	.debug_info,,n
.L4035:
	.sleb128	6
	.4byte		.L4032-.L2
	.byte		"IsIdentifierSupported"
	.byte		0
	.4byte		.L3101
	.uleb128	12155
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L4033
	.4byte		.L4034
	.sleb128	4
	.4byte		.L3101
	.uleb128	12155
	.uleb128	32
	.byte		"pSupport"
	.byte		0
	.4byte		.L3983
	.4byte		.L4036
	.sleb128	4
	.4byte		.L3101
	.uleb128	12155
	.uleb128	32
	.byte		"id"
	.byte		0
	.4byte		.L3157
	.4byte		.L4037
.L4038:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12157
	.uleb128	12
	.byte		"supported"
	.byte		0
	.4byte		.L3129
	.4byte		.L4039
.L4040:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12158
	.uleb128	16
	.byte		"bytePos"
	.byte		0
	.4byte		.L3190
	.4byte		.L4041
	.section	.debug_info,,n
	.sleb128	0
.L4032:
	.section	.debug_info,,n
.L4046:
	.sleb128	6
	.4byte		.L4043-.L2
	.byte		"GetVehInfoLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6435
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4044
	.4byte		.L4045
	.sleb128	4
	.4byte		.L3101
	.uleb128	6435
	.uleb128	53
	.byte		"idLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4047
	.sleb128	4
	.4byte		.L3101
	.uleb128	6435
	.uleb128	53
	.byte		"infoType"
	.byte		0
	.4byte		.L3157
	.4byte		.L4048
	.sleb128	4
	.4byte		.L3101
	.uleb128	6435
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3157
	.4byte		.L4049
	.sleb128	4
	.4byte		.L3101
	.uleb128	6435
	.uleb128	53
	.byte		"pInfoTypeLen"
	.byte		0
	.4byte		.L3179
	.4byte		.L4050
.L4051:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6440
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4052
.L4053:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6441
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4054
.L4055:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6442
	.uleb128	63
	.byte		"pVehInfo"
	.byte		0
	.4byte		.L4056
	.4byte		.L4060
	.section	.debug_info,,n
	.sleb128	0
.L4043:
	.section	.debug_info,,n
.L4065:
	.sleb128	6
	.4byte		.L4062-.L2
	.byte		"IsObdRangeSupported"
	.byte		0
	.4byte		.L3101
	.uleb128	12417
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L4063
	.4byte		.L4064
	.sleb128	4
	.4byte		.L3101
	.uleb128	12417
	.uleb128	32
	.byte		"supportPos"
	.byte		0
	.4byte		.L3190
	.4byte		.L4066
	.sleb128	4
	.4byte		.L3101
	.uleb128	12417
	.uleb128	32
	.byte		"pSupport"
	.byte		0
	.4byte		.L4067
	.4byte		.L4068
.L4069:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12420
	.uleb128	28
	.byte		"offset"
	.byte		0
	.4byte		.L3190
	.4byte		.L4070
	.section	.debug_info,,n
	.sleb128	0
.L4062:
	.section	.debug_info,,n
.L4075:
	.sleb128	6
	.4byte		.L4072-.L2
	.byte		"GetObdVehInfoDidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4073
	.4byte		.L4074
	.sleb128	4
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4076
	.sleb128	4
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4077
	.sleb128	10
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	10
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	2
	.byte		0x90
	.uleb128	6
	.sleb128	4
	.4byte		.L3101
	.uleb128	6622
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4078
.L4079:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6628
	.uleb128	28
	.byte		"reqIDType"
	.byte		0
	.4byte		.L3190
	.4byte		.L4080
.L4081:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6629
	.uleb128	28
	.byte		"bufPos"
	.byte		0
	.4byte		.L3190
	.4byte		.L4082
.L4083:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6630
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L4072:
	.section	.debug_info,,n
.L4088:
	.sleb128	6
	.4byte		.L4085-.L2
	.byte		"GetPowertrainPidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6495
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4086
	.4byte		.L4087
	.sleb128	4
	.4byte		.L3101
	.uleb128	6495
	.uleb128	53
	.byte		"idLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4089
	.sleb128	4
	.4byte		.L3101
	.uleb128	6495
	.uleb128	53
	.byte		"pidIdentifier"
	.byte		0
	.4byte		.L3157
	.4byte		.L4090
	.sleb128	4
	.4byte		.L3101
	.uleb128	6495
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3157
	.4byte		.L4091
	.sleb128	4
	.4byte		.L3101
	.uleb128	6495
	.uleb128	53
	.byte		"pPidLen"
	.byte		0
	.4byte		.L3179
	.4byte		.L4092
.L4093:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6500
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4094
.L4095:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6501
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4096
.L4097:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6502
	.uleb128	56
	.byte		"pPid"
	.byte		0
	.4byte		.L4098
	.4byte		.L4102
	.section	.debug_info,,n
	.sleb128	0
.L4085:
	.section	.debug_info,,n
.L4107:
	.sleb128	6
	.4byte		.L4104-.L2
	.byte		"GetObdPidDidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4105
	.4byte		.L4106
	.sleb128	4
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4108
	.sleb128	4
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4109
	.sleb128	10
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	10
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	2
	.byte		0x90
	.uleb128	6
	.sleb128	4
	.4byte		.L3101
	.uleb128	6675
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4110
.L4111:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6681
	.uleb128	28
	.byte		"reqIDType"
	.byte		0
	.4byte		.L3190
	.4byte		.L4112
.L4113:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6682
	.uleb128	28
	.byte		"bufPos"
	.byte		0
	.4byte		.L3190
	.4byte		.L4114
.L4115:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6683
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L4104:
	.section	.debug_info,,n
.L4120:
	.sleb128	6
	.4byte		.L4117-.L2
	.byte		"GetDddidSourcesLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6411
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4118
	.4byte		.L4119
	.sleb128	4
	.4byte		.L3101
	.uleb128	6411
	.uleb128	31
	.byte		"pDDDid"
	.byte		0
	.4byte		.L4121
	.4byte		.L4122
.L4123:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6413
	.uleb128	10
	.byte		"j"
	.byte		0
	.4byte		.L3157
	.4byte		.L4124
.L4125:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6414
	.uleb128	11
	.byte		"dddidLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4126
	.section	.debug_info,,n
	.sleb128	0
.L4117:
	.section	.debug_info,,n
.L4131:
	.sleb128	6
	.4byte		.L4128-.L2
	.byte		"GetDddidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4129
	.4byte		.L4130
	.sleb128	4
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4132
	.sleb128	4
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4133
	.sleb128	10
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	10
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	2
	.byte		0x90
	.uleb128	6
	.sleb128	4
	.4byte		.L3101
	.uleb128	6722
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4134
.L4135:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6728
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4136
.L4137:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6729
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4138
.L4139:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6730
	.uleb128	70
	.byte		"pDDDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L4140
	.section	.debug_info,,n
	.sleb128	0
.L4128:
	.section	.debug_info,,n
.L4145:
	.sleb128	3
	.4byte		.L4142-.L2
	.byte		"HandleStdRetVal"
	.byte		0
	.4byte		.L3101
	.uleb128	14460
	.uleb128	29
	.byte		0x1
	.4byte		.L4143
	.4byte		.L4144
	.sleb128	4
	.4byte		.L3101
	.uleb128	14460
	.uleb128	29
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L4146
	.sleb128	4
	.4byte		.L3101
	.uleb128	14460
	.uleb128	29
	.byte		"syncApi"
	.byte		0
	.4byte		.L3407
	.4byte		.L4147
	.sleb128	4
	.4byte		.L3101
	.uleb128	14460
	.uleb128	29
	.byte		"forceRcrrpSupport"
	.byte		0
	.4byte		.L3701
	.4byte		.L4148
	.sleb128	4
	.4byte		.L3101
	.uleb128	14460
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4149
	.section	.debug_info,,n
	.sleb128	0
.L4142:
	.section	.debug_info,,n
.L4154:
	.sleb128	6
	.4byte		.L4151-.L2
	.byte		"GetStandardDidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4152
	.4byte		.L4153
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4155
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4156
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4157
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4158
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4159
	.sleb128	4
	.4byte		.L3101
	.uleb128	6799
	.uleb128	31
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4160
.L4161:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6806
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4162
.L4163:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6807
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4164
.L4165:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6809
	.uleb128	55
	.byte		"pDid"
	.byte		0
	.4byte		.L4166
	.4byte		.L4170
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4174
	.4byte		.L4171
	.4byte		.L4172
.L4175:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6853
	.uleb128	17
	.byte		"tempDidLength"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4176:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6854
	.uleb128	25
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4177
	.section	.debug_info,,n
	.sleb128	0
.L4174:
	.section	.debug_info,,n
	.sleb128	0
.L4151:
	.section	.debug_info,,n
.L4182:
	.sleb128	6
	.4byte		.L4179-.L2
	.byte		"IsDidAvailableWithinRange"
	.byte		0
	.4byte		.L3101
	.uleb128	6895
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L4180
	.4byte		.L4181
	.sleb128	4
	.4byte		.L3101
	.uleb128	6895
	.uleb128	32
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4183
	.sleb128	4
	.4byte		.L3101
	.uleb128	6895
	.uleb128	32
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4188
	.sleb128	4
	.4byte		.L3101
	.uleb128	6895
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4189
	.sleb128	4
	.4byte		.L3101
	.uleb128	6895
	.uleb128	32
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4190
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4194
	.4byte		.L4191
	.4byte		.L4192
.L4195:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6903
	.uleb128	28
	.byte		"supported"
	.byte		0
	.4byte		.L4196
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4197:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6904
	.uleb128	22
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4198
	.section	.debug_info,,n
	.sleb128	0
.L4194:
	.section	.debug_info,,n
	.sleb128	0
.L4179:
	.section	.debug_info,,n
.L4203:
	.sleb128	6
	.4byte		.L4200-.L2
	.byte		"CallReadDidDataLengthFunc"
	.byte		0
	.4byte		.L3101
	.uleb128	6940
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4201
	.4byte		.L4202
	.sleb128	4
	.4byte		.L3101
	.uleb128	6940
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4204
	.sleb128	4
	.4byte		.L3101
	.uleb128	6940
	.uleb128	31
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4205
	.sleb128	4
	.4byte		.L3101
	.uleb128	6940
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4206
	.sleb128	4
	.4byte		.L3101
	.uleb128	6940
	.uleb128	31
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4207
.L4208:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6945
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4209:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6946
	.uleb128	37
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L4210
	.section	.debug_info,,n
	.sleb128	0
.L4200:
	.section	.debug_info,,n
.L4215:
	.sleb128	6
	.4byte		.L4212-.L2
	.byte		"GetDidRangeLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4213
	.4byte		.L4214
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4216
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4217
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4218
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4219
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4220
	.sleb128	4
	.4byte		.L3101
	.uleb128	6977
	.uleb128	31
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4221
.L4222:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6984
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4223
.L4224:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6985
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4225
.L4226:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6987
	.uleb128	61
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4227
	.section	.debug_info,,n
	.sleb128	0
.L4212:
	.section	.debug_info,,n
.L4232:
	.sleb128	6
	.4byte		.L4229-.L2
	.byte		"GetCommonDidLength"
	.byte		0
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4230
	.4byte		.L4231
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4233
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"pCurrentValidDidIndex"
	.byte		0
	.4byte		.L3179
	.4byte		.L4234
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4235
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4236
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4237
	.sleb128	4
	.4byte		.L3101
	.uleb128	6567
	.uleb128	31
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4238
.L4239:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6574
	.uleb128	11
	.byte		"didLength"
	.byte		0
	.4byte		.L3125
	.4byte		.L4240
	.section	.debug_info,,n
	.sleb128	0
.L4229:
	.section	.debug_info,,n
.L4245:
	.sleb128	6
	.4byte		.L4242-.L2
	.byte		"ReadConfiguredDid"
	.byte		0
	.4byte		.L3101
	.uleb128	10808
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4243
	.4byte		.L4244
	.sleb128	4
	.4byte		.L3101
	.uleb128	10808
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3125
	.4byte		.L4246
	.sleb128	10
	.4byte		.L3101
	.uleb128	10808
	.uleb128	53
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	2
	.byte		0x90
	.uleb128	4
	.sleb128	10
	.4byte		.L3101
	.uleb128	10808
	.uleb128	53
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	4
	.4byte		.L3101
	.uleb128	10808
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4251
.L4252:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10813
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4253
.L4254:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10814
	.uleb128	55
	.byte		"pDid"
	.byte		0
	.4byte		.L4166
	.4byte		.L4255
.L4256:
	.sleb128	7
	.4byte		.L3101
	.uleb128	10816
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4260
	.4byte		.L4257
	.4byte		.L4258
.L4261:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10886
	.uleb128	25
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4262
	.section	.debug_info,,n
	.sleb128	0
.L4260:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4266
	.4byte		.L4263
	.4byte		.L4264
.L4267:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10927
	.uleb128	25
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4268
	.section	.debug_info,,n
	.sleb128	0
.L4266:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4272
	.4byte		.L4269
	.4byte		.L4270
.L4273:
	.sleb128	5
	.4byte		.L3101
	.uleb128	10972
	.uleb128	22
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4274
	.section	.debug_info,,n
	.sleb128	0
.L4272:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4278
	.4byte		.L4275
	.4byte		.L4276
.L4279:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11043
	.uleb128	25
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4280
	.section	.debug_info,,n
	.sleb128	0
.L4278:
	.section	.debug_info,,n
	.sleb128	0
.L4242:
	.section	.debug_info,,n
.L4285:
	.sleb128	6
	.4byte		.L4282-.L2
	.byte		"ReadConfiguredDidRange_Init"
	.byte		0
	.4byte		.L3101
	.uleb128	11156
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4283
	.4byte		.L4284
	.sleb128	4
	.4byte		.L3101
	.uleb128	11156
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4286
	.sleb128	4
	.4byte		.L3101
	.uleb128	11156
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4287
.L4288:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11159
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4289:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11160
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4290
.L4291:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11161
	.uleb128	60
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4292
	.section	.debug_info,,n
	.sleb128	0
.L4282:
	.section	.debug_info,,n
.L4297:
	.sleb128	6
	.4byte		.L4294-.L2
	.byte		"ReadConfiguredDidRange_Length"
	.byte		0
	.4byte		.L3101
	.uleb128	11229
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4295
	.4byte		.L4296
	.sleb128	4
	.4byte		.L3101
	.uleb128	11229
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4298
	.sleb128	4
	.4byte		.L3101
	.uleb128	11229
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4299
.L4300:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11232
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4301
.L4302:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11233
	.uleb128	65
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4303
	.4byte		.L4304
.L4305:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11235
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4306
	.section	.debug_info,,n
	.sleb128	0
.L4294:
	.section	.debug_info,,n
.L4311:
	.sleb128	6
	.4byte		.L4308-.L2
	.byte		"ReadConfiguredDidRange_Buffer"
	.byte		0
	.4byte		.L3101
	.uleb128	11271
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4309
	.4byte		.L4310
	.sleb128	4
	.4byte		.L3101
	.uleb128	11271
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4312
	.sleb128	4
	.4byte		.L3101
	.uleb128	11271
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4313
.L4314:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11274
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4315
.L4316:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11275
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4317
	.section	.debug_info,,n
	.sleb128	0
.L4308:
	.section	.debug_info,,n
.L4322:
	.sleb128	6
	.4byte		.L4319-.L2
	.byte		"ReadConfiguredDidRange_Data"
	.byte		0
	.4byte		.L3101
	.uleb128	11326
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4320
	.4byte		.L4321
	.sleb128	4
	.4byte		.L3101
	.uleb128	11326
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4323
	.sleb128	4
	.4byte		.L3101
	.uleb128	11326
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4324
.L4325:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11329
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4326:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11330
	.uleb128	60
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4327
.L4328:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11335
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4329
	.section	.debug_info,,n
	.sleb128	0
.L4319:
	.section	.debug_info,,n
.L4334:
	.sleb128	6
	.4byte		.L4331-.L2
	.byte		"ReadConfiguredDidRange"
	.byte		0
	.4byte		.L3101
	.uleb128	11120
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4332
	.4byte		.L4333
	.sleb128	4
	.4byte		.L3101
	.uleb128	11120
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4335
	.sleb128	10
	.4byte		.L3101
	.uleb128	11120
	.uleb128	53
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	2
	.byte		0x90
	.uleb128	4
	.sleb128	10
	.4byte		.L3101
	.uleb128	11120
	.uleb128	53
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	4
	.4byte		.L3101
	.uleb128	11120
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4336
.L4337:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11125
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4338
	.section	.debug_info,,n
	.sleb128	0
.L4331:
	.section	.debug_info,,n
.L4343:
	.sleb128	6
	.4byte		.L4340-.L2
	.byte		"ReadOBDDataAndInfoType"
	.byte		0
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4341
	.4byte		.L4342
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3190
	.4byte		.L4344
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4345
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"readObdFunc"
	.byte		0
	.4byte		.L4346
	.4byte		.L4350
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"idSupport"
	.byte		0
	.4byte		.L4067
	.4byte		.L4351
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4352
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"position"
	.byte		0
	.4byte		.L3157
	.4byte		.L4353
	.sleb128	4
	.4byte		.L3101
	.uleb128	11811
	.uleb128	53
	.byte		"sizeOfMemory"
	.byte		0
	.4byte		.L3157
	.4byte		.L4354
.L4355:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11819
	.uleb128	28
	.byte		"obdId"
	.byte		0
	.4byte		.L3190
	.4byte		.L4356
.L4357:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11820
	.uleb128	28
	.byte		"bufPos"
	.byte		0
	.4byte		.L3190
	.4byte		.L4358
.L4359:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11821
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4360
.L4361:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11822
	.uleb128	44
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4362:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11823
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4363
.L4364:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11829
	.uleb128	37
	.byte		"sizeOfSupportedInfo"
	.byte		0
	.4byte		.L3706
	.4byte		.L4365
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4369
	.4byte		.L4366
	.4byte		.L4367
.L4370:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11840
	.uleb128	22
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4371
	.section	.debug_info,,n
	.sleb128	0
.L4369:
	.section	.debug_info,,n
	.sleb128	0
.L4340:
	.section	.debug_info,,n
.L4376:
	.sleb128	6
	.4byte		.L4373-.L2
	.byte		"ReadDynamicallyDefinedDid"
	.byte		0
	.4byte		.L3101
	.uleb128	11356
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4374
	.4byte		.L4375
	.sleb128	4
	.4byte		.L3101
	.uleb128	11356
	.uleb128	53
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3125
	.4byte		.L4377
	.sleb128	4
	.4byte		.L3101
	.uleb128	11356
	.uleb128	53
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4378
	.sleb128	4
	.4byte		.L3101
	.uleb128	11356
	.uleb128	53
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4379
	.sleb128	4
	.4byte		.L3101
	.uleb128	11356
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L4380
.L4381:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11361
	.uleb128	19
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4382
.L4383:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11362
	.uleb128	19
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4384
.L4385:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11363
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4386
.L4387:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11364
	.uleb128	70
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L4388
.L4389:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11365
	.uleb128	43
	.byte		"pBuf"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	16
.L4390:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11366
	.uleb128	11
	.byte		"didSize"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	14
.L4391:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11368
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
	.section	.debug_info,,n
	.sleb128	0
.L4373:
	.section	.debug_info,,n
.L4396:
	.sleb128	9
	.4byte		.L4393-.L2
	.byte		"Dcm_ReadDataByIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	4057
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4394
	.4byte		.L4395
	.sleb128	10
	.4byte		.L3101
	.uleb128	4057
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	4057
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4397
	.sleb128	4
	.4byte		.L3101
	.uleb128	4057
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4398
.L4399:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4059
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4400:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4060
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4404
	.4byte		.L4401
	.4byte		.L4402
.L4405:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4129
	.uleb128	35
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4406
	.section	.debug_info,,n
	.sleb128	0
.L4404:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4410
	.4byte		.L4407
	.4byte		.L4408
.L4411:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4205
	.uleb128	77
	.byte		"pDidInfo"
	.byte		0
	.4byte		.L4412
	.4byte		.L4417
	.section	.debug_info,,n
	.sleb128	0
.L4410:
	.section	.debug_info,,n
	.sleb128	0
.L4393:
	.section	.debug_info,,n
.L4422:
	.sleb128	9
	.4byte		.L4419-.L2
	.byte		"Dcm_ReadScalingByIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	4290
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4420
	.4byte		.L4421
	.sleb128	4
	.4byte		.L3101
	.uleb128	4290
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4423
	.sleb128	4
	.4byte		.L3101
	.uleb128	4290
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4424
	.sleb128	4
	.4byte		.L3101
	.uleb128	4290
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4425
.L4426:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4293
	.uleb128	11
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3125
	.4byte		.L4427
.L4428:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4294
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4429
.L4430:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4295
	.uleb128	55
	.byte		"pDid"
	.byte		0
	.4byte		.L4166
	.4byte		.L4431
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4435
	.4byte		.L4432
	.4byte		.L4433
.L4436:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4303
	.uleb128	36
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L4437
	.section	.debug_info,,n
	.sleb128	0
.L4435:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4441
	.4byte		.L4438
	.4byte		.L4439
.L4442:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4387
	.uleb128	43
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3407
	.4byte		.L4443
	.section	.debug_info,,n
	.sleb128	0
.L4441:
	.section	.debug_info,,n
	.sleb128	0
.L4419:
	.section	.debug_info,,n
.L4448:
	.sleb128	6
	.4byte		.L4445-.L2
	.byte		"CountConfiguredPeriodicDids"
	.byte		0
	.4byte		.L3101
	.uleb128	4426
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4446
	.4byte		.L4447
	.sleb128	4
	.4byte		.L3101
	.uleb128	4426
	.uleb128	31
	.byte		"pDids"
	.byte		0
	.4byte		.L4067
	.4byte		.L4449
	.sleb128	4
	.4byte		.L3101
	.uleb128	4426
	.uleb128	31
	.byte		"numDids"
	.byte		0
	.4byte		.L3507
	.4byte		.L4450
.L4451:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4429
	.uleb128	11
	.byte		"didIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4452
.L4453:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4430
	.uleb128	11
	.byte		"didCount"
	.byte		0
	.4byte		.L3125
	.4byte		.L4454
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4458
	.4byte		.L4455
	.4byte		.L4456
.L4459:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4437
	.uleb128	14
	.byte		"periodicDynamicDidIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4460
.L4461:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4438
	.uleb128	20
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4462
	.section	.debug_info,,n
	.sleb128	0
.L4458:
	.section	.debug_info,,n
	.sleb128	0
.L4445:
	.section	.debug_info,,n
.L4467:
	.sleb128	6
	.4byte		.L4464-.L2
	.byte		"IsValidPeriodicDid"
	.byte		0
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.4byte		.L3129
	.byte		0x1
	.4byte		.L4465
	.4byte		.L4466
	.sleb128	4
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4468
	.sleb128	4
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4469
	.sleb128	4
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.byte		"didId"
	.byte		0
	.4byte		.L3157
	.4byte		.L4470
	.sleb128	4
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.byte		"index"
	.byte		0
	.4byte		.L3180
	.4byte		.L4471
	.sleb128	4
	.4byte		.L3101
	.uleb128	12962
	.uleb128	32
	.byte		"numStored"
	.byte		0
	.4byte		.L3125
	.4byte		.L4472
.L4473:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12966
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4474
.L4475:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12967
	.uleb128	29
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4476
.L4477:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12968
	.uleb128	12
	.byte		"valid"
	.byte		0
	.4byte		.L3129
	.4byte		.L4478
.L4479:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12969
	.uleb128	35
	.byte		"pSelectedMemoryRange"
	.byte		0
	.4byte		.L3199
	.4byte		.L4480
.L4481:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12970
	.uleb128	70
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L4482
	.section	.debug_info,,n
	.sleb128	0
.L4464:
	.section	.debug_info,,n
.L4487:
	.sleb128	6
	.4byte		.L4484-.L2
	.byte		"StopSomeDIDs"
	.byte		0
	.4byte		.L3101
	.uleb128	13067
	.uleb128	31
	.4byte		.L3125
	.byte		0x1
	.4byte		.L4485
	.4byte		.L4486
	.sleb128	4
	.4byte		.L3101
	.uleb128	13067
	.uleb128	31
	.byte		"pRequestedDids"
	.byte		0
	.4byte		.L4067
	.4byte		.L4488
	.sleb128	4
	.4byte		.L3101
	.uleb128	13067
	.uleb128	31
	.byte		"numRequested"
	.byte		0
	.4byte		.L3507
	.4byte		.L4489
.L4490:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13070
	.uleb128	11
	.byte		"didIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4491
.L4492:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13071
	.uleb128	11
	.byte		"numFound"
	.byte		0
	.4byte		.L3125
	.4byte		.L4493
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4497
	.4byte		.L4494
	.4byte		.L4495
.L4498:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13078
	.uleb128	14
	.byte		"periodicDidIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4499
.L4500:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13080
	.uleb128	20
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4501
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4505
	.4byte		.L4502
	.4byte		.L4503
.L4506:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13089
	.uleb128	20
	.byte		"periodicDidMoveIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4507
	.section	.debug_info,,n
	.sleb128	0
.L4505:
	.section	.debug_info,,n
	.sleb128	0
.L4497:
	.section	.debug_info,,n
	.sleb128	0
.L4484:
	.section	.debug_info,,n
.L4512:
	.sleb128	3
	.4byte		.L4509-.L2
	.byte		"StartPeriodicTransmission"
	.byte		0
	.4byte		.L3101
	.uleb128	13125
	.uleb128	29
	.byte		0x1
	.4byte		.L4510
	.4byte		.L4511
	.section	.debug_info,,n
	.sleb128	0
.L4509:
	.section	.debug_info,,n
.L4517:
	.sleb128	9
	.4byte		.L4514-.L2
	.byte		"Dcm_ReadDataByPeriodicIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	4460
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4515
	.4byte		.L4516
	.sleb128	10
	.4byte		.L3101
	.uleb128	4460
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	4460
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4518
	.sleb128	4
	.4byte		.L3101
	.uleb128	4460
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4519
.L4520:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4463
	.uleb128	19
	.byte		"i"
	.byte		0
	.4byte		.L3193
	.4byte		.L4521
.L4522:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4464
	.uleb128	11
	.byte		"didIndex"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L4523:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4465
	.uleb128	59
	.byte		"pStatus"
	.byte		0
	.4byte		.L4524
	.4byte		.L4525
.L4526:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4466
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4527:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4467
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L4528:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4473
	.uleb128	16
	.byte		"requestedTransmissionMode"
	.byte		0
	.4byte		.L3190
	.4byte		.L4529
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4533
	.4byte		.L4530
	.4byte		.L4531
.L4534:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4523
	.uleb128	20
	.byte		"numStoppedDids"
	.byte		0
	.4byte		.L3507
	.4byte		.L4535
	.section	.debug_info,,n
	.sleb128	0
.L4533:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4539
	.4byte		.L4536
	.4byte		.L4537
.L4540:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4593
	.uleb128	14
	.byte		"numValidId"
	.byte		0
	.4byte		.L3125
	.4byte		.L4541
	.section	.debug_info,,n
	.sleb128	0
.L4539:
	.section	.debug_info,,n
	.sleb128	0
.L4514:
	.section	.debug_info,,n
.L4546:
	.sleb128	2
	.4byte		.L4543-.L2
	.byte		"Dcm_DspConfirmPeriodicTxData"
	.byte		0
	.4byte		.L3101
	.uleb128	4700
	.uleb128	22
	.byte		0x1
	.byte		0x1
	.4byte		.L4544
	.4byte		.L4545
.L4547:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4702
	.uleb128	59
	.byte		"pPeriodicStatus"
	.byte		0
	.4byte		.L4524
	.4byte		.L4548
	.section	.debug_info,,n
	.sleb128	0
.L4543:
	.section	.debug_info,,n
.L4554:
	.sleb128	6
	.4byte		.L4550-.L2
	.byte		"GetSourceDid"
	.byte		0
	.4byte		.L3101
	.uleb128	13810
	.uleb128	47
	.4byte		.L4553
	.byte		0x1
	.4byte		.L4551
	.4byte		.L4552
	.sleb128	4
	.4byte		.L3101
	.uleb128	13810
	.uleb128	47
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3125
	.4byte		.L4555
	.sleb128	4
	.4byte		.L3101
	.uleb128	13810
	.uleb128	47
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4556
	.sleb128	4
	.4byte		.L3101
	.uleb128	13810
	.uleb128	47
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4557
	.sleb128	4
	.4byte		.L3101
	.uleb128	13810
	.uleb128	47
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4558
.L4559:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13815
	.uleb128	34
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4560
.L4561:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13816
	.uleb128	55
	.byte		"pSrcDid"
	.byte		0
	.4byte		.L4166
	.4byte		.L4562
	.section	.debug_info,,n
	.sleb128	0
.L4550:
	.section	.debug_info,,n
.L4567:
	.sleb128	6
	.4byte		.L4564-.L2
	.byte		"DefineDDDidByIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	13881
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4565
	.4byte		.L4566
	.sleb128	4
	.4byte		.L3101
	.uleb128	13881
	.uleb128	53
	.byte		"pDid"
	.byte		0
	.4byte		.L4121
	.4byte		.L4568
	.sleb128	4
	.4byte		.L3101
	.uleb128	13881
	.uleb128	53
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.4byte		.L4569
	.sleb128	4
	.4byte		.L3101
	.uleb128	13881
	.uleb128	53
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.4byte		.L4570
	.sleb128	4
	.4byte		.L3101
	.uleb128	13881
	.uleb128	53
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L4571
.L4572:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13886
	.uleb128	28
	.byte		"numRequestedSources"
	.byte		0
	.4byte		.L3190
	.4byte		.L4573
.L4574:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13887
	.uleb128	29
	.byte		"lengthSource"
	.byte		0
	.4byte		.L3507
	.4byte		.L4575
.L4576:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13888
	.uleb128	12
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4577
.L4578:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13889
	.uleb128	10
	.byte		"numStoredSources"
	.byte		0
	.4byte		.L3157
	.4byte		.L4579
.L4580:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13890
	.uleb128	10
	.byte		"positionSourceRecord"
	.byte		0
	.4byte		.L3157
	.4byte		.L4581
.L4582:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13891
	.uleb128	10
	.byte		"sizeOfMemory"
	.byte		0
	.4byte		.L3157
	.4byte		.L4583
.L4584:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13892
	.uleb128	11
	.byte		"sourceId"
	.byte		0
	.4byte		.L3125
	.4byte		.L4585
.L4586:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13893
	.uleb128	11
	.byte		"sizeOfSrcDid"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
.L4587:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13894
	.uleb128	11
	.byte		"totalLength"
	.byte		0
	.4byte		.L3206
	.4byte		.L4588
.L4589:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13895
	.uleb128	27
	.byte		"pSrcDid"
	.byte		0
	.4byte		.L4553
	.4byte		.L4590
.L4591:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13896
	.uleb128	62
	.byte		"pDataSource"
	.byte		0
	.4byte		.L4592
	.4byte		.L4593
.L4594:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13897
	.uleb128	12
	.byte		"isVehInfo"
	.byte		0
	.4byte		.L3129
	.4byte		.L4595
.L4596:
	.sleb128	7
	.4byte		.L3101
	.uleb128	13899
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4597:
	.sleb128	5
	.4byte		.L3101
	.uleb128	13902
	.uleb128	51
	.byte		"pSourceDids"
	.byte		0
	.4byte		.L4067
	.4byte		.L4598
	.section	.debug_info,,n
	.sleb128	0
.L4564:
	.section	.debug_info,,n
.L4603:
	.sleb128	6
	.4byte		.L4600-.L2
	.byte		"ParseMemoryParameter"
	.byte		0
	.4byte		.L3101
	.uleb128	12794
	.uleb128	31
	.4byte		.L3206
	.byte		0x1
	.4byte		.L4601
	.4byte		.L4602
	.sleb128	4
	.4byte		.L3101
	.uleb128	12794
	.uleb128	31
	.byte		"parameterData"
	.byte		0
	.4byte		.L3983
	.4byte		.L4604
	.sleb128	4
	.4byte		.L3101
	.uleb128	12794
	.uleb128	31
	.byte		"parameterLength"
	.byte		0
	.4byte		.L3157
	.4byte		.L4605
.L4606:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12796
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4607
.L4608:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12797
	.uleb128	11
	.byte		"parameter"
	.byte		0
	.4byte		.L3206
	.4byte		.L4609
	.section	.debug_info,,n
	.sleb128	0
.L4600:
	.section	.debug_info,,n
.L4614:
	.sleb128	6
	.4byte		.L4611-.L2
	.byte		"DefineDDDidByMemoryAddress"
	.byte		0
	.4byte		.L3101
	.uleb128	14073
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4612
	.4byte		.L4613
	.sleb128	4
	.4byte		.L3101
	.uleb128	14073
	.uleb128	53
	.byte		"pDid"
	.byte		0
	.4byte		.L4121
	.4byte		.L4615
	.sleb128	4
	.4byte		.L3101
	.uleb128	14073
	.uleb128	53
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3464
	.4byte		.L4616
.L4617:
	.sleb128	7
	.4byte		.L3101
	.uleb128	14076
	.uleb128	28
	.byte		"dataStructure"
	.byte		0
	.4byte		.L4618
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4620:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14078
	.uleb128	29
	.byte		"lengthSource"
	.byte		0
	.4byte		.L3507
	.4byte		.L4621
.L4622:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14079
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4623
.L4624:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14080
	.uleb128	10
	.byte		"numRequestedSources"
	.byte		0
	.4byte		.L3157
	.4byte		.L4625
.L4626:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14081
	.uleb128	10
	.byte		"numStoredSources"
	.byte		0
	.4byte		.L3157
	.4byte		.L4627
.L4628:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14082
	.uleb128	10
	.byte		"sourceItemLength"
	.byte		0
	.4byte		.L3157
	.4byte		.L4629
.L4630:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14083
	.uleb128	11
	.byte		"totalLength"
	.byte		0
	.4byte		.L3206
	.4byte		.L4631
.L4632:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14085
	.uleb128	35
	.byte		"pSelectedMemoryRange"
	.byte		0
	.4byte		.L3199
	.4byte		.L4633
.L4634:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14086
	.uleb128	62
	.byte		"pDataSource"
	.byte		0
	.4byte		.L4592
	.4byte		.L4635
.L4636:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14088
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4637
.L4638:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14091
	.uleb128	51
	.byte		"pSourceMemory"
	.byte		0
	.4byte		.L4067
	.4byte		.L4639
	.section	.debug_info,,n
	.sleb128	0
.L4611:
	.section	.debug_info,,n
.L4644:
	.sleb128	9
	.4byte		.L4641-.L2
	.byte		"Dcm_DynamicallyDefineDataIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	4762
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4642
	.4byte		.L4643
	.sleb128	10
	.4byte		.L3101
	.uleb128	4762
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	4762
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4645
	.sleb128	4
	.4byte		.L3101
	.uleb128	4762
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4646
.L4647:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4765
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4648
.L4649:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4766
	.uleb128	11
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3125
	.4byte		.L4650
.L4651:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4767
	.uleb128	70
	.byte		"pDid"
	.byte		0
	.4byte		.L3249
	.4byte		.L4652
.L4653:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4768
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4654:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4769
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L4655:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4771
	.uleb128	28
	.byte		"subFunc"
	.byte		0
	.4byte		.L3190
	.4byte		.L4656
	.section	.debug_info,,n
	.sleb128	0
.L4641:
	.section	.debug_info,,n
.L4661:
	.sleb128	3
	.4byte		.L4658-.L2
	.byte		"ChangeAsyncState"
	.byte		0
	.4byte		.L3101
	.uleb128	12920
	.uleb128	29
	.byte		0x1
	.4byte		.L4659
	.4byte		.L4660
	.sleb128	4
	.4byte		.L3101
	.uleb128	12920
	.uleb128	29
	.byte		"pAsynchState"
	.byte		0
	.4byte		.L4662
	.4byte		.L4665
	.sleb128	4
	.4byte		.L3101
	.uleb128	12920
	.uleb128	29
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3572
	.4byte		.L4666
	.section	.debug_info,,n
	.sleb128	0
.L4658:
	.section	.debug_info,,n
.L4671:
	.sleb128	3
	.4byte		.L4668-.L2
	.byte		"DidWriteHelperFunction"
	.byte		0
	.4byte		.L3101
	.uleb128	14376
	.uleb128	29
	.byte		0x1
	.4byte		.L4669
	.4byte		.L4670
	.sleb128	4
	.4byte		.L3101
	.uleb128	14376
	.uleb128	29
	.byte		"pStatus"
	.byte		0
	.4byte		.L4672
	.4byte		.L4676
	.sleb128	4
	.4byte		.L3101
	.uleb128	14376
	.uleb128	29
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4677
	.sleb128	4
	.4byte		.L3101
	.uleb128	14376
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4678
.L4679:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14380
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4680
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4684
	.4byte		.L4681
	.4byte		.L4682
.L4685:
	.sleb128	7
	.4byte		.L3101
	.uleb128	14404
	.uleb128	28
	.byte		"supported"
	.byte		0
	.4byte		.L4196
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L4684:
	.section	.debug_info,,n
	.sleb128	0
.L4668:
	.section	.debug_info,,n
.L4690:
	.sleb128	9
	.4byte		.L4687-.L2
	.byte		"Dcm_WriteDataByIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	4955
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4688
	.4byte		.L4689
	.sleb128	10
	.4byte		.L3101
	.uleb128	4955
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	4955
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4691
	.sleb128	4
	.4byte		.L3101
	.uleb128	4955
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4692
.L4693:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4958
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4694
.L4695:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4959
	.uleb128	56
	.byte		"pDid"
	.byte		0
	.4byte		.L4166
	.4byte		.L4696
.L4697:
	.sleb128	5
	.4byte		.L3101
	.uleb128	4960
	.uleb128	61
	.byte		"pDidRange"
	.byte		0
	.4byte		.L4184
	.4byte		.L4698
.L4699:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4961
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4700:
	.sleb128	7
	.4byte		.L3101
	.uleb128	4962
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
	.section	.debug_info,,n
	.sleb128	0
.L4687:
	.section	.debug_info,,n
.L4705:
	.sleb128	3
	.4byte		.L4702-.L2
	.byte		"DidControlHelpFunc"
	.byte		0
	.4byte		.L3101
	.uleb128	14318
	.uleb128	29
	.byte		0x1
	.4byte		.L4703
	.4byte		.L4704
	.sleb128	4
	.4byte		.L3101
	.uleb128	14318
	.uleb128	29
	.byte		"status"
	.byte		0
	.4byte		.L4706
	.4byte		.L4711
	.sleb128	4
	.4byte		.L3101
	.uleb128	14318
	.uleb128	29
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4712
	.sleb128	4
	.4byte		.L3101
	.uleb128	14318
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4713
.L4714:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14322
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4715
	.section	.debug_info,,n
	.sleb128	0
.L4702:
	.section	.debug_info,,n
.L4720:
	.sleb128	9
	.4byte		.L4717-.L2
	.byte		"Dcm_InputOutputControlByIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	5189
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4718
	.4byte		.L4719
	.sleb128	10
	.4byte		.L3101
	.uleb128	5189
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x90
	.uleb128	3
	.sleb128	4
	.4byte		.L3101
	.uleb128	5189
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4721
	.sleb128	4
	.4byte		.L3101
	.uleb128	5189
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4722
.L4723:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5192
	.uleb128	11
	.byte		"confDidCounter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4724
.L4725:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5193
	.uleb128	29
	.byte		"didIdentifier"
	.byte		0
	.4byte		.L3507
	.4byte		.L4726
.L4727:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5194
	.uleb128	20
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4728:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5195
	.uleb128	21
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L4729:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5196
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4730
.L4731:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5198
	.uleb128	43
	.byte		"pBuf"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L4732:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5204
	.uleb128	28
	.byte		"ioControlParameter"
	.byte		0
	.4byte		.L3190
	.4byte		.L4733
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4737
	.4byte		.L4734
	.4byte		.L4735
.L4738:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5493
	.uleb128	25
	.byte		"i"
	.byte		0
	.4byte		.L3193
	.4byte		.L4739
	.section	.debug_info,,n
	.sleb128	0
.L4737:
	.section	.debug_info,,n
	.sleb128	0
.L4717:
	.section	.debug_info,,n
.L4744:
	.sleb128	3
	.4byte		.L4741-.L2
	.byte		"RoutineControlHelpFunc"
	.byte		0
	.4byte		.L3101
	.uleb128	6333
	.uleb128	29
	.byte		0x1
	.4byte		.L4742
	.4byte		.L4743
	.sleb128	4
	.4byte		.L3101
	.uleb128	6333
	.uleb128	29
	.byte		"pStatus"
	.byte		0
	.4byte		.L4745
	.4byte		.L4749
	.sleb128	4
	.4byte		.L3101
	.uleb128	6333
	.uleb128	29
	.byte		"opStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4750
	.sleb128	4
	.4byte		.L3101
	.uleb128	6333
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4751
.L4752:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6337
	.uleb128	19
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4753
.L4754:
	.sleb128	7
	.4byte		.L3101
	.uleb128	6338
	.uleb128	11
	.byte		"dataLength"
	.byte		0
	.4byte		.L3125
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	0
.L4741:
	.section	.debug_info,,n
.L4759:
	.sleb128	6
	.4byte		.L4756-.L2
	.byte		"StoreSupportedTypes"
	.byte		0
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4757
	.4byte		.L4758
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3190
	.4byte		.L4760
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"requestData"
	.byte		0
	.4byte		.L4067
	.4byte		.L4761
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"requestDataLength"
	.byte		0
	.4byte		.L3193
	.4byte		.L4762
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"responseData"
	.byte		0
	.4byte		.L3234
	.4byte		.L4763
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"pResponseDataLength"
	.byte		0
	.4byte		.L4764
	.4byte		.L4766
	.sleb128	4
	.4byte		.L3101
	.uleb128	12428
	.uleb128	53
	.byte		"pSupport"
	.byte		0
	.4byte		.L4067
	.4byte		.L4767
.L4768:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12435
	.uleb128	10
	.byte		"supportPos"
	.byte		0
	.4byte		.L3157
	.4byte		.L4769
.L4770:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12436
	.uleb128	10
	.byte		"responsePos"
	.byte		0
	.4byte		.L3157
	.4byte		.L4771
.L4772:
	.sleb128	7
	.4byte		.L3101
	.uleb128	12437
	.uleb128	10
	.byte		"infoTypes"
	.byte		0
	.4byte		.L4773
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4775:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12438
	.uleb128	11
	.byte		"i"
	.byte		0
	.4byte		.L3125
	.4byte		.L4776
.L4777:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12439
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4778
.L4779:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12446
	.uleb128	28
	.byte		"delta"
	.byte		0
	.4byte		.L3190
	.4byte		.L4780
.L4781:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12447
	.uleb128	28
	.byte		"pidLength"
	.byte		0
	.4byte		.L3190
	.4byte		.L4782
	.section	.debug_info,,n
	.sleb128	0
.L4756:
	.section	.debug_info,,n
.L4787:
	.sleb128	9
	.4byte		.L4784-.L2
	.byte		"Dcm_RoutineControl"
	.byte		0
	.4byte		.L3101
	.uleb128	5609
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4785
	.4byte		.L4786
	.sleb128	4
	.4byte		.L3101
	.uleb128	5609
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4788
	.sleb128	4
	.4byte		.L3101
	.uleb128	5609
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4789
	.sleb128	4
	.4byte		.L3101
	.uleb128	5609
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4790
.L4791:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5611
	.uleb128	29
	.byte		"routineId"
	.byte		0
	.4byte		.L3507
	.4byte		.L4792
.L4793:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5613
	.uleb128	12
	.byte		"udsRequest"
	.byte		0
	.4byte		.L3129
	.4byte		.L4794
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4798
	.4byte		.L4795
	.4byte		.L4796
.L4799:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5662
	.uleb128	34
	.byte		"obdRoutineId"
	.byte		0
	.4byte		.L3190
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4803
	.4byte		.L4800
	.4byte		.L4801
.L4804:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5702
	.uleb128	69
	.byte		"pReqCtrl"
	.byte		0
	.4byte		.L4805
	.4byte		.L4809
.L4810:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5703
	.uleb128	20
	.byte		"counter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4811
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4815
	.4byte		.L4812
	.4byte		.L4813
.L4816:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5739
	.uleb128	55
	.byte		"pReqBuf"
	.byte		0
	.4byte		.L3235
	.4byte		.L4817
	.section	.debug_info,,n
	.sleb128	0
.L4815:
	.section	.debug_info,,n
	.sleb128	0
.L4803:
	.section	.debug_info,,n
	.sleb128	0
.L4798:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4821
	.4byte		.L4818
	.4byte		.L4819
.L4822:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5781
	.uleb128	17
	.byte		"counter"
	.byte		0
	.4byte		.L3125
	.4byte		.L4823
.L4824:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5782
	.uleb128	26
	.byte		"activeSession"
	.byte		0
	.4byte		.L3166
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	9
.L4825:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5783
	.uleb128	27
	.byte		"activeSecurityLevel"
	.byte		0
	.4byte		.L3168
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	10
	.section	.debug_info,,n
	.sleb128	0
.L4821:
	.section	.debug_info,,n
	.sleb128	0
.L4784:
	.section	.debug_info,,n
.L4831:
	.sleb128	6
	.4byte		.L4828-.L2
	.byte		"HandleMemoryOpResult"
	.byte		0
	.4byte		.L3101
	.uleb128	12857
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4829
	.4byte		.L4830
	.sleb128	4
	.4byte		.L3101
	.uleb128	12857
	.uleb128	53
	.byte		"memOperationResult"
	.byte		0
	.4byte		.L4832
	.4byte		.L4833
	.sleb128	4
	.4byte		.L3101
	.uleb128	12857
	.uleb128	53
	.byte		"operationKind"
	.byte		0
	.4byte		.L4834
	.4byte		.L4836
.L4837:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12859
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4838
	.section	.debug_info,,n
	.sleb128	0
.L4828:
	.section	.debug_info,,n
.L4844:
	.sleb128	6
	.4byte		.L4841-.L2
	.byte		"GenericMemoryAddressOperation"
	.byte		0
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.4byte		.L3156
	.byte		0x1
	.4byte		.L4842
	.4byte		.L4843
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4845
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L4846
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"pMemConf"
	.byte		0
	.4byte		.L3210
	.4byte		.L4847
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"operationKind"
	.byte		0
	.4byte		.L4834
	.4byte		.L4848
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"pMemoryInitialisationFunc"
	.byte		0
	.4byte		.L4849
	.4byte		.L4857
	.sleb128	4
	.4byte		.L3101
	.uleb128	12532
	.uleb128	39
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3182
	.4byte		.L4858
.L4859:
	.sleb128	7
	.4byte		.L3101
	.uleb128	12539
	.uleb128	28
	.byte		"dataStructure"
	.byte		0
	.4byte		.L4618
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4860:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12541
	.uleb128	35
	.byte		"pSelectedMemoryRange"
	.byte		0
	.4byte		.L3199
	.4byte		.L4861
.L4862:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12542
	.uleb128	31
	.byte		"memOperationResult"
	.byte		0
	.4byte		.L4832
	.4byte		.L4863
	.section	.debug_info,,n
	.sleb128	0
.L4841:
	.section	.debug_info,,n
.L4868:
	.sleb128	9
	.4byte		.L4865-.L2
	.byte		"Dcm_ReadMemoryByAddress"
	.byte		0
	.4byte		.L3101
	.uleb128	5928
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4866
	.4byte		.L4867
	.sleb128	4
	.4byte		.L3101
	.uleb128	5928
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4869
	.sleb128	4
	.4byte		.L3101
	.uleb128	5928
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4870
	.sleb128	4
	.4byte		.L3101
	.uleb128	5928
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4871
	.section	.debug_info,,n
	.sleb128	0
.L4865:
	.section	.debug_info,,n
.L4876:
	.sleb128	9
	.4byte		.L4873-.L2
	.byte		"Dcm_WriteMemoryByAddress"
	.byte		0
	.4byte		.L3101
	.uleb128	5936
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4874
	.4byte		.L4875
	.sleb128	4
	.4byte		.L3101
	.uleb128	5936
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4877
	.sleb128	4
	.4byte		.L3101
	.uleb128	5936
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4878
	.sleb128	4
	.4byte		.L3101
	.uleb128	5936
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4879
	.section	.debug_info,,n
	.sleb128	0
.L4873:
	.section	.debug_info,,n
.L4884:
	.sleb128	9
	.4byte		.L4881-.L2
	.byte		"Dcm_RequestDownload"
	.byte		0
	.4byte		.L3101
	.uleb128	5944
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4882
	.4byte		.L4883
	.sleb128	4
	.4byte		.L3101
	.uleb128	5944
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4885
	.sleb128	4
	.4byte		.L3101
	.uleb128	5944
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4886
	.sleb128	4
	.4byte		.L3101
	.uleb128	5944
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4887
.L4888:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5946
	.uleb128	11
	.byte		"maxBlockLength"
	.byte		0
	.4byte		.L3206
	.4byte		.L4889
.L4890:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5947
	.uleb128	10
	.byte		"dataFormatIdentifier"
	.byte		0
	.4byte		.L3157
	.4byte		.L4891
.L4892:
	.sleb128	7
	.4byte		.L3101
	.uleb128	5948
	.uleb128	28
	.byte		"dataStructure"
	.byte		0
	.4byte		.L4618
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4893:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5950
	.uleb128	33
	.byte		"pRxChannel"
	.byte		0
	.4byte		.L3365
	.4byte		.L4894
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4898
	.4byte		.L4895
	.4byte		.L4896
.L4899:
	.sleb128	5
	.4byte		.L3101
	.uleb128	5964
	.uleb128	22
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4900
	.section	.debug_info,,n
	.sleb128	0
.L4898:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4904
	.4byte		.L4901
	.4byte		.L4902
.L4905:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6053
	.uleb128	28
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4906
	.section	.debug_info,,n
	.sleb128	0
.L4904:
	.section	.debug_info,,n
	.sleb128	0
.L4881:
	.section	.debug_info,,n
.L4911:
	.sleb128	3
	.4byte		.L4908-.L2
	.byte		"TransferData_Initial"
	.byte		0
	.4byte		.L3101
	.uleb128	14561
	.uleb128	29
	.byte		0x1
	.4byte		.L4909
	.4byte		.L4910
	.sleb128	4
	.4byte		.L3101
	.uleb128	14561
	.uleb128	29
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4912
	.sleb128	4
	.4byte		.L3101
	.uleb128	14561
	.uleb128	29
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4913
.L4914:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14569
	.uleb128	28
	.byte		"newSequenceNumber"
	.byte		0
	.4byte		.L3190
	.4byte		.L4915
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4919
	.4byte		.L4916
	.4byte		.L4917
.L4920:
	.sleb128	5
	.4byte		.L3101
	.uleb128	14655
	.uleb128	55
	.byte		"memOpRetVal"
	.byte		0
	.4byte		.L4921
	.4byte		.L4922
	.section	.debug_info,,n
	.sleb128	0
.L4919:
	.section	.debug_info,,n
	.sleb128	0
.L4908:
	.section	.debug_info,,n
.L4927:
	.sleb128	9
	.4byte		.L4924-.L2
	.byte		"Dcm_TransferData"
	.byte		0
	.4byte		.L3101
	.uleb128	6138
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4925
	.4byte		.L4926
	.sleb128	4
	.4byte		.L3101
	.uleb128	6138
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4928
	.sleb128	4
	.4byte		.L3101
	.uleb128	6138
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4929
	.sleb128	4
	.4byte		.L3101
	.uleb128	6138
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4930
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4934
	.4byte		.L4931
	.4byte		.L4932
.L4935:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6147
	.uleb128	52
	.byte		"memOpRetVal"
	.byte		0
	.4byte		.L4921
	.4byte		.L4936
	.section	.debug_info,,n
	.sleb128	0
.L4934:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4940
	.4byte		.L4937
	.4byte		.L4938
	.section	.debug_info,,n
	.sleb128	0
.L4940:
	.section	.debug_info,,n
	.sleb128	0
.L4924:
	.section	.debug_info,,n
.L4945:
	.sleb128	9
	.4byte		.L4942-.L2
	.byte		"Dcm_RequestTransferExit"
	.byte		0
	.4byte		.L3101
	.uleb128	6201
	.uleb128	32
	.4byte		.L3156
	.byte		0x1
	.byte		0x1
	.4byte		.L4943
	.4byte		.L4944
	.sleb128	4
	.4byte		.L3101
	.uleb128	6201
	.uleb128	32
	.byte		"OpStatus"
	.byte		0
	.4byte		.L3353
	.4byte		.L4946
	.sleb128	4
	.4byte		.L3101
	.uleb128	6201
	.uleb128	32
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3354
	.4byte		.L4947
	.sleb128	4
	.4byte		.L3101
	.uleb128	6201
	.uleb128	32
	.byte		"pErrorCode"
	.byte		0
	.4byte		.L3183
	.4byte		.L4948
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4952
	.4byte		.L4949
	.4byte		.L4950
.L4953:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6212
	.uleb128	22
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4954
	.section	.debug_info,,n
	.sleb128	0
.L4952:
	.section	.debug_info,,n
	.sleb128	8
	.4byte		.L4958
	.4byte		.L4955
	.4byte		.L4956
.L4959:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6233
	.uleb128	35
	.byte		"parameterRecordSize"
	.byte		0
	.4byte		.L3567
	.4byte		.L4960
.L4961:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6234
	.uleb128	54
	.byte		"parameterRecord"
	.byte		0
	.4byte		.L3234
	.4byte		.L4962
.L4963:
	.sleb128	5
	.4byte		.L3101
	.uleb128	6236
	.uleb128	25
	.byte		"stdRetVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4964
	.section	.debug_info,,n
	.sleb128	0
.L4958:
	.section	.debug_info,,n
	.sleb128	0
.L4942:
	.section	.debug_info,,n
.L4969:
	.sleb128	6
	.4byte		.L4966-.L2
	.byte		"ReadCommonPid"
	.byte		0
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4967
	.4byte		.L4968
	.sleb128	4
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3190
	.4byte		.L4970
	.sleb128	4
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.byte		"obdId"
	.byte		0
	.4byte		.L3190
	.4byte		.L4971
	.sleb128	10
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.sleb128	2
	.byte		0x90
	.uleb128	5
	.sleb128	4
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.byte		"position"
	.byte		0
	.4byte		.L3190
	.4byte		.L4972
	.sleb128	4
	.4byte		.L3101
	.uleb128	11594
	.uleb128	53
	.byte		"sizeOfMemory"
	.byte		0
	.4byte		.L3190
	.4byte		.L4973
.L4974:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11600
	.uleb128	10
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L4975
.L4976:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11601
	.uleb128	34
	.byte		"num_bytes"
	.byte		0
	.4byte		.L3125
	.4byte		.L4977
.L4978:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11602
	.uleb128	34
	.byte		"num_bits_left"
	.byte		0
	.4byte		.L3157
	.4byte		.L4979
.L4980:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11603
	.uleb128	34
	.byte		"DataIndex"
	.byte		0
	.4byte		.L3125
	.4byte		.L4981
.L4982:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11604
	.uleb128	34
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L4983
.L4984:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11605
	.uleb128	56
	.byte		"pPid"
	.byte		0
	.4byte		.L4098
	.4byte		.L4985
.L4986:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11606
	.uleb128	60
	.byte		"pData"
	.byte		0
	.4byte		.L4987
	.4byte		.L4991
.L4992:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11608
	.uleb128	44
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L4993:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11609
	.uleb128	44
	.byte		"dddidResBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L4994:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11611
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L4995
	.section	.debug_info,,n
	.sleb128	0
.L4966:
	.section	.debug_info,,n
.L5000:
	.sleb128	6
	.4byte		.L4997-.L2
	.byte		"ReadCommonOBDInfoTypeIdentifier"
	.byte		0
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L4998
	.4byte		.L4999
	.sleb128	4
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.byte		"sid"
	.byte		0
	.4byte		.L3190
	.4byte		.L5001
	.sleb128	4
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.byte		"obdId"
	.byte		0
	.4byte		.L3190
	.4byte		.L5002
	.sleb128	4
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4247
	.4byte		.L5003
	.sleb128	4
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.byte		"position"
	.byte		0
	.4byte		.L3190
	.4byte		.L5004
	.sleb128	4
	.4byte		.L3101
	.uleb128	11907
	.uleb128	53
	.byte		"sizeOfMemory"
	.byte		0
	.4byte		.L3190
	.4byte		.L5005
.L5006:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11913
	.uleb128	34
	.byte		"i"
	.byte		0
	.4byte		.L3157
	.4byte		.L5007
.L5008:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11914
	.uleb128	34
	.byte		"stdReturnVal"
	.byte		0
	.4byte		.L3156
	.4byte		.L5009
.L5010:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11915
	.uleb128	64
	.byte		"pVehInfo"
	.byte		0
	.4byte		.L4056
	.4byte		.L5011
.L5012:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11917
	.uleb128	19
	.byte		"totalAnswerSize"
	.byte		0
	.4byte		.L3193
	.4byte		.L5013
.L5014:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11918
	.uleb128	44
	.byte		"resBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	8
.L5015:
	.sleb128	7
	.4byte		.L3101
	.uleb128	11919
	.uleb128	44
	.byte		"dddidResBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	3
	.byte		0x92
	.uleb128	1
	.sleb128	12
.L5016:
	.sleb128	5
	.4byte		.L3101
	.uleb128	11921
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L5017
	.section	.debug_info,,n
	.sleb128	0
.L4997:
	.section	.debug_info,,n
.L5022:
	.sleb128	6
	.4byte		.L5019-.L2
	.byte		"ReadMemoryInitialisation"
	.byte		0
	.4byte		.L3101
	.uleb128	12710
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L5020
	.4byte		.L5021
	.sleb128	4
	.4byte		.L3101
	.uleb128	12710
	.uleb128	53
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L5023
	.sleb128	4
	.4byte		.L3101
	.uleb128	12710
	.uleb128	53
	.byte		"dataStructure"
	.byte		0
	.4byte		.L4618
	.4byte		.L5024
	.sleb128	4
	.4byte		.L3101
	.uleb128	12710
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4853
	.4byte		.L5025
.L5026:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12714
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L5027
	.section	.debug_info,,n
	.sleb128	0
.L5019:
	.section	.debug_info,,n
.L5032:
	.sleb128	6
	.4byte		.L5029-.L2
	.byte		"WriteMemoryInitialisation"
	.byte		0
	.4byte		.L3101
	.uleb128	12750
	.uleb128	53
	.4byte		.L3184
	.byte		0x1
	.4byte		.L5030
	.4byte		.L5031
	.sleb128	4
	.4byte		.L3101
	.uleb128	12750
	.uleb128	53
	.byte		"pMsgContext"
	.byte		0
	.4byte		.L3436
	.4byte		.L5033
	.sleb128	4
	.4byte		.L3101
	.uleb128	12750
	.uleb128	53
	.byte		"dataStructure"
	.byte		0
	.4byte		.L4618
	.4byte		.L5034
	.sleb128	4
	.4byte		.L3101
	.uleb128	12750
	.uleb128	53
	.byte		"pStatus"
	.byte		0
	.4byte		.L4853
	.4byte		.L5035
.L5036:
	.sleb128	5
	.4byte		.L3101
	.uleb128	12754
	.uleb128	33
	.byte		"ErrorCode"
	.byte		0
	.4byte		.L3184
	.4byte		.L5037
	.section	.debug_info,,n
	.sleb128	0
.L5029:
	.section	.debug_info,,n
.L5038:
	.sleb128	11
	.byte		0x1
	.byte		0x1
	.4byte		.L5039
	.uleb128	795
	.uleb128	49
	.byte		"Dcm_LCfg"
	.byte		0
	.4byte		.L5040
	.section	.debug_info,,n
.L5043:
	.sleb128	11
	.byte		0x1
	.byte		0x1
	.4byte		.L5044
	.uleb128	673
	.uleb128	54
	.byte		"Dcm_pPbCfg"
	.byte		0
	.4byte		.L5045
	.0byte		.L5043
.L5049:
	.sleb128	7
	.4byte		.L3101
	.uleb128	1026
	.uleb128	38
	.byte		"Dcm_DspInstance"
	.byte		0
	.4byte		.L5050
	.sleb128	5
	.byte		0x3
	.4byte		Dcm_DspInstance
	.lcomm		Dcm_DspInstance,248,2
.L5052:
	.sleb128	7
	.4byte		.L3101
	.uleb128	1044
	.uleb128	32
	.byte		"masks08"
	.byte		0
	.4byte		.L5053
	.sleb128	5
	.byte		0x3
	.4byte		masks08
	.section	.debug_info,,n
.L5055:
	.sleb128	7
	.4byte		.L3101
	.uleb128	1059
	.uleb128	41
	.byte		"readDtcReqLengths"
	.byte		0
	.4byte		.L5056
	.sleb128	5
	.byte		0x3
	.4byte		readDtcReqLengths
	.section	.debug_info,,n
.L5058:
	.sleb128	7
	.4byte		.L3101
	.uleb128	1069
	.uleb128	32
	.byte		"resetToMode"
	.byte		0
	.4byte		.L5059
	.sleb128	5
	.byte		0x3
	.4byte		resetToMode
	.section	.debug_info,,n
.L5061:
	.sleb128	7
	.4byte		.L3101
	.uleb128	1083
	.uleb128	32
	.byte		"powerShutdownToMode"
	.byte		0
	.4byte		.L5062
	.sleb128	5
	.byte		0x3
	.4byte		powerShutdownToMode
	.section	.debug_info,,n
.L5051:
	.sleb128	12
	.4byte		.L3101
	.uleb128	887
	.uleb128	14
	.4byte		.L5064-.L2
	.byte		"DspInstanceType_Tag"
	.byte		0
	.uleb128	248
	.section	.debug_info,,n
.L588:
	.sleb128	13
	.byte		"sec_acc_data"
	.byte		0
	.4byte		.L5065
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L589:
	.sleb128	13
	.byte		"asynch_state"
	.byte		0
	.4byte		.L4663
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L590:
	.sleb128	13
	.byte		"routine_control_status"
	.byte		0
	.4byte		.L4747
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L591:
	.sleb128	13
	.byte		"tid_control_status"
	.byte		0
	.4byte		.L5067
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
.L592:
	.sleb128	13
	.byte		"did_control_status"
	.byte		0
	.4byte		.L4709
	.sleb128	2
	.byte		0x23
	.uleb128	40
	.byte		0x1
.L593:
	.sleb128	13
	.byte		"communication_control_status"
	.byte		0
	.4byte		.L5069
	.sleb128	2
	.byte		0x23
	.uleb128	56
	.byte		0x1
.L594:
	.sleb128	13
	.byte		"control_dtc_setting_status"
	.byte		0
	.4byte		.L5071
	.sleb128	2
	.byte		0x23
	.uleb128	58
	.byte		0x1
.L595:
	.sleb128	13
	.byte		"diag_ses_ctrl_status"
	.byte		0
	.4byte		.L5073
	.sleb128	2
	.byte		0x23
	.uleb128	60
	.byte		0x1
.L596:
	.sleb128	13
	.byte		"memoryAddressOperation_status"
	.byte		0
	.4byte		.L4855
	.sleb128	2
	.byte		0x23
	.uleb128	76
	.byte		0x1
.L597:
	.sleb128	13
	.byte		"writeDataByIdentifier_status"
	.byte		0
	.4byte		.L4674
	.sleb128	2
	.byte		0x23
	.uleb128	84
	.byte		0x1
.L598:
	.sleb128	13
	.byte		"readScalingByIdentifier_status"
	.byte		0
	.4byte		.L5075
	.sleb128	2
	.byte		0x23
	.uleb128	120
	.byte		0x1
.L599:
	.sleb128	13
	.byte		"softwareDownloadOperation_status"
	.byte		0
	.4byte		.L5077
	.sleb128	3
	.byte		0x23
	.uleb128	128
	.byte		0x1
.L600:
	.sleb128	13
	.byte		"dtc_data_records_status"
	.byte		0
	.4byte		.L3874
	.sleb128	3
	.byte		0x23
	.uleb128	152
	.byte		0x1
.L601:
	.sleb128	13
	.byte		"read_did_status"
	.byte		0
	.4byte		.L4249
	.sleb128	3
	.byte		0x23
	.uleb128	176
	.byte		0x1
.L602:
	.sleb128	13
	.byte		"periodic_status"
	.byte		0
	.4byte		.L3301
	.sleb128	3
	.byte		0x23
	.uleb128	208
	.byte		0x1
	.sleb128	0
.L5064:
.L4619:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5079-.L2
	.byte		"MemoryDataStructureType_Tag"
	.byte		0
	.uleb128	16
.L578:
	.sleb128	13
	.byte		"include_memory_id_byte"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L579:
	.sleb128	13
	.byte		"memory_address_format"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L580:
	.sleb128	13
	.byte		"memory_address_length"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L581:
	.sleb128	13
	.byte		"memory_size_length"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	3
	.byte		0x1
.L582:
	.sleb128	13
	.byte		"memory_address_offset"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L583:
	.sleb128	13
	.byte		"memory_size_offset"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	5
	.byte		0x1
.L584:
	.sleb128	13
	.byte		"data_record_offset"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L585:
	.sleb128	13
	.byte		"memory_identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	7
	.byte		0x1
.L586:
	.sleb128	13
	.byte		"memory_address"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L587:
	.sleb128	13
	.byte		"memory_size"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5079:
.L4250:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5080-.L2
	.byte		"ReadDataByIdentifierStatusType_tag"
	.byte		0
	.uleb128	32
.L569:
	.sleb128	13
	.byte		"sendPositiveResponse"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L570:
	.sleb128	13
	.byte		"num_valid_requested_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L571:
	.sleb128	13
	.byte		"num_requested_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L572:
	.sleb128	13
	.byte		"current_did_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L573:
	.sleb128	13
	.byte		"current_source_did_index"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L574:
	.sleb128	13
	.byte		"total_answer_size"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	10
	.byte		0x1
.L575:
	.sleb128	13
	.byte		"currentDDDidOperation"
	.byte		0
	.4byte		.L5081
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L576:
	.sleb128	13
	.byte		"currentDidIndex"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L577:
	.sleb128	13
	.byte		"read_did_info"
	.byte		0
	.4byte		.L3175
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5080:
.L3875:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5083-.L2
	.byte		"ReportAllDtcDataRecordByDTCNumberStatusType_tag"
	.byte		0
	.uleb128	24
.L561:
	.sleb128	13
	.byte		"current_dtc_id"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L562:
	.sleb128	13
	.byte		"dtc_id"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L563:
	.sleb128	13
	.byte		"dtc_status"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L564:
	.sleb128	13
	.byte		"sub_service_id"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	9
	.byte		0x1
.L565:
	.sleb128	13
	.byte		"total_size"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	10
	.byte		0x1
.L566:
	.sleb128	13
	.byte		"maxNumberRecordsCounter"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L567:
	.sleb128	13
	.byte		"dataState"
	.byte		0
	.4byte		.L3769
	.sleb128	2
	.byte		0x23
	.uleb128	14
	.byte		0x1
.L568:
	.sleb128	13
	.byte		"dtc_origin"
	.byte		0
	.4byte		.L3608
	.sleb128	2
	.byte		0x23
	.uleb128	21
	.byte		0x1
	.sleb128	0
.L5083:
.L3770:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5084-.L2
	.byte		"ReadExtendedOrSnapshotDataRecordByDTCStatusType_tag"
	.byte		0
	.uleb128	7
.L554:
	.sleb128	13
	.byte		"sendPositiveResponse"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L555:
	.sleb128	13
	.byte		"dataPending"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L556:
	.sleb128	13
	.byte		"request_data_record_number"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L557:
	.sleb128	13
	.byte		"current_data_record_number"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	3
	.byte		0x1
.L558:
	.sleb128	13
	.byte		"dataRecordFoundWithSize"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L559:
	.sleb128	13
	.byte		"dataRecordFound"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	5
	.byte		0x1
.L560:
	.sleb128	13
	.byte		"dtcFound"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
	.sleb128	0
.L5084:
.L5078:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5085-.L2
	.byte		"SoftwareDownloadOperationStatusType_Tag"
	.byte		0
	.uleb128	24
.L547:
	.sleb128	13
	.byte		"pendingDataTransferState"
	.byte		0
	.4byte		.L5086
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L548:
	.sleb128	13
	.byte		"requestedBytes"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L549:
	.sleb128	13
	.byte		"transferredBytes"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L550:
	.sleb128	13
	.byte		"blockLength"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L551:
	.sleb128	13
	.byte		"blockSequenceCounter"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L552:
	.sleb128	13
	.byte		"negativeResponseCode"
	.byte		0
	.4byte		.L3184
	.sleb128	2
	.byte		0x23
	.uleb128	17
	.byte		0x1
.L553:
	.sleb128	13
	.byte		"previousReceivedBytes"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5085:
.L5076:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5088-.L2
	.byte		"ReadScalingByIdentifierOperationStatusType_Tag"
	.byte		0
	.uleb128	8
.L545:
	.sleb128	13
	.byte		"pCurrentDid"
	.byte		0
	.4byte		.L4166
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L546:
	.sleb128	13
	.byte		"pRequestData"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5088:
.L4675:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5089-.L2
	.byte		"WriteDataByIdentifierOperationStatusType_Tag"
	.byte		0
	.uleb128	36
.L533:
	.sleb128	13
	.byte		"fixed_length"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L534:
	.sleb128	13
	.byte		"RetStatus"
	.byte		0
	.4byte		.L3156
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L535:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L536:
	.sleb128	13
	.byte		"requestedDataLengthToWrite"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L537:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L538:
	.sleb128	13
	.byte		"pDataBuf"
	.byte		0
	.4byte		.L5090
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L539:
	.sleb128	13
	.byte		"SingleDidWriteDataFunc"
	.byte		0
	.4byte		.L5091
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L540:
	.sleb128	13
	.byte		"RangeDidWriteDataFunc"
	.byte		0
	.4byte		.L5095
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L541:
	.sleb128	13
	.byte		"RangeDidIsAvailableFunc"
	.byte		0
	.4byte		.L5099
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L542:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L3983
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L543:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L3983
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
.L544:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	32
	.byte		0x1
	.sleb128	0
.L5089:
.L4856:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5108-.L2
	.byte		"MemoryAddressOperationStatusType_Tag"
	.byte		0
	.uleb128	8
.L531:
	.sleb128	13
	.byte		"buffer"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L532:
	.sleb128	13
	.byte		"pendingBuffer"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5108:
.L5072:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5109-.L2
	.byte		"ControlDtcSettingStatusType_Tag"
	.byte		0
	.uleb128	1
.L530:
	.sleb128	13
	.byte		"enabled"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
	.sleb128	0
.L5109:
.L5070:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5110-.L2
	.byte		"CommunicationControlStatusType_Tag"
	.byte		0
	.uleb128	2
.L528:
	.sleb128	13
	.byte		"comNetwork"
	.byte		0
	.4byte		.L3526
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L529:
	.sleb128	13
	.byte		"requestedCommunicationMode"
	.byte		0
	.4byte		.L3500
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
	.sleb128	0
.L5110:
.L5074:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5111-.L2
	.byte		"DiagnosticSessionControlType_Tag"
	.byte		0
	.uleb128	16
.L525:
	.sleb128	13
	.byte		"pReqSession"
	.byte		0
	.4byte		.L3381
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L526:
	.sleb128	13
	.byte		"progCond"
	.byte		0
	.4byte		.L5112
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L527:
	.sleb128	13
	.byte		"bootload_interaction_finished"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	14
	.byte		0x1
	.sleb128	0
.L5111:
.L4710:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5114-.L2
	.byte		"DidControlStatusType_Tag"
	.byte		0
	.uleb128	16
.L519:
	.sleb128	13
	.byte		"ioctlsubFunction"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L520:
	.sleb128	13
	.byte		"ControlStatusRecordRead"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L521:
	.sleb128	13
	.byte		"DynDataLengh"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L522:
	.sleb128	13
	.byte		"pRequestData"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L523:
	.sleb128	13
	.byte		"ControlStateInfo"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L524:
	.sleb128	13
	.byte		"pDidCtrl"
	.byte		0
	.4byte		.L4166
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5114:
.L5068:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5115-.L2
	.byte		"TidControlStatusType_Tag"
	.byte		0
	.uleb128	10
.L512:
	.sleb128	13
	.byte		"midHighByteRead"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L513:
	.sleb128	13
	.byte		"visible"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L514:
	.sleb128	13
	.byte		"tidCnt"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L515:
	.sleb128	13
	.byte		"uasCnt"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	3
	.byte		0x1
.L516:
	.sleb128	13
	.byte		"midIdx"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L517:
	.sleb128	13
	.byte		"portCnt"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L518:
	.sleb128	13
	.byte		"lastReadMid"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5115:
.L4748:
	.sleb128	12
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5116-.L2
	.byte		"RoutineControlStatusType_Tag"
	.byte		0
	.uleb128	16
.L507:
	.sleb128	13
	.byte		"subFunction"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L508:
	.sleb128	13
	.byte		"currentDataLength"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L509:
	.sleb128	13
	.byte		"pCurrentRoutine"
	.byte		0
	.4byte		.L5117
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L510:
	.sleb128	13
	.byte		"pRequestData"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L511:
	.sleb128	13
	.byte		"routineIndex"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5116:
.L5066:
	.sleb128	12
	.4byte		.L3101
	.uleb128	622
	.uleb128	14
	.4byte		.L5121-.L2
	.byte		"DspSecAccDataType_Tag"
	.byte		0
	.uleb128	6
.L504:
	.sleb128	13
	.byte		"security_access_failed"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L505:
	.sleb128	13
	.byte		"security_delay_timer"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L506:
	.sleb128	13
	.byte		"pending_security_level"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5121:
.L3302:
	.sleb128	12
	.4byte		.L3101
	.uleb128	535
	.uleb128	14
	.4byte		.L5122-.L2
	.byte		"DspPeriodicStatusType_Tag"
	.byte		0
	.uleb128	40
.L491:
	.sleb128	13
	.byte		"timer_expired"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L492:
	.sleb128	13
	.byte		"rate"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L493:
	.sleb128	13
	.byte		"active_timer"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L494:
	.sleb128	13
	.byte		"num_periodic_id"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L495:
	.sleb128	13
	.byte		"next_did_to_be_sent"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L496:
	.sleb128	13
	.byte		"num_ready_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	10
	.byte		0x1
.L497:
	.sleb128	13
	.byte		"num_confirmed_sent_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L498:
	.sleb128	13
	.byte		"num_sent_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	14
	.byte		0x1
.L499:
	.sleb128	13
	.byte		"state"
	.byte		0
	.4byte		.L5123
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L500:
	.sleb128	13
	.byte		"current_did_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L501:
	.sleb128	13
	.byte		"current_source_did_index"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	22
	.byte		0x1
.L502:
	.sleb128	13
	.byte		"bufferOffset"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L503:
	.sleb128	13
	.byte		"read_did_info"
	.byte		0
	.4byte		.L3175
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
	.sleb128	0
.L5122:
.L3176:
	.sleb128	12
	.4byte		.L3101
	.uleb128	494
	.uleb128	14
	.4byte		.L5125-.L2
	.byte		"CommonReadDidInfoType_Tag"
	.byte		0
	.uleb128	12
.L487:
	.sleb128	13
	.byte		"current_size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L488:
	.sleb128	13
	.byte		"current_opstatus"
	.byte		0
	.4byte		.L3353
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L489:
	.sleb128	13
	.byte		"current_operation"
	.byte		0
	.4byte		.L5081
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L490:
	.sleb128	13
	.byte		"current_res_buffer"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5125:
.L5042:
	.sleb128	12
	.4byte		.L5039
	.uleb128	683
	.uleb128	14
	.4byte		.L5126-.L2
	.byte		"Dcm_LinkTimeConfigType_Tag"
	.byte		0
	.uleb128	180
.L433:
	.sleb128	13
	.byte		"maxNumberOfRecords"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L434:
	.sleb128	13
	.byte		"rte_unconnected"
	.byte		0
	.4byte		.L3156
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L435:
	.sleb128	13
	.byte		"power_down_time"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	3
	.byte		0x1
.L436:
	.sleb128	13
	.byte		"delay_boot_inv_key"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L437:
	.sleb128	13
	.byte		"timer_s3_server"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L438:
	.sleb128	13
	.byte		"resp_on_second_declined_request"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L439:
	.sleb128	13
	.byte		"periodic_transmission_rates"
	.byte		0
	.4byte		.L5127
	.sleb128	2
	.byte		0x23
	.uleb128	10
	.byte		0x1
.L440:
	.sleb128	13
	.byte		"paged_buffer_timeout"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L441:
	.sleb128	13
	.byte		"p_response_buffer"
	.byte		0
	.4byte		.L3234
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L442:
	.sleb128	13
	.byte		"sourceBufferSize"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L443:
	.sleb128	13
	.byte		"p_dddid_sourceBuffer"
	.byte		0
	.4byte		.L3234
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
.L444:
	.sleb128	13
	.byte		"num_sessions"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	32
	.byte		0x1
.L445:
	.sleb128	13
	.byte		"sessions"
	.byte		0
	.4byte		.L5129
	.sleb128	2
	.byte		0x23
	.uleb128	36
	.byte		0x1
.L446:
	.sleb128	13
	.byte		"num_securities"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	40
	.byte		0x1
.L447:
	.sleb128	13
	.byte		"securities"
	.byte		0
	.4byte		.L5130
	.sleb128	2
	.byte		0x23
	.uleb128	44
	.byte		0x1
.L448:
	.sleb128	13
	.byte		"num_service_tables"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	48
	.byte		0x1
.L449:
	.sleb128	13
	.byte		"service_tables"
	.byte		0
	.4byte		.L5131
	.sleb128	2
	.byte		0x23
	.uleb128	52
	.byte		0x1
.L450:
	.sleb128	13
	.byte		"max_did_to_read"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	56
	.byte		0x1
.L451:
	.sleb128	13
	.byte		"p_requested_dids"
	.byte		0
	.4byte		.L5136
	.sleb128	2
	.byte		0x23
	.uleb128	60
	.byte		0x1
.L452:
	.sleb128	13
	.byte		"num_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	64
	.byte		0x1
.L453:
	.sleb128	13
	.byte		"dids"
	.byte		0
	.4byte		.L5138
	.sleb128	2
	.byte		0x23
	.uleb128	68
	.byte		0x1
.L454:
	.sleb128	13
	.byte		"num_periodic_dynamic_dids"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	72
	.byte		0x1
.L455:
	.sleb128	13
	.byte		"periodicDynamicDids"
	.byte		0
	.4byte		.L4121
	.sleb128	2
	.byte		0x23
	.uleb128	76
	.byte		0x1
.L456:
	.sleb128	13
	.byte		"requested_periodicDids"
	.byte		0
	.4byte		.L3179
	.sleb128	2
	.byte		0x23
	.uleb128	80
	.byte		0x1
.L457:
	.sleb128	13
	.byte		"check_per_source_did"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	84
	.byte		0x1
.L458:
	.sleb128	13
	.byte		"num_did_ranges"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	86
	.byte		0x1
.L459:
	.sleb128	13
	.byte		"p_did_ranges"
	.byte		0
	.4byte		.L4303
	.sleb128	2
	.byte		0x23
	.uleb128	88
	.byte		0x1
.L460:
	.sleb128	13
	.byte		"num_pids"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	92
	.byte		0x1
.L461:
	.sleb128	13
	.byte		"p_pids"
	.byte		0
	.4byte		.L5139
	.sleb128	2
	.byte		0x23
	.uleb128	96
	.byte		0x1
.L462:
	.sleb128	13
	.byte		"num_req_ctrl"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	100
	.byte		0x1
.L463:
	.sleb128	13
	.byte		"p_req_ctrl"
	.byte		0
	.4byte		.L5140
	.sleb128	2
	.byte		0x23
	.uleb128	104
	.byte		0x1
.L464:
	.sleb128	13
	.byte		"p_roe"
	.byte		0
	.4byte		.L5141
	.sleb128	2
	.byte		0x23
	.uleb128	108
	.byte		0x1
.L465:
	.sleb128	13
	.byte		"num_vehicle_info"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	112
	.byte		0x1
.L466:
	.sleb128	13
	.byte		"p_vehicle_info"
	.byte		0
	.4byte		.L5146
	.sleb128	2
	.byte		0x23
	.uleb128	116
	.byte		0x1
.L467:
	.sleb128	13
	.byte		"num_routine_ctrl"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	120
	.byte		0x1
.L468:
	.sleb128	13
	.byte		"p_routine_ctrl"
	.byte		0
	.4byte		.L5147
	.sleb128	2
	.byte		0x23
	.uleb128	124
	.byte		0x1
.L469:
	.sleb128	13
	.byte		"num_freezeframe_records"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x23
	.uleb128	128
	.byte		0x1
.L470:
	.sleb128	13
	.byte		"p_freezeframe_records"
	.byte		0
	.4byte		.L4067
	.sleb128	3
	.byte		0x23
	.uleb128	132
	.byte		0x1
.L471:
	.sleb128	13
	.byte		"num_extendeddata_records"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x23
	.uleb128	136
	.byte		0x1
.L472:
	.sleb128	13
	.byte		"p_extendeddata_records"
	.byte		0
	.4byte		.L4067
	.sleb128	3
	.byte		0x23
	.uleb128	140
	.byte		0x1
.L473:
	.sleb128	13
	.byte		"index_obdedr_start"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x23
	.uleb128	144
	.byte		0x1
.L474:
	.sleb128	13
	.byte		"num_cb_req_service"
	.byte		0
	.4byte		.L3157
	.sleb128	3
	.byte		0x23
	.uleb128	145
	.byte		0x1
.L475:
	.sleb128	13
	.byte		"p_cb_req_services"
	.byte		0
	.4byte		.L5148
	.sleb128	3
	.byte		0x23
	.uleb128	148
	.byte		0x1
.L476:
	.sleb128	13
	.byte		"p_write_memory"
	.byte		0
	.4byte		.L3210
	.sleb128	3
	.byte		0x23
	.uleb128	152
	.byte		0x1
.L477:
	.sleb128	13
	.byte		"p_read_memory"
	.byte		0
	.4byte		.L3210
	.sleb128	3
	.byte		0x23
	.uleb128	156
	.byte		0x1
.L478:
	.sleb128	13
	.byte		"p_software_download"
	.byte		0
	.4byte		.L5153
	.sleb128	3
	.byte		0x23
	.uleb128	160
	.byte		0x1
.L479:
	.sleb128	13
	.byte		"p_routine_state"
	.byte		0
	.4byte		.L5158
	.sleb128	3
	.byte		0x23
	.uleb128	164
	.byte		0x1
.L480:
	.sleb128	13
	.byte		"p_ddid_init_info"
	.byte		0
	.4byte		.L5162
	.sleb128	3
	.byte		0x23
	.uleb128	168
	.byte		0x1
.L481:
	.sleb128	13
	.byte		"p_get_periodic_data_trigger"
	.byte		0
	.4byte		.L5167
	.sleb128	3
	.byte		0x23
	.uleb128	172
	.byte		0x1
.L482:
	.sleb128	13
	.byte		"p_transmit_periodic_data_trigger"
	.byte		0
	.4byte		.L5170
	.sleb128	3
	.byte		0x23
	.uleb128	176
	.byte		0x1
	.sleb128	0
.L5126:
.L4416:
	.sleb128	12
	.4byte		.L5039
	.uleb128	683
	.uleb128	14
	.4byte		.L5173-.L2
	.byte		"Dcm_Cfg_RequestedDidInfoType_Tag"
	.byte		0
	.uleb128	8
.L431:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L432:
	.sleb128	13
	.byte		"did_type"
	.byte		0
	.4byte		.L5174
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5173:
.L5166:
	.sleb128	12
	.4byte		.L5039
	.uleb128	652
	.uleb128	14
	.4byte		.L5176-.L2
	.byte		"Dcm_Cfg_DDidInitInfoType_Tag"
	.byte		0
	.uleb128	16
.L427:
	.sleb128	13
	.byte		"ddid_init_policy"
	.byte		0
	.4byte		.L3118
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L428:
	.sleb128	13
	.byte		"ddprid_init_policy"
	.byte		0
	.4byte		.L3121
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L429:
	.sleb128	13
	.byte		"ddprid_nvm_hash_rom"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L430:
	.sleb128	13
	.byte		"p_ddprid_nvm_hash_ram"
	.byte		0
	.4byte		.L5177
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5176:
.L5145:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5178-.L2
	.byte		"Dcm_Cfg_RoeType_Tag"
	.byte		0
	.uleb128	28
.L418:
	.sleb128	13
	.byte		"dtc_status_change_event"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L419:
	.sleb128	13
	.byte		"num_event"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L420:
	.sleb128	13
	.byte		"num_event_window_time"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L421:
	.sleb128	13
	.byte		"inter_msg_timeout"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L422:
	.sleb128	13
	.byte		"p_event_cfg"
	.byte		0
	.4byte		.L5179
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L423:
	.sleb128	13
	.byte		"p_event_window_times"
	.byte		0
	.4byte		.L5184
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L424:
	.sleb128	13
	.byte		"p_nvm_status"
	.byte		0
	.4byte		.L5189
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L425:
	.sleb128	13
	.byte		"p_event_status"
	.byte		0
	.4byte		.L5193
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L426:
	.sleb128	13
	.byte		"p_nvm_event_status"
	.byte		0
	.4byte		.L5197
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
	.sleb128	0
.L5178:
.L5196:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5201-.L2
	.byte		"Dcm_Cfg_RoeEventStatusType_Tag"
	.byte		0
	.uleb128	8
.L415:
	.sleb128	13
	.byte		"state"
	.byte		0
	.4byte		.L5202
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L416:
	.sleb128	13
	.byte		"queue_next"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L417:
	.sleb128	13
	.byte		"queue_previous"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	5
	.byte		0x1
	.sleb128	0
.L5201:
.L5188:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5204-.L2
	.byte		"Dcm_Cfg_RoeEventWindowTimeType_Tag"
	.byte		0
	.uleb128	2
.L413:
	.sleb128	13
	.byte		"type"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L414:
	.sleb128	13
	.byte		"evaluate_storage_state"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
	.sleb128	0
.L5204:
.L5183:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5205-.L2
	.byte		"Dcm_Cfg_RoeEventType_Tag"
	.byte		0
	.uleb128	8
.L410:
	.sleb128	13
	.byte		"initial_event_state_stopped"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L411:
	.sleb128	13
	.byte		"did"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L412:
	.sleb128	13
	.byte		"p_schm_mode_switch"
	.byte		0
	.4byte		.L5206
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5205:
.L5157:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5209-.L2
	.byte		"Dcm_Cfg_SoftwareDownloadType_Tag"
	.byte		0
	.uleb128	12
.L407:
	.sleb128	13
	.byte		"RequestDownloadFunc"
	.byte		0
	.4byte		.L5210
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L408:
	.sleb128	13
	.byte		"WriteMemoryFunc"
	.byte		0
	.4byte		.L5214
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L409:
	.sleb128	13
	.byte		"RequestTransferExitFunc"
	.byte		0
	.4byte		.L5218
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5209:
.L3214:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5222-.L2
	.byte		"Dcm_Cfg_MemoryType_Tag"
	.byte		0
	.uleb128	16
.L403:
	.sleb128	13
	.byte		"use_memory_id"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L404:
	.sleb128	13
	.byte		"MemoryOperationFunc"
	.byte		0
	.4byte		.L5214
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L405:
	.sleb128	13
	.byte		"p_memory_ranges"
	.byte		0
	.4byte		.L3225
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L406:
	.sleb128	13
	.byte		"num_memory_ranges"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5222:
.L3203:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5223-.L2
	.byte		"Dcm_Cfg_MemoryRangeType_Tag"
	.byte		0
	.uleb128	20
.L398:
	.sleb128	13
	.byte		"memid"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L399:
	.sleb128	13
	.byte		"low"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L400:
	.sleb128	13
	.byte		"high"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L401:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L402:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5223:
.L5152:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5224-.L2
	.byte		"Dcm_Cfg_CallbackReqServType_Tag"
	.byte		0
	.uleb128	8
.L396:
	.sleb128	13
	.byte		"start_protocol"
	.byte		0
	.4byte		.L5225
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L397:
	.sleb128	13
	.byte		"stop_protocol"
	.byte		0
	.4byte		.L5229
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5224:
.L5120:
	.sleb128	12
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5232-.L2
	.byte		"Dcm_Cfg_RoutineCtrlType_Tag"
	.byte		0
	.uleb128	28
.L386:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L387:
	.sleb128	13
	.byte		"StartFunc"
	.byte		0
	.4byte		.L5233
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L388:
	.sleb128	13
	.byte		"StopFunc"
	.byte		0
	.4byte		.L5236
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L389:
	.sleb128	13
	.byte		"RequestResultsFunc"
	.byte		0
	.4byte		.L5239
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L390:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L391:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L392:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
	.sleb128	0
.L5232:
.L3252:
	.sleb128	12
	.4byte		.L5039
	.uleb128	416
	.uleb128	1
	.4byte		.L5242-.L2
	.byte		"Dcm_Cfg_PeriodicDynamicDidType_Tag"
	.byte		0
	.uleb128	24
.L379:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L380:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L381:
	.sleb128	13
	.byte		"pDDDidInfo"
	.byte		0
	.4byte		.L5243
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L382:
	.sleb128	13
	.byte		"pDataSourcesRead"
	.byte		0
	.4byte		.L3159
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L383:
	.sleb128	13
	.byte		"pDataSourcesDefine"
	.byte		0
	.4byte		.L5248
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L384:
	.sleb128	13
	.byte		"pNumberOfDefinedSources"
	.byte		0
	.4byte		.L3234
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L385:
	.sleb128	13
	.byte		"sample_data"
	.byte		0
	.4byte		.L5249
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5242:
.L5252:
	.sleb128	12
	.4byte		.L5039
	.uleb128	416
	.uleb128	1
	.4byte		.L5253-.L2
	.byte		"Dcm_Cfg_PeriodicSampleDataType_Tag"
	.byte		0
	.uleb128	8
.L376:
	.sleb128	13
	.byte		"buffer_data_ready"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L377:
	.sleb128	13
	.byte		"buffer_size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L378:
	.sleb128	13
	.byte		"data_buffer"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5253:
.L5247:
	.sleb128	12
	.4byte		.L5039
	.uleb128	416
	.uleb128	1
	.4byte		.L5254-.L2
	.byte		"Dcm_Cfg_DDDDidInfoType_Tag"
	.byte		0
	.uleb128	12
.L373:
	.sleb128	13
	.byte		"max_no_of_requested_sources"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L374:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L375:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5254:
.L3163:
	.sleb128	12
	.4byte		.L5039
	.uleb128	416
	.uleb128	1
	.4byte		.L5255-.L2
	.byte		"Dcm_Cfg_DDDDidSourceType_Tag"
	.byte		0
	.uleb128	20
.L368:
	.sleb128	13
	.byte		"record_type"
	.byte		0
	.4byte		.L3170
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L369:
	.sleb128	13
	.byte		"memory_id"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L370:
	.sleb128	13
	.byte		"address"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L371:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3206
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L372:
	.sleb128	13
	.byte		"pDidRead"
	.byte		0
	.4byte		.L5256
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5255:
.L4187:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5260-.L2
	.byte		"Dcm_Cfg_DidRangeType_Tag"
	.byte		0
	.uleb128	20
.L362:
	.sleb128	13
	.byte		"lower_limit"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L363:
	.sleb128	13
	.byte		"upper_limit"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L364:
	.sleb128	13
	.byte		"max_data_length"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L365:
	.sleb128	13
	.byte		"IsDidAvailableFunc"
	.byte		0
	.4byte		.L5099
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L366:
	.sleb128	13
	.byte		"p_did_range_read"
	.byte		0
	.4byte		.L5261
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L367:
	.sleb128	13
	.byte		"p_did_range_write"
	.byte		0
	.4byte		.L5266
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5260:
.L5270:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5271-.L2
	.byte		"Dcm_Cfg_DidRangeWriteType_Tag"
	.byte		0
	.uleb128	16
.L358:
	.sleb128	13
	.byte		"WriteDidDataFunc"
	.byte		0
	.4byte		.L5095
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L359:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L360:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L361:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5271:
.L5265:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5272-.L2
	.byte		"Dcm_Cfg_DidRangeReadType_Tag"
	.byte		0
	.uleb128	20
.L353:
	.sleb128	13
	.byte		"ReadDidDataFunc"
	.byte		0
	.4byte		.L5273
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L354:
	.sleb128	13
	.byte		"ReadDidDataLengthFunc"
	.byte		0
	.4byte		.L5277
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L355:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L356:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L357:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5272:
.L4169:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5281-.L2
	.byte		"Dcm_Cfg_DidType_Tag"
	.byte		0
	.uleb128	28
.L344:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L345:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L346:
	.sleb128	13
	.byte		"scalingInfoSize"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L347:
	.sleb128	13
	.byte		"pDidWrite"
	.byte		0
	.4byte		.L5282
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L348:
	.sleb128	13
	.byte		"pDidRead"
	.byte		0
	.4byte		.L5287
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L349:
	.sleb128	13
	.byte		"pDidControl"
	.byte		0
	.4byte		.L5288
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L350:
	.sleb128	13
	.byte		"GetScalingInformationFunc"
	.byte		0
	.4byte		.L5293
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L351:
	.sleb128	13
	.byte		"RetStatus"
	.byte		0
	.4byte		.L3156
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L352:
	.sleb128	13
	.byte		"hasFixedLength"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	25
	.byte		0x1
	.sleb128	0
.L5281:
.L5292:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5297-.L2
	.byte		"Dcm_Cfg_DidControlType_Tag"
	.byte		0
	.uleb128	32
.L334:
	.sleb128	13
	.byte		"control_enable_mask_record_size"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L335:
	.sleb128	13
	.byte		"p_under_control"
	.byte		0
	.4byte		.L3234
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L336:
	.sleb128	13
	.byte		"rctecu_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L337:
	.sleb128	13
	.byte		"rtd_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	10
	.byte		0x1
.L338:
	.sleb128	13
	.byte		"fcs_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L339:
	.sleb128	13
	.byte		"sta_index"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	14
	.byte		0x1
.L340:
	.sleb128	13
	.byte		"ReadDataFunc"
	.byte		0
	.4byte		.L5298
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L341:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L342:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L343:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
	.sleb128	0
.L5297:
.L5259:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5302-.L2
	.byte		"Dcm_Cfg_DidReadType_Tag"
	.byte		0
	.uleb128	24
.L328:
	.sleb128	13
	.byte		"ConditionCheckReadFunc"
	.byte		0
	.4byte		.L5303
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L329:
	.sleb128	13
	.byte		"ReadDataLengthFunc"
	.byte		0
	.4byte		.L5307
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L330:
	.sleb128	13
	.byte		"ReadDataFunc"
	.byte		0
	.4byte		.L5298
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L331:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L332:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L333:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5302:
.L5286:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5311-.L2
	.byte		"Dcm_Cfg_DidWriteType_Tag"
	.byte		0
	.uleb128	16
.L324:
	.sleb128	13
	.byte		"WriteDataFunc"
	.byte		0
	.4byte		.L5091
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L325:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L326:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L327:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5311:
.L4101:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5312-.L2
	.byte		"Dcm_Cfg_PidType_Tag"
	.byte		0
	.uleb128	24
.L317:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L318:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L319:
	.sleb128	13
	.byte		"service_type"
	.byte		0
	.4byte		.L5313
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L320:
	.sleb128	13
	.byte		"num_support_infos"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L321:
	.sleb128	13
	.byte		"p_support_info"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L322:
	.sleb128	13
	.byte		"num_pidDatas"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L323:
	.sleb128	13
	.byte		"p_pidDatas"
	.byte		0
	.4byte		.L5315
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5312:
.L4990:
	.sleb128	12
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5316-.L2
	.byte		"Dcm_Cfg_PidDataType_Tag"
	.byte		0
	.uleb128	8
.L314:
	.sleb128	13
	.byte		"data_Pos"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L315:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L316:
	.sleb128	13
	.byte		"ReadDataFunc"
	.byte		0
	.4byte		.L5317
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5316:
.L4059:
	.sleb128	12
	.4byte		.L5039
	.uleb128	213
	.uleb128	1
	.4byte		.L5320-.L2
	.byte		"Dcm_Cfg_VehicleInfoType_Tag"
	.byte		0
	.uleb128	8
.L311:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L312:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L313:
	.sleb128	13
	.byte		"GetInfotypeValueDataFunc"
	.byte		0
	.4byte		.L5321
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5320:
.L4808:
	.sleb128	12
	.4byte		.L5039
	.uleb128	213
	.uleb128	1
	.4byte		.L5324-.L2
	.byte		"Dcm_Cfg_ReqCtrlType_Tag"
	.byte		0
	.uleb128	12
.L307:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L308:
	.sleb128	13
	.byte		"in_size"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L309:
	.sleb128	13
	.byte		"out_size"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L310:
	.sleb128	13
	.byte		"RequestControlFunc"
	.byte		0
	.4byte		.L5325
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5324:
.L3424:
	.sleb128	12
	.4byte		.L5039
	.uleb128	213
	.uleb128	1
	.4byte		.L5329-.L2
	.byte		"Dcm_Cfg_SecurityType_Tag"
	.byte		0
	.uleb128	24
.L299:
	.sleb128	13
	.byte		"security_level"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L300:
	.sleb128	13
	.byte		"GetSeedFunc"
	.byte		0
	.4byte		.L5330
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L301:
	.sleb128	13
	.byte		"CompareKeyFunc"
	.byte		0
	.4byte		.L5334
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L302:
	.sleb128	13
	.byte		"num_max_att_delay"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L303:
	.sleb128	13
	.byte		"delay_inv_key"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	14
	.byte		0x1
.L304:
	.sleb128	13
	.byte		"num_seed"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L305:
	.sleb128	13
	.byte		"num_key"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	18
	.byte		0x1
.L306:
	.sleb128	13
	.byte		"address_size"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
	.sleb128	0
.L5329:
.L3385:
	.sleb128	12
	.4byte		.L5039
	.uleb128	213
	.uleb128	1
	.4byte		.L5338-.L2
	.byte		"Dcm_Cfg_SessionType_Tag"
	.byte		0
	.uleb128	16
.L293:
	.sleb128	13
	.byte		"session_level"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L294:
	.sleb128	13
	.byte		"p2_server_max"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L295:
	.sleb128	13
	.byte		"p2_star_server_max"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L296:
	.sleb128	13
	.byte		"client_p2_server_max"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L297:
	.sleb128	13
	.byte		"client_p2_star_server_max"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L298:
	.sleb128	13
	.byte		"jump_to_bootloader"
	.byte		0
	.4byte		.L5339
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5338:
.L5135:
	.sleb128	12
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5342-.L2
	.byte		"Dcm_Cfg_ServiceTableType_Tag"
	.byte		0
	.uleb128	8
.L290:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L291:
	.sleb128	13
	.byte		"num_services"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L292:
	.sleb128	13
	.byte		"p_identifier_table"
	.byte		0
	.4byte		.L5343
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5342:
.L5347:
	.sleb128	12
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5348-.L2
	.byte		"Dcm_Cfg_ServiceType_Tag"
	.byte		0
	.uleb128	32
.L282:
	.sleb128	13
	.byte		"service_id"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L283:
	.sleb128	13
	.byte		"trigger_func"
	.byte		0
	.4byte		.L5349
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L284:
	.sleb128	13
	.byte		"possible_suppress_bit"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L285:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L286:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L287:
	.sleb128	13
	.byte		"num_subServices"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L288:
	.sleb128	13
	.byte		"p_subServices"
	.byte		0
	.4byte		.L5353
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L289:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
	.sleb128	0
.L5348:
.L5357:
	.sleb128	12
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5358-.L2
	.byte		"Dcm_Cfg_SubServiceType_Tag"
	.byte		0
	.uleb128	20
.L277:
	.sleb128	13
	.byte		"sub_service_id"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L278:
	.sleb128	13
	.byte		"p_security_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L279:
	.sleb128	13
	.byte		"p_session_levels"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L280:
	.sleb128	13
	.byte		"modeRuleFunc"
	.byte		0
	.4byte		.L5104
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L281:
	.sleb128	13
	.byte		"trigger_func"
	.byte		0
	.4byte		.L5349
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5358:
.L5200:
	.sleb128	12
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5359-.L2
	.byte		"Dcm_Cfg_RoeNvmEventStatusType_Tag"
	.byte		0
	.uleb128	8
.L196:
	.sleb128	13
	.byte		"stored_state"
	.byte		0
	.4byte		.L5202
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L197:
	.sleb128	13
	.byte		"event_window_time"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L198:
	.sleb128	13
	.byte		"rx_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
	.sleb128	0
.L5359:
.L5192:
	.sleb128	12
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5360-.L2
	.byte		"Dcm_Cfg_RoeNvmStatusType_Tag"
	.byte		0
	.uleb128	1
.L195:
	.sleb128	13
	.byte		"dtc_status_mask"
	.byte		0
	.4byte		.L3625
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
	.sleb128	0
.L5360:
.L5048:
	.sleb128	12
	.4byte		.L5361
	.uleb128	247
	.uleb128	1
	.4byte		.L5362-.L2
	.byte		"Dcm_ConfigType_Tag"
	.byte		0
	.uleb128	52
.L180:
	.sleb128	13
	.byte		"first_periodic_tx_confirmation_id_value"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L181:
	.sleb128	13
	.byte		"first_roe_tx_confirmation_id_value"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L182:
	.sleb128	13
	.byte		"first_invalid_tx_confirmation_id_value"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L183:
	.sleb128	13
	.byte		"num_rx_channels"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L184:
	.sleb128	13
	.byte		"p_rx_channels"
	.byte		0
	.4byte		.L5363
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L185:
	.sleb128	13
	.byte		"p_tx_channels"
	.byte		0
	.4byte		.L5364
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L186:
	.sleb128	13
	.byte		"p_periodic_tx_lookup_table"
	.byte		0
	.4byte		.L5369
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L187:
	.sleb128	13
	.byte		"max_num_resp_pend"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L188:
	.sleb128	13
	.byte		"p_pids_support_01"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L189:
	.sleb128	13
	.byte		"p_pids_support_02"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
.L190:
	.sleb128	13
	.byte		"p_req_ctrl_support"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	32
	.byte		0x1
.L191:
	.sleb128	13
	.byte		"p_vehicle_info_type_support"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	36
	.byte		0x1
.L192:
	.sleb128	13
	.byte		"p_service_table_support"
	.byte		0
	.4byte		.L5377
	.sleb128	2
	.byte		0x23
	.uleb128	40
	.byte		0x1
.L193:
	.sleb128	13
	.byte		"PBtoPCHashValue_P"
	.byte		0
	.4byte		.L5382
	.sleb128	2
	.byte		0x23
	.uleb128	44
	.byte		0x1
.L194:
	.sleb128	13
	.byte		"PBtoLTHashValue_P"
	.byte		0
	.4byte		.L5382
	.sleb128	2
	.byte		0x23
	.uleb128	48
	.byte		0x1
	.sleb128	0
.L5362:
.L5381:
	.sleb128	12
	.4byte		.L5361
	.uleb128	247
	.uleb128	1
	.4byte		.L5384-.L2
	.byte		"Dcm_Cfg_ServiceTableSupport_Tag"
	.byte		0
	.uleb128	8
.L178:
	.sleb128	13
	.byte		"service_table_id"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L179:
	.sleb128	13
	.byte		"p_service_support"
	.byte		0
	.4byte		.L4067
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5384:
.L3369:
	.sleb128	12
	.4byte		.L5361
	.uleb128	191
	.uleb128	1
	.4byte		.L5385-.L2
	.byte		"Dcm_Cfg_RxChannelType_Tag"
	.byte		0
	.uleb128	44
.L162:
	.sleb128	13
	.byte		"pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L163:
	.sleb128	13
	.byte		"networkId"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L164:
	.sleb128	13
	.byte		"tester_source_addr"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L165:
	.sleb128	13
	.byte		"roe_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L166:
	.sleb128	13
	.byte		"is_roe"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L167:
	.sleb128	13
	.byte		"p_buffer"
	.byte		0
	.4byte		.L5386
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L168:
	.sleb128	13
	.byte		"p_2ndReqBuffer"
	.byte		0
	.4byte		.L5386
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L169:
	.sleb128	13
	.byte		"p_protocol"
	.byte		0
	.4byte		.L5391
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L170:
	.sleb128	13
	.byte		"p_txchannel"
	.byte		0
	.4byte		.L5364
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L171:
	.sleb128	13
	.byte		"addr_type"
	.byte		0
	.4byte		.L5396
	.sleb128	2
	.byte		0x23
	.uleb128	28
	.byte		0x1
.L172:
	.sleb128	13
	.byte		"p_state"
	.byte		0
	.4byte		.L5398
	.sleb128	2
	.byte		0x23
	.uleb128	32
	.byte		0x1
.L173:
	.sleb128	13
	.byte		"p_commMode"
	.byte		0
	.4byte		.L5402
	.sleb128	2
	.byte		0x23
	.uleb128	36
	.byte		0x1
.L174:
	.sleb128	13
	.byte		"p_periodic"
	.byte		0
	.4byte		.L5406
	.sleb128	2
	.byte		0x23
	.uleb128	40
	.byte		0x1
	.sleb128	0
.L5385:
.L5410:
	.sleb128	12
	.4byte		.L5361
	.uleb128	191
	.uleb128	1
	.4byte		.L5411-.L2
	.byte		"Dcm_Cfg_PeriodicResponseType_Tag"
	.byte		0
	.uleb128	12
.L159:
	.sleb128	13
	.byte		"num_tx_channels"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L160:
	.sleb128	13
	.byte		"tx_channels"
	.byte		0
	.4byte		.L5412
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L161:
	.sleb128	13
	.byte		"p_commMode"
	.byte		0
	.4byte		.L5402
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5411:
.L5395:
	.sleb128	12
	.4byte		.L5361
	.uleb128	191
	.uleb128	1
	.4byte		.L5413-.L2
	.byte		"Dcm_Cfg_ProtocolType_Tag"
	.byte		0
	.uleb128	10
.L152:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L5228
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L153:
	.sleb128	13
	.byte		"priority"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	1
	.byte		0x1
.L154:
	.sleb128	13
	.byte		"identifier_table_id"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L155:
	.sleb128	13
	.byte		"send_resp_pend_on_trans_to_boot"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	3
	.byte		0x1
.L156:
	.sleb128	13
	.byte		"preempt_timeout"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L157:
	.sleb128	13
	.byte		"p2_adjust_timeout"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L158:
	.sleb128	13
	.byte		"p2_star_adjust_timeout"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5413:
.L5376:
	.sleb128	12
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5414-.L2
	.byte		"Dcm_Cfg_PeriodicTxChannelType_Tag"
	.byte		0
	.uleb128	8
.L149:
	.sleb128	13
	.byte		"tx_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L150:
	.sleb128	13
	.byte		"conf_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L151:
	.sleb128	13
	.byte		"channel_status"
	.byte		0
	.4byte		.L5415
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5414:
.L5418:
	.sleb128	12
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5419-.L2
	.byte		"Dcm_Cfg_PeriodicTxStatusType_Tag"
	.byte		0
	.uleb128	20
.L144:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L5420
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L145:
	.sleb128	13
	.byte		"buf_pos"
	.byte		0
	.4byte		.L5420
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L146:
	.sleb128	13
	.byte		"buf_ptr"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L147:
	.sleb128	13
	.byte		"pdu_info"
	.byte		0
	.4byte		.L5421
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L148:
	.sleb128	13
	.byte		"state"
	.byte		0
	.4byte		.L5423
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5419:
.L5368:
	.sleb128	12
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5425-.L2
	.byte		"Dcm_Cfg_TxChannelType_Tag"
	.byte		0
	.uleb128	20
.L138:
	.sleb128	13
	.byte		"tx_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L139:
	.sleb128	13
	.byte		"conf_pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L140:
	.sleb128	13
	.byte		"p_buffer"
	.byte		0
	.4byte		.L5387
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L141:
	.sleb128	13
	.byte		"pp_active_buffer"
	.byte		0
	.4byte		.L5426
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L142:
	.sleb128	13
	.byte		"pp_rx_channel"
	.byte		0
	.4byte		.L5428
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L143:
	.sleb128	13
	.byte		"p_busy"
	.byte		0
	.4byte		.L5429
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
	.sleb128	0
.L5425:
.L5390:
	.sleb128	12
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5430-.L2
	.byte		"Dcm_Cfg_BufferType_Tag"
	.byte		0
	.uleb128	16
.L133:
	.sleb128	13
	.byte		"identifier"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L134:
	.sleb128	13
	.byte		"size"
	.byte		0
	.4byte		.L5420
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L135:
	.sleb128	13
	.byte		"ptr"
	.byte		0
	.4byte		.L3234
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L136:
	.sleb128	13
	.byte		"p_status"
	.byte		0
	.4byte		.L5431
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L137:
	.sleb128	13
	.byte		"pdu_info"
	.byte		0
	.4byte		.L5435
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
	.sleb128	0
.L5430:
.L5434:
	.sleb128	12
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5437-.L2
	.byte		"Dcm_Cfg_BufferStatusType_Tag"
	.byte		0
	.uleb128	12
.L130:
	.sleb128	13
	.byte		"pdu_id"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L131:
	.sleb128	13
	.byte		"state"
	.byte		0
	.4byte		.L5438
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L132:
	.sleb128	13
	.byte		"buf_pos"
	.byte		0
	.4byte		.L5420
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5437:
.L5113:
	.sleb128	12
	.4byte		.L5440
	.uleb128	65
	.uleb128	14
	.4byte		.L5441-.L2
	.byte		"Dcm_ProgConditionsType_Tag"
	.byte		0
	.uleb128	10
.L123:
	.sleb128	13
	.byte		"ProtocolId"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L124:
	.sleb128	13
	.byte		"TesterSourceAddr"
	.byte		0
	.4byte		.L3125
	.sleb128	2
	.byte		0x23
	.uleb128	2
	.byte		0x1
.L125:
	.sleb128	13
	.byte		"Sid"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L126:
	.sleb128	13
	.byte		"SubFncId"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	5
	.byte		0x1
.L127:
	.sleb128	13
	.byte		"ReprogramingRequest"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	6
	.byte		0x1
.L128:
	.sleb128	13
	.byte		"ApplUpdated"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	7
	.byte		0x1
.L129:
	.sleb128	13
	.byte		"ResponseRequired"
	.byte		0
	.4byte		.L3129
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
	.sleb128	0
.L5441:
.L3356:
	.sleb128	12
	.4byte		.L5440
	.uleb128	65
	.uleb128	14
	.4byte		.L5442-.L2
	.byte		"Dcm_MsgContextType_Tag"
	.byte		0
	.uleb128	28
.L114:
	.sleb128	13
	.byte		"reqData"
	.byte		0
	.4byte		.L5443
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L115:
	.sleb128	13
	.byte		"reqDataLen"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
.L116:
	.sleb128	13
	.byte		"resData"
	.byte		0
	.4byte		.L5443
	.sleb128	2
	.byte		0x23
	.uleb128	8
	.byte		0x1
.L117:
	.sleb128	13
	.byte		"resDataLen"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	12
	.byte		0x1
.L118:
	.sleb128	13
	.byte		"msgAddInfo"
	.byte		0
	.4byte		.L5444
	.sleb128	2
	.byte		0x23
	.uleb128	16
	.byte		0x1
.L119:
	.sleb128	13
	.byte		"resMaxDataLen"
	.byte		0
	.4byte		.L3193
	.sleb128	2
	.byte		0x23
	.uleb128	20
	.byte		0x1
.L120:
	.sleb128	13
	.byte		"idContext"
	.byte		0
	.4byte		.L5446
	.sleb128	2
	.byte		0x23
	.uleb128	22
	.byte		0x1
.L121:
	.sleb128	13
	.byte		"dcmRxPduId"
	.byte		0
	.4byte		.L3371
	.sleb128	2
	.byte		0x23
	.uleb128	24
	.byte		0x1
.L122:
	.sleb128	13
	.byte		"subServiceId"
	.byte		0
	.4byte		.L3157
	.sleb128	2
	.byte		0x23
	.uleb128	26
	.byte		0x1
	.sleb128	0
.L5442:
.L5445:
	.sleb128	12
	.4byte		.L5440
	.uleb128	65
	.uleb128	14
	.4byte		.L5447-.L2
	.byte		"Dcm_MsgAddInfoType_Tag"
	.byte		0
	.uleb128	4
	.section	.debug_info,,n
.L112:
	.sleb128	14
	.byte		"reqType"
	.byte		0
	.4byte		.L5448
	.uleb128	4
	.byte		0x1
	.byte		0x0
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L113:
	.sleb128	14
	.byte		"suppressPosResponse"
	.byte		0
	.4byte		.L5448
	.uleb128	4
	.byte		0x1
	.byte		0x1
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
	.sleb128	0
.L5447:
.L5422:
	.sleb128	12
	.4byte		.L5449
	.uleb128	69
	.uleb128	1
	.4byte		.L5450-.L2
	.byte		"VSTAR_PduInfoType"
	.byte		0
	.uleb128	8
.L108:
	.sleb128	13
	.byte		"SduDataPtr"
	.byte		0
	.4byte		.L3235
	.sleb128	2
	.byte		0x23
	.uleb128	0
	.byte		0x1
.L109:
	.sleb128	13
	.byte		"SduLength"
	.byte		0
	.4byte		.L5420
	.sleb128	2
	.byte		0x23
	.uleb128	4
	.byte		0x1
	.sleb128	0
.L5450:
	.section	.debug_info,,n
.L4835:
	.sleb128	15
	.4byte		.L3101
	.uleb128	887
	.uleb128	14
	.4byte		.L5451-.L2
	.byte		"Dcm_MemoryOperationKindType_Tag"
	.byte		0
	.uleb128	4
	.section	.debug_info,,n
	.sleb128	16
	.byte		"DCM_MEM_OPERATION_READ"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_MEM_OPERATION_WRITE"
	.byte		0
	.sleb128	1
	.sleb128	0
.L5451:
.L4664:
	.sleb128	15
	.4byte		.L3101
	.uleb128	658
	.uleb128	14
	.4byte		.L5452-.L2
	.byte		"AsynchronousStateType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_INIT"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_PENDING"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_CANCEL"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_ACCEPTED"
	.byte		0
	.sleb128	3
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_REJECTED"
	.byte		0
	.sleb128	4
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_0x10_WAIT_CONF"
	.byte		0
	.sleb128	5
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_0x11_WAIT_CONF"
	.byte		0
	.sleb128	6
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_0x28_WAIT_CONF"
	.byte		0
	.sleb128	7
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_0x85_WAIT_CONF"
	.byte		0
	.sleb128	8
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_FORCE_RCRRP_WAIT_CONF"
	.byte		0
	.sleb128	9
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_SIZE_PENDING"
	.byte		0
	.sleb128	10
	.sleb128	16
	.byte		"DCM_ASYNCH_STATE_0x2F_COMPLETE"
	.byte		0
	.sleb128	11
	.sleb128	0
.L5452:
.L5087:
	.sleb128	15
	.4byte		.L3101
	.uleb128	622
	.uleb128	14
	.4byte		.L5453-.L2
	.byte		"DspDataTransferStateType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DATA_TRANSFER_IDLE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DATA_TRANSFER_NEGOTIATED"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DATA_TRANSFER_ONGOING"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5453:
.L5124:
	.sleb128	15
	.4byte		.L3101
	.uleb128	535
	.uleb128	14
	.4byte		.L5454-.L2
	.byte		"Dcm_DspPeriodicStateType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"PERIODIC_IDLE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"PERIODIC_ON_PROGRESS"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"PERIODIC_WAIT_TO_STOP"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"PERIODIC_WAIT_TO_RESTART"
	.byte		0
	.sleb128	3
	.sleb128	0
.L5454:
.L5082:
	.sleb128	15
	.4byte		.L3101
	.uleb128	494
	.uleb128	14
	.4byte		.L5455-.L2
	.byte		"Dcm_ReadDidOperationKindType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"READ_DID_INIT"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"READ_DID_CONDITION_CHECK"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"READ_DID_LENGTH"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"READ_DID_BUFFER"
	.byte		0
	.sleb128	3
	.sleb128	16
	.byte		"READ_DID_DATA"
	.byte		0
	.sleb128	4
	.sleb128	0
.L5455:
.L5175:
	.sleb128	15
	.4byte		.L5039
	.uleb128	683
	.uleb128	14
	.4byte		.L5456-.L2
	.byte		"Dcm_Cfg_DidEnumType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DID_ENUM_DID"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DID_ENUM_DDDID"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DID_ENUM_OBD_INFOTYPE"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DID_ENUM_OBD_PID"
	.byte		0
	.sleb128	3
	.sleb128	16
	.byte		"DID_ENUM_OBD_MID"
	.byte		0
	.sleb128	4
	.sleb128	16
	.byte		"DID_ENUM_DID_RANGE"
	.byte		0
	.sleb128	5
	.sleb128	0
.L5456:
.L3122:
	.sleb128	15
	.4byte		.L5039
	.uleb128	652
	.uleb128	14
	.4byte		.L5457-.L2
	.byte		"Dcm_Cfg_DDPRIDInitPolicyType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DDPRID_CLEAR_ALWAYS"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DDPRID_CLEAR_ONLY_POWERON"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DDPRID_CLEAR_NEVER"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5457:
.L3119:
	.sleb128	15
	.4byte		.L5039
	.uleb128	643
	.uleb128	14
	.4byte		.L5458-.L2
	.byte		"Dcm_Cfg_DDIDInitPolicyType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DDID_CLEAR_ALWAYS"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DDID_CLEAR_ONLY_POWERON"
	.byte		0
	.sleb128	1
	.sleb128	0
.L5458:
	.section	.debug_info,,n
.L5161:
	.sleb128	17
	.4byte		.L5039
	.uleb128	477
	.uleb128	1
	.4byte		.L5459-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_ROUTINE_STATE_INIT"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_ROUTINE_STATE_STARTED"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_ROUTINE_STATE_STOPPED"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5459:
.L3171:
	.sleb128	17
	.4byte		.L5039
	.uleb128	416
	.uleb128	1
	.4byte		.L5460-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_DD_DID"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_DD_PID"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_DD_VEH_INFO"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DCM_DD_MEMORY"
	.byte		0
	.sleb128	3
	.sleb128	16
	.byte		"DCM_COMP_DID"
	.byte		0
	.sleb128	4
	.sleb128	0
.L5460:
.L5314:
	.sleb128	17
	.4byte		.L5039
	.uleb128	274
	.uleb128	1
	.4byte		.L5461-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_SERVICE_01"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_SERVICE_01_02"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_SERVICE_02"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5461:
.L5340:
	.sleb128	17
	.4byte		.L5039
	.uleb128	213
	.uleb128	1
	.4byte		.L5462-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_NO_BOOT"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_OEM_BOOT"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_SYS_BOOT"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5462:
.L5203:
	.sleb128	15
	.4byte		.L5341
	.uleb128	67
	.uleb128	14
	.4byte		.L5463-.L2
	.byte		"Dcm_Roe_EventStateType_Tag"
	.byte		0
	.uleb128	4
	.sleb128	16
	.byte		"DCM_ROE_CLEARED"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_ROE_STOPPED"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_ROE_STARTED"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DCM_ROE_PAUSED"
	.byte		0
	.sleb128	3
	.sleb128	0
.L5463:
.L5405:
	.sleb128	17
	.4byte		.L5361
	.uleb128	191
	.uleb128	1
	.4byte		.L5464-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_NO_COMM_MODE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_SILENT_COMM_MODE"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_FULL_COMM_MODE"
	.byte		0
	.sleb128	2
	.sleb128	0
.L5464:
.L5401:
	.sleb128	17
	.4byte		.L5361
	.uleb128	180
	.uleb128	1
	.4byte		.L5465-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_CHANNEL_IDLE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_CHANNEL_PENDING"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_CHANNEL_BUSY"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DCM_CHANNEL_2ND_REQ"
	.byte		0
	.sleb128	3
	.sleb128	0
.L5465:
.L5424:
	.sleb128	17
	.4byte		.L5361
	.uleb128	91
	.uleb128	1
	.4byte		.L5466-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_PERIODIC_TX_IDLE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_PERIODIC_TX_PENDING"
	.byte		0
	.sleb128	1
	.sleb128	16
	.byte		"DCM_PERIODIC_TX_BUSY"
	.byte		0
	.sleb128	2
	.sleb128	16
	.byte		"DCM_PERIODIC_TX_CONFIRMED"
	.byte		0
	.sleb128	3
	.sleb128	0
.L5466:
.L5439:
	.sleb128	17
	.4byte		.L5361
	.uleb128	82
	.uleb128	1
	.4byte		.L5467-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_BUF_EMPTY"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_BUF_BUSY"
	.byte		0
	.sleb128	1
	.sleb128	0
.L5467:
.L5397:
	.sleb128	17
	.4byte		.L5361
	.uleb128	73
	.uleb128	1
	.4byte		.L5468-.L2
	.uleb128	4
	.sleb128	16
	.byte		"DCM_PHYSICAL_TYPE"
	.byte		0
	.sleb128	0
	.sleb128	16
	.byte		"DCM_FUNCTIONAL_TYPE"
	.byte		0
	.sleb128	1
	.sleb128	0
.L5468:
	.section	.debug_info,,n
.L3118:
	.sleb128	18
	.byte		"Dcm_Cfg_DDIDInitPolicyType"
	.byte		0
	.4byte		.L3119
.L3121:
	.sleb128	18
	.byte		"Dcm_Cfg_DDPRIDInitPolicyType"
	.byte		0
	.4byte		.L3122
	.section	.debug_info,,n
.L3126:
	.sleb128	19
	.byte		"unsigned short"
	.byte		0
	.byte		0x7
	.byte		0x2
.L3125:
	.sleb128	18
	.byte		"uint16"
	.byte		0
	.4byte		.L3126
.L3130:
	.sleb128	19
	.byte		"unsigned char"
	.byte		0
	.byte		0x8
	.byte		0x1
.L3129:
	.sleb128	18
	.byte		"boolean"
	.byte		0
	.4byte		.L3130
.L3157:
	.sleb128	18
	.byte		"uint8"
	.byte		0
	.4byte		.L3130
.L3156:
	.sleb128	18
	.byte		"Std_ReturnType"
	.byte		0
	.4byte		.L3157
.L3162:
	.sleb128	18
	.byte		"Dcm_Cfg_DDDDidSourceType"
	.byte		0
	.4byte		.L3163
	.section	.debug_info,,n
.L3161:
	.sleb128	20
	.4byte		.L3162
	.section	.debug_info,,n
.L3160:
	.sleb128	21
	.4byte		.L3161
.L3159:
	.sleb128	20
	.4byte		.L3160
.L3166:
	.sleb128	18
	.byte		"Dcm_SesCtrlType"
	.byte		0
	.4byte		.L3157
.L3168:
	.sleb128	18
	.byte		"Dcm_SecLevelType"
	.byte		0
	.4byte		.L3157
.L3170:
	.sleb128	18
	.byte		"Dcm_Cfg_DDSourcesType"
	.byte		0
	.4byte		.L3171
.L3175:
	.sleb128	18
	.byte		"CommonReadDidInfoType"
	.byte		0
	.4byte		.L3176
.L3174:
	.sleb128	21
	.4byte		.L3175
.L3173:
	.sleb128	20
	.4byte		.L3174
.L3180:
	.sleb128	21
	.4byte		.L3125
.L3179:
	.sleb128	20
	.4byte		.L3180
.L3184:
	.sleb128	18
	.byte		"Dcm_NegativeResponseCodeType"
	.byte		0
	.4byte		.L3157
.L3183:
	.sleb128	21
	.4byte		.L3184
.L3182:
	.sleb128	20
	.4byte		.L3183
.L3190:
	.sleb128	20
	.4byte		.L3157
.L3193:
	.sleb128	18
	.byte		"Dcm_MsgLenType"
	.byte		0
	.4byte		.L3125
.L3202:
	.sleb128	18
	.byte		"Dcm_Cfg_MemoryRangeType"
	.byte		0
	.4byte		.L3203
.L3201:
	.sleb128	20
	.4byte		.L3202
.L3200:
	.sleb128	21
	.4byte		.L3201
.L3199:
	.sleb128	18
	.byte		"Dcm_Cfg_MemoryRangePointerType"
	.byte		0
	.4byte		.L3200
.L3207:
	.sleb128	19
	.byte		"unsigned long"
	.byte		0
	.byte		0x7
	.byte		0x4
.L3206:
	.sleb128	18
	.byte		"uint32"
	.byte		0
	.4byte		.L3207
.L3213:
	.sleb128	18
	.byte		"Dcm_Cfg_MemoryType"
	.byte		0
	.4byte		.L3214
.L3212:
	.sleb128	20
	.4byte		.L3213
.L3211:
	.sleb128	21
	.4byte		.L3212
.L3210:
	.sleb128	20
	.4byte		.L3211
.L3225:
	.sleb128	20
	.4byte		.L3200
.L3235:
	.sleb128	21
	.4byte		.L3157
.L3234:
	.sleb128	20
	.4byte		.L3235
.L3239:
	.sleb128	20
	.4byte		.L3199
.L3251:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicDynamicDidType"
	.byte		0
	.4byte		.L3252
.L3250:
	.sleb128	20
	.4byte		.L3251
.L3249:
	.sleb128	21
	.4byte		.L3250
.L3301:
	.sleb128	18
	.byte		"DspPeriodicStatusType"
	.byte		0
	.4byte		.L3302
.L3300:
	.sleb128	20
	.4byte		.L3301
.L3299:
	.sleb128	21
	.4byte		.L3300
.L3298:
	.sleb128	20
	.4byte		.L3299
.L3331:
	.sleb128	18
	.byte		"Dcm_ConfirmationStatusType"
	.byte		0
	.4byte		.L3157
.L3353:
	.sleb128	18
	.byte		"Dcm_OpStatusType"
	.byte		0
	.4byte		.L3157
.L3355:
	.sleb128	18
	.byte		"Dcm_MsgContextType"
	.byte		0
	.4byte		.L3356
.L3354:
	.sleb128	21
	.4byte		.L3355
.L3368:
	.sleb128	18
	.byte		"Dcm_Cfg_RxChannelType"
	.byte		0
	.4byte		.L3369
.L3367:
	.sleb128	20
	.4byte		.L3368
.L3366:
	.sleb128	21
	.4byte		.L3367
.L3365:
	.sleb128	18
	.byte		"Dcm_Cfg_RxChannelPointerType"
	.byte		0
	.4byte		.L3366
.L3371:
	.sleb128	18
	.byte		"PduIdType"
	.byte		0
	.4byte		.L3125
.L3384:
	.sleb128	18
	.byte		"Dcm_Cfg_SessionType"
	.byte		0
	.4byte		.L3385
.L3383:
	.sleb128	20
	.4byte		.L3384
.L3382:
	.sleb128	21
	.4byte		.L3383
.L3381:
	.sleb128	18
	.byte		"Dcm_Cfg_SessionPointerType"
	.byte		0
	.4byte		.L3382
.L3407:
	.sleb128	20
	.4byte		.L3156
.L3414:
	.sleb128	20
	.4byte		.L3166
.L3423:
	.sleb128	18
	.byte		"Dcm_Cfg_SecurityType"
	.byte		0
	.4byte		.L3424
.L3422:
	.sleb128	20
	.4byte		.L3423
.L3421:
	.sleb128	21
	.4byte		.L3422
.L3420:
	.sleb128	18
	.byte		"Dcm_Cfg_SecurityPointerType"
	.byte		0
	.4byte		.L3421
.L3436:
	.sleb128	20
	.4byte		.L3354
.L3442:
	.sleb128	20
	.4byte		.L3420
.L3466:
	.sleb128	20
	.4byte		.L3355
.L3465:
	.sleb128	21
	.4byte		.L3466
.L3464:
	.sleb128	20
	.4byte		.L3465
.L3500:
	.sleb128	18
	.byte		"Dcm_CommunicationModeType"
	.byte		0
	.4byte		.L3157
.L3507:
	.sleb128	20
	.4byte		.L3125
.L3526:
	.sleb128	18
	.byte		"NetworkHandleType"
	.byte		0
	.4byte		.L3157
.L3552:
	.sleb128	18
	.byte		"Dem_ReturnControlDTCSettingType"
	.byte		0
	.4byte		.L3157
.L3551:
	.sleb128	20
	.4byte		.L3552
.L3567:
	.sleb128	20
	.4byte		.L3206
.L3570:
	.sleb128	18
	.byte		"Dem_DTCFormatType"
	.byte		0
	.4byte		.L3157
.L3569:
	.sleb128	20
	.4byte		.L3570
.L3572:
	.sleb128	20
	.4byte		.L3184
.L3577:
	.sleb128	18
	.byte		"Dem_ReturnClearDTCType"
	.byte		0
	.4byte		.L3157
.L3576:
	.sleb128	20
	.4byte		.L3577
.L3598:
	.sleb128	18
	.byte		"Dem_DTCSeverityType"
	.byte		0
	.4byte		.L3157
.L3608:
	.sleb128	18
	.byte		"Dem_DTCOriginType"
	.byte		0
	.4byte		.L3157
.L3620:
	.sleb128	18
	.byte		"Dem_DTCKindType"
	.byte		0
	.4byte		.L3157
.L3625:
	.sleb128	18
	.byte		"Dem_UdsStatusByteType"
	.byte		0
	.4byte		.L3157
.L3629:
	.sleb128	18
	.byte		"Dem_ReturnGetNumberOfFilteredDTCType"
	.byte		0
	.4byte		.L3157
.L3656:
	.sleb128	19
	.byte		"signed char"
	.byte		0
	.byte		0x6
	.byte		0x1
.L3655:
	.sleb128	18
	.byte		"sint8"
	.byte		0
	.4byte		.L3656
.L3659:
	.sleb128	18
	.byte		"Dem_ReturnGetNextFilteredElementType"
	.byte		0
	.4byte		.L3157
.L3658:
	.sleb128	20
	.4byte		.L3659
.L3701:
	.sleb128	20
	.4byte		.L3129
.L3706:
	.sleb128	20
	.4byte		.L3193
.L3769:
	.sleb128	18
	.byte		"ReadExtendedOrSnapshotDataRecordByDTCStatusType"
	.byte		0
	.4byte		.L3770
.L3768:
	.sleb128	21
	.4byte		.L3769
.L3767:
	.sleb128	20
	.4byte		.L3768
.L3774:
	.sleb128	18
	.byte		"Dem_ReturnGetSizeOfDataByDTCType"
	.byte		0
	.4byte		.L3157
.L3782:
	.sleb128	18
	.byte		"Dem_ReturnGetFreezeFrameDataByDTCType"
	.byte		0
	.4byte		.L3157
.L3827:
	.sleb128	18
	.byte		"Dcm_MsgItemType"
	.byte		0
	.4byte		.L3157
.L3826:
	.sleb128	20
	.4byte		.L3827
.L3853:
	.sleb128	18
	.byte		"Dem_ReturnGetExtendedDataRecordByDTCType"
	.byte		0
	.4byte		.L3157
.L3874:
	.sleb128	18
	.byte		"ReportAllDtcDataRecordByDTCNumberStatusType"
	.byte		0
	.4byte		.L3875
.L3873:
	.sleb128	21
	.4byte		.L3874
.L3872:
	.sleb128	20
	.4byte		.L3873
.L3962:
	.sleb128	18
	.byte		"Dem_DTCRequestType"
	.byte		0
	.4byte		.L3157
.L3983:
	.sleb128	21
	.4byte		.L3190
.L4058:
	.sleb128	18
	.byte		"Dcm_Cfg_VehicleInfoType"
	.byte		0
	.4byte		.L4059
.L4057:
	.sleb128	20
	.4byte		.L4058
.L4056:
	.sleb128	21
	.4byte		.L4057
.L4067:
	.sleb128	20
	.4byte		.L3983
.L4100:
	.sleb128	18
	.byte		"Dcm_Cfg_PidType"
	.byte		0
	.4byte		.L4101
.L4099:
	.sleb128	20
	.4byte		.L4100
.L4098:
	.sleb128	21
	.4byte		.L4099
.L4121:
	.sleb128	20
	.4byte		.L3249
.L4168:
	.sleb128	18
	.byte		"Dcm_Cfg_DidType"
	.byte		0
	.4byte		.L4169
.L4167:
	.sleb128	20
	.4byte		.L4168
.L4166:
	.sleb128	21
	.4byte		.L4167
.L4186:
	.sleb128	18
	.byte		"Dcm_Cfg_DidRangeType"
	.byte		0
	.4byte		.L4187
.L4185:
	.sleb128	20
	.4byte		.L4186
.L4184:
	.sleb128	21
	.4byte		.L4185
.L4196:
	.sleb128	18
	.byte		"Dcm_DidSupportedType"
	.byte		0
	.4byte		.L3157
.L4249:
	.sleb128	18
	.byte		"ReadDataByIdentifierStatusType"
	.byte		0
	.4byte		.L4250
.L4248:
	.sleb128	21
	.4byte		.L4249
.L4247:
	.sleb128	20
	.4byte		.L4248
.L4303:
	.sleb128	20
	.4byte		.L4184
	.section	.debug_info,,n
.L4348:
	.sleb128	22
	.4byte		.L4349-.L2
	.4byte		.L3184
	.byte		0x1
	.section	.debug_info,,n
	.sleb128	23
	.4byte		.L3190
	.sleb128	23
	.4byte		.L3190
	.sleb128	23
	.4byte		.L4247
	.sleb128	23
	.4byte		.L3190
	.sleb128	23
	.4byte		.L3190
	.sleb128	0
.L4349:
.L4347:
	.sleb128	21
	.4byte		.L4348
.L4346:
	.sleb128	18
	.byte		"ReadObdFuncType"
	.byte		0
	.4byte		.L4347
.L4415:
	.sleb128	18
	.byte		"Dcm_Cfg_RequestedDidInfoType"
	.byte		0
	.4byte		.L4416
.L4414:
	.sleb128	20
	.4byte		.L4415
.L4413:
	.sleb128	21
	.4byte		.L4414
.L4412:
	.sleb128	20
	.4byte		.L4413
.L4524:
	.sleb128	21
	.4byte		.L3301
.L4553:
	.sleb128	18
	.byte		"Dcm_Cfg_DidPointerType"
	.byte		0
	.4byte		.L4166
.L4592:
	.sleb128	21
	.4byte		.L3162
.L4618:
	.sleb128	18
	.byte		"MemoryDataStructureType"
	.byte		0
	.4byte		.L4619
.L4663:
	.sleb128	18
	.byte		"AsynchronousStateType"
	.byte		0
	.4byte		.L4664
.L4662:
	.sleb128	21
	.4byte		.L4663
.L4674:
	.sleb128	18
	.byte		"WriteDataByIdentifierOperationStatusType"
	.byte		0
	.4byte		.L4675
.L4673:
	.sleb128	21
	.4byte		.L4674
.L4672:
	.sleb128	20
	.4byte		.L4673
.L4709:
	.sleb128	18
	.byte		"DidControlStatusType"
	.byte		0
	.4byte		.L4710
.L4708:
	.sleb128	20
	.4byte		.L4709
.L4707:
	.sleb128	21
	.4byte		.L4708
.L4706:
	.sleb128	20
	.4byte		.L4707
.L4747:
	.sleb128	18
	.byte		"RoutineControlStatusType"
	.byte		0
	.4byte		.L4748
.L4746:
	.sleb128	21
	.4byte		.L4747
.L4745:
	.sleb128	20
	.4byte		.L4746
.L4765:
	.sleb128	21
	.4byte		.L3193
.L4764:
	.sleb128	20
	.4byte		.L4765
	.section	.debug_info,,n
.L4773:
	.sleb128	24
	.4byte		.L4774-.L2
	.4byte		.L3157
	.section	.debug_info,,n
	.sleb128	25
	.uleb128	5
	.sleb128	0
.L4774:
.L4807:
	.sleb128	18
	.byte		"Dcm_Cfg_ReqCtrlType"
	.byte		0
	.4byte		.L4808
.L4806:
	.sleb128	20
	.4byte		.L4807
.L4805:
	.sleb128	21
	.4byte		.L4806
.L4832:
	.sleb128	18
	.byte		"Dcm_ReturnMemOperationType"
	.byte		0
	.4byte		.L3157
.L4834:
	.sleb128	18
	.byte		"Dcm_MemoryOperationKindType"
	.byte		0
	.4byte		.L4835
.L4851:
	.sleb128	22
	.4byte		.L4852-.L2
	.4byte		.L3184
	.byte		0x1
	.sleb128	23
	.4byte		.L3436
	.sleb128	23
	.4byte		.L4618
.L4855:
	.sleb128	18
	.byte		"MemoryAddressOperationStatusType"
	.byte		0
	.4byte		.L4856
.L4854:
	.sleb128	21
	.4byte		.L4855
.L4853:
	.sleb128	20
	.4byte		.L4854
	.sleb128	23
	.4byte		.L4853
	.sleb128	0
.L4852:
.L4850:
	.sleb128	21
	.4byte		.L4851
.L4849:
	.sleb128	18
	.byte		"MemoryInitialisationFuncType"
	.byte		0
	.4byte		.L4850
.L4921:
	.sleb128	20
	.4byte		.L4832
.L4989:
	.sleb128	18
	.byte		"Dcm_Cfg_PidDataType"
	.byte		0
	.4byte		.L4990
.L4988:
	.sleb128	20
	.4byte		.L4989
.L4987:
	.sleb128	21
	.4byte		.L4988
.L5041:
	.sleb128	18
	.byte		"Dcm_LinkTimeConfigType"
	.byte		0
	.4byte		.L5042
.L5040:
	.sleb128	20
	.4byte		.L5041
.L5047:
	.sleb128	18
	.byte		"Dcm_ConfigType"
	.byte		0
	.4byte		.L5048
.L5046:
	.sleb128	20
	.4byte		.L5047
.L5045:
	.sleb128	21
	.4byte		.L5046
.L5050:
	.sleb128	18
	.byte		"DspInstanceType"
	.byte		0
	.4byte		.L5051
.L5053:
	.sleb128	24
	.4byte		.L5054-.L2
	.4byte		.L3190
	.sleb128	25
	.uleb128	8
	.sleb128	0
.L5054:
.L5056:
	.sleb128	24
	.4byte		.L5057-.L2
	.4byte		.L3706
	.sleb128	25
	.uleb128	25
	.sleb128	0
.L5057:
.L5059:
	.sleb128	24
	.4byte		.L5060-.L2
	.4byte		.L3190
	.sleb128	25
	.uleb128	2
	.sleb128	0
.L5060:
.L5062:
	.sleb128	24
	.4byte		.L5063-.L2
	.4byte		.L3190
	.sleb128	25
	.uleb128	1
	.sleb128	0
.L5063:
.L5065:
	.sleb128	18
	.byte		"DspSecAccDataType"
	.byte		0
	.4byte		.L5066
.L5067:
	.sleb128	18
	.byte		"TidControlStatusType"
	.byte		0
	.4byte		.L5068
.L5069:
	.sleb128	18
	.byte		"CommunicationControlStatusType"
	.byte		0
	.4byte		.L5070
.L5071:
	.sleb128	18
	.byte		"ControlDtcSettingStatusType"
	.byte		0
	.4byte		.L5072
.L5073:
	.sleb128	18
	.byte		"DiagnosticSessionControlType"
	.byte		0
	.4byte		.L5074
.L5075:
	.sleb128	18
	.byte		"ReadScalingByIdentifierOperationStatusType"
	.byte		0
	.4byte		.L5076
.L5077:
	.sleb128	18
	.byte		"SoftwareDownloadOperationStatusType"
	.byte		0
	.4byte		.L5078
.L5081:
	.sleb128	18
	.byte		"Dcm_ReadDidOperationKindType"
	.byte		0
	.4byte		.L5082
.L5086:
	.sleb128	18
	.byte		"DspDataTransferStateType"
	.byte		0
	.4byte		.L5087
.L5090:
	.sleb128	21
	.4byte		.L3827
.L5093:
	.sleb128	22
	.4byte		.L5094-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5094:
.L5092:
	.sleb128	21
	.4byte		.L5093
.L5091:
	.sleb128	18
	.byte		"Dcm_WriteDataFuncType"
	.byte		0
	.4byte		.L5092
.L5097:
	.sleb128	22
	.4byte		.L5098-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5098:
.L5096:
	.sleb128	21
	.4byte		.L5097
.L5095:
	.sleb128	18
	.byte		"Dcm_WriteDidDataFuncType"
	.byte		0
	.4byte		.L5096
.L5101:
	.sleb128	22
	.4byte		.L5102-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3353
.L5103:
	.sleb128	21
	.4byte		.L4196
	.sleb128	23
	.4byte		.L5103
	.sleb128	0
.L5102:
.L5100:
	.sleb128	21
	.4byte		.L5101
.L5099:
	.sleb128	18
	.byte		"Dcm_IsDidAvailableFuncType"
	.byte		0
	.4byte		.L5100
.L5106:
	.sleb128	22
	.4byte		.L5107-.L2
	.4byte		.L3184
	.byte		0x1
	.sleb128	0
.L5107:
.L5105:
	.sleb128	21
	.4byte		.L5106
.L5104:
	.sleb128	18
	.byte		"Dcm_ModeRuleFuncType"
	.byte		0
	.4byte		.L5105
.L5112:
	.sleb128	18
	.byte		"Dcm_ProgConditionsType"
	.byte		0
	.4byte		.L5113
.L5119:
	.sleb128	18
	.byte		"Dcm_Cfg_RoutineCtrlType"
	.byte		0
	.4byte		.L5120
.L5118:
	.sleb128	20
	.4byte		.L5119
.L5117:
	.sleb128	21
	.4byte		.L5118
.L5123:
	.sleb128	18
	.byte		"Dcm_DspPeriodicStateType"
	.byte		0
	.4byte		.L5124
.L5127:
	.sleb128	24
	.4byte		.L5128-.L2
	.4byte		.L3125
	.sleb128	25
	.uleb128	2
	.sleb128	0
.L5128:
.L5129:
	.sleb128	20
	.4byte		.L3382
.L5130:
	.sleb128	20
	.4byte		.L3421
.L5134:
	.sleb128	18
	.byte		"Dcm_Cfg_ServiceTableType"
	.byte		0
	.4byte		.L5135
.L5133:
	.sleb128	20
	.4byte		.L5134
.L5132:
	.sleb128	21
	.4byte		.L5133
.L5131:
	.sleb128	20
	.4byte		.L5132
.L5137:
	.sleb128	21
	.4byte		.L4415
.L5136:
	.sleb128	20
	.4byte		.L5137
.L5138:
	.sleb128	20
	.4byte		.L4166
.L5139:
	.sleb128	20
	.4byte		.L4098
.L5140:
	.sleb128	20
	.4byte		.L4805
.L5144:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeType"
	.byte		0
	.4byte		.L5145
.L5143:
	.sleb128	20
	.4byte		.L5144
.L5142:
	.sleb128	21
	.4byte		.L5143
.L5141:
	.sleb128	20
	.4byte		.L5142
.L5146:
	.sleb128	20
	.4byte		.L4056
.L5147:
	.sleb128	20
	.4byte		.L5117
.L5151:
	.sleb128	18
	.byte		"Dcm_Cfg_CallbackReqServType"
	.byte		0
	.4byte		.L5152
.L5150:
	.sleb128	20
	.4byte		.L5151
.L5149:
	.sleb128	21
	.4byte		.L5150
.L5148:
	.sleb128	20
	.4byte		.L5149
.L5156:
	.sleb128	18
	.byte		"Dcm_Cfg_SoftwareDownloadType"
	.byte		0
	.4byte		.L5157
.L5155:
	.sleb128	20
	.4byte		.L5156
.L5154:
	.sleb128	21
	.4byte		.L5155
.L5153:
	.sleb128	20
	.4byte		.L5154
.L5160:
	.sleb128	18
	.byte		"Dcm_Cfg_RoutineStateType"
	.byte		0
	.4byte		.L5161
.L5159:
	.sleb128	21
	.4byte		.L5160
.L5158:
	.sleb128	20
	.4byte		.L5159
.L5165:
	.sleb128	18
	.byte		"Dcm_Cfg_DDidInitInfoType"
	.byte		0
	.4byte		.L5166
.L5164:
	.sleb128	20
	.4byte		.L5165
.L5163:
	.sleb128	21
	.4byte		.L5164
.L5162:
	.sleb128	20
	.4byte		.L5163
	.section	.debug_info,,n
.L5168:
	.sleb128	26
	.4byte		.L5169-.L2
	.byte		0x1
	.sleb128	0
.L5169:
.L5167:
	.sleb128	21
	.4byte		.L5168
.L5171:
	.sleb128	26
	.4byte		.L5172-.L2
	.byte		0x1
	.sleb128	0
.L5172:
.L5170:
	.sleb128	21
	.4byte		.L5171
.L5174:
	.sleb128	18
	.byte		"Dcm_Cfg_DidEnumType"
	.byte		0
	.4byte		.L5175
.L5177:
	.sleb128	21
	.4byte		.L3206
.L5182:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeEventType"
	.byte		0
	.4byte		.L5183
.L5181:
	.sleb128	20
	.4byte		.L5182
.L5180:
	.sleb128	21
	.4byte		.L5181
.L5179:
	.sleb128	20
	.4byte		.L5180
.L5187:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeEventWindowTimeType"
	.byte		0
	.4byte		.L5188
.L5186:
	.sleb128	20
	.4byte		.L5187
.L5185:
	.sleb128	21
	.4byte		.L5186
.L5184:
	.sleb128	20
	.4byte		.L5185
.L5191:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeNvmStatusType"
	.byte		0
	.4byte		.L5192
.L5190:
	.sleb128	21
	.4byte		.L5191
.L5189:
	.sleb128	20
	.4byte		.L5190
.L5195:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeEventStatusType"
	.byte		0
	.4byte		.L5196
.L5194:
	.sleb128	21
	.4byte		.L5195
.L5193:
	.sleb128	20
	.4byte		.L5194
.L5199:
	.sleb128	18
	.byte		"Dcm_Cfg_RoeNvmEventStatusType"
	.byte		0
	.4byte		.L5200
.L5198:
	.sleb128	21
	.4byte		.L5199
.L5197:
	.sleb128	20
	.4byte		.L5198
.L5202:
	.sleb128	18
	.byte		"Dcm_Roe_EventStateType"
	.byte		0
	.4byte		.L5203
.L5207:
	.sleb128	22
	.4byte		.L5208-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3157
	.sleb128	0
.L5208:
.L5206:
	.sleb128	21
	.4byte		.L5207
.L5212:
	.sleb128	22
	.4byte		.L5213-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3157
	.sleb128	23
	.4byte		.L3206
	.sleb128	23
	.4byte		.L3206
	.sleb128	23
	.4byte		.L5177
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5213:
.L5211:
	.sleb128	21
	.4byte		.L5212
.L5210:
	.sleb128	18
	.byte		"Dcm_ProcessRequestDownloadFuncType"
	.byte		0
	.4byte		.L5211
.L5216:
	.sleb128	22
	.4byte		.L5217-.L2
	.4byte		.L4832
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3157
	.sleb128	23
	.4byte		.L3206
	.sleb128	23
	.4byte		.L3206
	.sleb128	23
	.4byte		.L3235
	.sleb128	0
.L5217:
.L5215:
	.sleb128	21
	.4byte		.L5216
.L5214:
	.sleb128	18
	.byte		"Dcm_MemOperationType"
	.byte		0
	.4byte		.L5215
.L5220:
	.sleb128	22
	.4byte		.L5221-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3206
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5221:
.L5219:
	.sleb128	21
	.4byte		.L5220
.L5218:
	.sleb128	18
	.byte		"Dcm_ProcessRequestTransferExitFuncType"
	.byte		0
	.4byte		.L5219
.L5226:
	.sleb128	22
	.4byte		.L5227-.L2
	.4byte		.L3156
	.byte		0x1
.L5228:
	.sleb128	18
	.byte		"Dcm_ProtocolType"
	.byte		0
	.4byte		.L3157
	.sleb128	23
	.4byte		.L5228
	.sleb128	0
.L5227:
.L5225:
	.sleb128	21
	.4byte		.L5226
.L5230:
	.sleb128	22
	.4byte		.L5231-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L5228
	.sleb128	0
.L5231:
.L5229:
	.sleb128	21
	.4byte		.L5230
.L5234:
	.sleb128	22
	.4byte		.L5235-.L2
	.4byte		.L3157
	.byte		0x1
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3180
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5235:
.L5233:
	.sleb128	21
	.4byte		.L5234
.L5237:
	.sleb128	22
	.4byte		.L5238-.L2
	.4byte		.L3157
	.byte		0x1
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3180
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5238:
.L5236:
	.sleb128	21
	.4byte		.L5237
.L5240:
	.sleb128	22
	.4byte		.L5241-.L2
	.4byte		.L3157
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3180
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5241:
.L5239:
	.sleb128	21
	.4byte		.L5240
.L5246:
	.sleb128	18
	.byte		"Dcm_Cfg_DDDDidInfoType"
	.byte		0
	.4byte		.L5247
.L5245:
	.sleb128	20
	.4byte		.L5246
.L5244:
	.sleb128	21
	.4byte		.L5245
.L5243:
	.sleb128	20
	.4byte		.L5244
.L5248:
	.sleb128	20
	.4byte		.L4592
.L5251:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicSampleDataType"
	.byte		0
	.4byte		.L5252
.L5250:
	.sleb128	21
	.4byte		.L5251
.L5249:
	.sleb128	20
	.4byte		.L5250
.L5258:
	.sleb128	18
	.byte		"Dcm_Cfg_DidReadType"
	.byte		0
	.4byte		.L5259
.L5257:
	.sleb128	20
	.4byte		.L5258
.L5256:
	.sleb128	21
	.4byte		.L5257
.L5264:
	.sleb128	18
	.byte		"Dcm_Cfg_DidRangeReadType"
	.byte		0
	.4byte		.L5265
.L5263:
	.sleb128	20
	.4byte		.L5264
.L5262:
	.sleb128	21
	.4byte		.L5263
.L5261:
	.sleb128	20
	.4byte		.L5262
.L5269:
	.sleb128	18
	.byte		"Dcm_Cfg_DidRangeWriteType"
	.byte		0
	.4byte		.L5270
.L5268:
	.sleb128	20
	.4byte		.L5269
.L5267:
	.sleb128	21
	.4byte		.L5268
.L5266:
	.sleb128	20
	.4byte		.L5267
.L5275:
	.sleb128	22
	.4byte		.L5276-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3180
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5276:
.L5274:
	.sleb128	21
	.4byte		.L5275
.L5273:
	.sleb128	18
	.byte		"Dcm_ReadDidDataFuncType"
	.byte		0
	.4byte		.L5274
.L5279:
	.sleb128	22
	.4byte		.L5280-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3125
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3180
	.sleb128	0
.L5280:
.L5278:
	.sleb128	21
	.4byte		.L5279
.L5277:
	.sleb128	18
	.byte		"Dcm_ReadDidDataLengthFuncType"
	.byte		0
	.4byte		.L5278
.L5285:
	.sleb128	18
	.byte		"Dcm_Cfg_DidWriteType"
	.byte		0
	.4byte		.L5286
.L5284:
	.sleb128	20
	.4byte		.L5285
.L5283:
	.sleb128	21
	.4byte		.L5284
.L5282:
	.sleb128	20
	.4byte		.L5283
.L5287:
	.sleb128	20
	.4byte		.L5256
.L5291:
	.sleb128	18
	.byte		"Dcm_Cfg_DidControlType"
	.byte		0
	.4byte		.L5292
.L5290:
	.sleb128	20
	.4byte		.L5291
.L5289:
	.sleb128	21
	.4byte		.L5290
.L5288:
	.sleb128	20
	.4byte		.L5289
.L5295:
	.sleb128	22
	.4byte		.L5296-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5296:
.L5294:
	.sleb128	21
	.4byte		.L5295
.L5293:
	.sleb128	18
	.byte		"Dcm_GetScalingInformationFuncType"
	.byte		0
	.4byte		.L5294
.L5300:
	.sleb128	22
	.4byte		.L5301-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	0
.L5301:
.L5299:
	.sleb128	21
	.4byte		.L5300
.L5298:
	.sleb128	18
	.byte		"Dcm_ReadDataFuncType"
	.byte		0
	.4byte		.L5299
.L5305:
	.sleb128	22
	.4byte		.L5306-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5306:
.L5304:
	.sleb128	21
	.4byte		.L5305
.L5303:
	.sleb128	18
	.byte		"Dcm_ConditionCheckReadFuncType"
	.byte		0
	.4byte		.L5304
.L5309:
	.sleb128	22
	.4byte		.L5310-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3180
	.sleb128	0
.L5310:
.L5308:
	.sleb128	21
	.4byte		.L5309
.L5307:
	.sleb128	18
	.byte		"Dcm_ReadDataLengthFuncType"
	.byte		0
	.4byte		.L5308
.L5313:
	.sleb128	18
	.byte		"Dcm_Cfg_PidServiceType"
	.byte		0
	.4byte		.L5314
.L5315:
	.sleb128	20
	.4byte		.L4987
.L5318:
	.sleb128	22
	.4byte		.L5319-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3235
	.sleb128	0
.L5319:
.L5317:
	.sleb128	21
	.4byte		.L5318
.L5322:
	.sleb128	22
	.4byte		.L5323-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	0
.L5323:
.L5321:
	.sleb128	21
	.4byte		.L5322
.L5327:
	.sleb128	22
	.4byte		.L5328-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3983
	.sleb128	0
.L5328:
.L5326:
	.sleb128	21
	.4byte		.L5327
.L5325:
	.sleb128	18
	.byte		"Dcm_RequestControlFuncType"
	.byte		0
	.4byte		.L5326
.L5332:
	.sleb128	22
	.4byte		.L5333-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3235
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5333:
.L5331:
	.sleb128	21
	.4byte		.L5332
.L5330:
	.sleb128	18
	.byte		"Dcm_GetSeedFuncType"
	.byte		0
	.4byte		.L5331
.L5336:
	.sleb128	22
	.4byte		.L5337-.L2
	.4byte		.L3156
	.byte		0x1
	.sleb128	23
	.4byte		.L3983
	.sleb128	23
	.4byte		.L3353
	.sleb128	23
	.4byte		.L3183
	.sleb128	0
.L5337:
.L5335:
	.sleb128	21
	.4byte		.L5336
.L5334:
	.sleb128	18
	.byte		"Dcm_CompareKeyFuncType"
	.byte		0
	.4byte		.L5335
.L5339:
	.sleb128	18
	.byte		"Dcm_Cfg_SessionsForBootEnum"
	.byte		0
	.4byte		.L5340
.L5346:
	.sleb128	18
	.byte		"Dcm_Cfg_ServiceType"
	.byte		0
	.4byte		.L5347
.L5345:
	.sleb128	20
	.4byte		.L5346
.L5344:
	.sleb128	21
	.4byte		.L5345
.L5343:
	.sleb128	20
	.4byte		.L5344
.L5351:
	.sleb128	26
	.4byte		.L5352-.L2
	.byte		0x1
	.sleb128	0
.L5352:
.L5350:
	.sleb128	21
	.4byte		.L5351
.L5349:
	.sleb128	18
	.byte		"Dcm_ServiceTriggerFuncType"
	.byte		0
	.4byte		.L5350
.L5356:
	.sleb128	18
	.byte		"Dcm_Cfg_SubServiceType"
	.byte		0
	.4byte		.L5357
.L5355:
	.sleb128	20
	.4byte		.L5356
.L5354:
	.sleb128	21
	.4byte		.L5355
.L5353:
	.sleb128	20
	.4byte		.L5354
.L5363:
	.sleb128	20
	.4byte		.L3366
.L5367:
	.sleb128	18
	.byte		"Dcm_Cfg_TxChannelType"
	.byte		0
	.4byte		.L5368
.L5366:
	.sleb128	20
	.4byte		.L5367
.L5365:
	.sleb128	21
	.4byte		.L5366
.L5364:
	.sleb128	20
	.4byte		.L5365
.L5375:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicTxChannelType"
	.byte		0
	.4byte		.L5376
.L5374:
	.sleb128	20
	.4byte		.L5375
.L5373:
	.sleb128	21
	.4byte		.L5374
.L5372:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicTxChannelPointerType"
	.byte		0
	.4byte		.L5373
.L5371:
	.sleb128	20
	.4byte		.L5372
.L5370:
	.sleb128	21
	.4byte		.L5371
.L5369:
	.sleb128	20
	.4byte		.L5370
.L5380:
	.sleb128	18
	.byte		"Dcm_Cfg_ServiceTableSupport"
	.byte		0
	.4byte		.L5381
.L5379:
	.sleb128	20
	.4byte		.L5380
.L5378:
	.sleb128	21
	.4byte		.L5379
.L5377:
	.sleb128	20
	.4byte		.L5378
.L5383:
	.sleb128	21
	.4byte		.L3567
.L5382:
	.sleb128	20
	.4byte		.L5383
.L5389:
	.sleb128	18
	.byte		"Dcm_Cfg_BufferType"
	.byte		0
	.4byte		.L5390
.L5388:
	.sleb128	20
	.4byte		.L5389
.L5387:
	.sleb128	21
	.4byte		.L5388
.L5386:
	.sleb128	20
	.4byte		.L5387
.L5394:
	.sleb128	18
	.byte		"Dcm_Cfg_ProtocolType"
	.byte		0
	.4byte		.L5395
.L5393:
	.sleb128	20
	.4byte		.L5394
.L5392:
	.sleb128	21
	.4byte		.L5393
.L5391:
	.sleb128	20
	.4byte		.L5392
.L5396:
	.sleb128	18
	.byte		"Dcm_Cfg_AddrTypeType"
	.byte		0
	.4byte		.L5397
.L5400:
	.sleb128	18
	.byte		"Dcm_Cfg_ChannelStateType"
	.byte		0
	.4byte		.L5401
.L5399:
	.sleb128	21
	.4byte		.L5400
.L5398:
	.sleb128	20
	.4byte		.L5399
.L5404:
	.sleb128	18
	.byte		"Dcm_Cfg_ChannelCommModeType"
	.byte		0
	.4byte		.L5405
.L5403:
	.sleb128	21
	.4byte		.L5404
.L5402:
	.sleb128	20
	.4byte		.L5403
.L5409:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicResponseType"
	.byte		0
	.4byte		.L5410
.L5408:
	.sleb128	20
	.4byte		.L5409
.L5407:
	.sleb128	21
	.4byte		.L5408
.L5406:
	.sleb128	20
	.4byte		.L5407
.L5412:
	.sleb128	20
	.4byte		.L5373
.L5417:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicTxStatusType"
	.byte		0
	.4byte		.L5418
.L5416:
	.sleb128	21
	.4byte		.L5417
.L5415:
	.sleb128	20
	.4byte		.L5416
.L5420:
	.sleb128	18
	.byte		"PduLengthType"
	.byte		0
	.4byte		.L3125
.L5421:
	.sleb128	18
	.byte		"PduInfoType"
	.byte		0
	.4byte		.L5422
.L5423:
	.sleb128	18
	.byte		"Dcm_Cfg_PeriodicTxChannelStateType"
	.byte		0
	.4byte		.L5424
.L5427:
	.sleb128	18
	.byte		"Dcm_Cfg_BufferPointerType"
	.byte		0
	.4byte		.L5387
.L5426:
	.sleb128	21
	.4byte		.L5427
.L5428:
	.sleb128	21
	.4byte		.L3365
.L5429:
	.sleb128	21
	.4byte		.L3129
.L5433:
	.sleb128	18
	.byte		"Dcm_Cfg_BufferStatusType"
	.byte		0
	.4byte		.L5434
.L5432:
	.sleb128	21
	.4byte		.L5433
.L5431:
	.sleb128	20
	.4byte		.L5432
.L5436:
	.sleb128	21
	.4byte		.L5421
.L5435:
	.sleb128	20
	.4byte		.L5436
.L5438:
	.sleb128	18
	.byte		"Dcm_Cfg_BufferStateType"
	.byte		0
	.4byte		.L5439
.L5443:
	.sleb128	18
	.byte		"Dcm_MsgType"
	.byte		0
	.4byte		.L5090
.L5444:
	.sleb128	18
	.byte		"Dcm_MsgAddInfoType"
	.byte		0
	.4byte		.L5445
.L5446:
	.sleb128	18
	.byte		"Dcm_IdContextType"
	.byte		0
	.4byte		.L3157
.L5448:
	.sleb128	19
	.byte		"unsigned int"
	.byte		0
	.byte		0x7
	.byte		0x4
.L7:
	.sleb128	0
.L3:

	.section	.debug_loc,,n
	.align	0
.L3120:
	.d2locreg	%offsetof(.Llo1), %offsetof(.Llo2),3
	.d2locreg	%offsetof(.Llo3), %offsetof(.Llo4),3
	.d2locend
.L3123:
	.d2locreg	%offsetof(.Llo1), %offsetof(.Llo5),4
	.d2locreg	%offsetof(.Llo6), %offsetof(.Llo2),0
	.d2locreg	%offsetof(.Llo7), %offsetof(.Llo4),0
	.d2locend
.L3127:
	.d2locreg	%offsetof(.Llo5), %offsetof(.Llo2),4
	.d2locend
.L3131:
	.d2locreg	%offsetof(.Llo8), %offsetof(.Llo2),7
	.d2locend
.L3164:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo10),3
	.d2locreg	%offsetof(.Llo11), %offsetof(.Llo12),31
	.d2locend
.L3165:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo13),4
	.d2locreg	%offsetof(.Llo11), %offsetof(.Llo14),30
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo16),30
	.d2locend
.L3167:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),5
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo18),3
	.d2locreg	%offsetof(.Llo19), %offsetof(.Llo20),5
	.d2locreg	%offsetof(.Llo21), %offsetof(.Llo22),3
	.d2locreg	%offsetof(.Llo23), %offsetof(.Llo24),3
	.d2locreg	%offsetof(.Llo25), %offsetof(.Llo26),3
	.d2locreg	%offsetof(.Llo27), %offsetof(.Llo28),3
	.d2locreg	%offsetof(.Llo29), %offsetof(.Llo30),3
	.d2locreg	%offsetof(.Llo31), %offsetof(.Llo32),3
	.d2locreg	%offsetof(.Llo33), %offsetof(.Llo34),5
	.d2locreg	%offsetof(.Llo35), %offsetof(.Llo36),5
	.d2locreg	%offsetof(.Llo37), %offsetof(.Llo38),5
	.d2locreg	%offsetof(.Llo39), %offsetof(.Llo14),5
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo40),5
	.d2locreg	%offsetof(.Llo41), %offsetof(.Llo42),3
	.d2locreg	%offsetof(.Llo43), %offsetof(.Llo44),5
	.d2locend
.L3169:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),6
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo45),29
	.d2locreg	%offsetof(.Llo31), %offsetof(.Llo32),29
	.d2locreg	%offsetof(.Llo33), %offsetof(.Llo34),6
	.d2locreg	%offsetof(.Llo35), %offsetof(.Llo36),6
	.d2locreg	%offsetof(.Llo37), %offsetof(.Llo38),6
	.d2locreg	%offsetof(.Llo39), %offsetof(.Llo14),6
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo40),6
	.d2locreg	%offsetof(.Llo43), %offsetof(.Llo44),6
	.d2locend
.L3172:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),7
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo46),28
	.d2locreg	%offsetof(.Llo47), %offsetof(.Llo14),7
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo40),7
	.d2locreg	%offsetof(.Llo43), %offsetof(.Llo44),7
	.d2locend
.L3177:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),8
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo12),27
	.d2locreg	%offsetof(.Llo48), %offsetof(.Llo44),8
	.d2locend
.L3178:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),9
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo49),26
	.d2locreg	%offsetof(.Llo50), %offsetof(.Llo38),9
	.d2locreg	%offsetof(.Llo39), %offsetof(.Llo51),9
	.d2locreg	%offsetof(.Llo52), %offsetof(.Llo53),26
	.d2locreg	%offsetof(.Llo54), %offsetof(.Llo14),9
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo40),9
	.d2locreg	%offsetof(.Llo43), %offsetof(.Llo44),9
	.d2locend
.L3181:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo11),10
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo12),25
	.d2locreg	%offsetof(.Llo48), %offsetof(.Llo44),10
	.d2locend
.L3185:
	.d2locreg	%offsetof(.Llo55), %offsetof(.Llo30),24
	.d2locreg	%offsetof(.Llo56), %offsetof(.Llo32),24
	.d2locend
.L3187:
	.d2locreg	%offsetof(.Llo9), %offsetof(.Llo30),22
	.d2locreg	%offsetof(.Llo57), %offsetof(.Llo56),3
	.d2locreg	%offsetof(.Llo58), %offsetof(.Llo59),22
	.d2locreg	%offsetof(.Llo34), %offsetof(.Llo35),3
	.d2locreg	%offsetof(.Llo60), %offsetof(.Llo61),22
	.d2locreg	%offsetof(.Llo62), %offsetof(.Llo63),22
	.d2locreg	%offsetof(.Llo36), %offsetof(.Llo37),3
	.d2locreg	%offsetof(.Llo64), %offsetof(.Llo46),22
	.d2locreg	%offsetof(.Llo14), %offsetof(.Llo15),3
	.d2locreg	%offsetof(.Llo65), %offsetof(.Llo66),22
	.d2locreg	%offsetof(.Llo40), %offsetof(.Llo67),3
	.d2locreg	%offsetof(.Llo41), %offsetof(.Llo68),22
	.d2locend
.L3191:
	.d2locreg	%offsetof(.Llo69), %offsetof(.Llo11),0
	.d2locreg	%offsetof(.Llo17), %offsetof(.Llo70),4
	.d2locreg	%offsetof(.Llo71), %offsetof(.Llo72),23
	.d2locreg	%offsetof(.Llo73), %offsetof(.Llo74),4
	.d2locreg	%offsetof(.Llo15), %offsetof(.Llo16),23
	.d2locreg	%offsetof(.Llo75), %offsetof(.Llo76),4
	.d2locreg	%offsetof(.Llo77), %offsetof(.Llo67),0
	.d2locreg	%offsetof(.Llo78), %offsetof(.Llo79),4
	.d2locreg	%offsetof(.Llo80), %offsetof(.Llo43),0
	.d2locreg	%offsetof(.Llo81), %offsetof(.Llo82),0
	.d2locreg	%offsetof(.Llo83), %offsetof(.Llo84),0
	.d2locreg	%offsetof(.Llo85), %offsetof(.Llo86),0
	.d2locreg	%offsetof(.Llo87), %offsetof(.Llo88),0
	.d2locreg	%offsetof(.Llo89), %offsetof(.Llo12),0
	.d2locend
.L3194:
	.d2locreg	%offsetof(.Llo90), %offsetof(.Llo38),0
	.d2locend
.L3205:
	.d2locreg	%offsetof(.Llo91), %offsetof(.Llo92),3
	.d2locend
.L3208:
	.d2locreg	%offsetof(.Llo91), %offsetof(.Llo92),4
	.d2locend
.L3209:
	.d2locreg	%offsetof(.Llo91), %offsetof(.Llo92),5
	.d2locend
.L3215:
	.d2locreg	%offsetof(.Llo91), %offsetof(.Llo92),6
	.d2locend
.L3217:
	.d2locreg	%offsetof(.Llo93), %offsetof(.Llo94),7
	.d2locend
.L3219:
	.d2locreg	%offsetof(.Llo95), %offsetof(.Llo96),31
	.d2locreg	%offsetof(.Llo97), %offsetof(.Llo92),31
	.d2locend
.L3226:
	.d2locreg	%offsetof(.Llo98), %offsetof(.Llo99),3
	.d2locreg	%offsetof(.Llo100), %offsetof(.Llo101),31
	.d2locend
.L3233:
	.d2locreg	%offsetof(.Llo102), %offsetof(.Llo103),3
	.d2locreg	%offsetof(.Llo104), %offsetof(.Llo105),31
	.d2locend
.L3236:
	.d2locreg	%offsetof(.Llo102), %offsetof(.Llo104),4
	.d2locreg	%offsetof(.Llo106), %offsetof(.Llo107),27
	.d2locend
.L3237:
	.d2locreg	%offsetof(.Llo102), %offsetof(.Llo108),5
	.d2locreg	%offsetof(.Llo107), %offsetof(.Llo109),30
	.d2locend
.L3240:
	.d2locreg	%offsetof(.Llo110), %offsetof(.Llo107),3
	.d2locreg	%offsetof(.Llo111), %offsetof(.Llo112),29
	.d2locreg	%offsetof(.Llo113), %offsetof(.Llo114),3
	.d2locreg	%offsetof(.Llo105), %offsetof(.Llo115),3
	.d2locend
.L3242:
	.d2locreg	%offsetof(.Llo116), %offsetof(.Llo117),28
	.d2locend
.L3253:
	.d2locreg	%offsetof(.Llo118), %offsetof(.Llo119),3
	.d2locreg	%offsetof(.Llo120), %offsetof(.Llo121),31
	.d2locend
.L3254:
	.d2locreg	%offsetof(.Llo118), %offsetof(.Llo120),4
	.d2locreg	%offsetof(.Llo122), %offsetof(.Llo121),30
	.d2locend
.L3255:
	.d2locreg	%offsetof(.Llo118), %offsetof(.Llo120),5
	.d2locreg	%offsetof(.Llo122), %offsetof(.Llo121),29
	.d2locreg	%offsetof(.Llo123), %offsetof(.Llo124),5
	.d2locend
.L3257:
	.d2locreg	%offsetof(.Llo125), %offsetof(.Llo121),28
	.d2locend
.L3260:
	.d2locreg	%offsetof(.Llo126), %offsetof(.Llo127),0
	.d2locreg	%offsetof(.Llo128), %offsetof(.Llo129),3
	.d2locend
.L3262:
	.d2locreg	%offsetof(.Llo130), %offsetof(.Llo121),27
	.d2locend
.L3269:
	.d2locreg	%offsetof(.Llo131), %offsetof(.Llo132),26
	.d2locreg	%offsetof(.Llo133), %offsetof(.Llo134),4
	.d2locreg	%offsetof(.Llo135), %offsetof(.Llo121),26
	.d2locend
.L3276:
	.d2locreg	%offsetof(.Llo136), %offsetof(.Llo137),0
	.d2locreg	%offsetof(.Llo138), %offsetof(.Llo139),0
	.d2locreg	%offsetof(.Llo140), %offsetof(.Llo141),0
	.d2locreg	%offsetof(.Llo142), %offsetof(.Llo143),0
	.d2locend
.L3280:
	.d2locreg	%offsetof(.Llo144), %offsetof(.Llo145),31
	.d2locreg	%offsetof(.Llo139), %offsetof(.Llo146),0
	.d2locend
.L3282:
	.d2locreg	%offsetof(.Llo145), %offsetof(.Llo147),31
	.d2locreg	%offsetof(.Llo148), %offsetof(.Llo143),3
	.d2locend
.L3303:
	.d2locreg	%offsetof(.Llo149), %offsetof(.Llo150),3
	.d2locend
.L3309:
	.d2locreg	%offsetof(.Llo151), %offsetof(.Llo152),3
	.d2locend
.L3316:
	.d2locreg	%offsetof(.Llo153), %offsetof(.Llo154),0
	.d2locreg	%offsetof(.Llo155), %offsetof(.Llo156),0
	.d2locreg	%offsetof(.Llo157), %offsetof(.Llo158),0
	.d2locreg	%offsetof(.Llo159), %offsetof(.Llo160),0
	.d2locend
.L3318:
	.d2locreg	%offsetof(.Llo161), %offsetof(.Llo162),31
	.d2locreg	%offsetof(.Llo163), %offsetof(.Llo164),3
	.d2locreg	%offsetof(.Llo165), %offsetof(.Llo166),3
	.d2locend
.L3320:
	.d2locreg	%offsetof(.Llo167), %offsetof(.Llo168),30
	.d2locreg	%offsetof(.Llo169), %offsetof(.Llo157),0
	.d2locreg	%offsetof(.Llo158), %offsetof(.Llo170),30
	.d2locend
.L3332:
	.d2locreg	%offsetof(.Llo171), %offsetof(.Llo172),3
	.d2locreg	%offsetof(.Llo173), %offsetof(.Llo174),3
	.d2locreg	%offsetof(.Llo175), %offsetof(.Llo176),3
	.d2locreg	%offsetof(.Llo177), %offsetof(.Llo178),3
	.d2locreg	%offsetof(.Llo179), %offsetof(.Llo180),3
	.d2locreg	%offsetof(.Llo181), %offsetof(.Llo182),3
	.d2locreg	%offsetof(.Llo183), %offsetof(.Llo184),3
	.d2locreg	%offsetof(.Llo185), %offsetof(.Llo186),3
	.d2locend
.L3357:
	.d2locreg	%offsetof(.Llo187), %offsetof(.Llo188),4
	.d2locreg	%offsetof(.Llo189), %offsetof(.Llo190),31
	.d2locreg	%offsetof(.Llo191), %offsetof(.Llo192),4
	.d2locend
.L3358:
	.d2locreg	%offsetof(.Llo187), %offsetof(.Llo188),5
	.d2locreg	%offsetof(.Llo189), %offsetof(.Llo190),30
	.d2locreg	%offsetof(.Llo191), %offsetof(.Llo192),5
	.d2locend
.L3360:
	.d2locreg	%offsetof(.Llo193), %offsetof(.Llo194),29
	.d2locend
.L3372:
	.d2locreg	%offsetof(.Llo195), %offsetof(.Llo196),3
	.d2locreg	%offsetof(.Llo197), %offsetof(.Llo198),0
	.d2locend
.L3374:
	.d2locreg	%offsetof(.Llo196), %offsetof(.Llo199),3
	.d2locreg	%offsetof(.Llo200), %offsetof(.Llo201),3
	.d2locreg	%offsetof(.Llo202), %offsetof(.Llo198),3
	.d2locend
.L3376:
	.d2locreg	%offsetof(.Llo203), %offsetof(.Llo204),4
	.d2locend
.L3387:
	.d2locreg	%offsetof(.Llo205), %offsetof(.Llo206),3
	.d2locreg	%offsetof(.Llo207), %offsetof(.Llo208),6
	.d2locend
.L3389:
	.d2locreg	%offsetof(.Llo206), %offsetof(.Llo209),3
	.d2locreg	%offsetof(.Llo210), %offsetof(.Llo211),3
	.d2locreg	%offsetof(.Llo212), %offsetof(.Llo208),3
	.d2locend
.L3391:
	.d2locreg	%offsetof(.Llo213), %offsetof(.Llo214),4
	.d2locend
.L3397:
	.d2locreg	%offsetof(.Llo215), %offsetof(.Llo216),3
	.d2locreg	%offsetof(.Llo217), %offsetof(.Llo218),31
	.d2locend
.L3398:
	.d2locreg	%offsetof(.Llo215), %offsetof(.Llo219),4
	.d2locreg	%offsetof(.Llo220), %offsetof(.Llo221),30
	.d2locend
.L3399:
	.d2locreg	%offsetof(.Llo215), %offsetof(.Llo219),5
	.d2locreg	%offsetof(.Llo220), %offsetof(.Llo222),29
	.d2locend
.L3401:
	.d2locreg	%offsetof(.Llo219), %offsetof(.Llo223),3
	.d2locreg	%offsetof(.Llo220), %offsetof(.Llo224),28
	.d2locend
.L3408:
	.d2locreg	%offsetof(.Llo225), %offsetof(.Llo226),3
	.d2locreg	%offsetof(.Llo227), %offsetof(.Llo228),3
	.d2locreg	%offsetof(.Llo229), %offsetof(.Llo230),3
	.d2locreg	%offsetof(.Llo231), %offsetof(.Llo232),3
	.d2locreg	%offsetof(.Llo233), %offsetof(.Llo234),3
	.d2locreg	%offsetof(.Llo235), %offsetof(.Llo236),3
	.d2locreg	%offsetof(.Llo237), %offsetof(.Llo238),3
	.d2locreg	%offsetof(.Llo239), %offsetof(.Llo240),3
	.d2locreg	%offsetof(.Llo241), %offsetof(.Llo242),3
	.d2locreg	%offsetof(.Llo243), %offsetof(.Llo244),3
	.d2locreg	%offsetof(.Llo245), %offsetof(.Llo246),3
	.d2locreg	%offsetof(.Llo247), %offsetof(.Llo221),3
	.d2locreg	%offsetof(.Llo248), %offsetof(.Llo224),3
	.d2locreg	%offsetof(.Llo249), %offsetof(.Llo250),3
	.d2locend
.L3415:
	.d2locreg	%offsetof(.Llo251), %offsetof(.Llo242),7
	.d2locend
.L3426:
	.d2locreg	%offsetof(.Llo252), %offsetof(.Llo253),3
	.d2locreg	%offsetof(.Llo254), %offsetof(.Llo255),0
	.d2locend
.L3428:
	.d2locreg	%offsetof(.Llo253), %offsetof(.Llo255),3
	.d2locend
.L3430:
	.d2locreg	%offsetof(.Llo256), %offsetof(.Llo257),4
	.d2locend
.L3437:
	.d2locreg	%offsetof(.Llo258), %offsetof(.Llo259),3
	.d2locreg	%offsetof(.Llo260), %offsetof(.Llo261),31
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo263),31
	.d2locend
.L3438:
	.d2locreg	%offsetof(.Llo258), %offsetof(.Llo264),4
	.d2locreg	%offsetof(.Llo265), %offsetof(.Llo266),30
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo263),30
	.d2locend
.L3439:
	.d2locreg	%offsetof(.Llo258), %offsetof(.Llo264),5
	.d2locreg	%offsetof(.Llo265), %offsetof(.Llo266),29
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo267),29
	.d2locreg	%offsetof(.Llo268), %offsetof(.Llo269),29
	.d2locend
.L3440:
	.d2locreg	%offsetof(.Llo258), %offsetof(.Llo264),6
	.d2locreg	%offsetof(.Llo265), %offsetof(.Llo266),28
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo270),28
	.d2locend
.L3443:
	.d2locreg	%offsetof(.Llo264), %offsetof(.Llo271),3
	.d2locreg	%offsetof(.Llo265), %offsetof(.Llo261),27
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo263),27
	.d2locend
.L3446:
	.d2locreg	%offsetof(.Llo272), %offsetof(.Llo266),26
	.d2locreg	%offsetof(.Llo262), %offsetof(.Llo267),26
	.d2locend
.L3452:
	.d2locreg	%offsetof(.Llo273), %offsetof(.Llo274),3
	.d2locreg	%offsetof(.Llo275), %offsetof(.Llo261),3
	.d2locend
.L3458:
	.d2locreg	%offsetof(.Llo267), %offsetof(.Llo276),3
	.d2locreg	%offsetof(.Llo277), %offsetof(.Llo263),3
	.d2locend
.L3467:
	.d2locreg	%offsetof(.Llo278), %offsetof(.Llo279),3
	.d2locreg	%offsetof(.Llo280), %offsetof(.Llo281),27
	.d2locend
.L3468:
	.d2locreg	%offsetof(.Llo278), %offsetof(.Llo282),4
	.d2locreg	%offsetof(.Llo280), %offsetof(.Llo283),31
	.d2locend
.L3469:
	.d2locreg	%offsetof(.Llo278), %offsetof(.Llo282),5
	.d2locreg	%offsetof(.Llo280), %offsetof(.Llo281),30
	.d2locreg	%offsetof(.Llo284), %offsetof(.Llo285),30
	.d2locend
.L3470:
	.d2locreg	%offsetof(.Llo278), %offsetof(.Llo282),6
	.d2locreg	%offsetof(.Llo280), %offsetof(.Llo286),29
	.d2locend
.L3472:
	.d2locreg	%offsetof(.Llo287), %offsetof(.Llo288),28
	.d2locend
.L3478:
	.d2locreg	%offsetof(.Llo289), %offsetof(.Llo290),3
	.d2locend
.L3480:
	.d2locreg	%offsetof(.Llo281), %offsetof(.Llo291),3
	.d2locreg	%offsetof(.Llo292), %offsetof(.Llo293),3
	.d2locreg	%offsetof(.Llo294), %offsetof(.Llo295),3
	.d2locreg	%offsetof(.Llo296), %offsetof(.Llo297),3
	.d2locreg	%offsetof(.Llo298), %offsetof(.Llo299),3
	.d2locreg	%offsetof(.Llo300), %offsetof(.Llo301),3
	.d2locend
.L3486:
	.d2locreg	%offsetof(.Llo302), %offsetof(.Llo303),3
	.d2locreg	%offsetof(.Llo304), %offsetof(.Llo305),3
	.d2locend
.L3487:
	.d2locreg	%offsetof(.Llo302), %offsetof(.Llo306),4
	.d2locreg	%offsetof(.Llo304), %offsetof(.Llo307),4
	.d2locreg	%offsetof(.Llo308), %offsetof(.Llo309),3
	.d2locend
.L3488:
	.d2locreg	%offsetof(.Llo302), %offsetof(.Llo310),5
	.d2locreg	%offsetof(.Llo311), %offsetof(.Llo312),31
	.d2locend
.L3490:
	.d2locreg	%offsetof(.Llo313), %offsetof(.Llo311),7
	.d2locend
.L3492:
	.d2locreg	%offsetof(.Llo314), %offsetof(.Llo315),0
	.d2locreg	%offsetof(.Llo304), %offsetof(.Llo316),0
	.d2locend
.L3502:
	.d2locreg	%offsetof(.Llo317), %offsetof(.Llo318),3
	.d2locend
.L3503:
	.d2locreg	%offsetof(.Llo317), %offsetof(.Llo318),4
	.d2locend
.L3505:
	.d2locreg	%offsetof(.Llo319), %offsetof(.Llo320),3
	.d2locreg	%offsetof(.Llo321), %offsetof(.Llo322),3
	.d2locreg	%offsetof(.Llo323), %offsetof(.Llo324),3
	.d2locreg	%offsetof(.Llo325), %offsetof(.Llo326),3
	.d2locreg	%offsetof(.Llo327), %offsetof(.Llo328),3
	.d2locreg	%offsetof(.Llo329), %offsetof(.Llo330),3
	.d2locreg	%offsetof(.Llo331), %offsetof(.Llo332),3
	.d2locreg	%offsetof(.Llo333), %offsetof(.Llo334),3
	.d2locreg	%offsetof(.Llo335), %offsetof(.Llo336),3
	.d2locreg	%offsetof(.Llo337), %offsetof(.Llo338),3
	.d2locreg	%offsetof(.Llo339), %offsetof(.Llo340),3
	.d2locreg	%offsetof(.Llo341), %offsetof(.Llo342),3
	.d2locend
.L3508:
	.d2locreg	%offsetof(.Llo343), %offsetof(.Llo344),0
	.d2locreg	%offsetof(.Llo345), %offsetof(.Llo346),0
	.d2locend
.L3517:
	.d2locreg	%offsetof(.Llo347), %offsetof(.Llo348),4
	.d2locreg	%offsetof(.Llo349), %offsetof(.Llo350),31
	.d2locend
.L3518:
	.d2locreg	%offsetof(.Llo347), %offsetof(.Llo348),5
	.d2locreg	%offsetof(.Llo349), %offsetof(.Llo351),30
	.d2locend
.L3520:
	.d2locreg	%offsetof(.Llo352), %offsetof(.Llo353),0
	.d2locreg	%offsetof(.Llo354), %offsetof(.Llo355),0
	.d2locreg	%offsetof(.Llo356), %offsetof(.Llo357),0
	.d2locreg	%offsetof(.Llo358), %offsetof(.Llo350),0
	.d2locend
.L3522:
	.d2locreg	%offsetof(.Llo359), %offsetof(.Llo357),29
	.d2locreg	%offsetof(.Llo360), %offsetof(.Llo361),29
	.d2locend
.L3524:
	.d2locreg	%offsetof(.Llo355), %offsetof(.Llo350),3
	.d2locreg	%offsetof(.Llo362), %offsetof(.Llo363),3
	.d2locend
.L3527:
	.d2locreg	%offsetof(.Llo364), %offsetof(.Llo357),29
	.d2locreg	%offsetof(.Llo365), %offsetof(.Llo350),29
	.d2locend
.L3529:
	.d2locreg	%offsetof(.Llo347), %offsetof(.Llo361),28
	.d2locend
.L3535:
	.d2locreg	%offsetof(.Llo366), %offsetof(.Llo367),4
	.d2locend
.L3536:
	.d2locreg	%offsetof(.Llo366), %offsetof(.Llo368),5
	.d2locend
.L3542:
	.d2locreg	%offsetof(.Llo369), %offsetof(.Llo370),4
	.d2locend
.L3543:
	.d2locreg	%offsetof(.Llo369), %offsetof(.Llo371),5
	.d2locreg	%offsetof(.Llo372), %offsetof(.Llo373),31
	.d2locreg	%offsetof(.Llo374), %offsetof(.Llo375),5
	.d2locend
.L3545:
	.d2locreg	%offsetof(.Llo376), %offsetof(.Llo371),0
	.d2locreg	%offsetof(.Llo377), %offsetof(.Llo370),0
	.d2locreg	%offsetof(.Llo378), %offsetof(.Llo379),0
	.d2locreg	%offsetof(.Llo380), %offsetof(.Llo381),0
	.d2locreg	%offsetof(.Llo382), %offsetof(.Llo383),0
	.d2locreg	%offsetof(.Llo384), %offsetof(.Llo385),0
	.d2locreg	%offsetof(.Llo386), %offsetof(.Llo387),0
	.d2locreg	%offsetof(.Llo388), %offsetof(.Llo389),0
	.d2locreg	%offsetof(.Llo390), %offsetof(.Llo391),0
	.d2locreg	%offsetof(.Llo392), %offsetof(.Llo373),0
	.d2locend
.L3553:
	.d2locreg	%offsetof(.Llo393), %offsetof(.Llo379),3
	.d2locreg	%offsetof(.Llo394), %offsetof(.Llo395),3
	.d2locreg	%offsetof(.Llo375), %offsetof(.Llo396),3
	.d2locend
.L3559:
	.d2locreg	%offsetof(.Llo397), %offsetof(.Llo387),3
	.d2locreg	%offsetof(.Llo398), %offsetof(.Llo399),3
	.d2locend
.L3566:
	.d2locreg	%offsetof(.Llo400), %offsetof(.Llo401),3
	.d2locreg	%offsetof(.Llo402), %offsetof(.Llo403),31
	.d2locreg	%offsetof(.Llo404), %offsetof(.Llo405),31
	.d2locreg	%offsetof(.Llo406), %offsetof(.Llo407),31
	.d2locreg	%offsetof(.Llo408), %offsetof(.Llo409),31
	.d2locend
.L3568:
	.d2locreg	%offsetof(.Llo400), %offsetof(.Llo410),4
	.d2locreg	%offsetof(.Llo411), %offsetof(.Llo412),3
	.d2locend
.L3571:
	.d2locreg	%offsetof(.Llo400), %offsetof(.Llo413),5
	.d2locend
.L3573:
	.d2locreg	%offsetof(.Llo400), %offsetof(.Llo414),6
	.d2locreg	%offsetof(.Llo402), %offsetof(.Llo415),30
	.d2locreg	%offsetof(.Llo404), %offsetof(.Llo406),30
	.d2locreg	%offsetof(.Llo407), %offsetof(.Llo408),30
	.d2locreg	%offsetof(.Llo409), %offsetof(.Llo416),30
	.d2locend
.L3574:
	.d2locreg	%offsetof(.Llo400), %offsetof(.Llo414),7
	.d2locreg	%offsetof(.Llo402), %offsetof(.Llo417),29
	.d2locend
.L3578:
	.d2locreg	%offsetof(.Llo414), %offsetof(.Llo402),3
	.d2locreg	%offsetof(.Llo415), %offsetof(.Llo403),6
	.d2locreg	%offsetof(.Llo404), %offsetof(.Llo418),6
	.d2locreg	%offsetof(.Llo406), %offsetof(.Llo409),6
	.d2locend
.L3585:
	.d2locreg	%offsetof(.Llo419), %offsetof(.Llo420),3
	.d2locreg	%offsetof(.Llo421), %offsetof(.Llo422),3
	.d2locend
.L3586:
	.d2locreg	%offsetof(.Llo419), %offsetof(.Llo423),4
	.d2locreg	%offsetof(.Llo424), %offsetof(.Llo425),3
	.d2locend
.L3587:
	.d2locreg	%offsetof(.Llo419), %offsetof(.Llo420),5
	.d2locreg	%offsetof(.Llo426), %offsetof(.Llo427),31
	.d2locreg	%offsetof(.Llo428), %offsetof(.Llo424),5
	.d2locend
.L3593:
	.d2locreg	%offsetof(.Llo429), %offsetof(.Llo427),0
	.d2locend
.L3600:
	.d2locreg	%offsetof(.Llo430), %offsetof(.Llo431),3
	.d2locend
.L3602:
	.d2locreg	%offsetof(.Llo432), %offsetof(.Llo433),3
	.d2locreg	%offsetof(.Llo434), %offsetof(.Llo435),3
	.d2locreg	%offsetof(.Llo436), %offsetof(.Llo437),3
	.d2locreg	%offsetof(.Llo438), %offsetof(.Llo439),3
	.d2locreg	%offsetof(.Llo440), %offsetof(.Llo441),3
	.d2locend
.L3610:
	.d2locreg	%offsetof(.Llo442), %offsetof(.Llo443),3
	.d2locreg	%offsetof(.Llo444), %offsetof(.Llo445),3
	.d2locreg	%offsetof(.Llo446), %offsetof(.Llo447),3
	.d2locend
.L3612:
	.d2locreg	%offsetof(.Llo448), %offsetof(.Llo449),3
	.d2locreg	%offsetof(.Llo450), %offsetof(.Llo444),3
	.d2locreg	%offsetof(.Llo445), %offsetof(.Llo446),3
	.d2locreg	%offsetof(.Llo447), %offsetof(.Llo451),3
	.d2locreg	%offsetof(.Llo452), %offsetof(.Llo453),3
	.d2locend
.L3619:
	.d2locreg	%offsetof(.Llo454), %offsetof(.Llo455),3
	.d2locreg	%offsetof(.Llo456), %offsetof(.Llo457),31
	.d2locend
.L3621:
	.d2locreg	%offsetof(.Llo454), %offsetof(.Llo456),4
	.d2locreg	%offsetof(.Llo458), %offsetof(.Llo459),30
	.d2locreg	%offsetof(.Llo460), %offsetof(.Llo461),30
	.d2locreg	%offsetof(.Llo462), %offsetof(.Llo463),4
	.d2locreg	%offsetof(.Llo464), %offsetof(.Llo465),4
	.d2locend
.L3622:
	.d2locreg	%offsetof(.Llo454), %offsetof(.Llo456),5
	.d2locreg	%offsetof(.Llo458), %offsetof(.Llo464),29
	.d2locreg	%offsetof(.Llo466), %offsetof(.Llo465),5
	.d2locend
.L3626:
	.d2locreg	%offsetof(.Llo467), %offsetof(.Llo468),0
	.d2locreg	%offsetof(.Llo469), %offsetof(.Llo470),0
	.d2locreg	%offsetof(.Llo471), %offsetof(.Llo472),4
	.d2locreg	%offsetof(.Llo473), %offsetof(.Llo474),4
	.d2locend
.L3630:
	.d2locreg	%offsetof(.Llo463), %offsetof(.Llo475),3
	.d2locreg	%offsetof(.Llo474), %offsetof(.Llo457),3
	.d2locend
.L3632:
	.d2locreg	%offsetof(.Llo454), %offsetof(.Llo459),28
	.d2locreg	%offsetof(.Llo460), %offsetof(.Llo461),28
	.d2locend
.L3638:
	.d2locreg	%offsetof(.Llo476), %offsetof(.Llo477),3
	.d2locreg	%offsetof(.Llo478), %offsetof(.Llo479),31
	.d2locreg	%offsetof(.Llo480), %offsetof(.Llo481),31
	.d2locend
.L3639:
	.d2locreg	%offsetof(.Llo476), %offsetof(.Llo478),4
	.d2locreg	%offsetof(.Llo482), %offsetof(.Llo483),4
	.d2locreg	%offsetof(.Llo480), %offsetof(.Llo481),4
	.d2locend
.L3640:
	.d2locreg	%offsetof(.Llo476), %offsetof(.Llo478),5
	.d2locreg	%offsetof(.Llo484), %offsetof(.Llo485),30
	.d2locreg	%offsetof(.Llo486), %offsetof(.Llo487),5
	.d2locend
.L3642:
	.d2locreg	%offsetof(.Llo488), %offsetof(.Llo489),29
	.d2locreg	%offsetof(.Llo490), %offsetof(.Llo491),29
	.d2locreg	%offsetof(.Llo492), %offsetof(.Llo485),29
	.d2locend
.L3645:
	.d2locreg	%offsetof(.Llo493), %offsetof(.Llo494),3
	.d2locreg	%offsetof(.Llo495), %offsetof(.Llo496),3
	.d2locreg	%offsetof(.Llo497), %offsetof(.Llo479),3
	.d2locreg	%offsetof(.Llo498), %offsetof(.Llo480),3
	.d2locreg	%offsetof(.Llo499), %offsetof(.Llo481),3
	.d2locend
.L3647:
	.d2locreg	%offsetof(.Llo500), %offsetof(.Llo501),28
	.d2locreg	%offsetof(.Llo502), %offsetof(.Llo503),3
	.d2locreg	%offsetof(.Llo504), %offsetof(.Llo485),28
	.d2locend
.L3660:
	.d2locreg	%offsetof(.Llo505), %offsetof(.Llo506),3
	.d2locreg	%offsetof(.Llo507), %offsetof(.Llo489),6
	.d2locreg	%offsetof(.Llo508), %offsetof(.Llo491),6
	.d2locend
.L3666:
	.d2locreg	%offsetof(.Llo509), %offsetof(.Llo510),3
	.d2locreg	%offsetof(.Llo511), %offsetof(.Llo512),31
	.d2locend
.L3667:
	.d2locreg	%offsetof(.Llo509), %offsetof(.Llo513),4
	.d2locreg	%offsetof(.Llo514), %offsetof(.Llo512),30
	.d2locend
.L3673:
	.d2locreg	%offsetof(.Llo515), %offsetof(.Llo512),29
	.d2locend
.L3679:
	.d2locreg	%offsetof(.Llo516), %offsetof(.Llo517),0
	.d2locend
.L3685:
	.d2locreg	%offsetof(.Llo518), %offsetof(.Llo519),3
	.d2locreg	%offsetof(.Llo520), %offsetof(.Llo521),31
	.d2locreg	%offsetof(.Llo522), %offsetof(.Llo523),31
	.d2locreg	%offsetof(.Llo524), %offsetof(.Llo525),3
	.d2locreg	%offsetof(.Llo526), %offsetof(.Llo527),3
	.d2locreg	%offsetof(.Llo528), %offsetof(.Llo529),3
	.d2locreg	%offsetof(.Llo530), %offsetof(.Llo531),31
	.d2locend
.L3686:
	.d2locreg	%offsetof(.Llo518), %offsetof(.Llo520),4
	.d2locreg	%offsetof(.Llo532), %offsetof(.Llo521),30
	.d2locreg	%offsetof(.Llo522), %offsetof(.Llo533),30
	.d2locreg	%offsetof(.Llo529), %offsetof(.Llo531),30
	.d2locreg	%offsetof(.Llo534), %offsetof(.Llo535),4
	.d2locreg	%offsetof(.Llo536), %offsetof(.Llo537),4
	.d2locend
.L3687:
	.d2locreg	%offsetof(.Llo518), %offsetof(.Llo520),5
	.d2locreg	%offsetof(.Llo532), %offsetof(.Llo536),29
	.d2locreg	%offsetof(.Llo538), %offsetof(.Llo537),5
	.d2locend
.L3690:
	.d2locreg	%offsetof(.Llo518), %offsetof(.Llo539),25
	.d2locreg	%offsetof(.Llo540), %offsetof(.Llo541),3
	.d2locreg	%offsetof(.Llo542), %offsetof(.Llo536),25
	.d2locend
.L3702:
	.d2locreg	%offsetof(.Llo543), %offsetof(.Llo544),0
	.d2locreg	%offsetof(.Llo545), %offsetof(.Llo546),0
	.d2locreg	%offsetof(.Llo547), %offsetof(.Llo521),0
	.d2locreg	%offsetof(.Llo548), %offsetof(.Llo549),0
	.d2locreg	%offsetof(.Llo550), %offsetof(.Llo522),0
	.d2locreg	%offsetof(.Llo551), %offsetof(.Llo552),0
	.d2locreg	%offsetof(.Llo553), %offsetof(.Llo554),0
	.d2locreg	%offsetof(.Llo555), %offsetof(.Llo556),0
	.d2locreg	%offsetof(.Llo557), %offsetof(.Llo558),0
	.d2locreg	%offsetof(.Llo559), %offsetof(.Llo523),0
	.d2locreg	%offsetof(.Llo560), %offsetof(.Llo525),0
	.d2locreg	%offsetof(.Llo561), %offsetof(.Llo527),0
	.d2locreg	%offsetof(.Llo562), %offsetof(.Llo563),0
	.d2locreg	%offsetof(.Llo564), %offsetof(.Llo529),0
	.d2locreg	%offsetof(.Llo565), %offsetof(.Llo531),0
	.d2locreg	%offsetof(.Llo566), %offsetof(.Llo567),0
	.d2locreg	%offsetof(.Llo568), %offsetof(.Llo569),0
	.d2locreg	%offsetof(.Llo570), %offsetof(.Llo571),0
	.d2locreg	%offsetof(.Llo572), %offsetof(.Llo536),0
	.d2locend
.L3704:
	.d2locreg	%offsetof(.Llo573), %offsetof(.Llo546),28
	.d2locreg	%offsetof(.Llo574), %offsetof(.Llo521),28
	.d2locreg	%offsetof(.Llo522), %offsetof(.Llo558),28
	.d2locreg	%offsetof(.Llo575), %offsetof(.Llo523),28
	.d2locend
.L3707:
	.d2locreg	%offsetof(.Llo576), %offsetof(.Llo577),3
	.d2locreg	%offsetof(.Llo578), %offsetof(.Llo579),4
	.d2locreg	%offsetof(.Llo580), %offsetof(.Llo521),27
	.d2locreg	%offsetof(.Llo581), %offsetof(.Llo549),3
	.d2locreg	%offsetof(.Llo582), %offsetof(.Llo522),3
	.d2locreg	%offsetof(.Llo583), %offsetof(.Llo523),27
	.d2locreg	%offsetof(.Llo530), %offsetof(.Llo531),3
	.d2locend
.L3709:
	.d2locreg	%offsetof(.Llo584), %offsetof(.Llo527),26
	.d2locend
.L3711:
	.d2locreg	%offsetof(.Llo585), %offsetof(.Llo586),4
	.d2locreg	%offsetof(.Llo587), %offsetof(.Llo588),3
	.d2locreg	%offsetof(.Llo589), %offsetof(.Llo546),4
	.d2locreg	%offsetof(.Llo522), %offsetof(.Llo590),4
	.d2locend
.L3718:
	.d2locreg	%offsetof(.Llo591), %offsetof(.Llo592),3
	.d2locend
.L3724:
	.d2locreg	%offsetof(.Llo534), %offsetof(.Llo593),31
	.d2locreg	%offsetof(.Llo594), %offsetof(.Llo569),31
	.d2locreg	%offsetof(.Llo595), %offsetof(.Llo536),31
	.d2locend
.L3732:
	.d2locreg	%offsetof(.Llo596), %offsetof(.Llo597),3
	.d2locreg	%offsetof(.Llo598), %offsetof(.Llo593),6
	.d2locreg	%offsetof(.Llo599), %offsetof(.Llo569),6
	.d2locend
.L3738:
	.d2locreg	%offsetof(.Llo600), %offsetof(.Llo601),3
	.d2locreg	%offsetof(.Llo602), %offsetof(.Llo603),31
	.d2locreg	%offsetof(.Llo604), %offsetof(.Llo605),31
	.d2locend
.L3739:
	.d2locreg	%offsetof(.Llo600), %offsetof(.Llo602),4
	.d2locreg	%offsetof(.Llo606), %offsetof(.Llo607),30
	.d2locreg	%offsetof(.Llo608), %offsetof(.Llo609),4
	.d2locend
.L3742:
	.d2locreg	%offsetof(.Llo610), %offsetof(.Llo611),3
	.d2locreg	%offsetof(.Llo612), %offsetof(.Llo613),3
	.d2locreg	%offsetof(.Llo614), %offsetof(.Llo603),3
	.d2locreg	%offsetof(.Llo615), %offsetof(.Llo604),3
	.d2locreg	%offsetof(.Llo616), %offsetof(.Llo605),3
	.d2locend
.L3744:
	.d2locreg	%offsetof(.Llo617), %offsetof(.Llo618),29
	.d2locreg	%offsetof(.Llo619), %offsetof(.Llo620),29
	.d2locreg	%offsetof(.Llo621), %offsetof(.Llo607),29
	.d2locend
.L3746:
	.d2locreg	%offsetof(.Llo600), %offsetof(.Llo622),28
	.d2locreg	%offsetof(.Llo623), %offsetof(.Llo624),3
	.d2locreg	%offsetof(.Llo625), %offsetof(.Llo607),28
	.d2locend
.L3755:
	.d2locreg	%offsetof(.Llo626), %offsetof(.Llo627),3
	.d2locreg	%offsetof(.Llo628), %offsetof(.Llo618),6
	.d2locreg	%offsetof(.Llo629), %offsetof(.Llo620),6
	.d2locend
.L3761:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),3
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo633),31
	.d2locreg	%offsetof(.Llo634), %offsetof(.Llo635),31
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),31
	.d2locreg	%offsetof(.Llo638), %offsetof(.Llo639),3
	.d2locend
.L3762:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),4
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo633),30
	.d2locreg	%offsetof(.Llo634), %offsetof(.Llo635),30
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),30
	.d2locend
.L3763:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),5
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo633),29
	.d2locreg	%offsetof(.Llo634), %offsetof(.Llo635),29
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),29
	.d2locend
.L3764:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),6
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo640),28
	.d2locreg	%offsetof(.Llo635), %offsetof(.Llo641),28
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),28
	.d2locend
.L3765:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),7
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo642),27
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),27
	.d2locend
.L3766:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo643),8
	.d2locreg	%offsetof(.Llo631), %offsetof(.Llo633),26
	.d2locreg	%offsetof(.Llo634), %offsetof(.Llo640),26
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),26
	.d2locend
.L3771:
	.d2locreg	%offsetof(.Llo630), %offsetof(.Llo631),9
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo641),25
	.d2locreg	%offsetof(.Llo636), %offsetof(.Llo637),25
	.d2locend
.L3775:
	.d2locreg	%offsetof(.Llo644), %offsetof(.Llo645),3
	.d2locreg	%offsetof(.Llo646), %offsetof(.Llo647),3
	.d2locend
.L3777:
	.d2locreg	%offsetof(.Llo648), %offsetof(.Llo641),24
	.d2locreg	%offsetof(.Llo649), %offsetof(.Llo650),24
	.d2locend
.L3779:
	.d2locreg	%offsetof(.Llo651), %offsetof(.Llo652),3
	.d2locreg	%offsetof(.Llo653), %offsetof(.Llo654),3
	.d2locreg	%offsetof(.Llo655), %offsetof(.Llo656),3
	.d2locreg	%offsetof(.Llo657), %offsetof(.Llo658),3
	.d2locreg	%offsetof(.Llo659), %offsetof(.Llo660),3
	.d2locend
.L3783:
	.d2locreg	%offsetof(.Llo661), %offsetof(.Llo662),6
	.d2locreg	%offsetof(.Llo663), %offsetof(.Llo642),3
	.d2locreg	%offsetof(.Llo664), %offsetof(.Llo665),6
	.d2locreg	%offsetof(.Llo634), %offsetof(.Llo640),6
	.d2locend
.L3785:
	.d2locreg	%offsetof(.Llo666), %offsetof(.Llo631),0
	.d2locreg	%offsetof(.Llo632), %offsetof(.Llo667),3
	.d2locreg	%offsetof(.Llo668), %offsetof(.Llo640),23
	.d2locreg	%offsetof(.Llo669), %offsetof(.Llo670),0
	.d2locreg	%offsetof(.Llo655), %offsetof(.Llo671),23
	.d2locreg	%offsetof(.Llo657), %offsetof(.Llo641),23
	.d2locreg	%offsetof(.Llo659), %offsetof(.Llo637),23
	.d2locend
.L3791:
	.d2locreg	%offsetof(.Llo672), %offsetof(.Llo673),3
	.d2locreg	%offsetof(.Llo674), %offsetof(.Llo675),31
	.d2locreg	%offsetof(.Llo676), %offsetof(.Llo677),31
	.d2locreg	%offsetof(.Llo678), %offsetof(.Llo679),3
	.d2locreg	%offsetof(.Llo680), %offsetof(.Llo681),3
	.d2locend
.L3792:
	.d2locreg	%offsetof(.Llo672), %offsetof(.Llo674),4
	.d2locreg	%offsetof(.Llo682), %offsetof(.Llo683),25
	.d2locreg	%offsetof(.Llo684), %offsetof(.Llo685),4
	.d2locend
.L3798:
	.d2locreg	%offsetof(.Llo686), %offsetof(.Llo687),30
	.d2locreg	%offsetof(.Llo688), %offsetof(.Llo676),29
	.d2locreg	%offsetof(.Llo689), %offsetof(.Llo677),3
	.d2locreg	%offsetof(.Llo690), %offsetof(.Llo691),0
	.d2locreg	%offsetof(.Llo692), %offsetof(.Llo693),3
	.d2locreg	%offsetof(.Llo694), %offsetof(.Llo695),0
	.d2locreg	%offsetof(.Llo696), %offsetof(.Llo697),0
	.d2locreg	%offsetof(.Llo698), %offsetof(.Llo699),3
	.d2locreg	%offsetof(.Llo700), %offsetof(.Llo701),3
	.d2locreg	%offsetof(.Llo702), %offsetof(.Llo703),3
	.d2locreg	%offsetof(.Llo704), %offsetof(.Llo705),0
	.d2locreg	%offsetof(.Llo706), %offsetof(.Llo707),3
	.d2locreg	%offsetof(.Llo708), %offsetof(.Llo709),3
	.d2locreg	%offsetof(.Llo710), %offsetof(.Llo711),3
	.d2locreg	%offsetof(.Llo712), %offsetof(.Llo713),4
	.d2locreg	%offsetof(.Llo714), %offsetof(.Llo679),4
	.d2locreg	%offsetof(.Llo715), %offsetof(.Llo716),0
	.d2locreg	%offsetof(.Llo717), %offsetof(.Llo718),3
	.d2locreg	%offsetof(.Llo719), %offsetof(.Llo720),0
	.d2locreg	%offsetof(.Llo721), %offsetof(.Llo722),3
	.d2locreg	%offsetof(.Llo723), %offsetof(.Llo724),0
	.d2locreg	%offsetof(.Llo725), %offsetof(.Llo726),3
	.d2locreg	%offsetof(.Llo727), %offsetof(.Llo728),0
	.d2locreg	%offsetof(.Llo729), %offsetof(.Llo730),3
	.d2locreg	%offsetof(.Llo731), %offsetof(.Llo732),3
	.d2locreg	%offsetof(.Llo681), %offsetof(.Llo733),3
	.d2locreg	%offsetof(.Llo734), %offsetof(.Llo735),0
	.d2locreg	%offsetof(.Llo736), %offsetof(.Llo683),0
	.d2locend
.L3800:
	.d2locreg	%offsetof(.Llo737), %offsetof(.Llo738),29
	.d2locreg	%offsetof(.Llo739), %offsetof(.Llo676),29
	.d2locend
.L3802:
	.d2locreg	%offsetof(.Llo740), %offsetof(.Llo741),28
	.d2locreg	%offsetof(.Llo742), %offsetof(.Llo675),28
	.d2locend
.L3804:
	.d2locreg	%offsetof(.Llo682), %offsetof(.Llo743),3
	.d2locreg	%offsetof(.Llo744), %offsetof(.Llo745),27
	.d2locreg	%offsetof(.Llo746), %offsetof(.Llo741),0
	.d2locreg	%offsetof(.Llo747), %offsetof(.Llo675),0
	.d2locreg	%offsetof(.Llo748), %offsetof(.Llo749),0
	.d2locreg	%offsetof(.Llo750), %offsetof(.Llo751),0
	.d2locreg	%offsetof(.Llo752), %offsetof(.Llo677),0
	.d2locend
.L3806:
	.d2locreg	%offsetof(.Llo753), %offsetof(.Llo687),26
	.d2locend
.L3815:
	.d2locreg	%offsetof(.Llo754), %offsetof(.Llo726),31
	.d2locreg	%offsetof(.Llo728), %offsetof(.Llo730),31
	.d2locreg	%offsetof(.Llo735), %offsetof(.Llo683),31
	.d2locend
.L3817:
	.d2locreg	%offsetof(.Llo755), %offsetof(.Llo756),6
	.d2locreg	%offsetof(.Llo709), %offsetof(.Llo757),6
	.d2locend
.L3823:
	.d2locreg	%offsetof(.Llo758), %offsetof(.Llo759),3
	.d2locreg	%offsetof(.Llo760), %offsetof(.Llo761),31
	.d2locend
.L3824:
	.d2locreg	%offsetof(.Llo758), %offsetof(.Llo762),4
	.d2locreg	%offsetof(.Llo763), %offsetof(.Llo761),30
	.d2locreg	%offsetof(.Llo764), %offsetof(.Llo765),4
	.d2locend
.L3828:
	.d2locreg	%offsetof(.Llo758), %offsetof(.Llo761),29
	.d2locend
.L3837:
	.d2locreg	%offsetof(.Llo766), %offsetof(.Llo767),3
	.d2locreg	%offsetof(.Llo768), %offsetof(.Llo769),3
	.d2locreg	%offsetof(.Llo770), %offsetof(.Llo771),3
	.d2locreg	%offsetof(.Llo772), %offsetof(.Llo773),3
	.d2locreg	%offsetof(.Llo774), %offsetof(.Llo775),3
	.d2locreg	%offsetof(.Llo776), %offsetof(.Llo777),3
	.d2locend
.L3838:
	.d2locreg	%offsetof(.Llo766), %offsetof(.Llo778),4
	.d2locreg	%offsetof(.Llo779), %offsetof(.Llo780),4
	.d2locend
.L3840:
	.d2locreg	%offsetof(.Llo781), %offsetof(.Llo778),0
	.d2locreg	%offsetof(.Llo782), %offsetof(.Llo771),0
	.d2locreg	%offsetof(.Llo783), %offsetof(.Llo779),3
	.d2locreg	%offsetof(.Llo772), %offsetof(.Llo777),0
	.d2locreg	%offsetof(.Llo780), %offsetof(.Llo784),3
	.d2locend
.L3846:
	.d2locreg	%offsetof(.Llo785), %offsetof(.Llo786),3
	.d2locreg	%offsetof(.Llo787), %offsetof(.Llo788),31
	.d2locreg	%offsetof(.Llo789), %offsetof(.Llo790),31
	.d2locend
.L3847:
	.d2locreg	%offsetof(.Llo785), %offsetof(.Llo791),4
	.d2locreg	%offsetof(.Llo792), %offsetof(.Llo788),30
	.d2locreg	%offsetof(.Llo789), %offsetof(.Llo790),30
	.d2locend
.L3848:
	.d2locreg	%offsetof(.Llo785), %offsetof(.Llo793),5
	.d2locreg	%offsetof(.Llo792), %offsetof(.Llo794),29
	.d2locreg	%offsetof(.Llo789), %offsetof(.Llo790),29
	.d2locend
.L3849:
	.d2locreg	%offsetof(.Llo785), %offsetof(.Llo795),6
	.d2locreg	%offsetof(.Llo792), %offsetof(.Llo794),28
	.d2locreg	%offsetof(.Llo789), %offsetof(.Llo790),28
	.d2locend
.L3851:
	.d2locreg	%offsetof(.Llo796), %offsetof(.Llo797),3
	.d2locreg	%offsetof(.Llo798), %offsetof(.Llo799),3
	.d2locreg	%offsetof(.Llo800), %offsetof(.Llo801),3
	.d2locreg	%offsetof(.Llo802), %offsetof(.Llo803),3
	.d2locend
.L3854:
	.d2locreg	%offsetof(.Llo804), %offsetof(.Llo805),6
	.d2locreg	%offsetof(.Llo806), %offsetof(.Llo788),3
	.d2locreg	%offsetof(.Llo807), %offsetof(.Llo808),6
	.d2locreg	%offsetof(.Llo809), %offsetof(.Llo810),6
	.d2locend
.L3857:
	.d2locreg	%offsetof(.Llo811), %offsetof(.Llo812),3
	.d2locreg	%offsetof(.Llo813), %offsetof(.Llo810),3
	.d2locend
.L3860:
	.d2locreg	%offsetof(.Llo814), %offsetof(.Llo794),27
	.d2locreg	%offsetof(.Llo815), %offsetof(.Llo816),27
	.d2locend
.L3871:
	.d2locreg	%offsetof(.Llo817), %offsetof(.Llo818),3
	.d2locreg	%offsetof(.Llo819), %offsetof(.Llo820),31
	.d2locreg	%offsetof(.Llo821), %offsetof(.Llo822),31
	.d2locend
.L3876:
	.d2locreg	%offsetof(.Llo817), %offsetof(.Llo818),4
	.d2locreg	%offsetof(.Llo819), %offsetof(.Llo823),30
	.d2locreg	%offsetof(.Llo824), %offsetof(.Llo825),4
	.d2locend
.L3877:
	.d2locreg	%offsetof(.Llo817), %offsetof(.Llo818),5
	.d2locreg	%offsetof(.Llo819), %offsetof(.Llo820),29
	.d2locreg	%offsetof(.Llo826), %offsetof(.Llo821),5
	.d2locreg	%offsetof(.Llo827), %offsetof(.Llo828),29
	.d2locreg	%offsetof(.Llo829), %offsetof(.Llo830),29
	.d2locreg	%offsetof(.Llo831), %offsetof(.Llo825),5
	.d2locend
.L3880:
	.d2locreg	%offsetof(.Llo832), %offsetof(.Llo833),3
	.d2locreg	%offsetof(.Llo834), %offsetof(.Llo835),3
	.d2locreg	%offsetof(.Llo836), %offsetof(.Llo837),3
	.d2locreg	%offsetof(.Llo838), %offsetof(.Llo839),3
	.d2locreg	%offsetof(.Llo840), %offsetof(.Llo841),3
	.d2locreg	%offsetof(.Llo842), %offsetof(.Llo843),3
	.d2locreg	%offsetof(.Llo844), %offsetof(.Llo845),3
	.d2locreg	%offsetof(.Llo846), %offsetof(.Llo847),3
	.d2locreg	%offsetof(.Llo848), %offsetof(.Llo849),3
	.d2locreg	%offsetof(.Llo850), %offsetof(.Llo822),3
	.d2locreg	%offsetof(.Llo851), %offsetof(.Llo828),3
	.d2locreg	%offsetof(.Llo852), %offsetof(.Llo853),3
	.d2locreg	%offsetof(.Llo854), %offsetof(.Llo855),3
	.d2locreg	%offsetof(.Llo856), %offsetof(.Llo823),3
	.d2locend
.L3882:
	.d2locreg	%offsetof(.Llo857), %offsetof(.Llo858),0
	.d2locreg	%offsetof(.Llo859), %offsetof(.Llo818),0
	.d2locreg	%offsetof(.Llo819), %offsetof(.Llo860),0
	.d2locreg	%offsetof(.Llo861), %offsetof(.Llo821),28
	.d2locreg	%offsetof(.Llo862), %offsetof(.Llo822),0
	.d2locreg	%offsetof(.Llo863), %offsetof(.Llo828),0
	.d2locreg	%offsetof(.Llo864), %offsetof(.Llo865),0
	.d2locreg	%offsetof(.Llo866), %offsetof(.Llo829),0
	.d2locreg	%offsetof(.Llo867), %offsetof(.Llo855),0
	.d2locreg	%offsetof(.Llo868), %offsetof(.Llo869),0
	.d2locreg	%offsetof(.Llo870), %offsetof(.Llo830),28
	.d2locreg	%offsetof(.Llo831), %offsetof(.Llo871),0
	.d2locreg	%offsetof(.Llo872), %offsetof(.Llo823),0
	.d2locend
.L3884:
	.d2locreg	%offsetof(.Llo873), %offsetof(.Llo874),5
	.d2locreg	%offsetof(.Llo839), %offsetof(.Llo875),5
	.d2locend
.L3890:
	.d2locreg	%offsetof(.Llo876), %offsetof(.Llo877),3
	.d2locreg	%offsetof(.Llo878), %offsetof(.Llo879),31
	.d2locreg	%offsetof(.Llo880), %offsetof(.Llo881),3
	.d2locreg	%offsetof(.Llo882), %offsetof(.Llo883),3
	.d2locreg	%offsetof(.Llo884), %offsetof(.Llo885),3
	.d2locreg	%offsetof(.Llo886), %offsetof(.Llo887),3
	.d2locreg	%offsetof(.Llo888), %offsetof(.Llo889),3
	.d2locreg	%offsetof(.Llo890), %offsetof(.Llo891),31
	.d2locreg	%offsetof(.Llo892), %offsetof(.Llo893),3
	.d2locreg	%offsetof(.Llo894), %offsetof(.Llo895),3
	.d2locreg	%offsetof(.Llo896), %offsetof(.Llo897),3
	.d2locreg	%offsetof(.Llo898), %offsetof(.Llo899),3
	.d2locreg	%offsetof(.Llo900), %offsetof(.Llo901),3
	.d2locreg	%offsetof(.Llo902), %offsetof(.Llo903),3
	.d2locreg	%offsetof(.Llo904), %offsetof(.Llo905),3
	.d2locreg	%offsetof(.Llo906), %offsetof(.Llo907),3
	.d2locreg	%offsetof(.Llo908), %offsetof(.Llo909),3
	.d2locreg	%offsetof(.Llo910), %offsetof(.Llo911),3
	.d2locreg	%offsetof(.Llo912), %offsetof(.Llo913),3
	.d2locreg	%offsetof(.Llo914), %offsetof(.Llo915),3
	.d2locreg	%offsetof(.Llo916), %offsetof(.Llo917),3
	.d2locreg	%offsetof(.Llo918), %offsetof(.Llo919),3
	.d2locreg	%offsetof(.Llo920), %offsetof(.Llo921),3
	.d2locreg	%offsetof(.Llo922), %offsetof(.Llo923),3
	.d2locreg	%offsetof(.Llo924), %offsetof(.Llo925),3
	.d2locend
.L3891:
	.d2locreg	%offsetof(.Llo876), %offsetof(.Llo878),4
	.d2locreg	%offsetof(.Llo926), %offsetof(.Llo927),27
	.d2locreg	%offsetof(.Llo928), %offsetof(.Llo929),4
	.d2locend
.L3898:
	.d2locreg	%offsetof(.Llo930), %offsetof(.Llo931),5
	.d2locreg	%offsetof(.Llo932), %offsetof(.Llo933),4
	.d2locreg	%offsetof(.Llo934), %offsetof(.Llo935),4
	.d2locreg	%offsetof(.Llo936), %offsetof(.Llo937),5
	.d2locreg	%offsetof(.Llo938), %offsetof(.Llo939),4
	.d2locreg	%offsetof(.Llo940), %offsetof(.Llo881),4
	.d2locreg	%offsetof(.Llo941), %offsetof(.Llo883),4
	.d2locreg	%offsetof(.Llo942), %offsetof(.Llo943),4
	.d2locreg	%offsetof(.Llo944), %offsetof(.Llo889),4
	.d2locreg	%offsetof(.Llo945), %offsetof(.Llo899),5
	.d2locreg	%offsetof(.Llo946), %offsetof(.Llo947),5
	.d2locreg	%offsetof(.Llo948), %offsetof(.Llo949),4
	.d2locreg	%offsetof(.Llo950), %offsetof(.Llo913),4
	.d2locreg	%offsetof(.Llo951), %offsetof(.Llo919),5
	.d2locreg	%offsetof(.Llo952), %offsetof(.Llo953),4
	.d2locreg	%offsetof(.Llo954), %offsetof(.Llo955),5
	.d2locend
.L3904:
	.d2locreg	%offsetof(.Llo956), %offsetof(.Llo957),30
	.d2locreg	%offsetof(.Llo958), %offsetof(.Llo879),30
	.d2locreg	%offsetof(.Llo889), %offsetof(.Llo891),30
	.d2locend
.L3906:
	.d2locreg	%offsetof(.Llo959), %offsetof(.Llo960),3
	.d2locreg	%offsetof(.Llo961), %offsetof(.Llo962),29
	.d2locreg	%offsetof(.Llo963), %offsetof(.Llo964),0
	.d2locreg	%offsetof(.Llo965), %offsetof(.Llo966),0
	.d2locreg	%offsetof(.Llo967), %offsetof(.Llo957),0
	.d2locreg	%offsetof(.Llo968), %offsetof(.Llo879),0
	.d2locreg	%offsetof(.Llo969), %offsetof(.Llo881),0
	.d2locreg	%offsetof(.Llo970), %offsetof(.Llo883),0
	.d2locreg	%offsetof(.Llo971), %offsetof(.Llo885),0
	.d2locreg	%offsetof(.Llo972), %offsetof(.Llo889),0
	.d2locreg	%offsetof(.Llo890), %offsetof(.Llo891),29
	.d2locreg	%offsetof(.Llo973), %offsetof(.Llo893),0
	.d2locreg	%offsetof(.Llo974), %offsetof(.Llo895),0
	.d2locreg	%offsetof(.Llo975), %offsetof(.Llo899),0
	.d2locreg	%offsetof(.Llo976), %offsetof(.Llo977),0
	.d2locreg	%offsetof(.Llo978), %offsetof(.Llo901),0
	.d2locreg	%offsetof(.Llo979), %offsetof(.Llo903),0
	.d2locreg	%offsetof(.Llo980), %offsetof(.Llo905),0
	.d2locreg	%offsetof(.Llo981), %offsetof(.Llo907),0
	.d2locreg	%offsetof(.Llo982), %offsetof(.Llo983),0
	.d2locreg	%offsetof(.Llo984), %offsetof(.Llo915),0
	.d2locreg	%offsetof(.Llo985), %offsetof(.Llo986),0
	.d2locreg	%offsetof(.Llo987), %offsetof(.Llo917),0
	.d2locreg	%offsetof(.Llo988), %offsetof(.Llo919),0
	.d2locreg	%offsetof(.Llo989), %offsetof(.Llo921),0
	.d2locreg	%offsetof(.Llo990), %offsetof(.Llo925),0
	.d2locreg	%offsetof(.Llo991), %offsetof(.Llo992),0
	.d2locreg	%offsetof(.Llo993), %offsetof(.Llo927),0
	.d2locend
.L3908:
	.d2locreg	%offsetof(.Llo994), %offsetof(.Llo883),28
	.d2locreg	%offsetof(.Llo889), %offsetof(.Llo891),28
	.d2locend
.L3914:
	.d2locreg	%offsetof(.Llo995), %offsetof(.Llo921),31
	.d2locreg	%offsetof(.Llo992), %offsetof(.Llo927),31
	.d2locend
.L3920:
	.d2locreg	%offsetof(.Llo897), %offsetof(.Llo921),31
	.d2locreg	%offsetof(.Llo992), %offsetof(.Llo927),31
	.d2locend
.L3926:
	.d2locreg	%offsetof(.Llo996), %offsetof(.Llo997),3
	.d2locreg	%offsetof(.Llo998), %offsetof(.Llo999),31
	.d2locreg	%offsetof(.Llo1000), %offsetof(.Llo1001),3
	.d2locend
.L3928:
	.d2locreg	%offsetof(.Llo1002), %offsetof(.Llo1003),30
	.d2locreg	%offsetof(.Llo1004), %offsetof(.Llo1005),30
	.d2locreg	%offsetof(.Llo1006), %offsetof(.Llo999),30
	.d2locend
.L3930:
	.d2locreg	%offsetof(.Llo996), %offsetof(.Llo1007),29
	.d2locreg	%offsetof(.Llo1008), %offsetof(.Llo1009),3
	.d2locreg	%offsetof(.Llo1010), %offsetof(.Llo999),29
	.d2locend
.L3941:
	.d2locreg	%offsetof(.Llo1011), %offsetof(.Llo1012),3
	.d2locreg	%offsetof(.Llo1013), %offsetof(.Llo1003),6
	.d2locreg	%offsetof(.Llo1014), %offsetof(.Llo1005),6
	.d2locend
.L3947:
	.d2locreg	%offsetof(.Llo1015), %offsetof(.Llo1016),3
	.d2locreg	%offsetof(.Llo1017), %offsetof(.Llo1018),31
	.d2locreg	%offsetof(.Llo1019), %offsetof(.Llo1020),0
	.d2locreg	%offsetof(.Llo1021), %offsetof(.Llo1022),0
	.d2locreg	%offsetof(.Llo1023), %offsetof(.Llo1024),31
	.d2locend
.L3948:
	.d2locreg	%offsetof(.Llo1015), %offsetof(.Llo1017),4
	.d2locreg	%offsetof(.Llo1025), %offsetof(.Llo1026),30
	.d2locreg	%offsetof(.Llo1027), %offsetof(.Llo1028),4
	.d2locend
.L3950:
	.d2locreg	%offsetof(.Llo1029), %offsetof(.Llo1030),4
	.d2locreg	%offsetof(.Llo1031), %offsetof(.Llo1032),0
	.d2locreg	%offsetof(.Llo1033), %offsetof(.Llo1034),4
	.d2locend
.L3954:
	.d2locreg	%offsetof(.Llo1035), %offsetof(.Llo1036),3
	.d2locend
.L3961:
	.d2locreg	%offsetof(.Llo1037), %offsetof(.Llo1038),3
	.d2locreg	%offsetof(.Llo1039), %offsetof(.Llo1040),29
	.d2locend
.L3963:
	.d2locreg	%offsetof(.Llo1037), %offsetof(.Llo1041),4
	.d2locreg	%offsetof(.Llo1039), %offsetof(.Llo1042),31
	.d2locend
.L3964:
	.d2locreg	%offsetof(.Llo1037), %offsetof(.Llo1041),5
	.d2locreg	%offsetof(.Llo1039), %offsetof(.Llo1040),30
	.d2locend
.L3974:
	.d2locreg	%offsetof(.Llo1043), %offsetof(.Llo1044),3
	.d2locreg	%offsetof(.Llo1045), %offsetof(.Llo1046),0
	.d2locreg	%offsetof(.Llo1047), %offsetof(.Llo1048),0
	.d2locreg	%offsetof(.Llo1049), %offsetof(.Llo1050),0
	.d2locend
.L3975:
	.d2locreg	%offsetof(.Llo1043), %offsetof(.Llo1046),4
	.d2locreg	%offsetof(.Llo1051), %offsetof(.Llo1052),3
	.d2locreg	%offsetof(.Llo1053), %offsetof(.Llo1054),3
	.d2locreg	%offsetof(.Llo1055), %offsetof(.Llo1056),3
	.d2locreg	%offsetof(.Llo1057), %offsetof(.Llo1058),3
	.d2locreg	%offsetof(.Llo1059), %offsetof(.Llo1060),3
	.d2locreg	%offsetof(.Llo1061), %offsetof(.Llo1062),3
	.d2locreg	%offsetof(.Llo1063), %offsetof(.Llo1064),3
	.d2locreg	%offsetof(.Llo1065), %offsetof(.Llo1066),3
	.d2locreg	%offsetof(.Llo1067), %offsetof(.Llo1068),3
	.d2locreg	%offsetof(.Llo1069), %offsetof(.Llo1070),3
	.d2locreg	%offsetof(.Llo1071), %offsetof(.Llo1072),3
	.d2locreg	%offsetof(.Llo1073), %offsetof(.Llo1074),3
	.d2locreg	%offsetof(.Llo1075), %offsetof(.Llo1076),3
	.d2locreg	%offsetof(.Llo1077), %offsetof(.Llo1078),3
	.d2locreg	%offsetof(.Llo1079), %offsetof(.Llo1080),3
	.d2locreg	%offsetof(.Llo1081), %offsetof(.Llo1082),4
	.d2locend
.L3976:
	.d2locreg	%offsetof(.Llo1043), %offsetof(.Llo1046),5
	.d2locreg	%offsetof(.Llo1051), %offsetof(.Llo1081),31
	.d2locreg	%offsetof(.Llo1083), %offsetof(.Llo1082),5
	.d2locend
.L3984:
	.d2locreg	%offsetof(.Llo1084), %offsetof(.Llo1085),3
	.d2locreg	%offsetof(.Llo1086), %offsetof(.Llo1087),0
	.d2locreg	%offsetof(.Llo1088), %offsetof(.Llo1089),0
	.d2locend
.L3985:
	.d2locreg	%offsetof(.Llo1084), %offsetof(.Llo1090),4
	.d2locreg	%offsetof(.Llo1088), %offsetof(.Llo1089),4
	.d2locend
.L3986:
	.d2locreg	%offsetof(.Llo1084), %offsetof(.Llo1086),5
	.d2locreg	%offsetof(.Llo1088), %offsetof(.Llo1089),5
	.d2locend
.L3987:
	.d2locreg	%offsetof(.Llo1084), %offsetof(.Llo1087),6
	.d2locreg	%offsetof(.Llo1088), %offsetof(.Llo1089),6
	.d2locend
.L3989:
	.d2locreg	%offsetof(.Llo1085), %offsetof(.Llo1091),3
	.d2locreg	%offsetof(.Llo1088), %offsetof(.Llo1089),3
	.d2locend
.L3991:
	.d2locreg	%offsetof(.Llo1092), %offsetof(.Llo1089),7
	.d2locend
.L3993:
	.d2locreg	%offsetof(.Llo1093), %offsetof(.Llo1094),30
	.d2locend
.L3995:
	.d2locreg	%offsetof(.Llo1095), %offsetof(.Llo1096),28
	.d2locreg	%offsetof(.Llo1097), %offsetof(.Llo1089),29
	.d2locend
.L3997:
	.d2locreg	%offsetof(.Llo1098), %offsetof(.Llo1099),26
	.d2locreg	%offsetof(.Llo1094), %offsetof(.Llo1100),30
	.d2locreg	%offsetof(.Llo1101), %offsetof(.Llo1089),26
	.d2locend
.L3999:
	.d2locreg	%offsetof(.Llo1102), %offsetof(.Llo1103),30
	.d2locreg	%offsetof(.Llo1104), %offsetof(.Llo1095),28
	.d2locreg	%offsetof(.Llo1096), %offsetof(.Llo1105),26
	.d2locreg	%offsetof(.Llo1101), %offsetof(.Llo1106),8
	.d2locreg	%offsetof(.Llo1107), %offsetof(.Llo1089),30
	.d2locend
.L4001:
	.d2locreg	%offsetof(.Llo1108), %offsetof(.Llo1093),30
	.d2locreg	%offsetof(.Llo1109), %offsetof(.Llo1089),27
	.d2locend
.L4003:
	.d2locreg	%offsetof(.Llo1110), %offsetof(.Llo1111),29
	.d2locend
.L4005:
	.d2locreg	%offsetof(.Llo1099), %offsetof(.Llo1105),26
	.d2locend
.L4011:
	.d2locreg	%offsetof(.Llo1112), %offsetof(.Llo1113),3
	.d2locreg	%offsetof(.Llo1114), %offsetof(.Llo1115),0
	.d2locend
.L4012:
	.d2locreg	%offsetof(.Llo1112), %offsetof(.Llo1116),4
	.d2locend
.L4013:
	.d2locreg	%offsetof(.Llo1112), %offsetof(.Llo1117),5
	.d2locreg	%offsetof(.Llo1118), %offsetof(.Llo1119),5
	.d2locend
.L4014:
	.d2locreg	%offsetof(.Llo1112), %offsetof(.Llo1120),6
	.d2locend
.L4016:
	.d2locreg	%offsetof(.Llo1121), %offsetof(.Llo1122),0
	.d2locreg	%offsetof(.Llo1115), %offsetof(.Llo1123),0
	.d2locreg	%offsetof(.Llo1124), %offsetof(.Llo1125),0
	.d2locend
.L4018:
	.d2locreg	%offsetof(.Llo1123), %offsetof(.Llo1126),0
	.d2locreg	%offsetof(.Llo1127), %offsetof(.Llo1128),7
	.d2locend
.L4020:
	.d2locreg	%offsetof(.Llo1129), %offsetof(.Llo1130),6
	.d2locreg	%offsetof(.Llo1131), %offsetof(.Llo1132),0
	.d2locend
.L4022:
	.d2locreg	%offsetof(.Llo1133), %offsetof(.Llo1117),7
	.d2locreg	%offsetof(.Llo1118), %offsetof(.Llo1128),6
	.d2locreg	%offsetof(.Llo1124), %offsetof(.Llo1125),7
	.d2locreg	%offsetof(.Llo1134), %offsetof(.Llo1131),0
	.d2locreg	%offsetof(.Llo1135), %offsetof(.Llo1116),6
	.d2locend
.L4024:
	.d2locreg	%offsetof(.Llo1120), %offsetof(.Llo1129),6
	.d2locend
.L4026:
	.d2locreg	%offsetof(.Llo1136), %offsetof(.Llo1137),7
	.d2locreg	%offsetof(.Llo1138), %offsetof(.Llo1117),7
	.d2locreg	%offsetof(.Llo1139), %offsetof(.Llo1140),7
	.d2locreg	%offsetof(.Llo1128), %offsetof(.Llo1125),7
	.d2locend
.L4028:
	.d2locreg	%offsetof(.Llo1141), %offsetof(.Llo1116),31
	.d2locend
.L4030:
	.d2locreg	%offsetof(.Llo1113), %offsetof(.Llo1116),3
	.d2locend
.L4036:
	.d2locreg	%offsetof(.Llo1142), %offsetof(.Llo1143),3
	.d2locend
.L4037:
	.d2locreg	%offsetof(.Llo1142), %offsetof(.Llo1144),4
	.d2locend
.L4039:
	.d2locreg	%offsetof(.Llo1145), %offsetof(.Llo1146),0
	.d2locreg	%offsetof(.Llo1147), %offsetof(.Llo1148),0
	.d2locreg	%offsetof(.Llo1149), %offsetof(.Llo1150),0
	.d2locend
.L4041:
	.d2locreg	%offsetof(.Llo1144), %offsetof(.Llo1150),4
	.d2locend
.L4047:
	.d2locreg	%offsetof(.Llo1151), %offsetof(.Llo1152),3
	.d2locreg	%offsetof(.Llo1153), %offsetof(.Llo1154),7
	.d2locreg	%offsetof(.Llo1155), %offsetof(.Llo1156),3
	.d2locend
.L4048:
	.d2locreg	%offsetof(.Llo1151), %offsetof(.Llo1157),4
	.d2locreg	%offsetof(.Llo1158), %offsetof(.Llo1159),4
	.d2locend
.L4049:
	.d2locreg	%offsetof(.Llo1151), %offsetof(.Llo1160),5
	.d2locend
.L4050:
	.d2locreg	%offsetof(.Llo1151), %offsetof(.Llo1154),6
	.d2locend
.L4052:
	.d2locreg	%offsetof(.Llo1161), %offsetof(.Llo1162),3
	.d2locreg	%offsetof(.Llo1163), %offsetof(.Llo1158),3
	.d2locreg	%offsetof(.Llo1164), %offsetof(.Llo1165),3
	.d2locreg	%offsetof(.Llo1166), %offsetof(.Llo1155),3
	.d2locend
.L4054:
	.d2locreg	%offsetof(.Llo1167), %offsetof(.Llo1168),31
	.d2locend
.L4060:
	.d2locreg	%offsetof(.Llo1169), %offsetof(.Llo1154),30
	.d2locend
.L4066:
	.d2locreg	%offsetof(.Llo1170), %offsetof(.Llo1171),3
	.d2locend
.L4068:
	.d2locreg	%offsetof(.Llo1170), %offsetof(.Llo1172),4
	.d2locreg	%offsetof(.Llo1173), %offsetof(.Llo1174),0
	.d2locreg	%offsetof(.Llo1175), %offsetof(.Llo1176),0
	.d2locend
.L4070:
	.d2locreg	%offsetof(.Llo1177), %offsetof(.Llo1173),0
	.d2locend
.L4076:
	.d2locreg	%offsetof(.Llo1178), %offsetof(.Llo1179),3
	.d2locreg	%offsetof(.Llo1180), %offsetof(.Llo1181),31
	.d2locend
.L4077:
	.d2locreg	%offsetof(.Llo1178), %offsetof(.Llo1182),4
	.d2locreg	%offsetof(.Llo1183), %offsetof(.Llo1181),30
	.d2locend
.L4078:
	.d2locreg	%offsetof(.Llo1178), %offsetof(.Llo1183),7
	.d2locreg	%offsetof(.Llo1184), %offsetof(.Llo1185),29
	.d2locreg	%offsetof(.Llo1186), %offsetof(.Llo1187),7
	.d2locend
.L4080:
	.d2locreg	%offsetof(.Llo1182), %offsetof(.Llo1188),4
	.d2locreg	%offsetof(.Llo1189), %offsetof(.Llo1190),4
	.d2locreg	%offsetof(.Llo1191), %offsetof(.Llo1192),4
	.d2locreg	%offsetof(.Llo1193), %offsetof(.Llo1194),4
	.d2locreg	%offsetof(.Llo1195), %offsetof(.Llo1181),4
	.d2locend
.L4082:
	.d2locreg	%offsetof(.Llo1196), %offsetof(.Llo1188),3
	.d2locreg	%offsetof(.Llo1197), %offsetof(.Llo1192),3
	.d2locreg	%offsetof(.Llo1194), %offsetof(.Llo1198),3
	.d2locreg	%offsetof(.Llo1199), %offsetof(.Llo1200),3
	.d2locend
.L4089:
	.d2locreg	%offsetof(.Llo1201), %offsetof(.Llo1202),3
	.d2locreg	%offsetof(.Llo1203), %offsetof(.Llo1204),7
	.d2locreg	%offsetof(.Llo1205), %offsetof(.Llo1206),3
	.d2locend
.L4090:
	.d2locreg	%offsetof(.Llo1201), %offsetof(.Llo1207),4
	.d2locend
.L4091:
	.d2locreg	%offsetof(.Llo1201), %offsetof(.Llo1208),5
	.d2locend
.L4092:
	.d2locreg	%offsetof(.Llo1201), %offsetof(.Llo1204),6
	.d2locend
.L4094:
	.d2locreg	%offsetof(.Llo1209), %offsetof(.Llo1207),3
	.d2locreg	%offsetof(.Llo1210), %offsetof(.Llo1211),3
	.d2locreg	%offsetof(.Llo1212), %offsetof(.Llo1213),3
	.d2locreg	%offsetof(.Llo1214), %offsetof(.Llo1205),3
	.d2locend
.L4096:
	.d2locreg	%offsetof(.Llo1215), %offsetof(.Llo1216),31
	.d2locend
.L4102:
	.d2locreg	%offsetof(.Llo1217), %offsetof(.Llo1204),30
	.d2locend
.L4108:
	.d2locreg	%offsetof(.Llo1218), %offsetof(.Llo1219),3
	.d2locreg	%offsetof(.Llo1220), %offsetof(.Llo1221),31
	.d2locend
.L4109:
	.d2locreg	%offsetof(.Llo1218), %offsetof(.Llo1222),4
	.d2locreg	%offsetof(.Llo1223), %offsetof(.Llo1221),30
	.d2locend
.L4110:
	.d2locreg	%offsetof(.Llo1218), %offsetof(.Llo1223),7
	.d2locreg	%offsetof(.Llo1224), %offsetof(.Llo1225),29
	.d2locreg	%offsetof(.Llo1226), %offsetof(.Llo1227),7
	.d2locend
.L4112:
	.d2locreg	%offsetof(.Llo1222), %offsetof(.Llo1228),4
	.d2locreg	%offsetof(.Llo1229), %offsetof(.Llo1230),4
	.d2locreg	%offsetof(.Llo1231), %offsetof(.Llo1232),4
	.d2locreg	%offsetof(.Llo1233), %offsetof(.Llo1234),4
	.d2locreg	%offsetof(.Llo1235), %offsetof(.Llo1221),4
	.d2locend
.L4114:
	.d2locreg	%offsetof(.Llo1236), %offsetof(.Llo1228),3
	.d2locreg	%offsetof(.Llo1237), %offsetof(.Llo1232),3
	.d2locreg	%offsetof(.Llo1234), %offsetof(.Llo1238),3
	.d2locreg	%offsetof(.Llo1239), %offsetof(.Llo1240),3
	.d2locend
.L4122:
	.d2locreg	%offsetof(.Llo1241), %offsetof(.Llo1242),3
	.d2locend
.L4124:
	.d2locreg	%offsetof(.Llo1243), %offsetof(.Llo1242),4
	.d2locend
.L4126:
	.d2locreg	%offsetof(.Llo1244), %offsetof(.Llo1245),5
	.d2locend
.L4132:
	.d2locreg	%offsetof(.Llo1246), %offsetof(.Llo1247),3
	.d2locreg	%offsetof(.Llo1248), %offsetof(.Llo1249),31
	.d2locend
.L4133:
	.d2locreg	%offsetof(.Llo1246), %offsetof(.Llo1250),4
	.d2locreg	%offsetof(.Llo1248), %offsetof(.Llo1249),30
	.d2locend
.L4134:
	.d2locreg	%offsetof(.Llo1246), %offsetof(.Llo1251),7
	.d2locend
.L4136:
	.d2locreg	%offsetof(.Llo1247), %offsetof(.Llo1252),3
	.d2locreg	%offsetof(.Llo1253), %offsetof(.Llo1254),3
	.d2locreg	%offsetof(.Llo1255), %offsetof(.Llo1249),3
	.d2locend
.L4138:
	.d2locreg	%offsetof(.Llo1250), %offsetof(.Llo1256),4
	.d2locreg	%offsetof(.Llo1257), %offsetof(.Llo1258),3
	.d2locreg	%offsetof(.Llo1259), %offsetof(.Llo1260),4
	.d2locend
.L4140:
	.d2locreg	%offsetof(.Llo1261), %offsetof(.Llo1257),5
	.d2locreg	%offsetof(.Llo1258), %offsetof(.Llo1262),5
	.d2locreg	%offsetof(.Llo1263), %offsetof(.Llo1249),5
	.d2locend
.L4146:
	.d2locreg	%offsetof(.Llo1264), %offsetof(.Llo1265),3
	.d2locend
.L4147:
	.d2locreg	%offsetof(.Llo1264), %offsetof(.Llo1266),4
	.d2locreg	%offsetof(.Llo1267), %offsetof(.Llo1268),4
	.d2locend
.L4148:
	.d2locreg	%offsetof(.Llo1264), %offsetof(.Llo1268),5
	.d2locreg	%offsetof(.Llo1269), %offsetof(.Llo1270),5
	.d2locend
.L4149:
	.d2locreg	%offsetof(.Llo1264), %offsetof(.Llo1271),6
	.d2locreg	%offsetof(.Llo1265), %offsetof(.Llo1272),31
	.d2locend
.L4155:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1274),3
	.d2locreg	%offsetof(.Llo1275), %offsetof(.Llo1276),31
	.d2locend
.L4156:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1277),4
	.d2locreg	%offsetof(.Llo1275), %offsetof(.Llo1276),30
	.d2locend
.L4157:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1275),5
	.d2locreg	%offsetof(.Llo1278), %offsetof(.Llo1279),3
	.d2locreg	%offsetof(.Llo1280), %offsetof(.Llo1281),3
	.d2locreg	%offsetof(.Llo1282), %offsetof(.Llo1283),3
	.d2locreg	%offsetof(.Llo1284), %offsetof(.Llo1285),3
	.d2locreg	%offsetof(.Llo1286), %offsetof(.Llo1287),3
	.d2locreg	%offsetof(.Llo1288), %offsetof(.Llo1289),3
	.d2locreg	%offsetof(.Llo1290), %offsetof(.Llo1291),3
	.d2locreg	%offsetof(.Llo1292), %offsetof(.Llo1293),0
	.d2locreg	%offsetof(.Llo1294), %offsetof(.Llo1295),0
	.d2locreg	%offsetof(.Llo1296), %offsetof(.Llo1297),0
	.d2locreg	%offsetof(.Llo1298), %offsetof(.Llo1299),3
	.d2locreg	%offsetof(.Llo1300), %offsetof(.Llo1276),0
	.d2locend
.L4158:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1275),6
	.d2locreg	%offsetof(.Llo1278), %offsetof(.Llo1301),29
	.d2locreg	%offsetof(.Llo1302), %offsetof(.Llo1303),6
	.d2locend
.L4159:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1275),7
	.d2locreg	%offsetof(.Llo1278), %offsetof(.Llo1297),28
	.d2locreg	%offsetof(.Llo1298), %offsetof(.Llo1303),7
	.d2locend
.L4160:
	.d2locreg	%offsetof(.Llo1273), %offsetof(.Llo1275),8
	.d2locreg	%offsetof(.Llo1278), %offsetof(.Llo1304),27
	.d2locreg	%offsetof(.Llo1302), %offsetof(.Llo1303),8
	.d2locend
.L4162:
	.d2locreg	%offsetof(.Llo1277), %offsetof(.Llo1305),4
	.d2locreg	%offsetof(.Llo1306), %offsetof(.Llo1280),4
	.d2locreg	%offsetof(.Llo1307), %offsetof(.Llo1276),4
	.d2locend
.L4164:
	.d2locreg	%offsetof(.Llo1308), %offsetof(.Llo1309),26
	.d2locend
.L4170:
	.d2locreg	%offsetof(.Llo1310), %offsetof(.Llo1295),25
	.d2locend
.L4177:
	.d2locreg	%offsetof(.Llo1304), %offsetof(.Llo1311),3
	.d2locend
.L4183:
	.d2locreg	%offsetof(.Llo1312), %offsetof(.Llo1313),3
	.d2locreg	%offsetof(.Llo1314), %offsetof(.Llo1315),3
	.d2locend
.L4188:
	.d2locreg	%offsetof(.Llo1312), %offsetof(.Llo1316),4
	.d2locend
.L4189:
	.d2locreg	%offsetof(.Llo1312), %offsetof(.Llo1313),5
	.d2locreg	%offsetof(.Llo1317), %offsetof(.Llo1318),31
	.d2locreg	%offsetof(.Llo1319), %offsetof(.Llo1320),5
	.d2locend
.L4190:
	.d2locreg	%offsetof(.Llo1312), %offsetof(.Llo1321),6
	.d2locend
.L4198:
	.d2locreg	%offsetof(.Llo1321), %offsetof(.Llo1322),3
	.d2locreg	%offsetof(.Llo1319), %offsetof(.Llo1323),3
	.d2locend
.L4204:
	.d2locreg	%offsetof(.Llo1324), %offsetof(.Llo1325),3
	.d2locend
.L4205:
	.d2locreg	%offsetof(.Llo1324), %offsetof(.Llo1326),4
	.d2locreg	%offsetof(.Llo1327), %offsetof(.Llo1328),31
	.d2locend
.L4206:
	.d2locreg	%offsetof(.Llo1324), %offsetof(.Llo1329),5
	.d2locreg	%offsetof(.Llo1330), %offsetof(.Llo1331),30
	.d2locend
.L4207:
	.d2locreg	%offsetof(.Llo1324), %offsetof(.Llo1330),6
	.d2locend
.L4210:
	.d2locreg	%offsetof(.Llo1330), %offsetof(.Llo1332),3
	.d2locreg	%offsetof(.Llo1333), %offsetof(.Llo1328),3
	.d2locend
.L4216:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1335),3
	.d2locreg	%offsetof(.Llo1336), %offsetof(.Llo1337),31
	.d2locend
.L4217:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1338),4
	.d2locreg	%offsetof(.Llo1336), %offsetof(.Llo1337),30
	.d2locend
.L4218:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1336),5
	.d2locreg	%offsetof(.Llo1339), %offsetof(.Llo1340),3
	.d2locreg	%offsetof(.Llo1341), %offsetof(.Llo1342),3
	.d2locreg	%offsetof(.Llo1343), %offsetof(.Llo1344),3
	.d2locreg	%offsetof(.Llo1345), %offsetof(.Llo1346),3
	.d2locreg	%offsetof(.Llo1347), %offsetof(.Llo1348),3
	.d2locreg	%offsetof(.Llo1349), %offsetof(.Llo1350),3
	.d2locreg	%offsetof(.Llo1351), %offsetof(.Llo1352),3
	.d2locreg	%offsetof(.Llo1353), %offsetof(.Llo1354),3
	.d2locreg	%offsetof(.Llo1355), %offsetof(.Llo1337),3
	.d2locend
.L4219:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1336),6
	.d2locreg	%offsetof(.Llo1339), %offsetof(.Llo1356),29
	.d2locend
.L4220:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1336),7
	.d2locreg	%offsetof(.Llo1339), %offsetof(.Llo1357),28
	.d2locreg	%offsetof(.Llo1358), %offsetof(.Llo1359),7
	.d2locend
.L4221:
	.d2locreg	%offsetof(.Llo1334), %offsetof(.Llo1336),8
	.d2locreg	%offsetof(.Llo1339), %offsetof(.Llo1360),27
	.d2locreg	%offsetof(.Llo1361), %offsetof(.Llo1357),27
	.d2locreg	%offsetof(.Llo1358), %offsetof(.Llo1359),8
	.d2locend
.L4223:
	.d2locreg	%offsetof(.Llo1338), %offsetof(.Llo1362),4
	.d2locreg	%offsetof(.Llo1363), %offsetof(.Llo1341),4
	.d2locreg	%offsetof(.Llo1364), %offsetof(.Llo1337),4
	.d2locend
.L4225:
	.d2locreg	%offsetof(.Llo1365), %offsetof(.Llo1366),26
	.d2locend
.L4227:
	.d2locreg	%offsetof(.Llo1367), %offsetof(.Llo1360),25
	.d2locreg	%offsetof(.Llo1361), %offsetof(.Llo1357),25
	.d2locend
.L4233:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1369),3
	.d2locreg	%offsetof(.Llo1370), %offsetof(.Llo1371),31
	.d2locend
.L4234:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1372),4
	.d2locreg	%offsetof(.Llo1370), %offsetof(.Llo1371),30
	.d2locend
.L4235:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1373),5
	.d2locreg	%offsetof(.Llo1370), %offsetof(.Llo1371),29
	.d2locend
.L4236:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1374),6
	.d2locreg	%offsetof(.Llo1370), %offsetof(.Llo1371),28
	.d2locend
.L4237:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1375),7
	.d2locreg	%offsetof(.Llo1376), %offsetof(.Llo1371),27
	.d2locend
.L4238:
	.d2locreg	%offsetof(.Llo1368), %offsetof(.Llo1377),8
	.d2locreg	%offsetof(.Llo1370), %offsetof(.Llo1371),26
	.d2locend
.L4240:
	.d2locreg	%offsetof(.Llo1378), %offsetof(.Llo1379),0
	.d2locreg	%offsetof(.Llo1380), %offsetof(.Llo1381),3
	.d2locend
.L4246:
	.d2locreg	%offsetof(.Llo1382), %offsetof(.Llo1383),3
	.d2locreg	%offsetof(.Llo1384), %offsetof(.Llo1385),31
	.d2locreg	%offsetof(.Llo1386), %offsetof(.Llo1387),3
	.d2locreg	%offsetof(.Llo1388), %offsetof(.Llo1389),31
	.d2locreg	%offsetof(.Llo1390), %offsetof(.Llo1391),3
	.d2locend
.L4251:
	.d2locreg	%offsetof(.Llo1382), %offsetof(.Llo1383),6
	.d2locreg	%offsetof(.Llo1384), %offsetof(.Llo1392),29
	.d2locreg	%offsetof(.Llo1390), %offsetof(.Llo1393),6
	.d2locend
.L4253:
	.d2locreg	%offsetof(.Llo1394), %offsetof(.Llo1395),3
	.d2locreg	%offsetof(.Llo1396), %offsetof(.Llo1397),3
	.d2locreg	%offsetof(.Llo1398), %offsetof(.Llo1399),3
	.d2locreg	%offsetof(.Llo1400), %offsetof(.Llo1401),3
	.d2locreg	%offsetof(.Llo1402), %offsetof(.Llo1403),3
	.d2locreg	%offsetof(.Llo1404), %offsetof(.Llo1405),3
	.d2locreg	%offsetof(.Llo1406), %offsetof(.Llo1407),3
	.d2locreg	%offsetof(.Llo1408), %offsetof(.Llo1409),3
	.d2locreg	%offsetof(.Llo1387), %offsetof(.Llo1410),3
	.d2locreg	%offsetof(.Llo1411), %offsetof(.Llo1412),3
	.d2locreg	%offsetof(.Llo1413), %offsetof(.Llo1414),0
	.d2locend
.L4255:
	.d2locreg	%offsetof(.Llo1415), %offsetof(.Llo1383),0
	.d2locreg	%offsetof(.Llo1384), %offsetof(.Llo1416),4
	.d2locreg	%offsetof(.Llo1417), %offsetof(.Llo1418),0
	.d2locreg	%offsetof(.Llo1419), %offsetof(.Llo1420),0
	.d2locreg	%offsetof(.Llo1421), %offsetof(.Llo1422),0
	.d2locreg	%offsetof(.Llo1423), %offsetof(.Llo1424),0
	.d2locreg	%offsetof(.Llo1425), %offsetof(.Llo1426),0
	.d2locreg	%offsetof(.Llo1427), %offsetof(.Llo1401),0
	.d2locreg	%offsetof(.Llo1402), %offsetof(.Llo1428),30
	.d2locreg	%offsetof(.Llo1429), %offsetof(.Llo1430),0
	.d2locreg	%offsetof(.Llo1431), %offsetof(.Llo1432),0
	.d2locreg	%offsetof(.Llo1433), %offsetof(.Llo1434),0
	.d2locreg	%offsetof(.Llo1435), %offsetof(.Llo1436),0
	.d2locreg	%offsetof(.Llo1437), %offsetof(.Llo1405),0
	.d2locreg	%offsetof(.Llo1438), %offsetof(.Llo1439),30
	.d2locreg	%offsetof(.Llo1440), %offsetof(.Llo1441),0
	.d2locreg	%offsetof(.Llo1442), %offsetof(.Llo1443),0
	.d2locreg	%offsetof(.Llo1444), %offsetof(.Llo1445),0
	.d2locreg	%offsetof(.Llo1446), %offsetof(.Llo1447),0
	.d2locreg	%offsetof(.Llo1448), %offsetof(.Llo1449),0
	.d2locreg	%offsetof(.Llo1450), %offsetof(.Llo1451),0
	.d2locreg	%offsetof(.Llo1452), %offsetof(.Llo1453),0
	.d2locreg	%offsetof(.Llo1454), %offsetof(.Llo1455),0
	.d2locreg	%offsetof(.Llo1456), %offsetof(.Llo1385),0
	.d2locreg	%offsetof(.Llo1386), %offsetof(.Llo1410),0
	.d2locreg	%offsetof(.Llo1411), %offsetof(.Llo1457),31
	.d2locreg	%offsetof(.Llo1414), %offsetof(.Llo1392),31
	.d2locend
.L4262:
	.d2locreg	%offsetof(.Llo1458), %offsetof(.Llo1459),3
	.d2locend
.L4268:
	.d2locreg	%offsetof(.Llo1460), %offsetof(.Llo1439),3
	.d2locend
.L4274:
	.d2locreg	%offsetof(.Llo1461), %offsetof(.Llo1462),3
	.d2locreg	%offsetof(.Llo1463), %offsetof(.Llo1453),3
	.d2locend
.L4280:
	.d2locreg	%offsetof(.Llo1464), %offsetof(.Llo1465),3
	.d2locreg	%offsetof(.Llo1466), %offsetof(.Llo1457),0
	.d2locreg	%offsetof(.Llo1414), %offsetof(.Llo1467),0
	.d2locreg	%offsetof(.Llo1468), %offsetof(.Llo1390),0
	.d2locend
.L4286:
	.d2locreg	%offsetof(.Llo1469), %offsetof(.Llo1470),3
	.d2locreg	%offsetof(.Llo1471), %offsetof(.Llo1472),3
	.d2locreg	%offsetof(.Llo1473), %offsetof(.Llo1474),3
	.d2locreg	%offsetof(.Llo1475), %offsetof(.Llo1476),3
	.d2locend
.L4287:
	.d2locreg	%offsetof(.Llo1469), %offsetof(.Llo1477),4
	.d2locreg	%offsetof(.Llo1478), %offsetof(.Llo1479),31
	.d2locreg	%offsetof(.Llo1480), %offsetof(.Llo1476),31
	.d2locend
.L4290:
	.d2locreg	%offsetof(.Llo1477), %offsetof(.Llo1470),4
	.d2locend
.L4292:
	.d2locreg	%offsetof(.Llo1481), %offsetof(.Llo1473),5
	.d2locend
.L4298:
	.d2locreg	%offsetof(.Llo1482), %offsetof(.Llo1483),3
	.d2locend
.L4299:
	.d2locreg	%offsetof(.Llo1482), %offsetof(.Llo1484),4
	.d2locreg	%offsetof(.Llo1485), %offsetof(.Llo1486),31
	.d2locend
.L4301:
	.d2locreg	%offsetof(.Llo1487), %offsetof(.Llo1488),3
	.d2locreg	%offsetof(.Llo1489), %offsetof(.Llo1490),3
	.d2locreg	%offsetof(.Llo1491), %offsetof(.Llo1492),3
	.d2locreg	%offsetof(.Llo1493), %offsetof(.Llo1494),3
	.d2locend
.L4304:
	.d2locreg	%offsetof(.Llo1482), %offsetof(.Llo1495),30
	.d2locreg	%offsetof(.Llo1496), %offsetof(.Llo1497),0
	.d2locreg	%offsetof(.Llo1498), %offsetof(.Llo1499),30
	.d2locend
.L4306:
	.d2locreg	%offsetof(.Llo1498), %offsetof(.Llo1500),3
	.d2locreg	%offsetof(.Llo1487), %offsetof(.Llo1501),3
	.d2locreg	%offsetof(.Llo1489), %offsetof(.Llo1490),3
	.d2locreg	%offsetof(.Llo1502), %offsetof(.Llo1499),3
	.d2locreg	%offsetof(.Llo1491), %offsetof(.Llo1492),3
	.d2locreg	%offsetof(.Llo1493), %offsetof(.Llo1494),3
	.d2locend
.L4312:
	.d2locreg	%offsetof(.Llo1503), %offsetof(.Llo1504),3
	.d2locreg	%offsetof(.Llo1505), %offsetof(.Llo1506),31
	.d2locend
.L4313:
	.d2locreg	%offsetof(.Llo1503), %offsetof(.Llo1507),4
	.d2locreg	%offsetof(.Llo1505), %offsetof(.Llo1506),30
	.d2locend
.L4315:
	.d2locreg	%offsetof(.Llo1508), %offsetof(.Llo1509),3
	.d2locreg	%offsetof(.Llo1506), %offsetof(.Llo1510),3
	.d2locend
.L4317:
	.d2locreg	%offsetof(.Llo1504), %offsetof(.Llo1511),3
	.d2locreg	%offsetof(.Llo1512), %offsetof(.Llo1505),3
	.d2locreg	%offsetof(.Llo1513), %offsetof(.Llo1508),3
	.d2locend
.L4323:
	.d2locreg	%offsetof(.Llo1514), %offsetof(.Llo1515),3
	.d2locreg	%offsetof(.Llo1516), %offsetof(.Llo1517),0
	.d2locreg	%offsetof(.Llo1518), %offsetof(.Llo1519),0
	.d2locend
.L4324:
	.d2locreg	%offsetof(.Llo1514), %offsetof(.Llo1520),4
	.d2locreg	%offsetof(.Llo1521), %offsetof(.Llo1519),31
	.d2locend
.L4327:
	.d2locreg	%offsetof(.Llo1521), %offsetof(.Llo1522),4
	.d2locreg	%offsetof(.Llo1523), %offsetof(.Llo1524),0
	.d2locreg	%offsetof(.Llo1525), %offsetof(.Llo1526),4
	.d2locend
.L4329:
	.d2locreg	%offsetof(.Llo1527), %offsetof(.Llo1528),3
	.d2locend
.L4335:
	.d2locreg	%offsetof(.Llo1529), %offsetof(.Llo1530),3
	.d2locreg	%offsetof(.Llo1531), %offsetof(.Llo1532),31
	.d2locend
.L4336:
	.d2locreg	%offsetof(.Llo1529), %offsetof(.Llo1531),6
	.d2locreg	%offsetof(.Llo1533), %offsetof(.Llo1532),30
	.d2locreg	%offsetof(.Llo1534), %offsetof(.Llo1535),6
	.d2locend
.L4338:
	.d2locreg	%offsetof(.Llo1530), %offsetof(.Llo1534),3
	.d2locend
.L4344:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1537),3
	.d2locreg	%offsetof(.Llo1538), %offsetof(.Llo1539),31
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1541),31
	.d2locreg	%offsetof(.Llo1542), %offsetof(.Llo1543),31
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),31
	.d2locend
.L4345:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1546),4
	.d2locreg	%offsetof(.Llo1537), %offsetof(.Llo1539),30
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1547),30
	.d2locreg	%offsetof(.Llo1542), %offsetof(.Llo1543),30
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),30
	.d2locend
.L4350:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1548),5
	.d2locreg	%offsetof(.Llo1537), %offsetof(.Llo1539),0
	.d2locend
.L4351:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1537),6
	.d2locreg	%offsetof(.Llo1538), %offsetof(.Llo1539),29
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1543),29
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),29
	.d2locreg	%offsetof(.Llo1549), %offsetof(.Llo1550),6
	.d2locend
.L4352:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1551),7
	.d2locreg	%offsetof(.Llo1537), %offsetof(.Llo1552),5
	.d2locreg	%offsetof(.Llo1553), %offsetof(.Llo1554),5
	.d2locend
.L4353:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1537),8
	.d2locreg	%offsetof(.Llo1538), %offsetof(.Llo1539),28
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1543),28
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),28
	.d2locreg	%offsetof(.Llo1549), %offsetof(.Llo1550),8
	.d2locend
.L4354:
	.d2locreg	%offsetof(.Llo1536), %offsetof(.Llo1537),9
	.d2locreg	%offsetof(.Llo1538), %offsetof(.Llo1552),7
	.d2locreg	%offsetof(.Llo1555), %offsetof(.Llo1539),9
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1556),7
	.d2locreg	%offsetof(.Llo1557), %offsetof(.Llo1558),9
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1550),9
	.d2locend
.L4356:
	.d2locreg	%offsetof(.Llo1546), %offsetof(.Llo1552),4
	.d2locreg	%offsetof(.Llo1559), %offsetof(.Llo1560),4
	.d2locreg	%offsetof(.Llo1561), %offsetof(.Llo1562),4
	.d2locreg	%offsetof(.Llo1563), %offsetof(.Llo1564),4
	.d2locreg	%offsetof(.Llo1565), %offsetof(.Llo1566),4
	.d2locend
.L4358:
	.d2locreg	%offsetof(.Llo1567), %offsetof(.Llo1539),27
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1543),27
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),27
	.d2locend
.L4360:
	.d2locreg	%offsetof(.Llo1547), %offsetof(.Llo1566),3
	.d2locend
.L4363:
	.d2locreg	%offsetof(.Llo1539), %offsetof(.Llo1540),3
	.d2locreg	%offsetof(.Llo1568), %offsetof(.Llo1542),3
	.d2locreg	%offsetof(.Llo1543), %offsetof(.Llo1544),3
	.d2locreg	%offsetof(.Llo1545), %offsetof(.Llo1549),3
	.d2locend
.L4365:
	.d2locreg	%offsetof(.Llo1538), %offsetof(.Llo1569),26
	.d2locreg	%offsetof(.Llo1570), %offsetof(.Llo1539),26
	.d2locreg	%offsetof(.Llo1540), %offsetof(.Llo1543),26
	.d2locreg	%offsetof(.Llo1544), %offsetof(.Llo1545),26
	.d2locend
.L4371:
	.d2locreg	%offsetof(.Llo1558), %offsetof(.Llo1571),3
	.d2locreg	%offsetof(.Llo1572), %offsetof(.Llo1573),3
	.d2locend
.L4377:
	.d2locreg	%offsetof(.Llo1574), %offsetof(.Llo1575),3
	.d2locreg	%offsetof(.Llo1576), %offsetof(.Llo1577),28
	.d2locend
.L4378:
	.d2locreg	%offsetof(.Llo1574), %offsetof(.Llo1576),4
	.d2locreg	%offsetof(.Llo1578), %offsetof(.Llo1579),31
	.d2locreg	%offsetof(.Llo1580), %offsetof(.Llo1581),4
	.d2locend
.L4379:
	.d2locreg	%offsetof(.Llo1574), %offsetof(.Llo1576),5
	.d2locreg	%offsetof(.Llo1578), %offsetof(.Llo1579),30
	.d2locreg	%offsetof(.Llo1580), %offsetof(.Llo1581),5
	.d2locend
.L4380:
	.d2locreg	%offsetof(.Llo1574), %offsetof(.Llo1576),6
	.d2locreg	%offsetof(.Llo1578), %offsetof(.Llo1582),29
	.d2locreg	%offsetof(.Llo1583), %offsetof(.Llo1581),6
	.d2locend
.L4382:
	.d2locreg	%offsetof(.Llo1584), %offsetof(.Llo1585),3
	.d2locreg	%offsetof(.Llo1586), %offsetof(.Llo1587),3
	.d2locreg	%offsetof(.Llo1588), %offsetof(.Llo1589),3
	.d2locreg	%offsetof(.Llo1590), %offsetof(.Llo1591),3
	.d2locreg	%offsetof(.Llo1592), %offsetof(.Llo1593),3
	.d2locreg	%offsetof(.Llo1594), %offsetof(.Llo1595),3
	.d2locreg	%offsetof(.Llo1596), %offsetof(.Llo1597),3
	.d2locreg	%offsetof(.Llo1598), %offsetof(.Llo1599),3
	.d2locreg	%offsetof(.Llo1600), %offsetof(.Llo1601),3
	.d2locreg	%offsetof(.Llo1602), %offsetof(.Llo1603),3
	.d2locreg	%offsetof(.Llo1604), %offsetof(.Llo1605),3
	.d2locreg	%offsetof(.Llo1606), %offsetof(.Llo1607),3
	.d2locreg	%offsetof(.Llo1608), %offsetof(.Llo1609),3
	.d2locreg	%offsetof(.Llo1610), %offsetof(.Llo1611),3
	.d2locreg	%offsetof(.Llo1612), %offsetof(.Llo1613),3
	.d2locreg	%offsetof(.Llo1614), %offsetof(.Llo1615),3
	.d2locreg	%offsetof(.Llo1616), %offsetof(.Llo1617),3
	.d2locend
.L4384:
	.d2locreg	%offsetof(.Llo1618), %offsetof(.Llo1579),28
	.d2locend
.L4386:
	.d2locreg	%offsetof(.Llo1574), %offsetof(.Llo1579),26
	.d2locend
.L4388:
	.d2locreg	%offsetof(.Llo1578), %offsetof(.Llo1585),5
	.d2locreg	%offsetof(.Llo1619), %offsetof(.Llo1587),0
	.d2locreg	%offsetof(.Llo1620), %offsetof(.Llo1579),27
	.d2locend
.L4397:
	.d2locreg	%offsetof(.Llo1621), %offsetof(.Llo1622),4
	.d2locreg	%offsetof(.Llo1623), %offsetof(.Llo1624),31
	.d2locreg	%offsetof(.Llo1625), %offsetof(.Llo1626),31
	.d2locend
.L4398:
	.d2locreg	%offsetof(.Llo1621), %offsetof(.Llo1622),5
	.d2locreg	%offsetof(.Llo1623), %offsetof(.Llo1627),30
	.d2locend
.L4406:
	.d2locreg	%offsetof(.Llo1628), %offsetof(.Llo1629),0
	.d2locend
.L4417:
	.d2locreg	%offsetof(.Llo1630), %offsetof(.Llo1631),3
	.d2locreg	%offsetof(.Llo1632), %offsetof(.Llo1633),3
	.d2locreg	%offsetof(.Llo1634), %offsetof(.Llo1635),3
	.d2locreg	%offsetof(.Llo1636), %offsetof(.Llo1637),3
	.d2locreg	%offsetof(.Llo1638), %offsetof(.Llo1639),3
	.d2locreg	%offsetof(.Llo1640), %offsetof(.Llo1641),3
	.d2locreg	%offsetof(.Llo1642), %offsetof(.Llo1643),3
	.d2locreg	%offsetof(.Llo1644), %offsetof(.Llo1645),3
	.d2locreg	%offsetof(.Llo1646), %offsetof(.Llo1647),3
	.d2locreg	%offsetof(.Llo1648), %offsetof(.Llo1649),3
	.d2locreg	%offsetof(.Llo1650), %offsetof(.Llo1651),3
	.d2locreg	%offsetof(.Llo1652), %offsetof(.Llo1653),3
	.d2locreg	%offsetof(.Llo1654), %offsetof(.Llo1655),3
	.d2locreg	%offsetof(.Llo1656), %offsetof(.Llo1657),3
	.d2locreg	%offsetof(.Llo1658), %offsetof(.Llo1659),3
	.d2locreg	%offsetof(.Llo1660), %offsetof(.Llo1661),3
	.d2locend
.L4423:
	.d2locreg	%offsetof(.Llo1662), %offsetof(.Llo1663),3
	.d2locreg	%offsetof(.Llo1664), %offsetof(.Llo1665),31
	.d2locreg	%offsetof(.Llo1666), %offsetof(.Llo1667),3
	.d2locreg	%offsetof(.Llo1668), %offsetof(.Llo1669),0
	.d2locreg	%offsetof(.Llo1670), %offsetof(.Llo1671),0
	.d2locreg	%offsetof(.Llo1672), %offsetof(.Llo1673),3
	.d2locreg	%offsetof(.Llo1674), %offsetof(.Llo1675),0
	.d2locreg	%offsetof(.Llo1676), %offsetof(.Llo1677),3
	.d2locend
.L4424:
	.d2locreg	%offsetof(.Llo1662), %offsetof(.Llo1663),4
	.d2locreg	%offsetof(.Llo1664), %offsetof(.Llo1675),30
	.d2locreg	%offsetof(.Llo1678), %offsetof(.Llo1676),4
	.d2locend
.L4425:
	.d2locreg	%offsetof(.Llo1662), %offsetof(.Llo1663),5
	.d2locreg	%offsetof(.Llo1664), %offsetof(.Llo1675),29
	.d2locreg	%offsetof(.Llo1678), %offsetof(.Llo1676),5
	.d2locend
.L4427:
	.d2locreg	%offsetof(.Llo1679), %offsetof(.Llo1680),0
	.d2locreg	%offsetof(.Llo1681), %offsetof(.Llo1682),5
	.d2locend
.L4429:
	.d2locreg	%offsetof(.Llo1680), %offsetof(.Llo1682),3
	.d2locreg	%offsetof(.Llo1683), %offsetof(.Llo1684),3
	.d2locend
.L4431:
	.d2locreg	%offsetof(.Llo1662), %offsetof(.Llo1685),28
	.d2locreg	%offsetof(.Llo1686), %offsetof(.Llo1665),28
	.d2locend
.L4437:
	.d2locreg	%offsetof(.Llo1687), %offsetof(.Llo1688),3
	.d2locend
.L4443:
	.d2locreg	%offsetof(.Llo1685), %offsetof(.Llo1686),3
	.d2locend
.L4449:
	.d2locreg	%offsetof(.Llo1689), %offsetof(.Llo1690),3
	.d2locend
.L4450:
	.d2locreg	%offsetof(.Llo1689), %offsetof(.Llo1691),4
	.d2locreg	%offsetof(.Llo1692), %offsetof(.Llo1693),0
	.d2locend
.L4452:
	.d2locreg	%offsetof(.Llo1691), %offsetof(.Llo1693),4
	.d2locend
.L4454:
	.d2locreg	%offsetof(.Llo1694), %offsetof(.Llo1695),5
	.d2locend
.L4460:
	.d2locreg	%offsetof(.Llo1692), %offsetof(.Llo1696),6
	.d2locreg	%offsetof(.Llo1697), %offsetof(.Llo1698),6
	.d2locreg	%offsetof(.Llo1699), %offsetof(.Llo1700),6
	.d2locend
.L4462:
	.d2locreg	%offsetof(.Llo1701), %offsetof(.Llo1700),30
	.d2locend
.L4468:
	.d2locreg	%offsetof(.Llo1702), %offsetof(.Llo1703),3
	.d2locreg	%offsetof(.Llo1704), %offsetof(.Llo1705),31
	.d2locend
.L4469:
	.d2locreg	%offsetof(.Llo1702), %offsetof(.Llo1704),4
	.d2locreg	%offsetof(.Llo1706), %offsetof(.Llo1705),30
	.d2locend
.L4470:
	.d2locreg	%offsetof(.Llo1702), %offsetof(.Llo1707),5
	.d2locreg	%offsetof(.Llo1708), %offsetof(.Llo1709),5
	.d2locreg	%offsetof(.Llo1710), %offsetof(.Llo1711),5
	.d2locreg	%offsetof(.Llo1712), %offsetof(.Llo1713),5
	.d2locend
.L4471:
	.d2locreg	%offsetof(.Llo1702), %offsetof(.Llo1714),6
	.d2locreg	%offsetof(.Llo1715), %offsetof(.Llo1716),6
	.d2locend
.L4472:
	.d2locreg	%offsetof(.Llo1702), %offsetof(.Llo1714),7
	.d2locend
.L4474:
	.d2locreg	%offsetof(.Llo1704), %offsetof(.Llo1717),4
	.d2locreg	%offsetof(.Llo1718), %offsetof(.Llo1714),5
	.d2locreg	%offsetof(.Llo1719), %offsetof(.Llo1705),29
	.d2locend
.L4476:
	.d2locreg	%offsetof(.Llo1707), %offsetof(.Llo1704),5
	.d2locreg	%offsetof(.Llo1706), %offsetof(.Llo1717),29
	.d2locend
.L4478:
	.d2locreg	%offsetof(.Llo1703), %offsetof(.Llo1720),3
	.d2locreg	%offsetof(.Llo1721), %offsetof(.Llo1722),3
	.d2locreg	%offsetof(.Llo1723), %offsetof(.Llo1724),3
	.d2locreg	%offsetof(.Llo1725), %offsetof(.Llo1726),3
	.d2locreg	%offsetof(.Llo1727), %offsetof(.Llo1728),3
	.d2locreg	%offsetof(.Llo1729), %offsetof(.Llo1730),3
	.d2locreg	%offsetof(.Llo1731), %offsetof(.Llo1732),3
	.d2locreg	%offsetof(.Llo1733), %offsetof(.Llo1734),3
	.d2locreg	%offsetof(.Llo1735), %offsetof(.Llo1736),3
	.d2locreg	%offsetof(.Llo1737), %offsetof(.Llo1738),3
	.d2locend
.L4480:
	.d2locreg	%offsetof(.Llo1733), %offsetof(.Llo1739),3
	.d2locreg	%offsetof(.Llo1736), %offsetof(.Llo1740),3
	.d2locend
.L4482:
	.d2locreg	%offsetof(.Llo1741), %offsetof(.Llo1705),28
	.d2locend
.L4488:
	.d2locreg	%offsetof(.Llo1742), %offsetof(.Llo1743),3
	.d2locend
.L4489:
	.d2locreg	%offsetof(.Llo1742), %offsetof(.Llo1744),4
	.d2locreg	%offsetof(.Llo1745), %offsetof(.Llo1746),0
	.d2locend
.L4491:
	.d2locreg	%offsetof(.Llo1744), %offsetof(.Llo1746),4
	.d2locend
.L4493:
	.d2locreg	%offsetof(.Llo1747), %offsetof(.Llo1748),5
	.d2locend
.L4499:
	.d2locreg	%offsetof(.Llo1745), %offsetof(.Llo1749),6
	.d2locreg	%offsetof(.Llo1750), %offsetof(.Llo1751),6
	.d2locend
.L4501:
	.d2locreg	%offsetof(.Llo1752), %offsetof(.Llo1753),30
	.d2locreg	%offsetof(.Llo1754), %offsetof(.Llo1755),30
	.d2locreg	%offsetof(.Llo1756), %offsetof(.Llo1757),30
	.d2locreg	%offsetof(.Llo1758), %offsetof(.Llo1751),30
	.d2locend
.L4507:
	.d2locreg	%offsetof(.Llo1759), %offsetof(.Llo1751),6
	.d2locend
.L4518:
	.d2locreg	%offsetof(.Llo1760), %offsetof(.Llo1761),4
	.d2locreg	%offsetof(.Llo1762), %offsetof(.Llo1763),31
	.d2locreg	%offsetof(.Llo1764), %offsetof(.Llo1765),4
	.d2locreg	%offsetof(.Llo1766), %offsetof(.Llo1767),31
	.d2locreg	%offsetof(.Llo1768), %offsetof(.Llo1769),31
	.d2locreg	%offsetof(.Llo1770), %offsetof(.Llo1771),31
	.d2locreg	%offsetof(.Llo1772), %offsetof(.Llo1773),4
	.d2locend
.L4519:
	.d2locreg	%offsetof(.Llo1760), %offsetof(.Llo1761),5
	.d2locreg	%offsetof(.Llo1762), %offsetof(.Llo1772),30
	.d2locreg	%offsetof(.Llo1774), %offsetof(.Llo1773),5
	.d2locend
.L4521:
	.d2locreg	%offsetof(.Llo1775), %offsetof(.Llo1771),29
	.d2locend
.L4525:
	.d2locreg	%offsetof(.Llo1776), %offsetof(.Llo1767),28
	.d2locreg	%offsetof(.Llo1768), %offsetof(.Llo1777),28
	.d2locreg	%offsetof(.Llo1770), %offsetof(.Llo1772),28
	.d2locreg	%offsetof(.Llo1773), %offsetof(.Llo1778),3
	.d2locend
.L4529:
	.d2locreg	%offsetof(.Llo1779), %offsetof(.Llo1763),27
	.d2locreg	%offsetof(.Llo1766), %offsetof(.Llo1780),27
	.d2locreg	%offsetof(.Llo1770), %offsetof(.Llo1781),27
	.d2locreg	%offsetof(.Llo1782), %offsetof(.Llo1783),27
	.d2locend
.L4535:
	.d2locreg	%offsetof(.Llo1784), %offsetof(.Llo1785),0
	.d2locreg	%offsetof(.Llo1786), %offsetof(.Llo1787),3
	.d2locreg	%offsetof(.Llo1788), %offsetof(.Llo1789),0
	.d2locreg	%offsetof(.Llo1790), %offsetof(.Llo1791),0
	.d2locreg	%offsetof(.Llo1792), %offsetof(.Llo1767),3
	.d2locreg	%offsetof(.Llo1793), %offsetof(.Llo1769),0
	.d2locreg	%offsetof(.Llo1794), %offsetof(.Llo1795),0
	.d2locreg	%offsetof(.Llo1796), %offsetof(.Llo1797),0
	.d2locreg	%offsetof(.Llo1798), %offsetof(.Llo1799),0
	.d2locreg	%offsetof(.Llo1800), %offsetof(.Llo1801),0
	.d2locreg	%offsetof(.Llo1802), %offsetof(.Llo1803),0
	.d2locreg	%offsetof(.Llo1804), %offsetof(.Llo1805),0
	.d2locend
.L4541:
	.d2locreg	%offsetof(.Llo1806), %offsetof(.Llo1772),26
	.d2locend
.L4548:
	.d2locreg	%offsetof(.Llo1807), %offsetof(.Llo1808),5
	.d2locreg	%offsetof(.Llo1809), %offsetof(.Llo1810),5
	.d2locreg	%offsetof(.Llo1811), %offsetof(.Llo1812),5
	.d2locreg	%offsetof(.Llo1813), %offsetof(.Llo1814),3
	.d2locend
.L4555:
	.d2locreg	%offsetof(.Llo1815), %offsetof(.Llo1816),3
	.d2locreg	%offsetof(.Llo1817), %offsetof(.Llo1818),3
	.d2locreg	%offsetof(.Llo1819), %offsetof(.Llo1820),3
	.d2locreg	%offsetof(.Llo1821), %offsetof(.Llo1822),3
	.d2locreg	%offsetof(.Llo1823), %offsetof(.Llo1824),3
	.d2locreg	%offsetof(.Llo1825), %offsetof(.Llo1826),3
	.d2locreg	%offsetof(.Llo1827), %offsetof(.Llo1828),3
	.d2locreg	%offsetof(.Llo1829), %offsetof(.Llo1830),3
	.d2locend
.L4556:
	.d2locreg	%offsetof(.Llo1815), %offsetof(.Llo1831),4
	.d2locreg	%offsetof(.Llo1832), %offsetof(.Llo1816),0
	.d2locreg	%offsetof(.Llo1833), %offsetof(.Llo1819),0
	.d2locreg	%offsetof(.Llo1834), %offsetof(.Llo1835),0
	.d2locreg	%offsetof(.Llo1836), %offsetof(.Llo1837),0
	.d2locreg	%offsetof(.Llo1838), %offsetof(.Llo1839),0
	.d2locreg	%offsetof(.Llo1840), %offsetof(.Llo1841),0
	.d2locreg	%offsetof(.Llo1842), %offsetof(.Llo1843),0
	.d2locreg	%offsetof(.Llo1844), %offsetof(.Llo1830),0
	.d2locreg	%offsetof(.Llo1845), %offsetof(.Llo1846),0
	.d2locend
.L4557:
	.d2locreg	%offsetof(.Llo1815), %offsetof(.Llo1831),5
	.d2locreg	%offsetof(.Llo1832), %offsetof(.Llo1847),31
	.d2locreg	%offsetof(.Llo1846), %offsetof(.Llo1848),5
	.d2locend
.L4558:
	.d2locreg	%offsetof(.Llo1815), %offsetof(.Llo1831),6
	.d2locreg	%offsetof(.Llo1832), %offsetof(.Llo1846),30
	.d2locreg	%offsetof(.Llo1849), %offsetof(.Llo1848),6
	.d2locend
.L4560:
	.d2locreg	%offsetof(.Llo1831), %offsetof(.Llo1816),4
	.d2locend
.L4562:
	.d2locreg	%offsetof(.Llo1815), %offsetof(.Llo1850),29
	.d2locend
.L4568:
	.d2locreg	%offsetof(.Llo1851), %offsetof(.Llo1852),3
	.d2locreg	%offsetof(.Llo1853), %offsetof(.Llo1854),31
	.d2locend
.L4569:
	.d2locreg	%offsetof(.Llo1851), %offsetof(.Llo1855),4
	.d2locreg	%offsetof(.Llo1856), %offsetof(.Llo1857),30
	.d2locreg	%offsetof(.Llo1858), %offsetof(.Llo1859),4
	.d2locend
.L4570:
	.d2locreg	%offsetof(.Llo1851), %offsetof(.Llo1855),5
	.d2locreg	%offsetof(.Llo1856), %offsetof(.Llo1857),29
	.d2locreg	%offsetof(.Llo1860), %offsetof(.Llo1859),5
	.d2locend
.L4571:
	.d2locreg	%offsetof(.Llo1851), %offsetof(.Llo1855),6
	.d2locreg	%offsetof(.Llo1856), %offsetof(.Llo1861),28
	.d2locreg	%offsetof(.Llo1862), %offsetof(.Llo1858),6
	.d2locreg	%offsetof(.Llo1863), %offsetof(.Llo1864),28
	.d2locreg	%offsetof(.Llo1865), %offsetof(.Llo1859),6
	.d2locend
.L4573:
	.d2locreg	%offsetof(.Llo1866), %offsetof(.Llo1854),27
	.d2locend
.L4575:
	.d2locreg	%offsetof(.Llo1867), %offsetof(.Llo1855),0
	.d2locreg	%offsetof(.Llo1856), %offsetof(.Llo1868),0
	.d2locreg	%offsetof(.Llo1869), %offsetof(.Llo1870),0
	.d2locreg	%offsetof(.Llo1871), %offsetof(.Llo1872),0
	.d2locreg	%offsetof(.Llo1873), %offsetof(.Llo1874),0
	.d2locreg	%offsetof(.Llo1875), %offsetof(.Llo1876),0
	.d2locreg	%offsetof(.Llo1877), %offsetof(.Llo1878),0
	.d2locreg	%offsetof(.Llo1879), %offsetof(.Llo1880),0
	.d2locreg	%offsetof(.Llo1881), %offsetof(.Llo1882),0
	.d2locreg	%offsetof(.Llo1883), %offsetof(.Llo1884),0
	.d2locreg	%offsetof(.Llo1885), %offsetof(.Llo1886),0
	.d2locreg	%offsetof(.Llo1887), %offsetof(.Llo1888),0
	.d2locreg	%offsetof(.Llo1889), %offsetof(.Llo1890),0
	.d2locreg	%offsetof(.Llo1891), %offsetof(.Llo1892),0
	.d2locreg	%offsetof(.Llo1893), %offsetof(.Llo1894),0
	.d2locreg	%offsetof(.Llo1895), %offsetof(.Llo1896),0
	.d2locreg	%offsetof(.Llo1897), %offsetof(.Llo1898),0
	.d2locreg	%offsetof(.Llo1899), %offsetof(.Llo1900),0
	.d2locreg	%offsetof(.Llo1901), %offsetof(.Llo1902),0
	.d2locreg	%offsetof(.Llo1903), %offsetof(.Llo1904),0
	.d2locreg	%offsetof(.Llo1905), %offsetof(.Llo1906),0
	.d2locreg	%offsetof(.Llo1907), %offsetof(.Llo1857),0
	.d2locreg	%offsetof(.Llo1908), %offsetof(.Llo1909),0
	.d2locreg	%offsetof(.Llo1910), %offsetof(.Llo1911),0
	.d2locreg	%offsetof(.Llo1912), %offsetof(.Llo1861),0
	.d2locreg	%offsetof(.Llo1862), %offsetof(.Llo1913),0
	.d2locreg	%offsetof(.Llo1914), %offsetof(.Llo1915),0
	.d2locreg	%offsetof(.Llo1916), %offsetof(.Llo1917),0
	.d2locreg	%offsetof(.Llo1918), %offsetof(.Llo1858),0
	.d2locreg	%offsetof(.Llo1863), %offsetof(.Llo1864),0
	.d2locreg	%offsetof(.Llo1919), %offsetof(.Llo1854),0
	.d2locend
.L4577:
	.d2locreg	%offsetof(.Llo1920), %offsetof(.Llo1857),19
	.d2locreg	%offsetof(.Llo1860), %offsetof(.Llo1861),4
	.d2locend
.L4579:
	.d2locreg	%offsetof(.Llo1921), %offsetof(.Llo1861),26
	.d2locreg	%offsetof(.Llo1858), %offsetof(.Llo1864),26
	.d2locend
.L4581:
	.d2locreg	%offsetof(.Llo1922), %offsetof(.Llo1923),25
	.d2locreg	%offsetof(.Llo1924), %offsetof(.Llo1898),25
	.d2locreg	%offsetof(.Llo1925), %offsetof(.Llo1926),25
	.d2locreg	%offsetof(.Llo1927), %offsetof(.Llo1928),25
	.d2locend
.L4583:
	.d2locreg	%offsetof(.Llo1929), %offsetof(.Llo1923),24
	.d2locreg	%offsetof(.Llo1930), %offsetof(.Llo1898),24
	.d2locreg	%offsetof(.Llo1931), %offsetof(.Llo1926),24
	.d2locreg	%offsetof(.Llo1932), %offsetof(.Llo1928),24
	.d2locend
.L4585:
	.d2locreg	%offsetof(.Llo1933), %offsetof(.Llo1874),3
	.d2locreg	%offsetof(.Llo1934), %offsetof(.Llo1880),3
	.d2locreg	%offsetof(.Llo1935), %offsetof(.Llo1898),23
	.d2locreg	%offsetof(.Llo1936), %offsetof(.Llo1937),3
	.d2locreg	%offsetof(.Llo1938), %offsetof(.Llo1926),23
	.d2locreg	%offsetof(.Llo1939), %offsetof(.Llo1940),3
	.d2locreg	%offsetof(.Llo1941), %offsetof(.Llo1928),23
	.d2locreg	%offsetof(.Llo1942), %offsetof(.Llo1909),3
	.d2locreg	%offsetof(.Llo1943), %offsetof(.Llo1944),3
	.d2locreg	%offsetof(.Llo1945), %offsetof(.Llo1861),3
	.d2locreg	%offsetof(.Llo1865), %offsetof(.Llo1854),3
	.d2locend
.L4588:
	.d2locreg	%offsetof(.Llo1946), %offsetof(.Llo1947),0
	.d2locreg	%offsetof(.Llo1855), %offsetof(.Llo1917),22
	.d2locreg	%offsetof(.Llo1858), %offsetof(.Llo1864),22
	.d2locend
.L4590:
	.d2locreg	%offsetof(.Llo1948), %offsetof(.Llo1917),22
	.d2locreg	%offsetof(.Llo1858), %offsetof(.Llo1864),22
	.d2locend
.L4593:
	.d2locreg	%offsetof(.Llo1894), %offsetof(.Llo1949),0
	.d2locreg	%offsetof(.Llo1895), %offsetof(.Llo1950),3
	.d2locreg	%offsetof(.Llo1900), %offsetof(.Llo1937),0
	.d2locreg	%offsetof(.Llo1901), %offsetof(.Llo1926),3
	.d2locreg	%offsetof(.Llo1904), %offsetof(.Llo1940),0
	.d2locreg	%offsetof(.Llo1905), %offsetof(.Llo1951),3
	.d2locend
.L4595:
	.d2locreg	%offsetof(.Llo1952), %offsetof(.Llo1855),9
	.d2locreg	%offsetof(.Llo1856), %offsetof(.Llo1857),21
	.d2locend
.L4598:
	.d2locreg	%offsetof(.Llo1953), %offsetof(.Llo1857),20
	.d2locend
.L4604:
	.d2locreg	%offsetof(.Llo1954), %offsetof(.Llo1955),3
	.d2locend
.L4605:
	.d2locreg	%offsetof(.Llo1954), %offsetof(.Llo1956),4
	.d2locreg	%offsetof(.Llo1957), %offsetof(.Llo1958),7
	.d2locend
.L4607:
	.d2locreg	%offsetof(.Llo1956), %offsetof(.Llo1958),4
	.d2locend
.L4609:
	.d2locreg	%offsetof(.Llo1959), %offsetof(.Llo1960),5
	.d2locend
.L4615:
	.d2locreg	%offsetof(.Llo1961), %offsetof(.Llo1962),3
	.d2locreg	%offsetof(.Llo1963), %offsetof(.Llo1964),31
	.d2locend
.L4616:
	.d2locreg	%offsetof(.Llo1961), %offsetof(.Llo1963),4
	.d2locreg	%offsetof(.Llo1965), %offsetof(.Llo1966),30
	.d2locreg	%offsetof(.Llo1967), %offsetof(.Llo1968),30
	.d2locend
.L4621:
	.d2locreg	%offsetof(.Llo1969), %offsetof(.Llo1970),0
	.d2locreg	%offsetof(.Llo1963), %offsetof(.Llo1971),5
	.d2locend
.L4623:
	.d2locreg	%offsetof(.Llo1972), %offsetof(.Llo1973),24
	.d2locreg	%offsetof(.Llo1974), %offsetof(.Llo1966),4
	.d2locend
.L4625:
	.d2locreg	%offsetof(.Llo1975), %offsetof(.Llo1964),29
	.d2locend
.L4627:
	.d2locreg	%offsetof(.Llo1976), %offsetof(.Llo1966),28
	.d2locreg	%offsetof(.Llo1967), %offsetof(.Llo1968),28
	.d2locend
.L4629:
	.d2locreg	%offsetof(.Llo1977), %offsetof(.Llo1978),3
	.d2locreg	%offsetof(.Llo1979), %offsetof(.Llo1973),27
	.d2locend
.L4631:
	.d2locreg	%offsetof(.Llo1980), %offsetof(.Llo1968),26
	.d2locend
.L4633:
	.d2locreg	%offsetof(.Llo1981), %offsetof(.Llo1982),3
	.d2locreg	%offsetof(.Llo1983), %offsetof(.Llo1984),3
	.d2locreg	%offsetof(.Llo1985), %offsetof(.Llo1986),3
	.d2locreg	%offsetof(.Llo1987), %offsetof(.Llo1988),3
	.d2locreg	%offsetof(.Llo1989), %offsetof(.Llo1990),3
	.d2locreg	%offsetof(.Llo1991), %offsetof(.Llo1992),3
	.d2locreg	%offsetof(.Llo1993), %offsetof(.Llo1994),3
	.d2locreg	%offsetof(.Llo1995), %offsetof(.Llo1996),3
	.d2locreg	%offsetof(.Llo1997), %offsetof(.Llo1998),3
	.d2locreg	%offsetof(.Llo1999), %offsetof(.Llo2000),3
	.d2locreg	%offsetof(.Llo2001), %offsetof(.Llo1973),3
	.d2locreg	%offsetof(.Llo2002), %offsetof(.Llo2003),3
	.d2locreg	%offsetof(.Llo2004), %offsetof(.Llo2005),3
	.d2locreg	%offsetof(.Llo2006), %offsetof(.Llo1966),3
	.d2locreg	%offsetof(.Llo2007), %offsetof(.Llo1967),3
	.d2locreg	%offsetof(.Llo2008), %offsetof(.Llo1968),3
	.d2locreg	%offsetof(.Llo2009), %offsetof(.Llo1964),3
	.d2locend
.L4635:
	.d2locreg	%offsetof(.Llo2010), %offsetof(.Llo2000),0
	.d2locreg	%offsetof(.Llo2011), %offsetof(.Llo2012),3
	.d2locend
.L4637:
	.d2locreg	%offsetof(.Llo2013), %offsetof(.Llo2014),25
	.d2locend
.L4639:
	.d2locreg	%offsetof(.Llo2015), %offsetof(.Llo1973),23
	.d2locend
.L4645:
	.d2locreg	%offsetof(.Llo2016), %offsetof(.Llo2017),4
	.d2locreg	%offsetof(.Llo2018), %offsetof(.Llo2019),31
	.d2locend
.L4646:
	.d2locreg	%offsetof(.Llo2016), %offsetof(.Llo2020),5
	.d2locreg	%offsetof(.Llo2021), %offsetof(.Llo2022),30
	.d2locend
.L4648:
	.d2locreg	%offsetof(.Llo2023), %offsetof(.Llo2024),3
	.d2locreg	%offsetof(.Llo2025), %offsetof(.Llo2026),3
	.d2locreg	%offsetof(.Llo2027), %offsetof(.Llo2028),3
	.d2locreg	%offsetof(.Llo2029), %offsetof(.Llo2030),3
	.d2locreg	%offsetof(.Llo2031), %offsetof(.Llo2032),3
	.d2locreg	%offsetof(.Llo2033), %offsetof(.Llo2019),3
	.d2locend
.L4650:
	.d2locreg	%offsetof(.Llo2034), %offsetof(.Llo2020),0
	.d2locreg	%offsetof(.Llo2035), %offsetof(.Llo2021),0
	.d2locreg	%offsetof(.Llo2036), %offsetof(.Llo2037),0
	.d2locreg	%offsetof(.Llo2038), %offsetof(.Llo2039),0
	.d2locreg	%offsetof(.Llo2040), %offsetof(.Llo2041),0
	.d2locreg	%offsetof(.Llo2042), %offsetof(.Llo2043),0
	.d2locreg	%offsetof(.Llo2044), %offsetof(.Llo2045),0
	.d2locreg	%offsetof(.Llo2046), %offsetof(.Llo2047),0
	.d2locreg	%offsetof(.Llo2048), %offsetof(.Llo2049),0
	.d2locreg	%offsetof(.Llo2050), %offsetof(.Llo2051),0
	.d2locreg	%offsetof(.Llo2052), %offsetof(.Llo2053),0
	.d2locreg	%offsetof(.Llo2054), %offsetof(.Llo2055),0
	.d2locreg	%offsetof(.Llo2056), %offsetof(.Llo2057),0
	.d2locreg	%offsetof(.Llo2058), %offsetof(.Llo2023),4
	.d2locreg	%offsetof(.Llo2059), %offsetof(.Llo2060),29
	.d2locend
.L4652:
	.d2locreg	%offsetof(.Llo2061), %offsetof(.Llo2019),28
	.d2locreg	%offsetof(.Llo2062), %offsetof(.Llo2063),3
	.d2locend
.L4656:
	.d2locreg	%offsetof(.Llo2016), %offsetof(.Llo2064),27
	.d2locend
.L4665:
	.d2locreg	%offsetof(.Llo2065), %offsetof(.Llo2066),3
	.d2locend
.L4666:
	.d2locreg	%offsetof(.Llo2065), %offsetof(.Llo2067),4
	.d2locreg	%offsetof(.Llo2068), %offsetof(.Llo2069),6
	.d2locreg	%offsetof(.Llo2070), %offsetof(.Llo2071),6
	.d2locreg	%offsetof(.Llo2072), %offsetof(.Llo2073),4
	.d2locend
.L4676:
	.d2locreg	%offsetof(.Llo2074), %offsetof(.Llo2075),3
	.d2locreg	%offsetof(.Llo2076), %offsetof(.Llo2077),31
	.d2locend
.L4677:
	.d2locreg	%offsetof(.Llo2074), %offsetof(.Llo2078),4
	.d2locreg	%offsetof(.Llo2079), %offsetof(.Llo2080),30
	.d2locreg	%offsetof(.Llo2081), %offsetof(.Llo2082),4
	.d2locend
.L4678:
	.d2locreg	%offsetof(.Llo2074), %offsetof(.Llo2078),5
	.d2locreg	%offsetof(.Llo2079), %offsetof(.Llo2081),29
	.d2locreg	%offsetof(.Llo2082), %offsetof(.Llo2083),5
	.d2locend
.L4680:
	.d2locreg	%offsetof(.Llo2084), %offsetof(.Llo2078),3
	.d2locreg	%offsetof(.Llo2085), %offsetof(.Llo2086),3
	.d2locreg	%offsetof(.Llo2087), %offsetof(.Llo2088),3
	.d2locreg	%offsetof(.Llo2080), %offsetof(.Llo2089),3
	.d2locend
.L4691:
	.d2locreg	%offsetof(.Llo2090), %offsetof(.Llo2091),4
	.d2locreg	%offsetof(.Llo2092), %offsetof(.Llo2093),31
	.d2locreg	%offsetof(.Llo2094), %offsetof(.Llo2095),4
	.d2locend
.L4692:
	.d2locreg	%offsetof(.Llo2090), %offsetof(.Llo2091),5
	.d2locreg	%offsetof(.Llo2092), %offsetof(.Llo2093),30
	.d2locreg	%offsetof(.Llo2094), %offsetof(.Llo2095),5
	.d2locend
.L4694:
	.d2locreg	%offsetof(.Llo2096), %offsetof(.Llo2097),3
	.d2locreg	%offsetof(.Llo2098), %offsetof(.Llo2099),3
	.d2locreg	%offsetof(.Llo2100), %offsetof(.Llo2101),4
	.d2locreg	%offsetof(.Llo2102), %offsetof(.Llo2103),3
	.d2locreg	%offsetof(.Llo2104), %offsetof(.Llo2105),4
	.d2locreg	%offsetof(.Llo2106), %offsetof(.Llo2107),3
	.d2locreg	%offsetof(.Llo2108), %offsetof(.Llo2109),4
	.d2locreg	%offsetof(.Llo2110), %offsetof(.Llo2111),3
	.d2locreg	%offsetof(.Llo2112), %offsetof(.Llo2113),3
	.d2locreg	%offsetof(.Llo2114), %offsetof(.Llo2115),3
	.d2locreg	%offsetof(.Llo2116), %offsetof(.Llo2117),3
	.d2locreg	%offsetof(.Llo2118), %offsetof(.Llo2119),3
	.d2locreg	%offsetof(.Llo2120), %offsetof(.Llo2121),3
	.d2locreg	%offsetof(.Llo2122), %offsetof(.Llo2123),3
	.d2locreg	%offsetof(.Llo2124), %offsetof(.Llo2125),3
	.d2locreg	%offsetof(.Llo2126), %offsetof(.Llo2127),3
	.d2locreg	%offsetof(.Llo2128), %offsetof(.Llo2129),3
	.d2locreg	%offsetof(.Llo2130), %offsetof(.Llo2093),3
	.d2locreg	%offsetof(.Llo2095), %offsetof(.Llo2131),3
	.d2locend
.L4696:
	.d2locreg	%offsetof(.Llo2132), %offsetof(.Llo2133),29
	.d2locreg	%offsetof(.Llo2134), %offsetof(.Llo2127),29
	.d2locend
.L4698:
	.d2locreg	%offsetof(.Llo2135), %offsetof(.Llo2136),28
	.d2locreg	%offsetof(.Llo2137), %offsetof(.Llo2138),28
	.d2locreg	%offsetof(.Llo2134), %offsetof(.Llo2127),28
	.d2locend
.L4711:
	.d2locreg	%offsetof(.Llo2139), %offsetof(.Llo2140),3
	.d2locreg	%offsetof(.Llo2141), %offsetof(.Llo2142),31
	.d2locend
.L4712:
	.d2locreg	%offsetof(.Llo2139), %offsetof(.Llo2143),4
	.d2locreg	%offsetof(.Llo2144), %offsetof(.Llo2145),6
	.d2locreg	%offsetof(.Llo2146), %offsetof(.Llo2147),4
	.d2locreg	%offsetof(.Llo2148), %offsetof(.Llo2149),6
	.d2locreg	%offsetof(.Llo2150), %offsetof(.Llo2151),4
	.d2locreg	%offsetof(.Llo2152), %offsetof(.Llo2153),6
	.d2locreg	%offsetof(.Llo2154), %offsetof(.Llo2155),4
	.d2locreg	%offsetof(.Llo2156), %offsetof(.Llo2157),6
	.d2locreg	%offsetof(.Llo2158), %offsetof(.Llo2159),4
	.d2locend
.L4713:
	.d2locreg	%offsetof(.Llo2139), %offsetof(.Llo2141),5
	.d2locreg	%offsetof(.Llo2160), %offsetof(.Llo2157),30
	.d2locreg	%offsetof(.Llo2158), %offsetof(.Llo2161),5
	.d2locend
.L4715:
	.d2locreg	%offsetof(.Llo2162), %offsetof(.Llo2163),0
	.d2locend
.L4721:
	.d2locreg	%offsetof(.Llo2164), %offsetof(.Llo2165),4
	.d2locreg	%offsetof(.Llo2166), %offsetof(.Llo2167),31
	.d2locreg	%offsetof(.Llo2168), %offsetof(.Llo2169),31
	.d2locreg	%offsetof(.Llo2170), %offsetof(.Llo2171),31
	.d2locreg	%offsetof(.Llo2172), %offsetof(.Llo2173),4
	.d2locreg	%offsetof(.Llo2174), %offsetof(.Llo2175),4
	.d2locreg	%offsetof(.Llo2176), %offsetof(.Llo2177),4
	.d2locreg	%offsetof(.Llo2178), %offsetof(.Llo2179),4
	.d2locreg	%offsetof(.Llo2180), %offsetof(.Llo2181),4
	.d2locend
.L4722:
	.d2locreg	%offsetof(.Llo2164), %offsetof(.Llo2165),5
	.d2locreg	%offsetof(.Llo2166), %offsetof(.Llo2180),30
	.d2locreg	%offsetof(.Llo2182), %offsetof(.Llo2181),5
	.d2locend
.L4724:
	.d2locreg	%offsetof(.Llo2183), %offsetof(.Llo2184),3
	.d2locreg	%offsetof(.Llo2185), %offsetof(.Llo2186),3
	.d2locreg	%offsetof(.Llo2187), %offsetof(.Llo2188),3
	.d2locreg	%offsetof(.Llo2189), %offsetof(.Llo2190),3
	.d2locend
.L4726:
	.d2locreg	%offsetof(.Llo2191), %offsetof(.Llo2192),0
	.d2locreg	%offsetof(.Llo2165), %offsetof(.Llo2186),29
	.d2locreg	%offsetof(.Llo2170), %offsetof(.Llo2171),29
	.d2locend
.L4730:
	.d2locreg	%offsetof(.Llo2193), %offsetof(.Llo2194),0
	.d2locreg	%offsetof(.Llo2195), %offsetof(.Llo2196),29
	.d2locreg	%offsetof(.Llo2192), %offsetof(.Llo2165),0
	.d2locreg	%offsetof(.Llo2197), %offsetof(.Llo2198),0
	.d2locreg	%offsetof(.Llo2199), %offsetof(.Llo2200),3
	.d2locreg	%offsetof(.Llo2201), %offsetof(.Llo2202),0
	.d2locreg	%offsetof(.Llo2203), %offsetof(.Llo2204),3
	.d2locreg	%offsetof(.Llo2205), %offsetof(.Llo2206),3
	.d2locreg	%offsetof(.Llo2207), %offsetof(.Llo2208),0
	.d2locreg	%offsetof(.Llo2209), %offsetof(.Llo2210),0
	.d2locreg	%offsetof(.Llo2211), %offsetof(.Llo2212),3
	.d2locreg	%offsetof(.Llo2213), %offsetof(.Llo2214),3
	.d2locreg	%offsetof(.Llo2215), %offsetof(.Llo2216),0
	.d2locreg	%offsetof(.Llo2217), %offsetof(.Llo2218),0
	.d2locreg	%offsetof(.Llo2219), %offsetof(.Llo2220),0
	.d2locreg	%offsetof(.Llo2221), %offsetof(.Llo2222),0
	.d2locreg	%offsetof(.Llo2223), %offsetof(.Llo2224),0
	.d2locreg	%offsetof(.Llo2225), %offsetof(.Llo2226),0
	.d2locreg	%offsetof(.Llo2227), %offsetof(.Llo2228),0
	.d2locreg	%offsetof(.Llo2229), %offsetof(.Llo2230),0
	.d2locreg	%offsetof(.Llo2231), %offsetof(.Llo2232),0
	.d2locreg	%offsetof(.Llo2233), %offsetof(.Llo2234),0
	.d2locreg	%offsetof(.Llo2235), %offsetof(.Llo2236),0
	.d2locreg	%offsetof(.Llo2237), %offsetof(.Llo2186),0
	.d2locreg	%offsetof(.Llo2238), %offsetof(.Llo2188),0
	.d2locreg	%offsetof(.Llo2239), %offsetof(.Llo2240),0
	.d2locreg	%offsetof(.Llo2241), %offsetof(.Llo2242),3
	.d2locreg	%offsetof(.Llo2243), %offsetof(.Llo2244),0
	.d2locreg	%offsetof(.Llo2245), %offsetof(.Llo2246),3
	.d2locreg	%offsetof(.Llo2247), %offsetof(.Llo2248),3
	.d2locreg	%offsetof(.Llo2249), %offsetof(.Llo2250),0
	.d2locreg	%offsetof(.Llo2251), %offsetof(.Llo2252),3
	.d2locreg	%offsetof(.Llo2253), %offsetof(.Llo2254),3
	.d2locreg	%offsetof(.Llo2255), %offsetof(.Llo2167),0
	.d2locreg	%offsetof(.Llo2256), %offsetof(.Llo2257),0
	.d2locreg	%offsetof(.Llo2258), %offsetof(.Llo2168),0
	.d2locreg	%offsetof(.Llo2259), %offsetof(.Llo2260),3
	.d2locreg	%offsetof(.Llo2261), %offsetof(.Llo2262),3
	.d2locreg	%offsetof(.Llo2263), %offsetof(.Llo2264),0
	.d2locreg	%offsetof(.Llo2265), %offsetof(.Llo2266),3
	.d2locreg	%offsetof(.Llo2267), %offsetof(.Llo2268),0
	.d2locreg	%offsetof(.Llo2269), %offsetof(.Llo2270),0
	.d2locreg	%offsetof(.Llo2271), %offsetof(.Llo2272),3
	.d2locreg	%offsetof(.Llo2273), %offsetof(.Llo2274),3
	.d2locreg	%offsetof(.Llo2275), %offsetof(.Llo2276),3
	.d2locreg	%offsetof(.Llo2277), %offsetof(.Llo2278),0
	.d2locreg	%offsetof(.Llo2279), %offsetof(.Llo2280),0
	.d2locreg	%offsetof(.Llo2281), %offsetof(.Llo2282),0
	.d2locreg	%offsetof(.Llo2283), %offsetof(.Llo2284),0
	.d2locreg	%offsetof(.Llo2285), %offsetof(.Llo2286),0
	.d2locreg	%offsetof(.Llo2287), %offsetof(.Llo2288),3
	.d2locreg	%offsetof(.Llo2289), %offsetof(.Llo2169),0
	.d2locreg	%offsetof(.Llo2290), %offsetof(.Llo2291),0
	.d2locreg	%offsetof(.Llo2292), %offsetof(.Llo2293),3
	.d2locreg	%offsetof(.Llo2294), %offsetof(.Llo2295),3
	.d2locreg	%offsetof(.Llo2296), %offsetof(.Llo2171),3
	.d2locreg	%offsetof(.Llo2172), %offsetof(.Llo2297),3
	.d2locreg	%offsetof(.Llo2298), %offsetof(.Llo2299),3
	.d2locreg	%offsetof(.Llo2300), %offsetof(.Llo2301),3
	.d2locreg	%offsetof(.Llo2302), %offsetof(.Llo2176),0
	.d2locreg	%offsetof(.Llo2303), %offsetof(.Llo2304),3
	.d2locreg	%offsetof(.Llo2305), %offsetof(.Llo2306),3
	.d2locreg	%offsetof(.Llo2307), %offsetof(.Llo2308),3
	.d2locreg	%offsetof(.Llo2309), %offsetof(.Llo2310),0
	.d2locreg	%offsetof(.Llo2311), %offsetof(.Llo2312),0
	.d2locreg	%offsetof(.Llo2313), %offsetof(.Llo2314),0
	.d2locreg	%offsetof(.Llo2315), %offsetof(.Llo2316),0
	.d2locreg	%offsetof(.Llo2317), %offsetof(.Llo2318),0
	.d2locreg	%offsetof(.Llo2319), %offsetof(.Llo2320),0
	.d2locreg	%offsetof(.Llo2321), %offsetof(.Llo2322),3
	.d2locreg	%offsetof(.Llo2323), %offsetof(.Llo2324),3
	.d2locreg	%offsetof(.Llo2325), %offsetof(.Llo2326),0
	.d2locreg	%offsetof(.Llo2327), %offsetof(.Llo2328),4
	.d2locreg	%offsetof(.Llo2329), %offsetof(.Llo2330),3
	.d2locreg	%offsetof(.Llo2331), %offsetof(.Llo2332),3
	.d2locreg	%offsetof(.Llo2333), %offsetof(.Llo2334),0
	.d2locreg	%offsetof(.Llo2335), %offsetof(.Llo2336),4
	.d2locreg	%offsetof(.Llo2337), %offsetof(.Llo2338),0
	.d2locreg	%offsetof(.Llo2339), %offsetof(.Llo2340),3
	.d2locreg	%offsetof(.Llo2181), %offsetof(.Llo2341),3
	.d2locend
.L4733:
	.d2locreg	%offsetof(.Llo2342), %offsetof(.Llo2186),27
	.d2locreg	%offsetof(.Llo2170), %offsetof(.Llo2171),27
	.d2locend
.L4739:
	.d2locreg	%offsetof(.Llo2343), %offsetof(.Llo2178),3
	.d2locend
.L4749:
	.d2locreg	%offsetof(.Llo2344), %offsetof(.Llo2345),3
	.d2locreg	%offsetof(.Llo2346), %offsetof(.Llo2347),31
	.d2locend
.L4750:
	.d2locreg	%offsetof(.Llo2344), %offsetof(.Llo2348),4
	.d2locreg	%offsetof(.Llo2349), %offsetof(.Llo2350),0
	.d2locreg	%offsetof(.Llo2351), %offsetof(.Llo2352),0
	.d2locreg	%offsetof(.Llo2353), %offsetof(.Llo2354),0
	.d2locreg	%offsetof(.Llo2355), %offsetof(.Llo2356),4
	.d2locend
.L4751:
	.d2locreg	%offsetof(.Llo2344), %offsetof(.Llo2357),5
	.d2locreg	%offsetof(.Llo2358), %offsetof(.Llo2359),30
	.d2locend
.L4753:
	.d2locreg	%offsetof(.Llo2357), %offsetof(.Llo2358),5
	.d2locreg	%offsetof(.Llo2360), %offsetof(.Llo2361),3
	.d2locreg	%offsetof(.Llo2349), %offsetof(.Llo2362),5
	.d2locreg	%offsetof(.Llo2350), %offsetof(.Llo2363),3
	.d2locreg	%offsetof(.Llo2351), %offsetof(.Llo2364),5
	.d2locreg	%offsetof(.Llo2354), %offsetof(.Llo2365),3
	.d2locreg	%offsetof(.Llo2366), %offsetof(.Llo2367),5
	.d2locend
.L4760:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2369),3
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2371),31
	.d2locend
.L4761:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2372),4
	.d2locreg	%offsetof(.Llo2373), %offsetof(.Llo2374),4
	.d2locend
.L4762:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2369),5
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2371),30
	.d2locend
.L4763:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2369),6
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2371),29
	.d2locend
.L4766:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2369),7
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2375),28
	.d2locend
.L4767:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2369),8
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2371),27
	.d2locend
.L4769:
	.d2locreg	%offsetof(.Llo2376), %offsetof(.Llo2377),6
	.d2locend
.L4771:
	.d2locreg	%offsetof(.Llo2368), %offsetof(.Llo2371),23
	.d2locend
.L4776:
	.d2locreg	%offsetof(.Llo2378), %offsetof(.Llo2371),7
	.d2locend
.L4778:
	.d2locreg	%offsetof(.Llo2379), %offsetof(.Llo2380),26
	.d2locend
.L4780:
	.d2locreg	%offsetof(.Llo2381), %offsetof(.Llo2369),0
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2382),3
	.d2locreg	%offsetof(.Llo2383), %offsetof(.Llo2371),25
	.d2locend
.L4782:
	.d2locreg	%offsetof(.Llo2370), %offsetof(.Llo2384),0
	.d2locreg	%offsetof(.Llo2385), %offsetof(.Llo2372),3
	.d2locreg	%offsetof(.Llo2386), %offsetof(.Llo2371),24
	.d2locreg	%offsetof(.Llo2387), %offsetof(.Llo2375),0
	.d2locend
.L4788:
	.d2locreg	%offsetof(.Llo2388), %offsetof(.Llo2389),3
	.d2locreg	%offsetof(.Llo2390), %offsetof(.Llo2391),0
	.d2locreg	%offsetof(.Llo2392), %offsetof(.Llo2393),0
	.d2locreg	%offsetof(.Llo2394), %offsetof(.Llo2395),0
	.d2locreg	%offsetof(.Llo2396), %offsetof(.Llo2397),0
	.d2locreg	%offsetof(.Llo2398), %offsetof(.Llo2399),0
	.d2locreg	%offsetof(.Llo2400), %offsetof(.Llo2401),0
	.d2locreg	%offsetof(.Llo2402), %offsetof(.Llo2403),0
	.d2locreg	%offsetof(.Llo2404), %offsetof(.Llo2405),0
	.d2locreg	%offsetof(.Llo2406), %offsetof(.Llo2407),0
	.d2locreg	%offsetof(.Llo2408), %offsetof(.Llo2409),0
	.d2locreg	%offsetof(.Llo2410), %offsetof(.Llo2411),0
	.d2locreg	%offsetof(.Llo2412), %offsetof(.Llo2413),0
	.d2locreg	%offsetof(.Llo2414), %offsetof(.Llo2415),0
	.d2locreg	%offsetof(.Llo2416), %offsetof(.Llo2417),0
	.d2locreg	%offsetof(.Llo2418), %offsetof(.Llo2419),0
	.d2locreg	%offsetof(.Llo2420), %offsetof(.Llo2421),0
	.d2locreg	%offsetof(.Llo2422), %offsetof(.Llo2423),0
	.d2locreg	%offsetof(.Llo2424), %offsetof(.Llo2425),0
	.d2locreg	%offsetof(.Llo2426), %offsetof(.Llo2427),4
	.d2locreg	%offsetof(.Llo2428), %offsetof(.Llo2429),4
	.d2locreg	%offsetof(.Llo2430), %offsetof(.Llo2431),0
	.d2locreg	%offsetof(.Llo2432), %offsetof(.Llo2433),4
	.d2locreg	%offsetof(.Llo2434), %offsetof(.Llo2435),0
	.d2locreg	%offsetof(.Llo2436), %offsetof(.Llo2437),4
	.d2locreg	%offsetof(.Llo2438), %offsetof(.Llo2439),0
	.d2locreg	%offsetof(.Llo2440), %offsetof(.Llo2441),0
	.d2locreg	%offsetof(.Llo2442), %offsetof(.Llo2443),0
	.d2locreg	%offsetof(.Llo2444), %offsetof(.Llo2445),0
	.d2locreg	%offsetof(.Llo2446), %offsetof(.Llo2447),0
	.d2locreg	%offsetof(.Llo2448), %offsetof(.Llo2449),0
	.d2locreg	%offsetof(.Llo2450), %offsetof(.Llo2451),0
	.d2locreg	%offsetof(.Llo2452), %offsetof(.Llo2453),0
	.d2locreg	%offsetof(.Llo2454), %offsetof(.Llo2455),0
	.d2locreg	%offsetof(.Llo2456), %offsetof(.Llo2457),0
	.d2locreg	%offsetof(.Llo2458), %offsetof(.Llo2459),0
	.d2locreg	%offsetof(.Llo2460), %offsetof(.Llo2461),0
	.d2locreg	%offsetof(.Llo2462), %offsetof(.Llo2463),0
	.d2locreg	%offsetof(.Llo2464), %offsetof(.Llo2465),4
	.d2locreg	%offsetof(.Llo2466), %offsetof(.Llo2467),4
	.d2locend
.L4789:
	.d2locreg	%offsetof(.Llo2388), %offsetof(.Llo2468),4
	.d2locreg	%offsetof(.Llo2390), %offsetof(.Llo2469),31
	.d2locend
.L4790:
	.d2locreg	%offsetof(.Llo2388), %offsetof(.Llo2390),5
	.d2locreg	%offsetof(.Llo2470), %offsetof(.Llo2469),30
	.d2locreg	%offsetof(.Llo2471), %offsetof(.Llo2472),5
	.d2locend
.L4792:
	.d2locreg	%offsetof(.Llo2473), %offsetof(.Llo2390),4
	.d2locreg	%offsetof(.Llo2470), %offsetof(.Llo2465),29
	.d2locend
.L4794:
	.d2locreg	%offsetof(.Llo2474), %offsetof(.Llo2399),28
	.d2locreg	%offsetof(.Llo2475), %offsetof(.Llo2476),28
	.d2locend
.L4809:
	.d2locreg	%offsetof(.Llo2477), %offsetof(.Llo2478),27
	.d2locend
.L4811:
	.d2locreg	%offsetof(.Llo2479), %offsetof(.Llo2480),3
	.d2locreg	%offsetof(.Llo2481), %offsetof(.Llo2419),3
	.d2locreg	%offsetof(.Llo2482), %offsetof(.Llo2423),3
	.d2locreg	%offsetof(.Llo2483), %offsetof(.Llo2484),3
	.d2locreg	%offsetof(.Llo2485), %offsetof(.Llo2486),3
	.d2locreg	%offsetof(.Llo2487), %offsetof(.Llo2488),3
	.d2locreg	%offsetof(.Llo2489), %offsetof(.Llo2478),3
	.d2locreg	%offsetof(.Llo2490), %offsetof(.Llo2455),3
	.d2locreg	%offsetof(.Llo2491), %offsetof(.Llo2492),3
	.d2locreg	%offsetof(.Llo2493), %offsetof(.Llo2461),3
	.d2locreg	%offsetof(.Llo2494), %offsetof(.Llo2465),3
	.d2locreg	%offsetof(.Llo2495), %offsetof(.Llo2496),3
	.d2locreg	%offsetof(.Llo2472), %offsetof(.Llo2497),3
	.d2locend
.L4817:
	.d2locreg	%offsetof(.Llo2498), %offsetof(.Llo2499),0
	.d2locreg	%offsetof(.Llo2427), %offsetof(.Llo2500),4
	.d2locreg	%offsetof(.Llo2501), %offsetof(.Llo2502),4
	.d2locreg	%offsetof(.Llo2503), %offsetof(.Llo2504),0
	.d2locend
.L4823:
	.d2locreg	%offsetof(.Llo2505), %offsetof(.Llo2506),3
	.d2locreg	%offsetof(.Llo2507), %offsetof(.Llo2441),3
	.d2locreg	%offsetof(.Llo2508), %offsetof(.Llo2509),3
	.d2locreg	%offsetof(.Llo2510), %offsetof(.Llo2511),3
	.d2locreg	%offsetof(.Llo2512), %offsetof(.Llo2513),3
	.d2locreg	%offsetof(.Llo2514), %offsetof(.Llo2515),3
	.d2locreg	%offsetof(.Llo2516), %offsetof(.Llo2517),3
	.d2locreg	%offsetof(.Llo2518), %offsetof(.Llo2519),3
	.d2locreg	%offsetof(.Llo2520), %offsetof(.Llo2521),3
	.d2locreg	%offsetof(.Llo2522), %offsetof(.Llo2523),3
	.d2locend
.L4833:
	.d2locreg	%offsetof(.Llo2524), %offsetof(.Llo2525),3
	.d2locreg	%offsetof(.Llo2526), %offsetof(.Llo2527),6
	.d2locreg	%offsetof(.Llo2528), %offsetof(.Llo2529),6
	.d2locreg	%offsetof(.Llo2530), %offsetof(.Llo2531),6
	.d2locreg	%offsetof(.Llo2532), %offsetof(.Llo2533),3
	.d2locreg	%offsetof(.Llo2534), %offsetof(.Llo2535),6
	.d2locreg	%offsetof(.Llo2536), %offsetof(.Llo2537),3
	.d2locend
.L4836:
	.d2locreg	%offsetof(.Llo2524), %offsetof(.Llo2538),4
	.d2locreg	%offsetof(.Llo2528), %offsetof(.Llo2539),4
	.d2locreg	%offsetof(.Llo2540), %offsetof(.Llo2531),4
	.d2locend
.L4838:
	.d2locreg	%offsetof(.Llo2541), %offsetof(.Llo2538),0
	.d2locreg	%offsetof(.Llo2528), %offsetof(.Llo2539),0
	.d2locreg	%offsetof(.Llo2542), %offsetof(.Llo2540),3
	.d2locreg	%offsetof(.Llo2543), %offsetof(.Llo2531),0
	.d2locreg	%offsetof(.Llo2544), %offsetof(.Llo2545),3
	.d2locreg	%offsetof(.Llo2533), %offsetof(.Llo2534),3
	.d2locreg	%offsetof(.Llo2546), %offsetof(.Llo2535),3
	.d2locreg	%offsetof(.Llo2547), %offsetof(.Llo2536),3
	.d2locreg	%offsetof(.Llo2537), %offsetof(.Llo2548),3
	.d2locend
.L4845:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2550),3
	.d2locreg	%offsetof(.Llo2551), %offsetof(.Llo2552),3
	.d2locreg	%offsetof(.Llo2553), %offsetof(.Llo2554),3
	.d2locreg	%offsetof(.Llo2555), %offsetof(.Llo2556),3
	.d2locreg	%offsetof(.Llo2557), %offsetof(.Llo2558),3
	.d2locreg	%offsetof(.Llo2559), %offsetof(.Llo2560),3
	.d2locreg	%offsetof(.Llo2561), %offsetof(.Llo2562),3
	.d2locreg	%offsetof(.Llo2563), %offsetof(.Llo2564),3
	.d2locreg	%offsetof(.Llo2565), %offsetof(.Llo2566),3
	.d2locreg	%offsetof(.Llo2567), %offsetof(.Llo2568),3
	.d2locreg	%offsetof(.Llo2569), %offsetof(.Llo2570),3
	.d2locreg	%offsetof(.Llo2571), %offsetof(.Llo2572),3
	.d2locend
.L4846:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2573),4
	.d2locreg	%offsetof(.Llo2574), %offsetof(.Llo2575),31
	.d2locreg	%offsetof(.Llo2576), %offsetof(.Llo2577),3
	.d2locreg	%offsetof(.Llo2578), %offsetof(.Llo2579),3
	.d2locreg	%offsetof(.Llo2580), %offsetof(.Llo2570),31
	.d2locend
.L4847:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2574),5
	.d2locreg	%offsetof(.Llo2581), %offsetof(.Llo2582),30
	.d2locreg	%offsetof(.Llo2583), %offsetof(.Llo2584),5
	.d2locend
.L4848:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2574),6
	.d2locreg	%offsetof(.Llo2581), %offsetof(.Llo2585),29
	.d2locreg	%offsetof(.Llo2586), %offsetof(.Llo2570),29
	.d2locreg	%offsetof(.Llo2587), %offsetof(.Llo2588),6
	.d2locreg	%offsetof(.Llo2583), %offsetof(.Llo2584),6
	.d2locend
.L4857:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2574),7
	.d2locreg	%offsetof(.Llo2581), %offsetof(.Llo2575),28
	.d2locreg	%offsetof(.Llo2580), %offsetof(.Llo2570),28
	.d2locreg	%offsetof(.Llo2587), %offsetof(.Llo2589),7
	.d2locreg	%offsetof(.Llo2583), %offsetof(.Llo2584),7
	.d2locend
.L4858:
	.d2locreg	%offsetof(.Llo2549), %offsetof(.Llo2574),8
	.d2locreg	%offsetof(.Llo2581), %offsetof(.Llo2583),27
	.d2locreg	%offsetof(.Llo2590), %offsetof(.Llo2584),8
	.d2locend
.L4861:
	.d2locreg	%offsetof(.Llo2591), %offsetof(.Llo2592),31
	.d2locreg	%offsetof(.Llo2593), %offsetof(.Llo2594),3
	.d2locreg	%offsetof(.Llo2595), %offsetof(.Llo2596),3
	.d2locend
.L4863:
	.d2locreg	%offsetof(.Llo2597), %offsetof(.Llo2598),0
	.d2locreg	%offsetof(.Llo2599), %offsetof(.Llo2574),0
	.d2locreg	%offsetof(.Llo2581), %offsetof(.Llo2550),0
	.d2locreg	%offsetof(.Llo2600), %offsetof(.Llo2601),3
	.d2locreg	%offsetof(.Llo2602), %offsetof(.Llo2554),0
	.d2locreg	%offsetof(.Llo2603), %offsetof(.Llo2604),0
	.d2locreg	%offsetof(.Llo2605), %offsetof(.Llo2558),0
	.d2locreg	%offsetof(.Llo2606), %offsetof(.Llo2607),0
	.d2locreg	%offsetof(.Llo2608), %offsetof(.Llo2609),0
	.d2locreg	%offsetof(.Llo2610), %offsetof(.Llo2611),0
	.d2locreg	%offsetof(.Llo2612), %offsetof(.Llo2613),0
	.d2locreg	%offsetof(.Llo2614), %offsetof(.Llo2615),0
	.d2locreg	%offsetof(.Llo2616), %offsetof(.Llo2617),0
	.d2locreg	%offsetof(.Llo2618), %offsetof(.Llo2619),0
	.d2locreg	%offsetof(.Llo2620), %offsetof(.Llo2560),0
	.d2locreg	%offsetof(.Llo2621), %offsetof(.Llo2622),0
	.d2locreg	%offsetof(.Llo2623), %offsetof(.Llo2562),0
	.d2locreg	%offsetof(.Llo2624), %offsetof(.Llo2625),0
	.d2locreg	%offsetof(.Llo2626), %offsetof(.Llo2564),0
	.d2locreg	%offsetof(.Llo2627), %offsetof(.Llo2566),0
	.d2locreg	%offsetof(.Llo2628), %offsetof(.Llo2629),0
	.d2locreg	%offsetof(.Llo2630), %offsetof(.Llo2631),3
	.d2locreg	%offsetof(.Llo2632), %offsetof(.Llo2633),0
	.d2locreg	%offsetof(.Llo2634), %offsetof(.Llo2635),3
	.d2locreg	%offsetof(.Llo2636), %offsetof(.Llo2637),0
	.d2locreg	%offsetof(.Llo2638), %offsetof(.Llo2639),0
	.d2locreg	%offsetof(.Llo2640), %offsetof(.Llo2585),0
	.d2locreg	%offsetof(.Llo2641), %offsetof(.Llo2642),0
	.d2locreg	%offsetof(.Llo2643), %offsetof(.Llo2586),0
	.d2locreg	%offsetof(.Llo2644), %offsetof(.Llo2595),3
	.d2locreg	%offsetof(.Llo2645), %offsetof(.Llo2570),0
	.d2locreg	%offsetof(.Llo2646), %offsetof(.Llo2583),0
	.d2locreg	%offsetof(.Llo2584), %offsetof(.Llo2647),3
	.d2locend
.L4869:
	.d2locreg	%offsetof(.Llo2648), %offsetof(.Llo2649),3
	.d2locend
.L4870:
	.d2locreg	%offsetof(.Llo2648), %offsetof(.Llo2649),4
	.d2locend
.L4871:
	.d2locreg	%offsetof(.Llo2648), %offsetof(.Llo2650),5
	.d2locreg	%offsetof(.Llo2651), %offsetof(.Llo2652),8
	.d2locend
.L4877:
	.d2locreg	%offsetof(.Llo2653), %offsetof(.Llo2654),3
	.d2locend
.L4878:
	.d2locreg	%offsetof(.Llo2653), %offsetof(.Llo2654),4
	.d2locend
.L4879:
	.d2locreg	%offsetof(.Llo2653), %offsetof(.Llo2655),5
	.d2locreg	%offsetof(.Llo2656), %offsetof(.Llo2657),8
	.d2locend
.L4885:
	.d2locreg	%offsetof(.Llo2658), %offsetof(.Llo2659),3
	.d2locreg	%offsetof(.Llo2660), %offsetof(.Llo2661),31
	.d2locend
.L4886:
	.d2locreg	%offsetof(.Llo2658), %offsetof(.Llo2662),4
	.d2locreg	%offsetof(.Llo2663), %offsetof(.Llo2664),30
	.d2locend
.L4887:
	.d2locreg	%offsetof(.Llo2658), %offsetof(.Llo2662),5
	.d2locreg	%offsetof(.Llo2663), %offsetof(.Llo2665),29
	.d2locend
.L4889:
	.d2locreg	%offsetof(.Llo2666), %offsetof(.Llo2664),5
	.d2locreg	%offsetof(.Llo2667), %offsetof(.Llo2668),3
	.d2locreg	%offsetof(.Llo2669), %offsetof(.Llo2670),3
	.d2locend
.L4891:
	.d2locreg	%offsetof(.Llo2671), %offsetof(.Llo2672),27
	.d2locend
.L4894:
	.d2locreg	%offsetof(.Llo2662), %offsetof(.Llo2673),3
	.d2locreg	%offsetof(.Llo2663), %offsetof(.Llo2674),28
	.d2locend
.L4900:
	.d2locreg	%offsetof(.Llo2675), %offsetof(.Llo2676),3
	.d2locend
.L4906:
	.d2locreg	%offsetof(.Llo2672), %offsetof(.Llo2677),3
	.d2locend
.L4912:
	.d2locreg	%offsetof(.Llo2678), %offsetof(.Llo2679),3
	.d2locreg	%offsetof(.Llo2680), %offsetof(.Llo2681),3
	.d2locreg	%offsetof(.Llo2682), %offsetof(.Llo2683),3
	.d2locreg	%offsetof(.Llo2684), %offsetof(.Llo2685),3
	.d2locreg	%offsetof(.Llo2686), %offsetof(.Llo2687),0
	.d2locend
.L4913:
	.d2locreg	%offsetof(.Llo2678), %offsetof(.Llo2688),4
	.d2locreg	%offsetof(.Llo2689), %offsetof(.Llo2687),31
	.d2locend
.L4915:
	.d2locreg	%offsetof(.Llo2690), %offsetof(.Llo2681),5
	.d2locreg	%offsetof(.Llo2691), %offsetof(.Llo2692),5
	.d2locend
.L4922:
	.d2locreg	%offsetof(.Llo2693), %offsetof(.Llo2684),3
	.d2locend
.L4928:
	.d2locreg	%offsetof(.Llo2694), %offsetof(.Llo2695),3
	.d2locreg	%offsetof(.Llo2696), %offsetof(.Llo2697),31
	.d2locreg	%offsetof(.Llo2698), %offsetof(.Llo2699),3
	.d2locreg	%offsetof(.Llo2700), %offsetof(.Llo2701),0
	.d2locreg	%offsetof(.Llo2702), %offsetof(.Llo2703),0
	.d2locreg	%offsetof(.Llo2704), %offsetof(.Llo2705),0
	.d2locreg	%offsetof(.Llo2706), %offsetof(.Llo2707),3
	.d2locend
.L4929:
	.d2locreg	%offsetof(.Llo2694), %offsetof(.Llo2695),4
	.d2locreg	%offsetof(.Llo2696), %offsetof(.Llo2705),30
	.d2locreg	%offsetof(.Llo2708), %offsetof(.Llo2706),4
	.d2locend
.L4930:
	.d2locreg	%offsetof(.Llo2694), %offsetof(.Llo2695),5
	.d2locreg	%offsetof(.Llo2696), %offsetof(.Llo2705),29
	.d2locreg	%offsetof(.Llo2708), %offsetof(.Llo2706),5
	.d2locend
.L4936:
	.d2locreg	%offsetof(.Llo2709), %offsetof(.Llo2710),3
	.d2locend
.L4946:
	.d2locreg	%offsetof(.Llo2711), %offsetof(.Llo2712),3
	.d2locreg	%offsetof(.Llo2713), %offsetof(.Llo2714),31
	.d2locreg	%offsetof(.Llo2715), %offsetof(.Llo2716),3
	.d2locreg	%offsetof(.Llo2717), %offsetof(.Llo2718),0
	.d2locreg	%offsetof(.Llo2719), %offsetof(.Llo2720),0
	.d2locreg	%offsetof(.Llo2721), %offsetof(.Llo2722),0
	.d2locreg	%offsetof(.Llo2723), %offsetof(.Llo2724),3
	.d2locend
.L4947:
	.d2locreg	%offsetof(.Llo2711), %offsetof(.Llo2712),4
	.d2locreg	%offsetof(.Llo2713), %offsetof(.Llo2722),30
	.d2locreg	%offsetof(.Llo2725), %offsetof(.Llo2723),4
	.d2locend
.L4948:
	.d2locreg	%offsetof(.Llo2711), %offsetof(.Llo2712),5
	.d2locreg	%offsetof(.Llo2713), %offsetof(.Llo2722),29
	.d2locreg	%offsetof(.Llo2725), %offsetof(.Llo2723),5
	.d2locend
.L4954:
	.d2locreg	%offsetof(.Llo2726), %offsetof(.Llo2727),3
	.d2locend
.L4960:
	.d2locreg	%offsetof(.Llo2728), %offsetof(.Llo2729),5
	.d2locreg	%offsetof(.Llo2730), %offsetof(.Llo2731),5
	.d2locend
.L4962:
	.d2locreg	%offsetof(.Llo2732), %offsetof(.Llo2733),4
	.d2locreg	%offsetof(.Llo2729), %offsetof(.Llo2734),4
	.d2locend
.L4964:
	.d2locreg	%offsetof(.Llo2735), %offsetof(.Llo2736),3
	.d2locend
.L4970:
	.d2locreg	%offsetof(.Llo2737), %offsetof(.Llo2738),3
	.d2locreg	%offsetof(.Llo2739), %offsetof(.Llo2740),31
	.d2locreg	%offsetof(.Llo2741), %offsetof(.Llo2742),31
	.d2locreg	%offsetof(.Llo2743), %offsetof(.Llo2744),31
	.d2locend
.L4971:
	.d2locreg	%offsetof(.Llo2737), %offsetof(.Llo2738),4
	.d2locreg	%offsetof(.Llo2739), %offsetof(.Llo2745),28
	.d2locreg	%offsetof(.Llo2743), %offsetof(.Llo2744),28
	.d2locend
.L4972:
	.d2locreg	%offsetof(.Llo2737), %offsetof(.Llo2738),6
	.d2locreg	%offsetof(.Llo2739), %offsetof(.Llo2740),30
	.d2locreg	%offsetof(.Llo2746), %offsetof(.Llo2742),30
	.d2locreg	%offsetof(.Llo2743), %offsetof(.Llo2744),30
	.d2locreg	%offsetof(.Llo2747), %offsetof(.Llo2748),6
	.d2locend
.L4973:
	.d2locreg	%offsetof(.Llo2737), %offsetof(.Llo2738),7
	.d2locreg	%offsetof(.Llo2739), %offsetof(.Llo2742),29
	.d2locreg	%offsetof(.Llo2743), %offsetof(.Llo2744),29
	.d2locreg	%offsetof(.Llo2747), %offsetof(.Llo2748),7
	.d2locend
.L4975:
	.d2locreg	%offsetof(.Llo2738), %offsetof(.Llo2749),3
	.d2locreg	%offsetof(.Llo2750), %offsetof(.Llo2751),3
	.d2locreg	%offsetof(.Llo2752), %offsetof(.Llo2753),3
	.d2locreg	%offsetof(.Llo2754), %offsetof(.Llo2755),3
	.d2locreg	%offsetof(.Llo2756), %offsetof(.Llo2757),3
	.d2locreg	%offsetof(.Llo2758), %offsetof(.Llo2759),3
	.d2locreg	%offsetof(.Llo2760), %offsetof(.Llo2761),3
	.d2locreg	%offsetof(.Llo2762), %offsetof(.Llo2763),3
	.d2locreg	%offsetof(.Llo2764), %offsetof(.Llo2765),3
	.d2locreg	%offsetof(.Llo2766), %offsetof(.Llo2767),3
	.d2locreg	%offsetof(.Llo2768), %offsetof(.Llo2769),3
	.d2locreg	%offsetof(.Llo2770), %offsetof(.Llo2771),3
	.d2locreg	%offsetof(.Llo2772), %offsetof(.Llo2773),3
	.d2locreg	%offsetof(.Llo2774), %offsetof(.Llo2775),3
	.d2locreg	%offsetof(.Llo2776), %offsetof(.Llo2777),3
	.d2locreg	%offsetof(.Llo2778), %offsetof(.Llo2779),28
	.d2locreg	%offsetof(.Llo2780), %offsetof(.Llo2742),3
	.d2locreg	%offsetof(.Llo2781), %offsetof(.Llo2744),3
	.d2locend
.L4977:
	.d2locreg	%offsetof(.Llo2782), %offsetof(.Llo2783),27
	.d2locend
.L4979:
	.d2locreg	%offsetof(.Llo2784), %offsetof(.Llo2783),26
	.d2locend
.L4981:
	.d2locreg	%offsetof(.Llo2785), %offsetof(.Llo2779),25
	.d2locend
.L4983:
	.d2locreg	%offsetof(.Llo2786), %offsetof(.Llo2787),23
	.d2locreg	%offsetof(.Llo2788), %offsetof(.Llo2789),3
	.d2locreg	%offsetof(.Llo2790), %offsetof(.Llo2791),3
	.d2locreg	%offsetof(.Llo2792), %offsetof(.Llo2762),3
	.d2locreg	%offsetof(.Llo2763), %offsetof(.Llo2793),24
	.d2locreg	%offsetof(.Llo2794), %offsetof(.Llo2795),3
	.d2locreg	%offsetof(.Llo2796), %offsetof(.Llo2779),24
	.d2locreg	%offsetof(.Llo2743), %offsetof(.Llo2744),24
	.d2locend
.L4985:
	.d2locreg	%offsetof(.Llo2787), %offsetof(.Llo2779),23
	.d2locreg	%offsetof(.Llo2797), %offsetof(.Llo2743),0
	.d2locreg	%offsetof(.Llo2798), %offsetof(.Llo2744),23
	.d2locreg	%offsetof(.Llo2799), %offsetof(.Llo2747),0
	.d2locend
.L4991:
	.d2locreg	%offsetof(.Llo2800), %offsetof(.Llo2783),22
	.d2locend
.L4995:
	.d2locreg	%offsetof(.Llo2801), %offsetof(.Llo2802),3
	.d2locreg	%offsetof(.Llo2803), %offsetof(.Llo2804),3
	.d2locreg	%offsetof(.Llo2805), %offsetof(.Llo2806),3
	.d2locreg	%offsetof(.Llo2807), %offsetof(.Llo2741),3
	.d2locreg	%offsetof(.Llo2780), %offsetof(.Llo2743),3
	.d2locreg	%offsetof(.Llo2781), %offsetof(.Llo2808),3
	.d2locend
.L5001:
	.d2locreg	%offsetof(.Llo2809), %offsetof(.Llo2810),3
	.d2locreg	%offsetof(.Llo2811), %offsetof(.Llo2812),31
	.d2locreg	%offsetof(.Llo2813), %offsetof(.Llo2814),31
	.d2locreg	%offsetof(.Llo2815), %offsetof(.Llo2816),31
	.d2locreg	%offsetof(.Llo2817), %offsetof(.Llo2818),31
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),31
	.d2locend
.L5002:
	.d2locreg	%offsetof(.Llo2809), %offsetof(.Llo2821),4
	.d2locreg	%offsetof(.Llo2822), %offsetof(.Llo2823),30
	.d2locreg	%offsetof(.Llo2824), %offsetof(.Llo2825),30
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),30
	.d2locend
.L5003:
	.d2locreg	%offsetof(.Llo2809), %offsetof(.Llo2822),5
	.d2locreg	%offsetof(.Llo2826), %offsetof(.Llo2827),29
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),29
	.d2locreg	%offsetof(.Llo2828), %offsetof(.Llo2829),5
	.d2locend
.L5004:
	.d2locreg	%offsetof(.Llo2809), %offsetof(.Llo2822),6
	.d2locreg	%offsetof(.Llo2826), %offsetof(.Llo2816),28
	.d2locreg	%offsetof(.Llo2830), %offsetof(.Llo2818),28
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),28
	.d2locreg	%offsetof(.Llo2828), %offsetof(.Llo2829),6
	.d2locend
.L5005:
	.d2locreg	%offsetof(.Llo2809), %offsetof(.Llo2822),7
	.d2locreg	%offsetof(.Llo2826), %offsetof(.Llo2818),27
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),27
	.d2locreg	%offsetof(.Llo2828), %offsetof(.Llo2829),7
	.d2locend
.L5007:
	.d2locreg	%offsetof(.Llo2831), %offsetof(.Llo2812),4
	.d2locreg	%offsetof(.Llo2832), %offsetof(.Llo2833),4
	.d2locreg	%offsetof(.Llo2834), %offsetof(.Llo2835),4
	.d2locend
.L5009:
	.d2locreg	%offsetof(.Llo2836), %offsetof(.Llo2837),3
	.d2locreg	%offsetof(.Llo2838), %offsetof(.Llo2839),3
	.d2locreg	%offsetof(.Llo2840), %offsetof(.Llo2841),3
	.d2locreg	%offsetof(.Llo2842), %offsetof(.Llo2843),0
	.d2locreg	%offsetof(.Llo2823), %offsetof(.Llo2824),3
	.d2locreg	%offsetof(.Llo2844), %offsetof(.Llo2845),3
	.d2locreg	%offsetof(.Llo2846), %offsetof(.Llo2847),0
	.d2locreg	%offsetof(.Llo2825), %offsetof(.Llo2848),3
	.d2locreg	%offsetof(.Llo2849), %offsetof(.Llo2814),4
	.d2locreg	%offsetof(.Llo2850), %offsetof(.Llo2851),0
	.d2locreg	%offsetof(.Llo2815), %offsetof(.Llo2827),4
	.d2locreg	%offsetof(.Llo2830), %offsetof(.Llo2852),4
	.d2locreg	%offsetof(.Llo2853), %offsetof(.Llo2819),0
	.d2locreg	%offsetof(.Llo2854), %offsetof(.Llo2828),0
	.d2locend
.L5011:
	.d2locreg	%offsetof(.Llo2855), %offsetof(.Llo2823),26
	.d2locreg	%offsetof(.Llo2824), %offsetof(.Llo2844),26
	.d2locreg	%offsetof(.Llo2847), %offsetof(.Llo2825),26
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),26
	.d2locend
.L5013:
	.d2locreg	%offsetof(.Llo2856), %offsetof(.Llo2837),24
	.d2locreg	%offsetof(.Llo2857), %offsetof(.Llo2839),24
	.d2locreg	%offsetof(.Llo2858), %offsetof(.Llo2827),24
	.d2locreg	%offsetof(.Llo2819), %offsetof(.Llo2820),24
	.d2locend
.L5017:
	.d2locreg	%offsetof(.Llo2826), %offsetof(.Llo2811),31
	.d2locreg	%offsetof(.Llo2859), %offsetof(.Llo2813),31
	.d2locreg	%offsetof(.Llo2860), %offsetof(.Llo2815),31
	.d2locreg	%offsetof(.Llo2861), %offsetof(.Llo2817),31
	.d2locreg	%offsetof(.Llo2862), %offsetof(.Llo2819),3
	.d2locreg	%offsetof(.Llo2863), %offsetof(.Llo2828),3
	.d2locreg	%offsetof(.Llo2864), %offsetof(.Llo2865),31
	.d2locend
.L5023:
	.d2locreg	%offsetof(.Llo2866), %offsetof(.Llo2867),3
	.d2locreg	%offsetof(.Llo2868), %offsetof(.Llo2869),3
	.d2locreg	%offsetof(.Llo2870), %offsetof(.Llo2871),3
	.d2locend
.L5024:
	.d2locreg	%offsetof(.Llo2866), %offsetof(.Llo2871),4
	.d2locend
.L5025:
	.d2locreg	%offsetof(.Llo2866), %offsetof(.Llo2871),5
	.d2locend
.L5027:
	.d2locreg	%offsetof(.Llo2872), %offsetof(.Llo2868),3
	.d2locreg	%offsetof(.Llo2873), %offsetof(.Llo2870),3
	.d2locreg	%offsetof(.Llo2871), %offsetof(.Llo2874),3
	.d2locend
.L5033:
	.d2locreg	%offsetof(.Llo2875), %offsetof(.Llo2876),3
	.d2locreg	%offsetof(.Llo2877), %offsetof(.Llo2878),6
	.d2locend
.L5034:
	.d2locreg	%offsetof(.Llo2875), %offsetof(.Llo2879),4
	.d2locend
.L5035:
	.d2locreg	%offsetof(.Llo2875), %offsetof(.Llo2880),5
	.d2locend
.L5037:
	.d2locreg	%offsetof(.Llo2877), %offsetof(.Llo2881),3
	.d2locreg	%offsetof(.Llo2882), %offsetof(.Llo2883),3
	.d2locreg	%offsetof(.Llo2884), %offsetof(.Llo2885),3
	.d2locreg	%offsetof(.Llo2886), %offsetof(.Llo2887),3
	.d2locend
	.wrcm.doc
	.wrcm.elem
	.wrcm.nelem "code"
	.wrcm.nelem "functions"
	.wrcm.nelem "DidControlHelpFunc"
	.wrcm.nstrlist "calls", "Dcm_FreezeCurrentStateWrapper","Dcm_ResetToDefaultWrapper","Dcm_ReturnControlToECUWrapper","Dcm_ShortTermAdjustmentWrapper","HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_WriteDataByIdentifier"
	.wrcm.nstrlist "calls", "ChangeAsyncState","Dcm_ErrorCodeToStdReturnType","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported","DidWriteHelperFunction"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "DidWriteHelperFunction"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ChangeAsyncState"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DynamicallyDefineDataIdentifier"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","Dcm_IsLevelSupported","Dcm_NvMSetRamBlockStatus","DefineDDDidByIdentifier","DefineDDDidByMemoryAddress","ResetAllDDDiDsAndPeriodicDids"
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "DefineDDDidByMemoryAddress"
	.wrcm.nstrlist "calls", "GetMemoryRange","IsMemoryRangeAcessible","ParseMemoryParameter"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 80
	.wrcm.end
	.wrcm.nelem "ParseMemoryParameter"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "DefineDDDidByIdentifier"
	.wrcm.nstrlist "calls", "GetPowertrainPidLength","GetSourceDid","GetVehInfoLength"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 80
	.wrcm.end
	.wrcm.nelem "GetSourceDid"
	.wrcm.nstrlist "calls", "Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_DspConfirmPeriodicTxData"
	.wrcm.nstrlist "calls", "AllPeriodicDIDsSent","AllSentSamplesConfirmed","Dcm_DspResetPeriodicTransmission","ResetPeriodicStatusVariables","StartPeriodicTransmission"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_ReadDataByPeriodicIdentifier"
	.wrcm.nlist "calls"
	.wrcm.str "AllSentSamplesConfirmed"
	.wrcm.str "CountConfiguredPeriodicDids"
	.wrcm.str "Dcm_DslSetPeriodicTxConnection"
	.wrcm.str "Dcm_DspResetPeriodicTransmission"
	.wrcm.str "Dcm_ErrorCodeToStdReturnType"
	.wrcm.str "Dcm_GetSecurityLevel"
	.wrcm.str "Dcm_GetSesCtrlType"
	.wrcm.str "IsValidPeriodicDid"
	.wrcm.str "SchM_Enter_Dcm_EaTimers"
	.wrcm.str "SchM_Exit_Dcm_EaTimers"
	.wrcm.str "StartPeriodicTransmission"
	.wrcm.str "StopSomeDIDs"
	.wrcm.end
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "StartPeriodicTransmission"
	.wrcm.nstrlist "calls", "ResetPeriodicStatusVariables","SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "StopSomeDIDs"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "IsValidPeriodicDid"
	.wrcm.nstrlist "calls", "Dcm_IsLevelSupported","GetMemoryRange"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "CountConfiguredPeriodicDids"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_ReadScalingByIdentifier"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","HandleStdRetVal"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_ReadDataByIdentifier"
	.wrcm.nstrlist "calls", "Dcm_DsdStartResponse","Dcm_ErrorCodeToStdReturnType","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","GetCommonDidLength","ReadConfiguredDid","ReadConfiguredDidRange","ReadDynamicallyDefinedDid","ReadOBDDataAndInfoType"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadDynamicallyDefinedDid"
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","ReadOBDDataAndInfoType","ReadOneDDDidByDid","ReadOneDDDidByMemory"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "ReadOBDDataAndInfoType"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","IsObdRangeSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDidRange"
	.wrcm.nstrlist "calls", "ReadConfiguredDidRange_Buffer","ReadConfiguredDidRange_Data","ReadConfiguredDidRange_Init","ReadConfiguredDidRange_Length"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDidRange_Data"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDidRange_Buffer"
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDidRange_Length"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDidRange_Init"
	.wrcm.nstrlist "calls", "Dcm_IsCurrentModesAllowed"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadConfiguredDid"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_IsCurrentModesAllowed","Det_ReportError","HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetCommonDidLength"
	.wrcm.nstrlist "calls", "GetDddidLength","GetDidRangeLength","GetObdPidDidLength","GetObdVehInfoDidLength","GetStandardDidLength"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "GetDidRangeLength"
	.wrcm.nstrlist "calls", "CallReadDidDataLengthFunc","Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported","IsDidAvailableWithinRange"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "CallReadDidDataLengthFunc"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "IsDidAvailableWithinRange"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetStandardDidLength"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_IsLevelSupported","HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "HandleStdRetVal"
	.wrcm.nstrlist "calls", "Dcm_CheckAndPossiblyConvertErrorCode","Det_ReportError"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetDddidLength"
	.wrcm.nstrlist "calls", "GetDddidSourcesLength"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetDddidSourcesLength"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "GetObdPidDidLength"
	.wrcm.nstrlist "calls", "GetPowertrainPidLength","IsObdRangeSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetPowertrainPidLength"
	.wrcm.nstrlist "calls", "IsIdentifierSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetObdVehInfoDidLength"
	.wrcm.nstrlist "calls", "GetVehInfoLength","IsObdRangeSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "IsObdRangeSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "GetVehInfoLength"
	.wrcm.nstrlist "calls", "IsIdentifierSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "IsIdentifierSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "WriteSignalToBuf_08"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "WriteSignalToBuf_uint8N"
	.wrcm.nstrlist "calls", "Dcm_Memcpy"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "Dcm_ReadDTCInformation"
	.wrcm.nlist "calls"
	.wrcm.str "Dcm_ErrorCodeToStdReturnType"
	.wrcm.str "Det_ReportError"
	.wrcm.str "ReportDTCBySeverityMaskRecord"
	.wrcm.str "ReportDTCExtendedDataRecordByDTCNumber"
	.wrcm.str "ReportDTCFaultDetectionCounter"
	.wrcm.str "ReportDTCSnapshotIdentification"
	.wrcm.str "ReportDTCSnapshotRecordByDTCNumber"
	.wrcm.str "ReportDTCSnapshotRecordByRecordNumber"
	.wrcm.str "ReportDTCsByStatusMask"
	.wrcm.str "ReportDtcInformationByOccurrence"
	.wrcm.str "ReportNumberOfDTCsByStatusMask"
	.wrcm.str "ReportSeverityInformationOfDTC"
	.wrcm.end
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReportDtcInformationByOccurrence"
	.wrcm.nstrlist "calls", "Dem_DcmGetDTCByOccurrenceTime","Dem_DcmGetDTCStatusAvailabilityMask","Dem_DcmGetStatusOfDTC"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReportDTCBySeverityMaskRecord"
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmGetDTCStatusAvailabilityMask","Dem_DcmGetNumberOfFilteredDTC","Dem_DcmSetDTCFilter","GetSeverityType","HelpFncReportDTCBySeverityMaskRecord"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "HelpFncReportDTCBySeverityMaskRecord"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dem_DcmGetNextFilteredDTCAndSeverity"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReportDTCExtendedDataRecordByDTCNumber"
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmDisableDTCRecordUpdate","Dem_DcmEnableDTCRecordUpdate","Dem_DcmGetStatusOfDTC","GetDTCOriginReadDTCInformation","GetOneExtendedDataRecordByDtc","GetStartIndexOfEDR","GetTotalSizeOfExtendedDataRecordByDtc"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "GetTotalSizeOfExtendedDataRecordByDtc"
	.wrcm.nstrlist "calls", "Dem_DcmGetSizeOfExtendedDataRecordByDTC"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetOneExtendedDataRecordByDtc"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dem_DcmGetExtendedDataRecordByDTC","Dem_DcmGetSizeOfExtendedDataRecordByDTC"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "GetStartIndexOfEDR"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ReportDTCSnapshotRecordByRecordNumber"
	.wrcm.nstrlist "calls", "Dem_DcmGetOBDFreezeFrameData","Dem_DcmGetStatusOfDTC","GetDTCOriginReadDTCInformation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReportDTCSnapshotRecordByDTCNumber"
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmDisableDTCRecordUpdate","Dem_DcmEnableDTCRecordUpdate","Dem_DcmGetSizeOfFreezeFrameByDTC","Dem_DcmGetStatusOfDTC","GetDTCOriginReadDTCInformation","GetOneSnapShotDataRecord"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "GetOneSnapShotDataRecord"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dem_DcmGetFreezeFrameDataByDTC","Dem_DcmGetSizeOfFreezeFrameByDTC"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "ReportDTCSnapshotIdentification"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmGetNextFilteredRecord","Dem_DcmSetFreezeFrameRecordFilter"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReportDTCsByStatusMask"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmGetDTCStatusAvailabilityMask","Dem_DcmGetNextFilteredDTC","Dem_DcmGetNumberOfFilteredDTC","Dem_DcmSetDTCFilter","GetDTCOriginReadDTCInformation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "ReportSeverityInformationOfDTC"
	.wrcm.nstrlist "calls", "Dem_DcmGetDTCStatusAvailabilityMask","Dem_DcmGetFunctionalUnitOfDTC","Dem_DcmGetSeverityOfDTC","Dem_DcmGetStatusOfDTC","GetDTCOriginReadDTCInformation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReportDTCFaultDetectionCounter"
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dem_DcmGetNextFilteredDTCAndFDC","Dem_DcmGetNumberOfFilteredDTC","Dem_DcmSetDTCFilter","GetDTCOriginReadDTCInformation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReportNumberOfDTCsByStatusMask"
	.wrcm.nstrlist "calls", "Dem_DcmGetDTCStatusAvailabilityMask","Dem_DcmGetNumberOfFilteredDTC","Dem_DcmGetTranslationType","Dem_DcmSetDTCFilter","GetDTCOriginReadDTCInformation","GetSeverityType"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetDTCOriginReadDTCInformation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "GetSeverityType"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_ClearDiagnosticInformation"
	.wrcm.nstrlist "calls", "ClearDtcInformation","Dcm_ErrorCodeToStdReturnType"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ClearDtcInformation"
	.wrcm.nstrlist "calls", "Dem_DcmClearDTC"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_ControlDTCSetting"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","Dem_DcmDisableDTCSetting","Dem_DcmEnableDTCSetting"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_TesterPresent"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_CommunicationControl"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","FindPduRxChannel","GetCommunicationMode"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetCommunicationMode"
	.wrcm.nstrlist "calls", "Det_ReportError"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_SecurityAccess"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","SecurityAccessCompareKey","SecurityAccessGetSeed"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "SecurityAccessCompareKey"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_CheckAndPossiblyConvertErrorCode","Dcm_SetSecurityLevel","IsSecurityLevelSupported","SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "SecurityAccessGetSeed"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_CheckAndPossiblyConvertErrorCode","Dcm_GetSecurityLevel","IsSecurityLevelSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "IsSecurityLevelSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DiagnosticSessionControl"
	.wrcm.nstrlist "calls", "Dcm_DspGetSessionConfiguration","Dcm_ErrorCodeToStdReturnType","Dcm_SetProgConditions","FindPduRxChannel","SchM_Switch_Dcm_DcmEcuReset"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_DspGetSessionConfiguration"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "FindPduRxChannel"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_EcuReset"
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","SchM_Switch_Dcm_DcmEcuReset","SchM_Switch_Dcm_DcmModeRapidPowerShutDown"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_DspResetPendingSecurityLevel"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspServiceCancelled"
	.wrcm.nstrlist "calls", "Dem_DcmEnableDTCRecordUpdate"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspEnableDtcSetting"
	.wrcm.nstrlist "calls", "Dem_DcmEnableDTCSetting","SchM_Switch_Dcm_DcmControlDTCSetting"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspConfirmation"
	.wrcm.nstrlist "calls", "BswM_Dcm_CommunicationMode_CurrentState","Dcm_SetSesCtrlType","SchM_Switch_Dcm_DcmControlDTCSetting","SchM_Switch_Dcm_DcmEcuReset"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_SE_TransmitPeriodicData"
	.wrcm.nstrlist "calls", "Dcm_DslPeriodicStateMachine","Dcm_DspTransmitPeriodicDataTrigger","SendPeriodicDids"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "SendPeriodicDids"
	.wrcm.nstrlist "calls", "AllPeriodicDIDsSent","AllSentSamplesConfirmed","Dcm_DslSendPeriodicTxData","Dcm_DspTransmitPeriodicDataTrigger","ResetPeriodicStatusVariables"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "AllPeriodicDIDsSent"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "AllSentSamplesConfirmed"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_SE_GetPeriodicData"
	.wrcm.nstrlist "calls", "Dcm_DspTransmitPeriodicDataTrigger","ReadAllRequestedPeriodicDids"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspTransmitPeriodicDataTrigger"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ReadAllRequestedPeriodicDids"
	.wrcm.nstrlist "calls", "Dcm_DspGetPeriodicDataTrigger","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","ReadOnePeriodicDid"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadOnePeriodicDid"
	.wrcm.nstrlist "calls", "ReadOneDDDidByDid","ReadOneDDDidByMemory"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReadOneDDDidByMemory"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","GetMemoryRange","IsMemoryRangeAcessible"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "IsMemoryRangeAcessible"
	.wrcm.nstrlist "calls", "Dcm_GetSecurityLevel","Dcm_IsLevelSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "GetMemoryRange"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "ReadOneDDDidByDid"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported","Dcm_Memcpy"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "Dcm_DspStateMachine"
	.wrcm.nstrlist "calls", "Dcm_DspGetPeriodicDataTrigger","SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspGetPeriodicDataTrigger"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspHandleTimers"
	.wrcm.nstrlist "calls", "SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspInit"
	.wrcm.nstrlist "calls", "Dcm_DspResetPeriodicTransmission","Dcm_DspStateMachineInit","ResetAllDDDiDsAndPeriodicDids","SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ResetAllDDDiDsAndPeriodicDids"
	.wrcm.nstrlist "calls", "Dcm_NvMSetRamBlockStatus"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_DspResetPeriodicTransmission"
	.wrcm.nstrlist "calls", "Dcm_DslClearPeriodicTxConnection","ResetPeriodicStatusVariables","SchM_Enter_Dcm_EaTimers","SchM_Exit_Dcm_EaTimers"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ResetPeriodicStatusVariables"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_DspStateMachineInit"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "WriteMemoryInitialisation"
	.wrcm.nstrlist "calls", "Dcm_Memcpy"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ReadMemoryInitialisation"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "ReadCommonOBDInfoTypeIdentifier"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdReleaseResponseBuffer","Dcm_DsdRequestResponseBuffer","Dcm_Memcpy","IsIdentifierSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "ReadCommonPid"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_DsdRequestResponseBuffer","Dcm_Memcpy","Dcm_Memset","IsIdentifierSupported","WriteSignalToBuf_08","WriteSignalToBuf_uint8N"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "Dcm_RequestTransferExit"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","HandleStdRetVal"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_TransferData"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","HandleMemoryOpResult","TransferData_Initial"
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "TransferData_Initial"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "HandleMemoryOpResult"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_RequestDownload"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "Dcm_ErrorCodeToStdReturnType","FindPduRxChannel","HandleStdRetVal","ParseMemoryParameter"
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "Dcm_WriteMemoryByAddress"
	.wrcm.nstrlist "calls", "GenericMemoryAddressOperation"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_ReadMemoryByAddress"
	.wrcm.nstrlist "calls", "GenericMemoryAddressOperation"
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "GenericMemoryAddressOperation"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "ChangeAsyncState","Dcm_ErrorCodeToStdReturnType","Dcm_IsCurrentModesAllowed","GetMemoryRange","HandleMemoryOpResult","IsMemoryRangeAcessible","ParseMemoryParameter"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 80
	.wrcm.end
	.wrcm.nelem "HandleMemoryOpResult"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 16
	.wrcm.end
	.wrcm.nelem "Dcm_RoutineControl"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "ChangeAsyncState","Dcm_ErrorCodeToStdReturnType","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported","Dcm_Memcpy","IsIdentifierSupported","RoutineControlHelpFunc","StoreSupportedTypes"
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.nelem "StoreSupportedTypes"
	.wrcm.nstrlist "calls", "Dcm_Memcpy","IsObdRangeSupported"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 64
	.wrcm.end
	.wrcm.nelem "RoutineControlHelpFunc"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "HandleStdRetVal"
	.wrcm.nint32 "local", 1
	.wrcm.nint32 "frameSize", 32
	.wrcm.end
	.wrcm.nelem "Dcm_InputOutputControlByIdentifier"
	.wrcm.nint32 "indirectCalls", 1
	.wrcm.nstrlist "calls", "ChangeAsyncState","Dcm_DsdRequestResponseBuffer","Dcm_DsdStartResponse","Dcm_ErrorCodeToStdReturnType","Dcm_GetSecurityLevel","Dcm_GetSesCtrlType","Dcm_IsCurrentModesAllowed","Dcm_IsLevelSupported","Dcm_Memcpy","DidControlHelpFunc","HandleStdRetVal"
	.wrcm.nint32 "frameSize", 48
	.wrcm.end
	.wrcm.end
	.wrcm.end
	.wrcm.nelem "tools"
	.wrcm.nelem "llopt"
	.wrcm.nelem "version"
	.wrcm.nstr "string", "5.9.6.4"
	.wrcm.nint32 "number", 5964
	.wrcm.nstr "path", "C:\WindRiver\compilers\diab-5.9.6.4\WIN32\bin\llopt.exe"
	.wrcm.nstr "label", "DIAB_5_9_6_4-FCS_20170817_111028"
	.wrcm.end
	.wrcm.end
	.wrcm.nelem "etoa"
	.wrcm.nelem "version"
	.wrcm.nstr "string", "5.9.6.4"
	.wrcm.nint32 "number", 5964
	.wrcm.nstr "path", "C:\WindRiver\compilers\diab-5.9.6.4\WIN32\lib\etoa.exe"
	.wrcm.nstr "label", "DIAB_5_9_6_4-FCS_20170817_111028"
	.wrcm.end
	.wrcm.nstr "options", "-ei4618 -Xmake-opt-key=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.o -Xsingle-fp -Xno-double -Xuser-specified-proc=PPCE200Z4204N3V -XPPCE200Z4 -Xname-code=.text_vle -Xname-const=.text_vle -Xname-uconst=.text_vle -Xname-string=.text_vle -Xstsw-slow -Xintrinsic-mask=0xc00041 -Xconventions-eabi -Xsoft-float -Xdouble-avoid -Xcoloring -Xapu-efpu-v2 -Xefpu-spfs -Xtarget-family=2 -Xlicense-proxy-use -Xlicense-proxy-path=C:\WINDRI~1\COMPIL~1\DIAB-5~1.4\WIN32 -Xdialect-c99 -Xforce-prototypes -Xforce-declarations -Xsmall-data=0 -Xsmall-const=0 -Xlocal-data-area=0 -Xnested-interrupts -Xdebug-inline-on -Xoptimized-debug-off -Xdebug-dwarf2 -Xpass-source -Xmake-dependency-canonicalize-path-off -Xmake-dependency=0x4 -Xc-mode -Xmake-dependency-target=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.o -Xmake-dependency-savefile=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.d -Xmake-opt-key=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.o -MC:\WINDRI~1\COMPIL~1\DIAB-5~1.4\PPC\PPCVLE.cd -ZC:\WINDRI~1\COMPIL~1\DIAB-5~1.4\WIN32\lib\cderror.cat -Xsingle-fp -Xno-double -Xuser-specified-proc=PPCE200Z4204N3V -XPPCE200Z4 -Xname-code=.text_vle -Xname-const=.text_vle -Xname-uconst=.text_vle -Xname-string=.text_vle -Xstsw-slow -Xintrinsic-mask=0xc00041 -Xconventions-eabi -Xsoft-float -Xdouble-avoid -Xcoloring -Xapu-efpu-v2 -Xefpu-spfs -Xtarget-family=2 -Xlicense-proxy-use -Xlicense-proxy-path=C:\WINDRI~1\COMPIL~1\DIAB-5~1.4\WIN32 -Xdialect-c99 -Xforce-prototypes -Xforce-declarations -Xsmall-data=0 -Xsmall-const=0 -Xlocal-data-area=0 -Xnested-interrupts -ei4618 -g2 -Xdebug-inline-on -Xoptimized-debug-off -Xdebug-dwarf2 -Xpass-source -Xmake-dependency-canonicalize-path-off -Xmake-dependency=0x4 -Xc-mode -Xmake-dependency-target=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.o -Xmake-dependency-savefile=objs\MPC5746R_ECU\WindRiver\Dcm_Dsp.d"
	.wrcm.end
	.wrcm.end
	.wrcm.nelem "file"
	.wrcm.nstr "input", "d:\VSB_Demo\VSTAR_MPC5746R_Diab_PR_4.2.2_g_3.0_10\VSTAR\BSWs\DIAG\Dcm\ssc\make\..\src\Dcm_Dsp.c"
	.wrcm.end
	.wrcm.end
	.wrcm.end
